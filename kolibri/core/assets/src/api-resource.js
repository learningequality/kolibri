import logger from 'kolibri.lib.logging';
import ConditionalPromise from './conditionalPromise';
import find from 'lodash/find';
import matches from 'lodash/matches';
import isEqual from 'lodash/isEqual';
import cloneDeep from './cloneDeep';
import urls from 'kolibri.urls';
import client from 'kolibri.client';

export const logging = logger.getLogger(__filename);

/** Class representing a single API resource object */
export class Model {
  /**
   * Create a model instance.
   * @param {object} data - data to insert into the model at creation time - should include at
   * least an id for fetching, or data an no id if the intention is to save a new model.
   * @param {Resource} resource - object of the Resource class, specifies the urls and fetching
   * behaviour for the model.
   */
  constructor(data, resourceIds = {}, resource) {
    this.resource = resource;
    if (!this.resource) {
      throw new TypeError('resource must be defined');
    }

    if (!data) {
      throw new TypeError('data must be defined');
    }

    if (typeof data !== 'object') {
      throw new TypeError('data must be an object');
    }

    if (Object.keys(data).length === 0) {
      throw new TypeError('data must be instantiated with some data');
    }

    const filteredResourceIds = this.resource.filterAndCheckResourceIds(resourceIds);
    this.resourceIds = filteredResourceIds;

    // Assign any data to the attributes property of the Model.
    this.attributes = {};
    this.set(data);

    this.synced = false;

    // Keep track of any unresolved promises that have been generated by async methods of the Model
    this.promises = [];
  }

  /**
   * Method to fetch data from the server for this particular model.
   * @param {object} getParams - an object of parameters to be parsed into GET parameters on the
   * fetch.
   * @param {boolean} [force=false] - fetch whether or not it's been synced already.
   * @returns {Promise} - Promise is resolved with Model attributes when the XHR successfully
   * returns, otherwise reject is called with the response object.
   */
  fetch(getParams = {}, force = false) {
    const promise = new ConditionalPromise((resolve, reject) => {
      Promise.all(this.promises).then(
        () => {
          if (!force && this.synced) {
            resolve(this.attributes);
          } else {
            this.synced = false;
            // Do a fetch on the URL.
            this.resource.client({ path: this.url, params: getParams }).then(
              response => {
                // Set the retrieved Object onto the Model instance.
                this.set(response.entity);
                // Flag that the Model has been fetched.
                this.synced = true;
                // Resolve the promise with the attributes of the Model.
                resolve(this.attributes);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              },
              response => {
                logging.error('An error occurred', response);
                reject(response);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              }
            );
          }
        },
        reason => {
          reject(reason);
        }
      );
    });
    this.promises.push(promise);
    return promise;
  }

  /**
   * Method to save data to the server for this particular model.
   * @param {object} attrs - an object of attributes to be saved on the model.
   * @returns {Promise} - Promise is resolved with Model attributes when the XHR successfully
   * returns, otherwise reject is called with the response object.
   */
  save(attrs) {
    const promise = new ConditionalPromise((resolve, reject) => {
      Promise.all(this.promises).then(
        () => {
          let payload = {};
          if (this.synced) {
            // Model is synced with the server, so we can do dirty checking.
            Object.keys(attrs).forEach(key => {
              if (!isEqual(attrs[key], this.attributes[key])) {
                payload[key] = attrs[key];
              }
            });
          } else {
            this.set(attrs);
            payload = this.attributes;
          }
          if (!Object.keys(payload).length) {
            // Nothing to save, so just resolve the promise now.
            resolve(this.attributes);
          } else {
            this.synced = false;
            let url;
            let clientObj;
            if (this.id) {
              // If this Model has an id, then can do a PATCH against the Model
              url = this.url;
              clientObj = { path: url, method: 'PATCH', entity: payload };
            } else {
              // Otherwise, must POST to the Collection endpoint to create the Model
              url = this.resource.collectionUrl();
              clientObj = { path: url, entity: payload };
            }
            // Do a save on the URL.
            this.resource.client(clientObj).then(
              response => {
                const oldId = this.id;
                // Set the retrieved Object onto the Model instance.
                this.set(response.entity);
                // if the model did not used to have an id and now does, add it to the cache.
                if (!oldId && this.id) {
                  this.resource.addModel(this);
                }
                // Flag that the Model has been fetched.
                this.synced = true;
                // Resolve the promise with the Model.
                resolve(response.entity);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              },
              response => {
                logging.error('An error occurred', response);
                reject(response);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              }
            );
          }
        },
        reason => {
          reject(reason);
        }
      );
    });
    this.promises.push(promise);
    return promise;
  }

  /**
   * Method to delete model.
   * @param {Integer} id - target model's id.
   * @returns {Promise} - Promise is resolved with target model's id
   * returns, otherwise reject is called with the response object.
   */
  delete() {
    const promise = new ConditionalPromise((resolve, reject) => {
      Promise.all(this.promises).then(
        () => {
          if (!this.id) {
            // Nothing to delete, so just resolve the promise now.
            reject('Can not delete model that we do not have an id for');
          } else {
            // Otherwise, DELETE the Model
            const clientObj = { path: this.url, method: 'DELETE' };
            this.resource.client(clientObj).then(
              response => {
                // delete this instance
                this.resource.removeModel(this);
                // Set a flag so that any collection containing this can ignore this model
                this.deleted = true;
                // Resolve the promise with the id.
                // Vuex will use this id to delete the model in its state.
                resolve(this.id);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              },
              response => {
                logging.error('An error occurred', response);
                reject(response);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              }
            );
          }
        },
        reason => {
          reject(reason);
        }
      );
    });
    this.promises.push(promise);
    return promise;
  }

  get orderedUrlParams() {
    return this.resource.resourceIds.map(key => this.resourceIds[key]);
  }

  get url() {
    return this.resource.modelUrl(...this.orderedUrlParams, this.id);
  }

  get id() {
    return this.attributes[this.resource.idKey];
  }

  set(attributes) {
    // force IDs to always be strings - this should be changed on the server-side too
    if (attributes && this.resource.idKey in attributes) {
      if (attributes[this.resource.idKey]) {
        // don't stringigy null or undefined.
        attributes[this.resource.idKey] = String(attributes[this.resource.idKey]);
      }
    }
    Object.assign(this.attributes, cloneDeep(attributes));
  }
}

/** Class representing a 'view' of a single API resource.
 *  Contains different Model objects, depending on the parameters passed to its fetch method.
 */
export class Collection {
  /**
   * Create a Collection instance.
   * @param {Object} getParams - Default parameters to use when fetching data from the server.
   * @param {Object[]|Model[]} data - Data to prepopulate the collection with,
   * useful if wanting to save multiple models.
   * @param {Resource} resource - object of the Resource class, specifies the urls and fetching
   * behaviour for the collection.
   */
  constructor(resourceIds = {}, getParams = {}, data = [], resource) {
    this.resource = resource;
    this.getParams = getParams;
    const filteredResourceIds = this.resource.filterAndCheckResourceIds(resourceIds);
    this.resourceIds = filteredResourceIds;
    if (!this.resource) {
      throw new TypeError('resource must be defined');
    }
    this.models = [];
    this._model_map = {};
    this.synced = false;
    this.set(data);
    // Keep track of any unresolved promises that have been generated by async methods of the Model
    this.promises = [];
  }

  /**
   * Method to fetch data from the server for this collection.
   * @param {object} extraParams - an object of parameters to be parsed into GET parameters on the
   * fetch.
   * @param {boolean} force - fetch whether or not it's been synced already.
   * @returns {Promise} - Promise is resolved with Array of Model attributes when the XHR
   * successfully returns, otherwise reject is called with the response object.
   */
  fetch(extraParams = {}, force = false) {
    const getParams = Object.assign({}, this.getParams, extraParams);
    const promise = new ConditionalPromise((resolve, reject) => {
      Promise.all(this.promises).then(
        () => {
          if (!force && this.synced) {
            resolve(this.data);
          } else {
            this.synced = false;
            this.resource.client({ path: this.url, params: getParams }).then(
              response => {
                // Set response object - an Array - on the Collection to record the data.
                // First check that the response *is* an Array
                if (Array.isArray(response.entity)) {
                  this.clearCache();
                  this.set(response.entity);
                  // Mark that the fetch has completed.
                  this.synced = true;
                } else if (typeof (response.entity || {}).results !== 'undefined') {
                  // If it's not, there are two possibilities - something is awry, or we have received
                  // paginated data! Check to see if it is paginated.
                  this.clearCache();
                  // Paginated objects have 'results' as their results object so interpret this as
                  // such.
                  this.set(response.entity.results);
                  this.pageCount = Math.ceil(response.entity.count / this.pageSize);
                  this.hasNext = Boolean(response.entity.next);
                  this.hasPrev = Boolean(response.entity.previous);
                  this.next = response.entity.next;
                  this.previous = response.entity.previous;
                  // Mark that the fetch has completed.
                  this.synced = true;
                } else {
                  // It's all gone a bit Pete Tong.
                  logging.debug('Data appears to be malformed', response.entity);
                  reject(response);
                }
                // Return the data from the models, not the models themselves.
                resolve(this.data);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              },
              response => {
                logging.error('An error occurred', response);
                reject(response);
                // Clean up the reference to this promise
                this.promises.splice(this.promises.indexOf(promise), 1);
              }
            );
          }
        },
        reason => {
          reject(reason);
        }
      );
    });
    this.promises.push(promise);
    return promise;
  }

  get orderedUrlParams() {
    return this.resource.resourceIds.map(key => this.resourceIds[key]);
  }

  get url() {
    return (this._url ? this._url : this.resource.collectionUrl)(...this.orderedUrlParams);
  }

  set url(url) {
    this._url = url;
  }

  /**
   * Clear this Collection's cache of models.
   */
  clearCache() {
    // Reset current models.
    this.models = [];
    this._model_map = {};
  }

  /**
   * Make a model a member of the collection - record in the models Array, and in the mapping
   * from id to model. Will automatically instantiate Models for data passed in as objects, and
   * deduplicate within the collection.
   * @param {(Object|Model|Object[]|Model[])} models - Either an Array or single instance of an
   * object or Model.
   */
  set(models) {
    let modelsToSet;
    if (!Array.isArray(models)) {
      modelsToSet = [models];
    } else {
      modelsToSet = models;
    }

    modelsToSet.forEach(model => {
      // Note: this method ensures instantiation deduplication of models within the collection
      //  and across collections.
      const setModel = this.resource.addModel(model, this.resourceIds);
      if (!this._model_map[setModel.id]) {
        this._model_map[setModel.id] = setModel;
        this.models.push(setModel);
      }
    });
  }

  get data() {
    return this.models.filter(model => !model.deleted).map(model => model.attributes);
  }

  get synced() {
    // We only say the Collection is synced if it, itself, is synced, and all its
    // constituent models are also.
    return this.models.reduce((synced, model) => synced && model.synced, this._synced);
  }

  /**
   * Set this Collection as synced or not, for true, will also set all models cached in it
   * as synced.
   * @param  {Boolean} value Is this Collection synced or not?
   */
  set synced(value) {
    this._synced = value;
    if (value) {
      this.models.forEach(model => {
        model.synced = true;
      });
    }
  }
}

/** Class representing a single API resource.
 *  Contains references to all Models that have been fetched from the server.
 *  Can also be subclassed in order to create custom behaviour for particular API resources.
 */
export class Resource {
  /**
   * Create a resource with a Django REST API name corresponding to the name parameter.
   */
  constructor() {
    this.clearCache();
  }

  cacheKey(...params) {
    const allParams = Object.assign({}, ...params);
    // Sort keys in order, then assign those keys to an empty object in that order.
    // Then stringify to create a cache key.
    return JSON.stringify(
      Object.assign(
        {},
        ...Object.keys(allParams).sort().map(paramKey => ({ [paramKey]: allParams[paramKey] }))
      )
    );
  }

  /**
   * Optionally pass in data and instantiate a collection for saving that data or fetching
   * data from the resource.
   * @param {Object} getParams - default parameters to use for Collection fetching.
   * @returns {Collection} - Returns an instantiated Collection object.
   */
  getCollection(resourceIds = {}, getParams = {}) {
    if (!this.hasResourceIds) {
      if (Object.keys(resourceIds).length && Object.keys(getParams).length) {
        throw TypeError(
          `resourceIds and getParams passed to getCollection method of ${this.name} ` +
            'resource, which does not use resourceIds, only pass getParams for this resource'
        );
      } else if (Object.keys(resourceIds).length) {
        getParams = resourceIds; // eslint-disable-line no-param-reassign
      }
    }
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    let collection;
    const key = this.cacheKey(getParams, filteredResourceIds);
    if (!this.collections[key]) {
      collection = this.createCollection(filteredResourceIds, getParams, []);
    } else {
      collection = this.collections[key];
    }
    return collection;
  }

  /**
   * Optionally pass in data and instantiate a collection for saving that data or fetching
   * data from the resource.
   * @param {Object} getParams - default parameters to use for Collection fetching.
   * @param {Object[]} data - Data to instantiate the Collection - see Model constructor for
   * details of data.
   * @returns {Collection} - Returns an instantiated Collection object.
   */
  createCollection(resourceIds = {}, getParams = {}, data = []) {
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    const collection = new Collection(filteredResourceIds, getParams, data, this);
    const key = this.cacheKey(getParams, filteredResourceIds);
    this.collections[key] = collection;
    return collection;
  }

  /**
   * Get a Collection with pagination settings.
   * @param {Object} [getParams={}] - default parameters to use for Collection fetching.
   * @param {Number} [pageSize=20] - The number of items to return in a page.
   * @param {Number} [page=1] - Which page to return.
   * @returns {Collection} - Returns an instantiated Collection object.
   */
  getPagedCollection(resourceIds = {}, getParams = {}, pageSize = 20, page = 1) {
    if (!this.hasResourceIds) {
      if (Object.keys(resourceIds).length && Object.keys(getParams).length) {
        throw TypeError(
          `resourceIds and getParams passed to getPagedCollection method of ${this.name} ` +
            'resource, which does not use resourceIds, only pass getParams for this resource'
        );
      } else if (Object.keys(resourceIds).length) {
        getParams = resourceIds; // eslint-disable-line no-param-reassign
      }
    }
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    const pagedParams = { page, page_size: pageSize };
    Object.assign(pagedParams, getParams);
    const collection = this.getCollection(filteredResourceIds, pagedParams);
    collection.page = page;
    collection.pageSize = pageSize;
    return collection;
  }

  /**
   * Get a model by id
   * @param {String} id - The primary key of the Model instance.
   * @returns {Model} - Returns a Model instance.
   */
  getModel(id, resourceIds = {}) {
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    let model;
    const cacheKey = this.cacheKey({ [this.idKey]: id }, filteredResourceIds);
    if (!this.models[cacheKey]) {
      model = this.createModel({ [this.idKey]: id }, filteredResourceIds);
    } else {
      model = this.models[cacheKey];
    }
    return model;
  }

  /**
   * Find a model by its attributes - will return first model found that matches
   * @param  {Object} attrs Hash of attributes to search by
   * @return {Model}       First matching Model
   */
  findModel(attrs) {
    return find(this.models, model => matches(attrs)(model.attributes));
  }

  /**
   * Add a model to the resource for deduplication, dirty checking, and tracking purposes.
   * @param {Object} data - The data for the model to add.
   * @param {Object} [resourceIds = {}]
   * @returns {Model} - Returns the instantiated Model.
   */
  createModel(data, resourceIds = {}) {
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    const model = new Model(data, filteredResourceIds, this);
    return this.addModel(model, filteredResourceIds);
  }

  /**
   * Add a model to the resource for deduplication, dirty checking, and tracking purposes.
   * @param {Object|Model} model - Either the data for the model to add, or the Model itself.
   * @param {Object} [resourceIds = {}]
   * @returns {Model} - Returns the instantiated Model.
   */
  addModel(model, resourceIds = {}) {
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    if (!(model instanceof Model)) {
      return this.createModel(model, filteredResourceIds);
    }
    // Add to the model cache using the default key if id is defined.
    if (model.id) {
      const cacheKey = this.cacheKey({ [this.idKey]: model.id }, filteredResourceIds);
      if (!this.models[cacheKey]) {
        this.models[cacheKey] = model;
      } else {
        this.models[cacheKey].set(model.attributes);
      }
      return this.models[cacheKey];
      // Otherwise use a hash of the models attributes to create a temporary cache key
    }
    const cacheKey = this.cacheKey(model.attributes, filteredResourceIds);
    this.models[cacheKey] = model;
    return model;
  }

  /**
   * Reset the cache for this Resource.
   */
  clearCache() {
    this.models = {};
    this.collections = {};
  }

  unCacheModel(id, resourceIds = {}) {
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    const cacheKey = this.cacheKey({ [this.idKey]: id }, filteredResourceIds);
    this.models[cacheKey].synced = false;
  }

  unCacheCollection(resourceIds = {}, getParams = {}) {
    if (!this.hasResourceIds) {
      if (Object.keys(resourceIds).length && Object.keys(getParams).length) {
        throw TypeError(
          `resourceIds and getParams passed to getCollection method of ${this.name} ` +
            'resource, which does not use resourceIds, only pass getParams for this resource'
        );
      } else if (Object.keys(resourceIds).length) {
        getParams = resourceIds; // eslint-disable-line no-param-reassign
      }
    }
    const filteredResourceIds = this.filterAndCheckResourceIds(resourceIds);
    const cacheKey = this.cacheKey(getParams, filteredResourceIds);
    this.collections[cacheKey].synced = false;
  }

  removeModel(model) {
    delete this.models[model.id];
  }

  /**
   * Check resourceIds against those set on resource to ensure that
   * a properly keyed object has been passed.
   * @param  {Object} params an object of the resourceIds.
   * @return {Object} an object containing only the permissible resourceIds.
   */
  filterAndCheckResourceIds(params) {
    const filteredParams = {};
    const missingParams = [];
    this.resourceIds.forEach(key => {
      if (!params[key]) {
        missingParams.push(key);
      } else {
        filteredParams[key] = params[key];
      }
    });
    if (missingParams.length > 0) {
      throw TypeError(`Missing required resourceIds: ${missingParams}`);
    }
    return filteredParams;
  }

  get urls() {
    return urls;
  }

  get modelUrl() {
    // Leveraging Django REST Framework generated URL patterns.
    return this.urls[`${this.name}_detail`];
  }

  get collectionUrl() {
    // Leveraging Django REST Framework generated URL patterns.
    return this.urls[`${this.name}_list`];
  }

  static idKey() {
    return 'id';
  }

  get idKey() {
    // In IE <= 10, static methods are not properly inherited
    // Do this to still return a value.
    // N.B. This will prevent a resource being subclassed from another
    // resource, but then being able to reference its parent's
    // idKey.
    return this.constructor.idKey ? this.constructor.idKey() : 'id';
  }

  static resourceName() {
    throw new ReferenceError('name is not defined for the base Resource class - please subclass.');
  }

  get name() {
    return this.constructor.resourceName();
  }

  get client() {
    return client;
  }

  get hasResourceIds() {
    return this.resourceIds.length > 0;
  }

  get resourceIds() {
    return this.constructor.resourceIdentifiers();
  }

  /*
  An ordered Array that corresponds to the order in which parameters are filled in the Django URL.
  Should be a list of the kwarg names that fill these in - note: this is by convention,
  they could technically be anything, as long as those values were passed into the Models and
  Collections with these names, but to make our code less opaque, we standardize around using
  the same kwargs that the Django URLs also use.
   */
  static resourceIdentifiers() {
    return [];
  }
}
