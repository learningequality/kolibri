'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var KAS = require('@khanacademy/kas');
var mathInput = require('@khanacademy/math-input');
var PerseusLinter = require('@khanacademy/perseus-linter');
var i18n = require('@khanacademy/wonder-blocks-i18n');
var classNames = require('classnames');
var React = require('react');
var _ = require('underscore');
var PropTypes = require('prop-types');
var $ = require('jquery');
var ReactDOM = require('react-dom');
var wonderBlocksProgressSpinner = require('@khanacademy/wonder-blocks-progress-spinner');
var kmath = require('@khanacademy/kmath');
var createReactClass = require('create-react-class');
var SimpleMarkdown = require('@khanacademy/simple-markdown');
var pureMarkdown = require('@khanacademy/pure-markdown');
var aphrodite = require('aphrodite');
var MathQuill = require('mathquill');
var wonderBlocksForm = require('@khanacademy/wonder-blocks-form');
var Button = require('@khanacademy/wonder-blocks-button');
var wonderBlocksCore = require('@khanacademy/wonder-blocks-core');
var Color = require('@khanacademy/wonder-blocks-color');
var wonderBlocksLayout = require('@khanacademy/wonder-blocks-layout');
var wonderBlocksPopover = require('@khanacademy/wonder-blocks-popover');
var Spacing = require('@khanacademy/wonder-blocks-spacing');
var wonderBlocksDropdown = require('@khanacademy/wonder-blocks-dropdown');
var debounce = require('lodash.debounce');
require('intersection-observer');
var Link$1 = require('@khanacademy/wonder-blocks-link');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var KAS__namespace = /*#__PURE__*/_interopNamespace(KAS);
var PerseusLinter__namespace = /*#__PURE__*/_interopNamespace(PerseusLinter);
var i18n__namespace = /*#__PURE__*/_interopNamespace(i18n);
var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var $__default = /*#__PURE__*/_interopDefaultLegacy($);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);
var createReactClass__default = /*#__PURE__*/_interopDefaultLegacy(createReactClass);
var SimpleMarkdown__default = /*#__PURE__*/_interopDefaultLegacy(SimpleMarkdown);
var MathQuill__default = /*#__PURE__*/_interopDefaultLegacy(MathQuill);
var Button__default = /*#__PURE__*/_interopDefaultLegacy(Button);
var Color__default = /*#__PURE__*/_interopDefaultLegacy(Color);
var Spacing__default = /*#__PURE__*/_interopDefaultLegacy(Spacing);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var Link__default = /*#__PURE__*/_interopDefaultLegacy(Link$1);

var version = {
  apiVersion: {
    major: 11,
    minor: 0
  },
  itemDataVersion: {
    major: 0,
    minor: 1
  }
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

/* eslint-disable react/forbid-prop-types */

const InlineIcon = _ref => {
  let {
    path,
    width,
    height,
    style = {},
    title
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement("svg", {
    role: "img",
    "aria-hidden": !title,
    style: {
      verticalAlign: "middle",
      ...style
    },
    width: "".concat(width / height, "em"),
    height: "1em",
    viewBox: "0 0 ".concat(width, " ").concat(height)
  }, !!title && /*#__PURE__*/React__namespace.createElement("title", null, title), /*#__PURE__*/React__namespace.createElement("path", {
    d: path,
    fill: "currentColor"
  }));
};

InlineIcon.propTypes = {
  // An SVG path to render.
  path: PropTypes__default["default"].string.isRequired,
  // The path's viewBox dimensions.
  // We set the viewport height to 1em and scale the width accordingly.
  height: PropTypes__default["default"].number.isRequired,
  width: PropTypes__default["default"].number.isRequired,
  style: PropTypes__default["default"].object,
  // A11y description for this icon. If absent, icon is marked
  // aria-hidden=true
  title: PropTypes__default["default"].string
};

const textWidthCache = {};

function getTextWidth(text) {
  if (!textWidthCache[text]) {
    // Hacky way to guess the width of an input box
    const $test = $__default["default"]("<span>").text(text).appendTo("body");
    textWidthCache[text] = $test.width() + 5;
    $test.remove();
  }

  return textWidthCache[text];
}

class TextListEditor extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      items: this.props.options.concat("")
    });

    _defineProperty(this, "onChange", (index, event) => {
      let items = ___default["default"].clone(this.state.items);

      items[index] = event.target.value;

      if (index === items.length - 1) {
        items = items.concat("");
      }

      this.setState({
        items: items
      });
      this.props.onChange(___default["default"].compact(items));
    });

    _defineProperty(this, "onKeyDown", (index, event) => {
      const which = event.nativeEvent.keyCode; // Backspace deletes an empty input...

      if (which === 8
      /* backspace */
      && this.state.items[index] === "") {
        event.preventDefault();

        const items = ___default["default"].clone(this.state.items);

        const focusIndex = index === 0 ? 0 : index - 1;

        if (index === items.length - 1 && (index === 0 || items[focusIndex] !== "")) {
          // ...except for the last one, iff it is the only empty
          // input at the end.
          // $FlowFixMe[incompatible-use]
          // $FlowFixMe[prop-missing]
          ReactDOM__default["default"].findDOMNode(this.refs["input_" + focusIndex]).focus(); // eslint-disable-line react/no-string-refs
        } else {
          items.splice(index, 1);
          this.setState({
            items: items
          }, function () {
            ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
            this.refs["input_" + focusIndex] // $FlowFixMe[incompatible-use]
            // $FlowFixMe[prop-missing]
            ).focus();
          });
        } // Deleting the last character in the second-to-last input
        // removes it

      } else if (which === 8
      /* backspace */
      && this.state.items[index].length === 1 && index === this.state.items.length - 2) {
        event.preventDefault();

        const items = ___default["default"].clone(this.state.items);

        items.splice(index, 1);
        this.setState({
          items: items
        });
        this.props.onChange(___default["default"].compact(items)); // Enter adds an option below the current one...
      } else if (which === 13
      /* enter */
      ) {
        event.preventDefault();

        const items = ___default["default"].clone(this.state.items);

        const focusIndex = index + 1;

        if (index === items.length - 2) {
          // ...unless the empty input is just below.
          // $FlowFixMe[incompatible-use]
          // $FlowFixMe[prop-missing]
          ReactDOM__default["default"].findDOMNode(this.refs["input_" + focusIndex]).focus(); // eslint-disable-line react/no-string-refs
        } else {
          items.splice(focusIndex, 0, "");
          this.setState({
            items: items
          }, function () {
            ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
            this.refs["input_" + focusIndex] // $FlowFixMe[incompatible-use]
            // $FlowFixMe[prop-missing]
            ).focus();
          });
        }
      }
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      items: nextProps.options.concat("")
    });
  }

  render() {
    const className = ["perseus-text-list-editor", "perseus-clearfix", "layout-" + this.props.layout].join(" ");

    const inputs = ___default["default"].map(this.state.items, function (item, i) {
      return /*#__PURE__*/React__namespace.createElement("li", {
        key: i
      }, /*#__PURE__*/React__namespace.createElement("input", {
        ref: "input_" + i,
        type: "text",
        value: item // eslint-disable-next-line react/jsx-no-bind
        ,
        onChange: this.onChange.bind(this, i) // eslint-disable-next-line react/jsx-no-bind
        ,
        onKeyDown: this.onKeyDown.bind(this, i),
        style: {
          width: getTextWidth(item)
        }
      }));
    }, this);

    return /*#__PURE__*/React__namespace.createElement("ul", {
      className: className
    }, inputs);
  }

}

_defineProperty(TextListEditor, "propTypes", {
  options: PropTypes__default["default"].array,
  layout: PropTypes__default["default"].string,
  onChange: PropTypes__default["default"].func.isRequired
});

_defineProperty(TextListEditor, "defaultProps", {
  options: [],
  layout: "horizontal"
});

const EMPTY_ARRAY = [];

class StubTagEditor extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", null, this.props.showTitle && /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        fontSize: 14
      }
    }, "Tags:"), /*#__PURE__*/React__namespace.createElement(TextListEditor, {
      options: this.props.value || EMPTY_ARRAY,
      layout: "vertical",
      onChange: this.props.onChange
    }));
  }

}

_defineProperty(StubTagEditor, "propTypes", {
  value: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  onChange: PropTypes__default["default"].func.isRequired,
  showTitle: PropTypes__default["default"].bool.isRequired
});

_defineProperty(StubTagEditor, "defaultProps", {
  value: EMPTY_ARRAY,
  showTitle: true
});

/**
 * [Most of] the Perseus client API.
 *
 * If making a change to this file, or otherwise to the perseus
 * API, you should increment:
 *  * the perseus api major version if it is a breaking change
 *  * the perseus api minor version if it is an additive-only change
 *  * nothing if it is purely a bug fix.
 *
 * Callbacks passed to Renderer/ItemRenderer:
 *  * onInputError:
 *    Called when there is an error grading a widget
 *  * onFocusChange: (newFocusPath, oldFocusPath, keypadDOMNode)
 *    Called when the user focus changes. The first two parameters are `path`
 *    arrays uniquely identifying the respect inputs. The third parameter,
 *    `keypadDOMNode`, is the DOM node of the custom keypad, or `null` if the
 *    keypad is disabled, which can be used by clients to accommodate for the
 *    appearance of the keypad on the screen.
 *    When focus changes to or from nothing being selected, `path` will be null.
 *  * interactionCallback: Called when the user interacts with a widget.
 *  * answerableCallback: Called with the current `answerability` of the
 *    problem, e.g. whether all required fields have input.
 *  * getAnotherHint: If provided, a button is rendered at the bottom of the
 *    hints (only when at least one hint has been shown, and not all hints
 *    have been shown) allowing the user to take another hint. This function
 *    is then called when the user clicks the button.
 *
 * Stable CSS ClassNames:
 * These are css class names that will continue to preserve their
 * semantic meaning across the same perseus api major version.
 */
const ApiOptions = {
  propTypes: PropTypes__default["default"].shape({
    isArticle: PropTypes__default["default"].bool.isRequired,
    satStyling: PropTypes__default["default"].bool.isRequired,
    onInputError: PropTypes__default["default"].func.isRequired,
    onFocusChange: PropTypes__default["default"].func.isRequired,
    staticRender: PropTypes__default["default"].bool.isRequired,
    GroupMetadataEditor: PropTypes__default["default"].func.isRequired,
    showAlignmentOptions: PropTypes__default["default"].bool.isRequired,
    readOnly: PropTypes__default["default"].bool.isRequired,
    answerableCallback: PropTypes__default["default"].func,
    getAnotherHint: PropTypes__default["default"].func,
    interactionCallback: PropTypes__default["default"].func,
    // A function that takes in the relative problem number (starts at
    // 0 and is incremented for each group widget), and the ID of the
    // group widget, then returns a react component that will be added
    // immediately above the renderer in the group widget. If the
    // function returns null, no annotation will be added.
    groupAnnotator: PropTypes__default["default"].func.isRequired,
    // If imagePlaceholder or widgetPlaceholder are set, perseus will
    // render the placeholder instead of the image or widget node.
    imagePlaceholder: PropTypes__default["default"].node,
    widgetPlaceholder: PropTypes__default["default"].node,
    // Base React elements that can be used in place of the standard DOM
    // DOM elements. For example, when provided, <Link /> will be used
    // in place of <a />. This allows clients to provide pre-styled
    // components or components with custom behavior.
    baseElements: PropTypes__default["default"].shape({
      // The <Link /> component provided here must adhere to the same
      // interface as React's base <a /> component.
      Link: PropTypes__default["default"].func
    }),
    // Function that takes dimensions and returns a React component
    // to display while an image is loading
    imagePreloader: PropTypes__default["default"].func,
    // Function that takes an object argument. The object should
    // include type and id, both strings, at least and can optionally
    // include a boolean "correct" value. This is used for keeping
    // track of widget interactions.
    trackInteraction: PropTypes__default["default"].func,
    // A boolean that indicates whether or not a custom keypad is
    // being used.  For mobile web this will be the ProvidedKeypad
    // component.  In this situation we use the MathInput component
    // from the math-input repo instead of the existing perseus math
    // input components.
    // TODO(charlie): Make this mutually exclusive with `staticRender`.
    // Internally, we defer to `customKeypad` over `staticRender`, but
    // they should really be represented as an enum or some other data
    // structure that forbids them both being enabled at once.
    customKeypad: PropTypes__default["default"].bool,
    // If this is provided, it is called instead of appending an instance
    // of `math-input`'s keypad to the body. This is used by the native
    // apps so they can have the keypad be defined on the native side.
    // It is called with an function that, when called, blurs the input,
    // and is expected to return an object of the shape
    // keypadElementPropType from math-input/src/prop-types.js.
    nativeKeypadProxy: PropTypes__default["default"].func,
    // Indicates whether or not to use mobile styling.
    isMobile: PropTypes__default["default"].bool,
    // A function, called with a bool indicating whether use of the
    // drawing area (scratchpad) should be allowed/disallowed.
    // Previously handled by `Khan.scratchpad.enable/disable`
    setDrawingAreaAvailable: PropTypes__default["default"].func,
    // Whether to use the Draft.js editor or the legacy textarea
    useDraftEditor: PropTypes__default["default"].bool,
    // Styling options that control the visual behavior of Perseus
    // items.
    // TODO(mdr): If we adopt this pattern, we'll need to think about
    //     how to make individual `styling` options be optional, and
    //     how to set their default values without overwriting provided
    //     values. For now, though, you must either specify all fields
    //     of `styling`, or omit the `styling` option entirely.
    styling: PropTypes__default["default"].shape({
      // Which version of radio widget styles to use in non-SAT
      // contexts.
      //
      // "legacy" was the version of the widget display after XOM but
      // before we started adding MCR styles. It doesn't have support
      // for rationales. It has since been removed.
      //
      // "intermediate" is a design which adds several new additions
      // to the "legacy" styles such as:
      //  1. Using the XOM "desktop" styles (with a visible check icon
      //     and lines in between choices) on mobile devices.
      //  2. Designs for rationales
      //  3. Using the single-select styles for multi-select styles
      //
      // "final" is a design which will build off of the
      // "intermediate" designs and adds some improved designs as well
      // as:
      //  1. a/b/c/d/etc. letters inside of the prompt check box
      //  2. New iconography and styles to indicate choice correctness
      //
      // The "legacy" and "intermediate" designs will be A/B tested
      // against each other to ensure that its changes don't cause
      // problems due to the new designs. Once the "intermediate"
      // designs are finished, they will be A/B tested against the
      // "final" designs.
      //
      // If no flag is provided, "legacy" styles will be shown.
      //
      // TODO(emily): Remove this by Aug 1, 2017, at which point all
      //   callsites should have been switched to using the "final"
      //   designs.
      radioStyleVersion: PropTypes__default["default"].oneOf(["intermediate", "final"])
    }),
    // The color used for the hint progress indicator (eg. 1 / 3)
    hintProgressColor: PropTypes__default["default"].string,
    // Whether this Renderer is allowed to auto-scroll the rest of the
    // page. For example, if this is enabled, the most recently used
    // radio widget will attempt to keep the "selected" answer in view
    // after entering review mode.
    //
    // Defaults to `false`.
    canScrollPage: PropTypes__default["default"].bool,
    // Whether or not we are rendering content inside of a modal.
    inModal: PropTypes__default["default"].bool,
    // Whether to enable the cross-out feature on multiple-choice radio
    // widgets. This allows users to note which answers they believe to
    // be incorrect, to find the answer by process of elimination.
    //
    // We plan to roll this out to all call sites eventually, but for
    // now we have this flag, to add it to Generalized Test Prep first.
    crossOutEnabled: PropTypes__default["default"].bool,
    // The value in milliseconds by which the local state of content
    // in a editor is delayed before propagated to a prop. For example,
    // when text is typed in the text area of an Editor component,
    // there will be a delay equal to the value of `editorChangeDelay`
    // before the change is propagated. This is added for better
    // responsiveness of the editor when used in certain contexts such
    // as StructuredItem exercises where constant re-rendering for each
    // keystroke caused text typed in the text area to appear in it
    // only after a good few seconds.
    editorChangeDelay: PropTypes__default["default"].number
  }).isRequired,
  defaults: {
    isArticle: false,
    isMobile: false,
    satStyling: false,
    onInputError: function () {},
    onFocusChange: function () {},
    staticRender: false,
    GroupMetadataEditor: StubTagEditor,
    showAlignmentOptions: false,
    readOnly: false,
    groupAnnotator: function () {
      return null;
    },
    baseElements: {
      Link: props => {
        return /*#__PURE__*/React__namespace.createElement("a", props);
      }
    },
    setDrawingAreaAvailable: function () {},
    useDraftEditor: false,
    styling: {
      radioStyleVersion: "final"
    },
    canScrollPage: false,
    inModal: false,
    crossOutEnabled: false,
    editorChangeDelay: 0
  }
};
const ClassNames = {
  RENDERER: "perseus-renderer",
  TWO_COLUMN_RENDERER: "perseus-renderer-two-columns",
  RESPONSIVE_RENDERER: "perseus-renderer-responsive",
  INPUT: "perseus-input",
  FOCUSED: "perseus-focused",
  RADIO: {
    OPTION: "perseus-radio-option",
    SELECTED: "perseus-radio-selected",
    OPTION_CONTENT: "perseus-radio-option-content"
  },
  INTERACTIVE: "perseus-interactive",
  CORRECT: "perseus-correct",
  INCORRECT: "perseus-incorrect",
  UNANSWERED: "perseus-unanswered",
  MOBILE: "perseus-mobile"
};

/**
 * A React context for keeping track of whether an component is fully
 * loaded.  This is used to know when SvgImage and (Zoomable)TeX are finished
 * renderering.
 */
const defaultContext$2 = {
  assetStatuses: {},
  setAssetStatus: (assetKey, loaded) => {}
};
const context$3 = /*#__PURE__*/React__namespace.createContext(defaultContext$2);

let _dependencies = null;
const setDependencies = dependencies => {
  _dependencies = dependencies;
};
const getDependencies = () => {
  if (_dependencies) {
    return _dependencies;
  }

  throw new Error(["Perseus has not been provided required dependencies.", "setDependencies(dependencies) must be called first.", "Make sure Perseus is being imported from javascript/perseus/perseus.js."].join("\n"));
};

var dependencies = /*#__PURE__*/Object.freeze({
    __proto__: null,
    setDependencies: setDependencies,
    getDependencies: getDependencies
});

// TODO(LP-11481): Change the primary API we use for logging in Perseus to use
// getDependencies() internally... simplify usage to just using a "singleton"
// which get's the injected logger.

/**
 * @typedef {Object} Errors utility for referencing the Perseus error taxonomy.
 */
const Errors = Object.freeze({
  /**
   * @property {ErrorKind} Unknown The kind of error is not known.
   */
  Unknown: "Unknown",

  /**
   * @property {ErrorKind} Internal The error is internal to the executing code.
   */
  Internal: "Internal",

  /**
   * @property {ErrorKind} InvalidInput There was a problem with the provided
   * input, such as the wrong format or a null value.
   */
  InvalidInput: "InvalidInput",

  /**
   * @property {ErrorKind} NotAllowed There was a problem due to the state of
   * the system not matching the requested operation or input. For example,
   * trying to create a username that is valid, but is already taken by
   * another user. Use {@link InvalidInput} instead when the input isn't
   * valid regardless of the state of the system. Use {@link NotFound} when
   * the failure is due to not being able to find a resource.
   */
  NotAllowed: "NotAllowed",

  /**
   * @property {ErrorKind} TransientService There was a problem when making a
   * request to a service.
   */
  TransientService: "TransientService",

  /**
   * @property {ErrorKind} Service There was a non-transient problem when
   * making a request to service.
   */
  Service: "Service"
});
/**
 * @type {ErrorKind} The kind of error being reported
 */

const Log = {
  // Logs a message
  log: (message, extra) => {
    getDependencies().Log.log(message, extra);
  },
  // Logs an error with a message
  error: (message, kind, extra) => {
    getDependencies().Log.error(message, kind, extra);
  }
};

class PerseusError extends Error {
  constructor(message, kind, options) {
    super(message);

    _defineProperty(this, "kind", void 0);

    _defineProperty(this, "metadata", void 0);

    this.kind = kind;
    this.metadata = options === null || options === void 0 ? void 0 : options.metadata;
  }

}

const KhanMath = {
  // Simplify formulas before display
  cleanMath: function (expr) {
    return typeof expr === "string" ? expr.replace(/\+\s*-/g, "- ").replace(/-\s*-/g, "+ ").replace(/\^1/g, "") : expr;
  },
  // Bound a number by 1e-6 and 1e20 to avoid exponents after toString
  bound: function (num) {
    if (num === 0) {
      return num;
    }

    if (num < 0) {
      return -KhanMath.bound(-num);
    }

    return Math.max(1e-6, Math.min(num, 1e20));
  },
  factorial: function (x) {
    if (x <= 1) {
      return x;
    }

    return x * KhanMath.factorial(x - 1);
  },
  getGCD: function (a, b) {
    if (arguments.length > 2) {
      // TODO(kevinb): rewrite using rest args instead of arguments
      // $FlowFixMe[method-unbinding]
      const rest = [].slice.call(arguments, 1);
      return KhanMath.getGCD(a, KhanMath.getGCD(...rest));
    }

    let mod;
    a = Math.abs(a);
    b = Math.abs(b);

    while (b) {
      mod = a % b;
      a = b;
      b = mod;
    }

    return a;
  },
  getLCM: function (a, b) {
    if (arguments.length > 2) {
      // TODO(kevinb): rewrite using rest args instead of arguments
      // $FlowFixMe[method-unbinding]
      const rest = [].slice.call(arguments, 1);
      return KhanMath.getLCM(a, KhanMath.getLCM(...rest));
    }

    return Math.abs(a * b) / KhanMath.getGCD(a, b);
  },
  primes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97],
  isPrime: function (n) {
    if (n <= 1) {
      return false;
    }

    if (n < 101) {
      return !!$__default["default"].grep(KhanMath.primes, function (p, i) {
        return Math.abs(p - n) <= 0.5;
      }).length;
    }

    if (n <= 1 || n > 2 && n % 2 === 0) {
      return false;
    }

    for (let i = 3, sqrt = Math.sqrt(n); i <= sqrt; i += 2) {
      if (n % i === 0) {
        return false;
      }
    }

    return true;
  },
  // $FlowFixMe[incompatible-return]
  getPrimeFactorization: function (number) {
    if (number === 1) {
      return [];
    }

    if (KhanMath.isPrime(number)) {
      return [number];
    }

    const maxf = Math.sqrt(number);

    for (let f = 2; f <= maxf; f++) {
      if (number % f === 0) {
        return $__default["default"].merge(KhanMath.getPrimeFactorization(f), KhanMath.getPrimeFactorization(number / f));
      }
    }
  },
  // Round a number to the nearest increment
  // E.g., if increment = 30 and num = 40, return 30. if increment = 30 and
  //     num = 45, return 60.
  roundToNearest: function (increment, num) {
    return Math.round(num / increment) * increment;
  },
  // Round a number to a certain number of decimal places
  roundTo: function (precision, num) {
    const factor = Math.pow(10, precision).toFixed(5); // $FlowFixMe[unsafe-addition]
    // $FlowFixMe[incompatible-call]

    return Math.round((num * factor).toFixed(5)) / factor;
  },

  /**
   * Return a string of num rounded to a fixed precision decimal places,
   * with an approx symbol if num had to be rounded, and trailing 0s
   */
  toFixedApprox: function (num, precision) {
    // TODO(aria): Make this locale-dependent like KhanUtil.localeToFixed
    const fixedStr = num.toFixed(precision);

    if (kmath.number.equal(+fixedStr, num)) {
      return fixedStr;
    }

    return "\\approx " + fixedStr;
  },

  /**
   * Return a string of num rounded to precision decimal places, with an
   * approx symbol if num had to be rounded, but no trailing 0s if it was
   * not rounded.
   */
  roundToApprox: function (num, precision) {
    const fixed = KhanMath.roundTo(precision, num);

    if (kmath.number.equal(fixed, num)) {
      return String(fixed);
    }

    return KhanMath.toFixedApprox(num, precision);
  },
  // toFraction(4/8) => [1, 2]
  // toFraction(0.666) => [333, 500]
  // toFraction(0.666, 0.001) => [2, 3]
  //
  // tolerance can't be bigger than 1, sorry
  toFraction: function (decimal, tolerance // $FlowFixMe[incompatible-return]
  ) {
    if (tolerance == null) {
      tolerance = Math.pow(2, -46);
    }

    if (decimal < 0 || decimal > 1) {
      let fract = decimal % 1;
      fract += fract < 0 ? 1 : 0;
      const nd = KhanMath.toFraction(fract, tolerance);
      nd[0] += Math.round(decimal - fract) * nd[1];
      return nd;
    }

    if (Math.abs(Math.round(Number(decimal)) - decimal) <= tolerance) {
      return [Math.round(decimal), 1];
    }

    let loN = 0;
    let loD = 1;
    let hiN = 1;
    let hiD = 1;
    let midN = 1;
    let midD = 2; // eslint-disable-next-line no-constant-condition

    while (true) {
      if (Math.abs(Number(midN / midD) - decimal) <= tolerance) {
        return [midN, midD];
      }

      if (midN / midD < decimal) {
        loN = midN;
        loD = midD;
      } else {
        hiN = midN;
        hiD = midD;
      }

      midN = loN + hiN;
      midD = loD + hiD;
    }
  },
  // Returns the format (string) of a given numeric string
  // Note: purposively more inclusive than answer-types' predicate.forms
  // That is, it is not necessarily true that interpreted input are numeric
  getNumericFormat: function (text) {
    text = $__default["default"].trim(text);
    text = text.replace(/\u2212/, "-").replace(/([+-])\s+/g, "$1");

    if (text.match(/^[+-]?\d+$/)) {
      return "integer";
    }

    if (text.match(/^[+-]?\d+\s+\d+\s*\/\s*\d+$/)) {
      return "mixed";
    }

    const fraction = text.match(/^[+-]?(\d+)\s*\/\s*(\d+)$/);

    if (fraction) {
      return parseFloat(fraction[1]) > parseFloat(fraction[2]) ? "improper" : "proper";
    }

    if (text.replace(/[,. ]/g, "").match(/^\d+$/)) {
      return "decimal";
    }

    if (text.match(/(pi?|\u03c0|t(?:au)?|\u03c4|pau)/)) {
      return "pi";
    }

    return null;
  },
  // Returns a string of the number in a specified format
  toNumericString: function (number, format) {
    if (number == null) {
      return "";
    }

    if (number === 0) {
      return "0"; // otherwise it might end up as 0% or 0pi
    }

    if (format === "percent") {
      return number * 100 + "%";
    }

    if (format === "pi") {
      const fraction = kmath.number.toFraction(number / Math.PI);
      const numerator = Math.abs(fraction[0]);
      const denominator = fraction[1];

      if (kmath.number.isInteger(numerator)) {
        const sign = number < 0 ? "-" : "";
        const pi = "\u03C0";
        return sign + (numerator === 1 ? "" : numerator) + pi + (denominator === 1 ? "" : "/" + denominator);
      }
    }

    if (___default["default"](["proper", "improper", "mixed", "fraction"]).contains(format)) {
      const fraction = kmath.number.toFraction(number);
      const numerator = Math.abs(fraction[0]);
      const denominator = fraction[1];
      const sign = number < 0 ? "-" : "";

      if (denominator === 1) {
        return sign + numerator; // for integers, irrational, d > 1000
      }

      if (format === "mixed") {
        const modulus = numerator % denominator;
        const integer = (numerator - modulus) / denominator;
        return sign + (integer ? integer + " " : "") + modulus + "/" + denominator;
      } // otherwise proper, improper, or fraction


      return sign + numerator + "/" + denominator;
    } // otherwise (decimal, float, long long)


    return String(number);
  }
};

/* eslint-disable no-useless-escape */
const MAXERROR_EPSILON = Math.pow(2, -42);
const errors = {
  APPROXIMATED_PI_ERROR: i18n__namespace._("Your answer is close, but you may " + "have approximated pi. Enter your " + "answer as a multiple of pi, like " + "<code>12\\ \\text{pi}</code> or " + "<code>2/3\\ \\text{pi}</code>"),
  EXTRA_SYMBOLS_ERROR: i18n__namespace._("We could not understand your " + "answer. Please check your answer for extra " + "text or symbols."),
  NEEDS_TO_BE_SIMPLFIED_ERROR: i18n__namespace._("Your answer is almost correct, " + "but it needs to be simplified."),
  MISSING_PERCENT_ERROR: i18n__namespace._("Your answer is almost correct, " + "but it is missing a " + "<code>\\%</code> at the end."),
  MULTIPLICATION_SIGN_ERROR: i18n__namespace._("I'm a computer. I only understand " + "multiplication if you use an asterisk " + "(*) as the multiplication sign."),
  WRONG_CASE_ERROR: i18n__namespace._("Your answer includes use of a variable with the wrong case."),
  WRONG_LETTER_ERROR: i18n__namespace._("Your answer includes a wrong variable letter.")
};
/*
 * Answer types
 *
 * Utility for creating answerable questions displayed in exercises
 *
 * Different answer types produce different kinds of input displays, and do
 * different kinds of checking on the solutions.
 *
 * Each of the objects contain two functions, setup and createValidator.
 *
 * The setup function takes a solutionarea and solution, and performs setup
 * within the solutionarea, and then returns an object which contains:
 *
 * answer: a function which, when called, will retrieve the current answer from
 *         the solutionarea, which can then be validated using the validator
 *         function
 * validator: a function returned from the createValidator function (defined
 *            below)
 * solution: the correct answer to the problem
 * showGuess: a function which, when given a guess, shows the guess within the
 *            provided solutionarea
 * showGuessCustom: a function which displays parts of a guess that are not
 *                  within the solutionarea; currently only used for custom
 *                  answers
 *
 * The createValidator function only takes a solution, and it returns a
 * function which can be used to validate an answer.
 *
 * The resulting validator function returns:
 * - true: if the answer is fully correct
 * - false: if the answer is incorrect
 * - "" (the empty string): if no answer has been provided (e.g. the answer box
 *   is left unfilled)
 * - a string: if there is some slight error
 *
 * In most cases, setup and createValidator don't really need the solution DOM
 * element so we have setupFunctional and createValidatorFunctional for them
 * which take only $solution.text() and $solution.data(). This makes it easier
 * to reuse specific answer types.
 *
 * TODO(alpert): Think of a less-absurd name for createValidatorFunctional.
 *
 */

const KhanAnswerTypes = {
  /*
   * predicate answer type
   *
   * performs simple predicate-based checking of a numeric solution, with
   * different kinds of number formats
   *
   * Uses the data-forms option on the solution to choose which number formats
   * are acceptable. Available data-forms:
   *
   * - integer:  3
   * - proper:   3/5
   * - improper: 5/3
   * - pi:       3 pi
   * - log:      log(5)
   * - percent:  15%
   * - mixed:    1 1/3
   * - decimal:  1.7
   *
   * The solution should be a predicate of the form:
   *
   * function(guess, maxError) {
   *     return abs(guess - 3) < maxError;
   * }
   *
   */
  predicate: {
    defaultForms: "integer, proper, improper, mixed, decimal",
    createValidatorFunctional: function (predicate, options) {
      // Extract the options from the given solution object
      options = ___default["default"].extend({
        simplify: "required",
        ratio: false,
        forms: KhanAnswerTypes.predicate.defaultForms
      }, options);
      let acceptableForms; // this is maintaining backwards compatibility
      // TODO(merlob) fix all places that depend on this, then delete

      if (!___default["default"].isArray(options.forms)) {
        acceptableForms = options.forms.split(/\s*,\s*/);
      } else {
        acceptableForms = options.forms;
      } // TODO(jack): remove options.inexact in favor of options.maxError


      if (options.inexact === undefined) {
        // If we aren't allowing inexact, ensure that we don't have a
        // large maxError as well.
        options.maxError = 0;
      } // Allow a small tolerance on maxError, to avoid numerical
      // representation issues (2.3 should be correct for a solution of
      // 2.45 with maxError=0.15).


      options.maxError = +options.maxError + MAXERROR_EPSILON; // If percent is an acceptable form, make sure it's the last one
      // in the list so we don't prematurely complain about not having
      // a percent sign when the user entered the correct answer in a
      // different form (such as a decimal or fraction)

      if (___default["default"].contains(acceptableForms, "percent")) {
        acceptableForms = ___default["default"].without(acceptableForms, "percent");
        acceptableForms.push("percent");
      } // Take text looking like a fraction, and turn it into a number


      const fractionTransformer = function (text) {
        text = text // Replace unicode minus sign with hyphen
        .replace(/\u2212/, "-") // Remove space after +, -
        .replace(/([+-])\s+/g, "$1") // Remove leading/trailing whitespace
        .replace(/(^\s*)|(\s*$)/gi, ""); // Extract numerator and denominator

        const match = text.match(/^([+-]?\d+)\s*\/\s*([+-]?\d+)$/); // Fractions are represented as "-\frac{numerator}{denominator}"
        // in Mobile device input instead of "numerator/denominator" as
        // in web-browser.

        const mobileDeviceMatch = text.match(/^([+-]?)\\frac\{([+-]?\d+)\}\{([+-]?\d+)\}$/);
        const parsedInt = parseInt(text, 10);

        if (match || mobileDeviceMatch) {
          let num;
          let denom;
          let simplified = true;

          if (match) {
            num = parseFloat(match[1]);
            denom = parseFloat(match[2]);
          } else {
            num = parseFloat(mobileDeviceMatch[2]);

            if (mobileDeviceMatch[1] === "-") {
              if (num < 0) {
                simplified = false;
              }

              num = -num;
            }

            denom = parseFloat(mobileDeviceMatch[3]);
          }

          simplified = simplified && denom > 0 && (options.ratio || denom !== 1) && KhanMath.getGCD(num, denom) === 1;
          return [{
            value: num / denom,
            exact: simplified
          }];
        }

        if (!isNaN(parsedInt) && "" + parsedInt === text) {
          return [{
            value: parsedInt,
            exact: true
          }];
        }

        return [];
      };
      /*
       * Different forms of numbers
       *
       * Each function returns a list of objects of the form:
       *
       * {
       *    value: numerical value,
       *    exact: true/false
       * }
       */


      const forms = {
        // integer, which is encompassed by decimal
        integer: function (text) {
          // Compare the decimal form to the decimal form rounded to
          // an integer. Only accept if the user actually entered an
          // integer.
          const decimal = forms.decimal(text);
          const rounded = forms.decimal(text, 1);

          if (decimal[0].value != null && decimal[0].value === rounded[0].value || decimal[1].value != null && decimal[1].value === rounded[1].value) {
            return decimal;
          }

          return [];
        },
        // A proper fraction
        proper: function (text) {
          return $__default["default"].map(fractionTransformer(text), function (o) {
            // All fractions that are less than 1
            if (Math.abs(o.value) < 1) {
              return [o];
            }

            return [];
          });
        },
        // an improper fraction
        improper: function (text) {
          return $__default["default"].map(fractionTransformer(text), function (o) {
            // All fractions that are greater than 1
            if (Math.abs(o.value) >= 1) {
              return [o];
            }

            return [];
          });
        },
        // pi-like numbers
        pi: function (text) {
          let match;
          let possibilities = []; // Replace unicode minus sign with hyphen

          text = text.replace(/\u2212/, "-"); // - pi
          // (Note: we also support \pi (for TeX), p, tau (and \tau,
          // and t), pau.)

          if (match = text.match(/^([+-]?)\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            possibilities = [{
              value: parseFloat(match[1] + "1"),
              exact: true
            }]; // 5 / 6 pi
          } else if (match = text.match(/^([+-]?\s*\d+\s*(?:\/\s*[+-]?\s*\d+)?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            possibilities = fractionTransformer(match[1]); // 4 5 / 6 pi
          } else if (match = text.match(/^([+-]?)\s*(\d+)\s*([+-]?\d+)\s*\/\s*([+-]?\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            const sign = parseFloat(match[1] + "1");
            const integ = parseFloat(match[2]);
            const num = parseFloat(match[3]);
            const denom = parseFloat(match[4]);
            const simplified = num < denom && KhanMath.getGCD(num, denom) === 1;
            possibilities = [{
              value: sign * (integ + num / denom),
              exact: simplified
            }]; // 5 pi / 6
          } else if (match = text.match(/^([+-]?\s*\d+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\s*\d+))?$/i)) {
            possibilities = fractionTransformer(match[1] + "/" + match[3]); // - pi / 4
          } else if (match = text.match(/^([+-]?)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)\s*(?:\/\s*([+-]?\d+))?$/i)) {
            possibilities = fractionTransformer(match[1] + "1/" + match[3]); // 0
          } else if (text === "0") {
            possibilities = [{
              value: 0,
              exact: true
            }]; // 0.5 pi (fallback)
          } else if (match = text.match(/^(.+)\s*\*?\s*(\\?pi|p|\u03c0|\\?tau|t|\u03c4|pau)$/i)) {
            possibilities = forms.decimal(match[1]);
          } else {
            possibilities = ___default["default"].reduce(KhanAnswerTypes.predicate.defaultForms.split(/\s*,\s*/), function (memo, form) {
              return memo.concat(forms[form](text));
            }, []); // If the answer is a floating point number that's
            // near a multiple of pi, mark is as being possibly
            // an approximation of pi.  We actually check if
            // it's a plausible approximation of pi/12, since
            // sometimes the correct answer is like pi/3 or pi/4.
            // We also say it's a pi-approximation if it involves
            // x/7 (since 22/7 is an approximation of pi.)
            // Never mark an integer as being an approximation
            // of pi.

            let approximatesPi = false;
            const number = parseFloat(text);

            if (!isNaN(number) && number !== parseInt(text)) {
              const piMult = Math.PI / 12;
              const roundedNumber = piMult * Math.round(number / piMult);

              if (Math.abs(number - roundedNumber) < 0.01) {
                approximatesPi = true;
              }
            } else if (text.match(/\/\s*7/)) {
              approximatesPi = true;
            }

            if (approximatesPi) {
              ___default["default"].each(possibilities, function (possibility) {
                possibility.piApprox = true;
              });
            }

            return possibilities;
          }

          let multiplier = Math.PI;

          if (text.match(/\\?tau|t|\u03c4/)) {
            multiplier = Math.PI * 2;
          } // We're taking an early stand along side xkcd in the
          // inevitable ti vs. pau debate... http://xkcd.com/1292


          if (text.match(/pau/)) {
            multiplier = Math.PI * 1.5;
          }

          $__default["default"].each(possibilities, function (ix, possibility) {
            possibility.value *= multiplier;
          });
          return possibilities;
        },
        // Converts '' to 1 and '-' to -1 so you can write "[___] x"
        // and accept sane things
        coefficient: function (text) {
          let possibilities = []; // Replace unicode minus sign with hyphen

          text = text.replace(/\u2212/, "-");

          if (text === "") {
            possibilities = [{
              value: 1,
              exact: true
            }];
          } else if (text === "-") {
            possibilities = [{
              value: -1,
              exact: true
            }];
          }

          return possibilities;
        },
        // simple log(c) form
        log: function (text) {
          let match;
          let possibilities = []; // Replace unicode minus sign with hyphen

          text = text.replace(/\u2212/, "-");
          text = text.replace(/[ \(\)]/g, "");

          if (match = text.match(/^log\s*(\S+)\s*$/i)) {
            possibilities = forms.decimal(match[1]);
          } else if (text === "0") {
            possibilities = [{
              value: 0,
              exact: true
            }];
          }

          return possibilities;
        },
        // Numbers with percent signs
        percent: function (text) {
          text = $__default["default"].trim(text); // store whether or not there is a percent sign

          let hasPercentSign = false;

          if (text.indexOf("%") === text.length - 1) {
            text = $__default["default"].trim(text.substring(0, text.length - 1));
            hasPercentSign = true;
          }

          const transformed = forms.decimal(text);
          $__default["default"].each(transformed, function (ix, t) {
            t.exact = hasPercentSign;
            t.value = t.value / 100;
          });
          return transformed;
        },
        // Mixed numbers, like 1 3/4
        mixed: function (text) {
          const match = text // Replace unicode minus sign with hyphen
          .replace(/\u2212/, "-") // Remove space after +, -
          .replace(/([+-])\s+/g, "$1") // Extract integer, numerator and denominator
          .match(/^([+-]?)(\d+)\s+(\d+)\s*\/\s*(\d+)$/);

          if (match) {
            const sign = parseFloat(match[1] + "1");
            const integ = parseFloat(match[2]);
            const num = parseFloat(match[3]);
            const denom = parseFloat(match[4]);
            const simplified = num < denom && KhanMath.getGCD(num, denom) === 1;
            return [{
              value: sign * (integ + num / denom),
              exact: simplified
            }];
          }

          return [];
        },
        // Decimal numbers -- compare entered text rounded to
        // 'precision' Reciprical of the precision against the correct
        // answer. We round to 1/1e10 by default, which is healthily
        // less than machine epsilon but should be more than any real
        // decimal answer would use. (The 'integer' answer type uses
        // precision == 1.)
        decimal: function (text) {
          let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e10;

          const normal = function (text) {
            text = $__default["default"].trim(text);
            const match = text // Replace unicode minus sign with hyphen
            .replace(/\u2212/, "-") // Remove space after +, -
            .replace(/([+-])\s+/g, "$1") // Extract integer, numerator and denominator. If
            // commas or spaces are used, they must be in the
            // "correct" places
            .match(/^([+-]?(?:\d{1,3}(?:[, ]?\d{3})*\.?|\d{0,3}(?:[, ]?\d{3})*\.(?:\d{3}[, ]?)*\d{1,3}))$/); // You can't start a number with `0,`, to prevent us
            // interpeting '0.342' as correct for '342'

            const badLeadingZero = text.match(/^0[0,]*,/);

            if (match && !badLeadingZero) {
              let x = parseFloat(match[1].replace(/[, ]/g, ""));

              if (options.inexact === undefined) {
                x = Math.round(x * precision) / precision;
              }

              return x;
            }
          };

          const commas = function (text) {
            text = text.replace(/([\.,])/g, function (_, c) {
              return c === "." ? "," : ".";
            });
            return normal(text);
          };

          return [{
            value: normal(text),
            exact: true
          }, {
            value: commas(text),
            exact: true
          }];
        }
      }; // validator function

      return function (guess) {
        // The fallback variable is used in place of the answer, if no
        // answer is provided (i.e. the field is left blank)
        const fallback = options.fallback != null ? "" + options.fallback : "";
        guess = $__default["default"].trim(guess) || fallback;
        const score = {
          empty: guess === "",
          correct: false,
          message: null,
          guess: guess
        }; // iterate over all the acceptable forms, and if one of the
        // answers is correct, return true

        $__default["default"].each(acceptableForms, function (i, form) {
          const transformed = forms[form](guess);

          for (let j = 0, l = transformed.length; j < l; j++) {
            const val = transformed[j].value;
            const exact = transformed[j].exact;
            const piApprox = transformed[j].piApprox; // If a string was returned, and it exactly matches,
            // return true

            if (predicate(val, options.maxError)) {
              // If the exact correct number was returned,
              // return true
              if (exact || options.simplify === "optional") {
                score.correct = true;
                score.message = options.message || null; // If the answer is correct, don't say it's
                // empty. This happens, for example, with the
                // coefficient type where guess === "" but is
                // interpreted as "1" which is correct.

                score.empty = false;
              } else if (form === "percent") {
                // Otherwise, an error was returned
                score.empty = true;
                score.message = errors.MISSING_PERCENT_ERROR;
              } else {
                if (options.simplify !== "enforced") {
                  score.empty = true;
                }

                score.message = errors.NEEDS_TO_BE_SIMPLFIED_ERROR;
              } // The return false below stops the looping of the
              // callback since predicate check  succeeded.
              // No more forms to look to verify the user guess.


              return false;
            }

            if (piApprox && predicate(val, Math.abs(val * 0.001))) {
              score.empty = true;
              score.message = errors.APPROXIMATED_PI_ERROR;
            }
          }
        });

        if (score.correct === false) {
          let interpretedGuess = false;

          ___default["default"].each(forms, function (form) {
            const anyAreNaN = ___default["default"].any(form(guess), function (t) {
              return t.value != null && !___default["default"].isNaN(t.value);
            });

            if (anyAreNaN) {
              interpretedGuess = true;
            }
          });

          if (!interpretedGuess) {
            score.empty = true;
            score.message = errors.EXTRA_SYMBOLS_ERROR;
            return score;
          }
        }

        return score;
      };
    }
  },

  /*
   * number answer type
   *
   * wraps the predicate answer type to performs simple number-based checking
   * of a solution
   */
  number: {
    convertToPredicate: function (correctAnswer, options) {
      // TODO(alpert): Don't think this $.trim is necessary
      const correctFloat = parseFloat($__default["default"].trim(correctAnswer));
      return [function (guess, maxError) {
        return Math.abs(guess - correctFloat) < maxError;
      }, $__default["default"].extend({}, options, {
        type: "predicate"
      })];
    },
    createValidatorFunctional: function (correctAnswer, options) {
      return KhanAnswerTypes.predicate.createValidatorFunctional(...KhanAnswerTypes.number.convertToPredicate(correctAnswer, options));
    }
  },

  /*
   * The expression answer type parses a given expression or equation
   * and semantically compares it to the solution. In addition, instant
   * feedback is provided by rendering the last answer that fully parsed.
   *
   * Parsing options:
   * functions (e.g. data-functions="f g h")
   *     A space or comma separated list of single-letter variables that
   *     should be interpreted as functions. Case sensitive. "e" and "i"
   *     are reserved.
   *
   *     no functions specified: f(x+y) == fx + fy
   *     with "f" as a function: f(x+y) != fx + fy
   *
   * Comparison options:
   * same-form (e.g. data-same-form)
   *     If present, the answer must match the solution's structure in
   *     addition to evaluating the same. Commutativity and excess negation
   *     are ignored, but all other changes will trigger a rejection. Useful
   *     for requiring a particular form of an equation, or if the answer
   *     must be factored.
   *
   *     example question:    Factor x^2 + x - 2
   *     example solution:    (x-1)(x+2)
   *     accepted answers:    (x-1)(x+2), (x+2)(x-1), ---(-x-2)(-1+x), etc.
   *     rejected answers:    x^2+x-2, x*x+x-2, x(x+1)-2, (x-1)(x+2)^1, etc.
   *     rejection message:   Your answer is not in the correct form
   *
   * simplify (e.g. data-simplify)
   *     If present, the answer must be fully expanded and simplified. Use
   *     carefully - simplification is hard and there may be bugs, or you
   *     might not agree on the definition of "simplified" used. You will
   *     get an error if the provided solution is not itself fully expanded
   *     and simplified.
   *
   *     example question:    Simplify ((n*x^5)^5) / (n^(-2)*x^2)^-3
   *     example solution:    x^31 / n
   *     accepted answers:    x^31 / n, x^31 / n^1, x^31 * n^(-1), etc.
   *     rejected answers:    (x^25 * n^5) / (x^(-6) * n^6), etc.
   *     rejection message:   Your answer is not fully expanded and simplified
   *
   * Rendering options:
   * times (e.g. data-times)
   *     If present, explicit multiplication (such as between numbers) will
   *     be rendered with a cross/x symbol (TeX: \times) instead of the usual
   *     center dot (TeX: \cdot).
   *
   *     normal rendering:    2 * 3^x -> 2 \cdot 3^{x}
   *     but with "times":    2 * 3^x -> 2 \times 3^{x}
   */
  expression: {
    parseSolution: function (solutionString, options) {
      let solution = KAS__namespace.parse(solutionString, options);

      if (!solution.parsed) {
        throw new PerseusError("The provided solution (" + solutionString + ") didn't parse.", Errors.InvalidInput);
      } else if (options.simplified && !solution.expr.isSimplified()) {
        throw new PerseusError("The provided solution (" + solutionString + ") isn't fully expanded and simplified.", Errors.InvalidInput);
      } else {
        solution = solution.expr;
      }

      return solution;
    },
    createValidatorFunctional: function (solution, options) {
      return function (guess) {
        const score = {
          empty: false,
          correct: false,
          message: null,
          guess: guess,
          // Setting `ungraded` to true indicates that if the
          // guess doesn't match any of the solutions, the guess
          // shouldn't be marked as incorrect; instead, `message`
          // should be shown to the user. This is different from
          // setting `empty` to true, since the behavior of `empty`
          // is that `message` only will be shown if the guess is
          // graded as empty for every solution.
          ungraded: false
        }; // Don't bother parsing an empty input

        if (!guess) {
          score.empty = true;
          return score;
        }

        const answer = KAS__namespace.parse(guess, options); // An unsuccessful parse doesn't count as wrong

        if (!answer.parsed) {
          score.empty = true;
          return score;
        } // Solution will need to be parsed again if we're creating
        // this from a multiple question type


        if (typeof solution === "string") {
          solution = KhanAnswerTypes.expression.parseSolution(solution, options);
        }

        const result = KAS__namespace.compare(answer.expr, solution, options);

        if (result.equal) {
          // Correct answer
          score.correct = true;
        } else if (result.wrongVariableNames || result.wrongVariableCase) {
          // We don't want to give people an error for getting the
          // variable names or the variable case wrong.
          // TODO(aasmund): This should ideally have been handled
          // under the `result.message` condition, but the
          // KAS messages currently aren't translatable.
          score.ungraded = true;
          score.message = result.wrongVariableCase ? errors.WRONG_CASE_ERROR : errors.WRONG_LETTER_ERROR; // Don't tell the use they're "almost there" in this case, that may not be true and isn't helpful.

          score.suppressAlmostThere = true;
        } else if (result.message) {
          // Nearly correct answer
          // TODO(aasmund): This message also isn't translatable;
          // need to fix that in KAS
          score.message = result.message;
        } else {
          // Replace x with * and see if it would have been correct
          // TODO(aasmund): I think this branch is effectively dead,
          // because the replacement will only work in situations
          // where the variables are wrong (except if the variable
          // is x, in which case the replacement won't work either),
          // which is handled by another branch. When we implement a
          // more sophisticated variable check, revive this or
          // remove it completely if it will never come into play.
          const answerX = KAS__namespace.parse(guess.replace(/[xX]/g, "*"), options);

          if (answerX.parsed) {
            const resultX = KAS__namespace.compare(answerX.expr, solution, options);

            if (resultX.equal) {
              score.ungraded = true;
              score.message = errors.MULTIPLICATION_SIGN_ERROR;
            } else if (resultX.message) {
              // TODO(aasmund): I18nize `score.message`
              score.message = resultX.message + " Also, I'm a computer. I only understand " + "multiplication if you use an " + "asterisk (*) as the multiplication " + "sign.";
            }
          }
        }

        return score;
      };
    }
  }
};

/* eslint-disable @babel/no-invalid-this, getter-return, one-var */
let supportsPassive = false;
const svgLabelsRegex = /^web\+graphie:/; // For offline exercises in the mobile app, we download the graphie data
// (svgs and localized data files) and serve them from the local file
// system (with file://). We replace urls that start with `web+graphie`
// in the perseus json with this `file+graphie` prefix to indicate that
// they should have the `file://` protocol instead of `https://`.

const svgLocalLabelsRegex$1 = /^file\+graphie:/;

const nestedMap$2 = function (children, func, context) {
  if (Array.isArray(children)) {
    return ___default["default"].map(children, function (child) {
      return nestedMap$2(child, func);
    });
  }

  return func.call(context, children);
};
/**
 * Used to compare equality of two input paths, which are represented as
 * arrays of strings.
 */


function inputPathsEqual(a, b) {
  if (a == null || b == null) {
    return a == null === (b == null);
  }

  return a.length === b.length && a.every((item, index) => {
    return b[index] === item;
  });
} // Keep `rWidgetRule` in sync with `WIDGET_RE`
// in content_internal/perseus_traversal.py
// sync-start:widget-id-regex 1271666319 services/content-editing/perseus/translation/content_traversal.go
// sync-start:widget-id-regex 680240484 services/static/javascript/perseus-merged-editor-package/editor.jsx
// sync-start:widget-id-regex 1400368396 content_internal/perseus_traversal.py


const rWidgetRule = /^\[\[\u2603 (([a-z-]+) ([0-9]+))\]\]/;
const rTypeFromWidgetId = /^([a-z-]+) ([0-9]+)$/; // sync-end:widget-id-regex

const rWidgetParts = new RegExp(rWidgetRule.source + "$");
const snowman = "\u2603";
const noScore = {
  type: "points",
  earned: 0,
  total: 0,
  message: null
};

const seededRNG$1 = function (seed) {
  let randomSeed = seed;
  return function () {
    // Robert Jenkins' 32 bit integer hash function.
    let seed = randomSeed;
    seed = seed + 0x7ed55d16 + (seed << 12) & 0xffffffff;
    seed = (seed ^ 0xc761c23c ^ seed >>> 19) & 0xffffffff;
    seed = seed + 0x165667b1 + (seed << 5) & 0xffffffff;
    seed = (seed + 0xd3a2646c ^ seed << 9) & 0xffffffff;
    seed = seed + 0xfd7046c5 + (seed << 3) & 0xffffffff;
    seed = (seed ^ 0xb55a4f09 ^ seed >>> 16) & 0xffffffff;
    return (randomSeed = seed & 0xfffffff) / 0x10000000;
  };
}; // Shuffle an array using a given random seed or function.
// If `ensurePermuted` is true, the input and ouput are guaranteed to be
// distinct permutations.


function shuffle$3(array, randomSeed) {
  let ensurePermuted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // Always return a copy of the input array
  const shuffled = ___default["default"].clone(array); // Handle edge cases (input array is empty or uniform)


  if (!shuffled.length || ___default["default"].all(shuffled, function (value) {
    return ___default["default"].isEqual(value, shuffled[0]);
  })) {
    return shuffled;
  }

  let random;

  if (typeof randomSeed === "function") {
    random = randomSeed;
  } else {
    random = seededRNG$1(randomSeed);
  }

  do {
    // Fischer-Yates shuffle
    for (let top = shuffled.length; top > 0; top--) {
      const newEnd = Math.floor(random() * top),
            temp = shuffled[newEnd];
      shuffled[newEnd] = shuffled[top - 1];
      shuffled[top - 1] = temp;
    }
  } while (ensurePermuted && ___default["default"].isEqual(array, shuffled));

  return shuffled;
}
/**
 * TODO(somewhatabstract, FEI-3463):
 * Drop this custom split thing.
 */
// In IE8, split doesn't work right. Implement it ourselves.


const split = "x".split(/(.)/g).length ? function (str, r) {
  return str.split(r);
} : function (str, r) {
  // Based on Steven Levithan's MIT-licensed split, available at
  // http://blog.stevenlevithan.com/archives/cross-browser-split
  const output = [];
  let lastIndex = r.lastIndex = 0;
  let match;

  while (match = r.exec(str)) {
    const m = match;
    output.push(str.slice(lastIndex, m.index));
    output.push(...m.slice(1));
    lastIndex = m.index + m[0].length;
  }

  output.push(str.slice(lastIndex));
  return output;
};
/**
 * Combine two score objects.
 *
 * Given two score objects for two different widgets, combine them so that
 * if one is wrong, the total score is wrong, etc.
 */

function combineScores(scoreA, scoreB) {
  let message;

  if (scoreA.type === "points" && scoreB.type === "points") {
    if (scoreA.message && scoreB.message && scoreA.message !== scoreB.message) {
      // TODO(alpert): Figure out how to combine messages usefully
      message = null;
    } else {
      message = scoreA.message || scoreB.message;
    }

    return {
      type: "points",
      earned: scoreA.earned + scoreB.earned,
      total: scoreA.total + scoreB.total,
      message: message
    };
  }

  if (scoreA.type === "points" && scoreB.type === "invalid") {
    return scoreB;
  }

  if (scoreA.type === "invalid" && scoreB.type === "points") {
    return scoreA;
  }

  if (scoreA.type === "invalid" && scoreB.type === "invalid") {
    if (scoreA.message && scoreB.message && scoreA.message !== scoreB.message) {
      // TODO(alpert): Figure out how to combine messages usefully
      message = null;
    } else {
      message = scoreA.message || scoreB.message;
    }

    return {
      type: "invalid",
      message: message
    };
  }
  /**
   * The above checks cover all combinations of score type, so if we get here
   * then something is amiss with our inputs.
   */


  throw new PerseusError("PerseusScore with unknown type encountered", Errors.InvalidInput, {
    metadata: {
      scoreA: JSON.stringify(scoreA),
      scoreB: JSON.stringify(scoreB)
    }
  });
}

function keScoreFromPerseusScore(score, guess, state) {
  if (score.type === "points") {
    return {
      empty: false,
      correct: score.earned >= score.total,
      message: score.message,
      guess: guess,
      state: state
    };
  }

  if (score.type === "invalid") {
    return {
      empty: true,
      correct: false,
      message: score.message,
      suppressAlmostThere: score.suppressAlmostThere,
      guess: guess,
      state: state
    };
  }

  throw new PerseusError("Invalid score type: " + score.type, Errors.InvalidInput, {
    metadata: {
      score: JSON.stringify(score),
      guess: JSON.stringify(guess),
      state: JSON.stringify(state)
    }
  });
}
/**
 * Return the first valid interpretation of 'text' as a number, in the form
 * {value: 2.3, exact: true}.
 */


function firstNumericalParse$1(text) {
  // TODO(alpert): This is sort of hacky...
  let first;
  const val = KhanAnswerTypes.predicate.createValidatorFunctional(function (ans) {
    first = ans;
    return true;
    /* break */
  }, {
    simplify: "optional",
    inexact: true,
    forms: "integer, proper, improper, pi, log, mixed, decimal"
  });
  val(text);
  return first;
}

function stringArrayOfSize$1(size) {
  return ___default["default"](size).times(function () {
    return "";
  });
}
/**
 * For a graph's x or y dimension, given the tick step,
 * the ranges extent (e.g. [-10, 10]), the pixel dimension constraint,
 * and the grid step, return a bunch of configurations for that dimension.
 *
 * Example:
 *      gridDimensionConfig(10, [-50, 50], 400, 5)
 *
 * Returns: {
 *      scale: 4,
 *      snap: 2.5,
 *      tickStep: 2,
 *      unityLabel: true
 * };
 */


function gridDimensionConfig(absTickStep, extent, dimensionConstraint, gridStep) {
  const scale = scaleFromExtent(extent, dimensionConstraint);
  const stepPx = absTickStep * scale;
  const unityLabel = stepPx > 30;
  return {
    scale: scale,
    tickStep: absTickStep / gridStep,
    unityLabel: unityLabel
  };
}
/**
 * Given the range, step, and boxSize, calculate the reasonable gridStep.
 * Used for when one was not given explicitly.
 *
 * Example:
 *      getGridStep([[-10, 10], [-10, 10]], [1, 1], 340)
 *
 * Returns: [1, 1]
 *
 * TODO(somewhatabstract, FEI-3464): Consolidate query string parsing functions.
 */


function getGridStep$1(range, step, boxSize) {
  return ___default["default"](2).times(function (i) {
    const scale = scaleFromExtent(range[i], boxSize);
    const gridStep = gridStepFromTickStep(step[i], scale);
    return gridStep;
  });
}

function snapStepFromGridStep(gridStep) {
  return [gridStep[0] / 2, gridStep[1] / 2];
}
/**
 * Given the tickStep and the graph's scale, find a
 * grid step.
 * Example:
 *      gridStepFromTickStep(200, 0.2) // returns 100
 */


function gridStepFromTickStep(tickStep, scale) {
  const tickWidth = tickStep * scale;
  const x = tickStep;
  const y = Math.pow(10, Math.floor(Math.log(x) / Math.LN10));
  const leadingDigit = Math.floor(x / y);

  if (tickWidth < 25) {
    return tickStep;
  }

  if (tickWidth < 50) {
    if (leadingDigit === 5) {
      return tickStep;
    }

    return tickStep / 2;
  }

  if (leadingDigit === 1) {
    return tickStep / 2;
  }

  if (leadingDigit === 2) {
    return tickStep / 4;
  }

  if (leadingDigit === 5) {
    return tickStep / 5;
  }
}
/**
 * Given the range and a dimension, come up with the appropriate
 * scale.
 * Example:
 *      scaleFromExtent([-25, 25], 500) // returns 10
 */


function scaleFromExtent(extent, dimensionConstraint) {
  const span = extent[1] - extent[0];
  const scale = dimensionConstraint / span;
  return scale;
}
/**
 * Return a reasonable tick step given extent and dimension.
 * (extent is [begin, end] of the domain.)
 * Example:
 *      tickStepFromExtent([-10, 10], 300) // returns 2
 */


function tickStepFromExtent(extent, dimensionConstraint) {
  const span = extent[1] - extent[0];
  let tickFactor; // If single number digits

  if (15 < span && span <= 20) {
    tickFactor = 23; // triple digit or decimal
  } else if (span > 100 || span < 5) {
    tickFactor = 10; // double digit
  } else {
    tickFactor = 16;
  }

  const constraintFactor = dimensionConstraint / 500;
  const desiredNumTicks = tickFactor * constraintFactor;
  return tickStepFromNumTicks(span, desiredNumTicks);
}
/**
 * Find a good tick step for the desired number of ticks in the range
 * Modified from d3.scale.linear: d3_scale_linearTickRange.
 * Thanks, mbostock!
 * Example:
 *      tickStepFromNumTicks(50, 6) // returns 10
 */


function tickStepFromNumTicks(span, numTicks) {
  let step = Math.pow(10, Math.floor(Math.log(span / numTicks) / Math.LN10));
  const err = numTicks / span * step; // Filter ticks to get closer to the desired count.

  if (err <= 0.15) {
    step *= 10;
  } else if (err <= 0.35) {
    step *= 5;
  } else if (err <= 0.75) {
    step *= 2;
  } // Round start and stop values to step interval.


  return step;
}

// [min, max]
const constrainTickStep = (step, range) => {
  const span = range[1] - range[0];
  const numTicks = span / step;

  if (numTicks <= 10) {
    // Will displays fine on mobile
    return step;
  }

  if (numTicks <= 20) {
    // Will be crowded on mobile, so hide every other tick
    return step * 2;
  } // Fallback in case we somehow have more than 20 ticks
  // Note: This shouldn't happen due to GraphSettings.validStep


  return tickStepFromNumTicks(span, 10);
};
/**
 * Constrain tick steps intended for desktop size graphs
 * to something more suitable for mobile size graphs.
 * Specifically, we aim for 10 or fewer ticks per graph axis.
 */


function constrainedTickStepsFromTickSteps(tickSteps, ranges) {
  return [constrainTickStep(tickSteps[0], ranges[0]), constrainTickStep(tickSteps[1], ranges[1])];
}
/**
 * Transparently update deprecated props so that the code to deal
 * with them only lives in one place: (Widget).deprecatedProps
 *
 * For example, if a boolean `foo` was deprecated in favor of a
 * number 'bar':
 *      deprecatedProps: {
 *          foo: function(props) {
 *              return {bar: props.foo ? 1 : 0};
 *          }
 *      }
 */


const DeprecationMixin$1 = {
  // This lifecycle stage is only called before first render
  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount: function () {
    const newProps = {};

    ___default["default"].each(this.deprecatedProps, function (func, prop) {
      if (___default["default"].has(this.props, prop)) {
        ___default["default"].extend(newProps, func(this.props));
      }
    }, this);

    if (!___default["default"].isEmpty(newProps)) {
      // Set new props directly so that widget renders correctly
      // when it first mounts, even though these will be overwritten
      // almost immediately afterwards...
      ___default["default"].extend(this.props, newProps); // ...when we propagate the new props upwards and they come
      // back down again.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax


      setTimeout(this.props.onChange, 0, newProps);
    }
  }
};
/**
 * Approximate equality on numbers and primitives.
 */

function eq$1(x, y) {
  if (typeof x === "number" && typeof y === "number") {
    return Math.abs(x - y) < 1e-9;
  }

  return x === y;
}
/**
 * Deep approximate equality on primitives, numbers, arrays, and objects.
 * Recursive.
 */


function deepEq$5(x, y) {
  if (Array.isArray(x) && Array.isArray(y)) {
    if (x.length !== y.length) {
      return false;
    }

    for (let i = 0; i < x.length; i++) {
      if (!deepEq$5(x[i], y[i])) {
        return false;
      }
    }

    return true;
  }

  if (Array.isArray(x) || Array.isArray(y)) {
    return false;
  }

  if (typeof x === "function" && typeof y === "function") {
    return eq$1(x, y);
  }

  if (typeof x === "function" || typeof y === "function") {
    return false;
  }

  if (typeof x === "object" && typeof y === "object" && !!x && !!y) {
    return x === y || ___default["default"].all(x, function (v, k) {
      return deepEq$5(y[k], v);
    }) && ___default["default"].all(y, function (v, k) {
      return deepEq$5(x[k], v);
    });
  }

  if (typeof x === "object" && !!x || typeof y === "object" && !!y) {
    return false;
  }

  return eq$1(x, y);
}
/**
 * Query String Parser
 *
 * Original from:
 * http://stackoverflow.com/questions/901115/get-querystring-values-in-javascript/2880929#2880929
 */


function parseQueryString(query) {
  // TODO(jangmi, CP-3340): Use withLocation to access SSR safe location.
  // eslint-disable-next-line no-restricted-syntax
  query = query || window.location.search.substring(1);
  const urlParams = {}; // Regex for replacing addition symbol with a space

  const a = /\+/g;
  const r = /([^&=]+)=?([^&]*)/g;

  const d = function (s) {
    return decodeURIComponent(s.replace(a, " "));
  };

  let e;

  while (e = r.exec(query)) {
    const m = e;
    urlParams[d(m[1])] = d(m[2]);
  }

  return urlParams;
}
/**
 * Query string adder
 * Works for URLs without #.
 * Original from:
 * http://stackoverflow.com/questions/5999118/add-or-update-query-string-parameter
 */


function updateQueryString$2(uri, key, value) {
  value = encodeURIComponent(value);
  const re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
  const separator = uri.indexOf("?") !== -1 ? "&" : "?";

  if (uri.match(re)) {
    return uri.replace(re, "$1" + key + "=" + value + "$2");
  }

  return uri + separator + key + "=" + value;
}
/**
 * A more strict encodeURIComponent that escapes `()'!`s
 * Especially useful for creating URLs that are embeddable in markdown
 *
 * Adapted from
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
 * This function and the above original available under the
 * CC-BY-SA 2.5 license.
 */


function strongEncodeURIComponent(str) {
  return encodeURIComponent(str) // Note that although RFC3986 reserves "!", RFC5987 does not,
  // so we do not need to escape it
  .replace(/['()!]/g, window.escape) // i.e., %27 %28 %29
  .replace(/\*/g, "%2A");
}
/**
 * TODO(somewhatabstract, JIRA-XXXX):
 * This does not appear to be used within webapp. Could be dead code.
 * Need to check with mobile.
 */
// There are certain widgets where we don't want to provide the "answered"
// highlight indicator.
// The issue with just using the `graded` flag on questions is that showing
// that a certain widget is ungraded can sometimes reveal the answer to a
// question ("is this transformation possible? if so, do it")
// This is kind of a hack to get around this.


function widgetShouldHighlight(widget) {
  if (!widget) {
    return false;
  }

  switch (widget.type) {
    /**
     * Highlight bar blacklist
     */
    case "measurer":
    case "protractor":
      return true;

    default:
      return false;
  }
}
/**
 * If a widget says that it is empty once it is graded.
 * Trying to encapsulate references to the score format.
 */


function scoreIsEmpty(score) {
  // HACK(benkomalo): ugh. this isn't great; the Perseus score objects
  // overload the type "invalid" for what should probably be three
  // distinct cases:
  //  - truly empty or not fully filled out
  //  - invalid or malformed inputs
  //  - "almost correct" like inputs where the widget wants to give
  //  feedback (e.g. a fraction needs to be reduced, or `pi` should
  //  be used instead of 3.14)
  //
  //  Unfortunately the coercion happens all over the place, as these
  //  Perseus style score objects are created *everywhere* (basically
  //  in every widget), so it's hard to change now. We assume that
  //  anything with a "message" is not truly empty, and one of the
  //  latter two cases for now.
  return score.type === "invalid" && (!score.message || score.message.length === 0);
}
/*
 * The touchHandlers are used to track the current state of the touch
 * event, such as whether or not the user is currently pressed down (either
 * through touch or mouse) on the screen.
 */


const touchHandlers = {
  pointerDown: false,
  currentTouchIdentifier: null
};

function resetTouchHandlers() {
  Object.assign(touchHandlers, {
    pointerDown: false,
    currentTouchIdentifier: null
  });
}
/**
 * Extracts the location of a touch or mouse event, allowing you to pass
 * in a "mouseup", "mousedown", or "mousemove" event and receive the
 * correct coordinates. Shouldn't be used with "vmouse" events.
 */


function extractPointerLocation(event) {
  let touchOrEvent;

  if (touchHandlers.pointerDown) {
    // Look for the touch matching the one we're tracking; ignore others
    if (touchHandlers.currentTouchIdentifier != null) {
      const len = event.changedTouches ? event.changedTouches.length : 0;

      for (let i = 0; i < len; i++) {
        if (event.changedTouches[i].identifier === touchHandlers.currentTouchIdentifier) {
          touchOrEvent = event.changedTouches[i];
        }
      }
    } else {
      touchOrEvent = event;
    }

    const isEndish = event.type === "touchend" || event.type === "touchcancel";

    if (touchOrEvent && isEndish) {
      touchHandlers.pointerDown = false;
      touchHandlers.currentTouchIdentifier = null;
    }
  } else {
    // touchstart or mousedown
    touchHandlers.pointerDown = true;

    if (event.changedTouches) {
      touchOrEvent = event.changedTouches[0];
      touchHandlers.currentTouchIdentifier = touchOrEvent.identifier;
    } else {
      touchOrEvent = event;
    }
  }

  if (touchOrEvent) {
    return {
      left: touchOrEvent.pageX,
      top: touchOrEvent.pageY
    };
  }
} // Older browsers don't support passive events and so we need to feature-
// detect them and do event subscription differently for them.
// See: orderer.jsx


const supportsPassiveEvents = () => {
  // Test via a getter in the options object to see if the passive
  // property is accessed
  try {
    const opts = Object.defineProperty({}, "passive", {
      get: function () {
        supportsPassive = true;
      }
    });
    window.addEventListener("testPassive", null, opts);
    window.removeEventListener("testPassive", null, opts);
  } catch (e) {// Intentionally left empty!
  }

  return supportsPassive;
};
/**
 * Pass this function as the touchstart for an element to
 * avoid sending the touch to the mobile scratchpad
 */


function captureScratchpadTouchStart$4(e) {
  e.stopPropagation();
}

function getImageSize(url, callback) {
  const img = new Image();

  img.onload = function () {
    // IE 11 seems to have problems calculating the heights of svgs
    // if they're not in the DOM. To solve this, we add the element to
    // the dom, wait for a rerender, and use `.clientWidth` and
    // `.clientHeight`. I think we could also solve the problem by
    // adding the image to the document before setting the src, but then
    // the experience would be worse for other browsers.
    // TODO(scottgrant): This is correctly calculating the width of SVG
    // images in browsers, but incorrectly saving the width of what may
    // be a smaller viewport when using the editor, and reusing that
    // width in a full-screen article.
    if (img.width === 0 && img.height === 0) {
      var _document$body;

      (_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.appendChild(img); // TODO(scottgrant): Remove this use of _.defer.

      ___default["default"].defer(function () {
        var _document$body2;

        callback(img.clientWidth, img.clientHeight);
        (_document$body2 = document.body) === null || _document$body2 === void 0 ? void 0 : _document$body2.removeChild(img);
      });
    } else {
      callback(img.width, img.height);
    }
  };

  img.src = getRealImageUrl(url);
} // Sometimes other components want to download the actual image e.g. to
// determine its size. Here, we transform an .svg-labels url into the
// correct image url, and leave normal image urls alone


function getRealImageUrl(url) {
  if (isLabeledSVG(url)) {
    return getSvgUrl(url);
  }

  return url;
}

function isLabeledSVG(url) {
  return svgLabelsRegex.test(url) || svgLocalLabelsRegex$1.test(url);
} // For each svg+labels, there are two urls we need to download from. This gets
// the base url without the suffix, and `getSvgUrl` and `getDataUrl` apply
// appropriate suffixes to get the image and other data


function getBaseUrl(url) {
  return url.replace(svgLabelsRegex, "https:").replace(svgLocalLabelsRegex$1, "file:");
}

function getSvgUrl(url) {
  return getBaseUrl(url) + ".svg";
}

function getDataUrl(url) {
  return getBaseUrl(url) + "-data.json";
}
/**
 * Gets the word right before where the textarea cursor is
 *
 * @param {Element} textarea - The textarea DOM element
 * @return {JSON} - An object with the word and its starting and ending positions in the textarea
 */


function getWordBeforeCursor(textarea) {
  const text = textarea.value;
  const endPos = textarea.selectionStart - 1;
  const startPos = Math.max(text.lastIndexOf("\n", endPos), text.lastIndexOf(" ", endPos)) + 1;
  return {
    string: text.substring(startPos, endPos + 1),
    pos: {
      start: startPos,
      end: endPos
    }
  };
}
/**
 * Moves the textarea cursor at the specified position
 *
 * @param {Element} textarea - The textarea DOM element
 * @param {int} pos - The position where the cursor will be moved
 */


function moveCursor(textarea, pos) {
  textarea.selectionStart = pos;
  textarea.selectionEnd = pos;
}

const textarea = {
  getWordBeforeCursor,
  moveCursor
};
/**
 * Many of our labels are automatically converted into math mode without
 * the dollar signs. Unfortunately, this makes them untranslatable! This
 * helper function removes the math mode symbols from a string if we want
 * to translate it but don't need the extra dollar signs.
 */

const unescapeMathMode$1 = label => label.startsWith("$") && label.endsWith("$") ? label.slice(1, -1) : label;

const random$1 = seededRNG$1(new Date().getTime() & 0xffffffff);
const Util = {
  inputPathsEqual,
  nestedMap: nestedMap$2,
  rWidgetRule,
  rTypeFromWidgetId,
  rWidgetParts,
  snowman,
  noScore,
  seededRNG: seededRNG$1,
  shuffle: shuffle$3,
  split,
  combineScores,
  keScoreFromPerseusScore,
  firstNumericalParse: firstNumericalParse$1,
  stringArrayOfSize: stringArrayOfSize$1,
  gridDimensionConfig,
  getGridStep: getGridStep$1,
  snapStepFromGridStep,
  scaleFromExtent,
  tickStepFromExtent,
  gridStepFromTickStep,
  tickStepFromNumTicks,
  constrainedTickStepsFromTickSteps,
  DeprecationMixin: DeprecationMixin$1,
  eq: eq$1,
  deepEq: deepEq$5,
  parseQueryString,
  updateQueryString: updateQueryString$2,
  strongEncodeURIComponent,
  widgetShouldHighlight,
  scoreIsEmpty,
  touchHandlers,
  resetTouchHandlers,
  extractPointerLocation,
  supportsPassiveEvents,
  captureScratchpadTouchStart: captureScratchpadTouchStart$4,
  getImageSize,
  getRealImageUrl,
  isLabeledSVG,
  getBaseUrl,
  getSvgUrl,
  getDataUrl,
  textarea,
  unescapeMathMode: unescapeMathMode$1,
  random: random$1
};

// Derived from the MIT-licensed:
/*jshint browser:true, node:true */

/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
// CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
// ============================================================

function transitionEnd() {
  const el = document.createElement("bootstrap");
  const transEndEventNames = {
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "transitionend",
    OTransition: "oTransitionEnd otransitionend",
    transition: "transitionend"
  };

  for (const name in transEndEventNames) {
    // $FlowFixMe[incompatible-type]
    if (el.style[name] !== undefined) {
      return {
        end: transEndEventNames[name]
      };
    }
  }

  return false; // explicit for ie8 (  ._.)
} // http://blog.alexmaccaw.com/css-transitions


$__default["default"].fn.emulateTransitionEnd = function (duration) {
  let called = false;
  const $el = this;
  $__default["default"](this).one("bsTransitionEnd", function () {
    called = true;
  });

  const callback = function () {
    if (!called) {
      $__default["default"]($el).trigger($__default["default"].support.transition.end);
    }
  }; // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
  // eslint-disable-next-line no-restricted-syntax


  setTimeout(callback, duration);
  return this;
};

$__default["default"](function () {
  $__default["default"].support.transition = transitionEnd();

  if (!$__default["default"].support.transition) {
    return;
  }

  $__default["default"].event.special.bsTransitionEnd = {
    bindType: $__default["default"].support.transition.end,
    delegateType: $__default["default"].support.transition.end,
    handle: function (e) {
      if ($__default["default"](e.target).is(this)) {
        return e.handleObj.handler.apply(this, arguments);
      }
    }
  };
});
/**
 * Changes the viewport meta tag to the given contentString. Invokes callback
 * after viewport meta tag changes have taken effect.
 *
 * TODO(david): Return a promise instead of invoking a callback.
 */

function changeViewportTag(contentString, callback) {
  const scrollX = window.scrollX;
  const scrollY = window.scrollY;
  const viewport = document.querySelector("meta[name=viewport]");

  if (viewport) {
    viewport.setAttribute("content", contentString);
  } else {
    $__default["default"]("head").append("<meta name=\"viewport\" content=\"".concat(contentString, "\">"));
  } // Hacky way to get the page to take the changes
  // From http://stackoverflow.com/a/36894653
  // $FlowFixMe[incompatible-use]
  // $FlowFixMe[incompatible-type]


  document.body.style.opacity = 0.9999; // ... and undo the temporary change.
  // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
  // eslint-disable-next-line no-restricted-syntax

  setTimeout(() => {
    // $FlowFixMe[incompatible-use]
    // $FlowFixMe[incompatible-type]
    document.body.style.opacity = 1; // ... which involves restoring the scroll position, which may have
    // changed.

    window.scrollTo(scrollX, scrollY); // Invoke callback on the next tick to wait for scroll position to have
    // finished resetting.
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax

    callback && setTimeout(callback, 0);
  }, 0);
}
/**
 * The zoom service
 */


function ZoomServiceClass() {}

ZoomServiceClass.prototype._initialize = function (enableMobilePinch) {
  // Check to see if the service is already initialized
  if (this._$document) {
    return;
  }

  this._activeZoom = this._initialScrollPosition = this._initialTouchPosition = this._touchMoveListener = null;
  this._$document = $__default["default"](document);
  this._$window = $__default["default"](window);
  this._$body = $__default["default"](document.body);
  this._boundClick = $__default["default"].proxy(this._clickHandler, this);
  this._enableMobilePinch = enableMobilePinch;
};

ZoomServiceClass.prototype.handleZoomClick = function (e, enableMobilePinch) {
  this._initialize(enableMobilePinch);

  const target = e.target;

  if (!target || target.tagName !== "IMG") {
    return;
  }

  if (this._$body.hasClass("zoom-overlay-open")) {
    return;
  }

  if (e.metaKey || e.ctrlKey) {
    return window.open(e.target.src, "_blank");
  }

  if (!enableMobilePinch && target.width >= window.innerWidth - Zoom.getOffset()) {
    return;
  }

  this._activeZoomClose(true); // Enable page zooming in (i.e. make sure there's no maximum-scale). Also,
  // disable page zoom out on mobile devices, because the container that the
  // image is placed in becomes bigger than the viewport if the page can be
  // zoomed out. We explored other fixes like fixing the overlay and page
  // size to be the viewport, but thought that might be even worse of a hack.
  // See for more info:
  // http://dbushell.com/2013/09/10/css-fixed-positioning-and-mobile-zoom/


  if (enableMobilePinch) {
    // Disable zoom out by setting minimum scale of 1 on the viewport tag.
    changeViewportTag("width=device-width, initial-scale=1, minimum-scale=1", () => this._zoom(target));
  } else {
    this._zoom(target);
  }

  if (!enableMobilePinch) {
    // todo(fat): probably worth throttling this
    this._$window.on("scroll.zoom", $__default["default"].proxy(this._scrollHandler, this));

    this._$document.on("keyup.zoom", $__default["default"].proxy(this._keyHandler, this));

    this._$document.on("touchstart.zoom", $__default["default"].proxy(this._touchStart, this));
  } // we use a capturing phase here to prevent unintended js events
  // sadly no useCapture in jquery api (http://bugs.jquery.com/ticket/14953)


  document.addEventListener("click", this._boundClick, true);
  e.stopPropagation();
};

ZoomServiceClass.prototype._zoom = function (target) {
  // $FlowFixMe[invalid-constructor]
  this._activeZoom = new Zoom(target, this._enableMobilePinch);

  this._activeZoom.zoomImage();
};

ZoomServiceClass.prototype._activeZoomClose = function (forceDispose) {
  if (!this._activeZoom) {
    return;
  }

  if (forceDispose) {
    this._activeZoom.dispose();

    this._disposeActiveZoom();
  } else {
    // Reset any underlying page zoom in case the user had pinched to zoom.
    changeViewportTag("width=device-width, initial-scale=1, minimum-scale=1,\n            maximum-scale=1", () => {
      if (this._activeZoom) {
        this._activeZoom.close();

        this._disposeActiveZoom();
      }
    });
  }
};

ZoomServiceClass.prototype._disposeActiveZoom = function () {
  this._$window.off(".zoom");

  this._$document.off(".zoom");

  document.removeEventListener("click", this._boundClick, true);
  this._activeZoom = null;
};

ZoomServiceClass.prototype._scrollHandler = function (e) {
  if (this._initialScrollPosition === null) {
    this._initialScrollPosition = window.scrollY;
  }

  const deltaY = this._initialScrollPosition - window.scrollY;

  if (Math.abs(deltaY) >= 40) {
    this._activeZoomClose();
  }
};

ZoomServiceClass.prototype._keyHandler = function (e) {
  if (e.keyCode === 27) {
    this._activeZoomClose();
  }
};

ZoomServiceClass.prototype._clickHandler = function (e) {
  e.stopPropagation();
  e.preventDefault();

  this._activeZoomClose();
};

ZoomServiceClass.prototype._touchStart = function (e) {
  // Our jQuery doesn't include `touches` in its event
  // TODO(kevindangoor) Remove `originalEvent` once jQuery is updated
  this._initialTouchPosition = e.originalEvent.touches[0].pageY;
  $__default["default"](e.target).on("touchmove.zoom", $__default["default"].proxy(this._touchMove, this));
};

ZoomServiceClass.prototype._touchMove = function (e) {
  // Our jQuery doesn't include `touches` in its event
  // TODO(kevindangoor) Remove `originalEvent` once jQuery is updated
  if (Math.abs(e.originalEvent.touches[0].pageY - this._initialTouchPosition) > 10) {
    this._activeZoomClose();

    $__default["default"](e.target).off("touchmove.zoom");
  }
};
/**
 * The zoom object
 */


function Zoom(img, enableMobilePinch) {
  this._fullHeight = this._fullWidth = this._overlay = null;
  this._targetImage = img;
  this._enableMobilePinch = enableMobilePinch;
  this._$body = $__default["default"](document.body);
}
/** Margin around the image when in the "zoomed"/lightbox state. */


Zoom._OFFSET = 80;
Zoom._MAX_WIDTH = 2560;
Zoom._MAX_HEIGHT = 4096;

Zoom.getOffset = function (zoomToFitOnMobile) {
  return zoomToFitOnMobile ? 0 : Zoom._OFFSET;
};

Zoom.prototype.getOffset = function () {
  return Zoom.getOffset(this._enableMobilePinch);
};

Zoom.prototype.zoomImage = function () {
  const img = document.createElement("img");
  const $zoomedImage = $__default["default"](img);

  img.onload = function () {
    // Load the image without specifying height and width so that we can find
    // the true height and width.
    this._fullHeight = Number(img.height);
    this._fullWidth = Number(img.width); // Set up our image to mirror the current image on the document.

    const imageOffset = this._imageOffset = $__default["default"](this._targetImage).offset(); // Position the image using viewport-fixed coordinates so that it is
    // exactly over the image on the document.
    //
    // Said another way ... get the coordinates of the image relative to
    // the viewport, and use those to position our new image (which is
    // absolutely positioned within a full-bleed fixed-position container).

    const left = this._left = imageOffset.left - $__default["default"](window).scrollLeft();
    const top = this._top = imageOffset.top - $__default["default"](window).scrollTop();
    $zoomedImage.css({
      left: left,
      top: top,
      width: this._targetImage.width,
      height: this._targetImage.height
    });

    this._zoomOriginal();
  }.bind(this);

  img.src = this._targetImage.src;
  this.$zoomedImage = $zoomedImage;
};

Zoom.prototype._zoomOriginal = function () {
  var _document$body, _document$body2, _this$_overlay;

  this.$zoomedImage.addClass("zoom-img").attr("data-action", "zoom-out");
  $__default["default"](this._targetImage).css("visibility", "hidden");
  this._backdrop = document.createElement("div");
  this._backdrop.className = "zoom-backdrop";
  (_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.appendChild(this._backdrop);
  this._overlay = document.createElement("div");
  this._overlay.className = "zoom-overlay";
  (_document$body2 = document.body) === null || _document$body2 === void 0 ? void 0 : _document$body2.appendChild(this._overlay);
  (_this$_overlay = this._overlay) === null || _this$_overlay === void 0 ? void 0 : _this$_overlay.appendChild(this.$zoomedImage[0]);

  this._calculateZoom();

  this._triggerAnimation();
};

Zoom.prototype._calculateZoom = function () {
  const originalFullImageWidth = this._fullWidth;
  const originalFullImageHeight = this._fullHeight;
  const viewportHeight = window.innerHeight - this.getOffset();
  const viewportWidth = window.innerWidth - this.getOffset(); // $FlowFixMe[unsafe-addition]

  const maxScaleFactor = originalFullImageWidth / this._targetImage.width; // Zoom to fit the viewport.
  // $FlowFixMe[unsafe-addition]

  const imageAspectRatio = originalFullImageWidth / originalFullImageHeight;
  const viewportAspectRatio = viewportWidth / viewportHeight;

  if ( // $FlowFixMe[invalid-compare]
  originalFullImageWidth < viewportWidth && // $FlowFixMe[invalid-compare]
  originalFullImageHeight < viewportHeight) {
    this._imgScaleFactor = maxScaleFactor;
  } else if (imageAspectRatio < viewportAspectRatio) {
    this._imgScaleFactor = // $FlowFixMe[unsafe-addition]
    viewportHeight / originalFullImageHeight * maxScaleFactor;
  } else {
    this._imgScaleFactor = viewportWidth / (originalFullImageWidth !== null && originalFullImageWidth !== void 0 ? originalFullImageWidth : 0) * maxScaleFactor;
  }
};

Zoom.prototype._triggerAnimation = function () {
  const viewportY = $__default["default"](window).scrollTop() + window.innerHeight / 2;
  const viewportX = $__default["default"](window).scrollLeft() + window.innerWidth / 2;
  const scaleFactor = this._imgScaleFactor;
  const imageCenterY = this._imageOffset.top + this._targetImage.height / 2;
  const imageCenterX = this._imageOffset.left + this._targetImage.width / 2;
  this._translateY = (viewportY - imageCenterY) / scaleFactor;
  this._translateX = (viewportX - imageCenterX) / scaleFactor; // NOTE: This is re-used below.

  this._zoomedInTransformString = "\n        scale(".concat(scaleFactor, ")\n        translate3d(").concat(this._translateX, "px, ").concat(this._translateY, "px, 0)\n    ");
  this.$zoomedImage.css({
    transform: this._zoomedInTransformString
  }).addClass("zoom-transition").one($__default["default"].support.transition.end, $__default["default"].proxy(this._onZoomInFinish, this)).emulateTransitionEnd(300);

  this._$body.addClass("zoom-overlay-open");
};

Zoom.prototype._onZoomInFinish = function () {
  // Remove the transform on the image, but make it look exactly the same as
  // the image with the transform -- full-size and centered in the viewport
  // -- using margins + left/top + scroll
  //
  // We need to remove the transform for scrolling to work -- the browser
  // would still calculate the element position/sizing by its pre-transform
  // dimensions.
  const height = this._targetImage.height * this._imgScaleFactor;
  const width = this._targetImage.width * this._imgScaleFactor;
  let left = 0;
  let top = 0;
  let marginLeft = 0;
  let marginTop = 0;
  let scrollLeft = 0;
  let scrollTop = 0; // Horizontally center the image within the viewport, either by positioning
  // with CSS or scrolling the viewport.

  if (width < window.innerWidth) {
    left = "50%";
    marginLeft = -width / 2;
  } else {
    scrollLeft = (width - window.innerWidth) / 2;
  } // ... and similarly, vertically center the image within the viewport.


  if (height < window.innerHeight) {
    top = "50%";
    marginTop = -height / 2;
  } else {
    scrollTop = (height - window.innerHeight) / 2;
  }

  this.$zoomedImage.css({
    height: height,
    left: left,
    marginLeft: marginLeft,
    marginTop: marginTop,
    top: top,
    transform: "",
    width: width
  }).removeClass("zoom-transition");
  $__default["default"](this._overlay).scrollLeft(scrollLeft).scrollTop(scrollTop);
};

Zoom.prototype.close = function () {
  this._$body.removeClass("zoom-overlay-open").addClass("zoom-overlay-transitioning"); // Upon closing the image, zoom it back out. Do this by first re-applying the
  // zoomed-in transform and resetting the CSS top/left + margins to what it
  // was right after zooming in -- basically undoing what we did in
  // _onZoomInFinish.
  // TODO(david): Adjust this translation of the transform to take into
  //     account the current scroll position of the image (if the user
  //     scrolled the image after it was zoomed).


  this.$zoomedImage.css({
    height: this._targetImage.height,
    left: this._left,
    marginLeft: 0,
    marginTop: 0,
    top: this._top,
    transform: this._zoomedInTransformString,
    width: this._targetImage.width
  }).removeClass("zoom-transition");
  $__default["default"](this._overlay).scrollLeft(0).scrollTop(0); // ... now that the image and its container have been set up to be in the
  // same state as right at the end of the zoom-in animation, reset the
  // transform to scale(1) to achieve the zoom-out-into-image-on-document
  // animation.
  // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
  // eslint-disable-next-line no-restricted-syntax

  setTimeout(() => {
    this.$zoomedImage.css({
      transform: "scale(1)"
    }).addClass("zoom-transition").one($__default["default"].support.transition.end, $__default["default"].proxy(this.dispose, this)).emulateTransitionEnd(300);
  }, 10);
};

Zoom.prototype.dispose = function () {
  if (this.$zoomedImage && this.$zoomedImage[0].parentNode) {
    this.$zoomedImage.remove();
    this.$zoomedImage = null;

    this._overlay.parentNode.removeChild(this._overlay);

    this._backdrop.parentNode.removeChild(this._backdrop);

    this._$body.removeClass("zoom-overlay-transitioning");
  }

  $__default["default"](this._targetImage).css("visibility", "visible");

  this._targetImage.focus();
}; // $FlowFixMe[invalid-constructor]


const ZoomService = new ZoomServiceClass();

// @baseFontFamily:        "Proxima Nova", sans-serif;
const baseFontFamily$1 = "'Proxima Nova',sans-serif"; // @boldFontFamily:        "Proxima Nova Semibold", sans-serif;

const boldFontFamily = "'Proxima Nova Semibold',sans-serif"; // @green:                 #76a005;

const green$1 = "#76A005"; // @kaGreen:               #71b307;

const kaGreen$1 = "#71B307"; // @blue:                  #1c758a;

const blue$1 = "#1C758A"; // @gray:                  #aaa;

const gray$1 = "#AAAAAA"; // @red:                   #ffbaba;

const red$1 = "#FFBABA"; // @grayLight:             #aaa;

const grayLight$1 = "#AAAAAA"; // @grayLighter:           #ddd;

const grayLighter$1 = "#DDDDDD"; // @learnstormBlue:        #4898fc;

const learnstormBlue$1 = "#4898FC";
const white$1 = "#FFFFFF";
const gray98 = "#FAFAFA";
const gray97 = "#F6F7F7";
const gray95 = "#F0F1F2";
const gray90 = "#E3E5E6";
const gray85 = "#D6D8DA";
const gray76 = "#BABEC2";
const gray68 = "#888D93";
const gray41 = "#626569";
const gray25 = "#3B3e40";
const gray17 = "#21242c";
const black$1 = "#000000";
const warning1 = "#F86700";
const warning3 = "#C75300"; // @pure-sm-min: 568px;

const pureSmMin$2 = "568px"; // @pure-md-min: 768px;

const pureMdMin$2 = "768px"; // @pure-lg-min: 1024px;

const pureLgMin$2 = "1024px"; // @pure-xl-min: 1280px;

const pureXlMin$2 = "1280px"; // @pure-xs-max: (@pure-sm-min - 1);

const pureXsMax$2 = "567px"; // @pure-sm-max: (@pure-md-min - 1);

const pureSmMax$2 = "767px"; // @pure-md-max: (@pure-lg-min - 1);

const pureMdMax$2 = "1023px"; // @pure-lg-max: (@pure-xl-min - 1);

const pureLgMax$2 = "1279px"; // @tableBackgroundAccent: #f9f9f9; // for striping

const tableBackgroundAccent$1 = "#F9F9F9";
const gtpBlue = "#4c00ff";
const gtpIncorrectColor = "#babec2";
const gtpCorrectColor = "#ffbe26"; // @satBlue:               #0084ce;

const satBlue = "#0084CE"; // @satSelectedBackgroundColor: #e4f3f9;

const satSelectedBackgroundColor = "#E4F3F9"; // @satActiveBackgroundColor: #d0edf4;

const satActiveBackgroundColor = "#D0EDF4"; // @satCorrectColor:       #009900;

const satCorrectColor = "#009900"; // @satCorrectBorderColor: #00cc00;

const satCorrectBorderColor = "#00CC00"; // @satCorrectBackgroundColor: #e4f7e4;

const satCorrectBackgroundColor = "#E4F7E4"; // @satIncorrectColor:     #990000;

const satIncorrectColor = "#990000"; // @satIncorrectBorderColor: #cc5252;

const satIncorrectBorderColor = "#CC5252"; // @satIncorrectBackgroundColor: #f2ebeb;

const satIncorrectBackgroundColor = "#F2EBEB"; // @zIndexScratchPad: 1;

const zIndexScratchPad = 1; // @zIndexAboveScratchpad: @zIndexScratchPad + 1;

const zIndexAboveScratchpad$1 = 2; // @zIndexInteractiveComponent: @zIndexAboveScratchpad + 1;

const zIndexInteractiveComponent$1 = 3; // @zIndexCurrentlyDragging: @zIndexInteractiveComponent + 1;

const zIndexCurrentlyDragging = 4; // @zIndexCalculator: @zIndexCurrentlyDragging + 1;

const zIndexCalculator = 5; // @phoneMargin: 16px;

const phoneMargin = 16;
const negativePhoneMargin = -16;
const hintBorderWidth = 4; // The 'base unit' -- our new typography and layout styles are defined in
// terms of multiples of the 'base unit'.

const baseUnitPx = 16;
const interactiveSizes$1 = {
  defaultBoxSize: 400,
  defaultBoxSizeSmall: 288
};
const circleSize$1 = 24;
const radioMarginWidth$1 = 2;
const warningColor = "#f86700";
const warningColorHover = "#df5c00";
const warningColorActive = "#c75300";
const publishBlockingErrorColor = "#be2612";
const radioBorderColor$2 = "#BABEC2";
const checkedColor$1 = "#71B307"; // sync-start:article-max-width 986452807 services/static/javascript/perseus-all-package/styles/variables.less

const articleMaxWidthInPx = 688;
const articleMaxWidthTableInPx = 512; // sync-end:article-max-width

var constants$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    baseFontFamily: baseFontFamily$1,
    boldFontFamily: boldFontFamily,
    green: green$1,
    kaGreen: kaGreen$1,
    blue: blue$1,
    gray: gray$1,
    red: red$1,
    grayLight: grayLight$1,
    grayLighter: grayLighter$1,
    learnstormBlue: learnstormBlue$1,
    white: white$1,
    gray98: gray98,
    gray97: gray97,
    gray95: gray95,
    gray90: gray90,
    gray85: gray85,
    gray76: gray76,
    gray68: gray68,
    gray41: gray41,
    gray25: gray25,
    gray17: gray17,
    black: black$1,
    warning1: warning1,
    warning3: warning3,
    pureSmMin: pureSmMin$2,
    pureMdMin: pureMdMin$2,
    pureLgMin: pureLgMin$2,
    pureXlMin: pureXlMin$2,
    pureXsMax: pureXsMax$2,
    pureSmMax: pureSmMax$2,
    pureMdMax: pureMdMax$2,
    pureLgMax: pureLgMax$2,
    tableBackgroundAccent: tableBackgroundAccent$1,
    gtpBlue: gtpBlue,
    gtpIncorrectColor: gtpIncorrectColor,
    gtpCorrectColor: gtpCorrectColor,
    satBlue: satBlue,
    satSelectedBackgroundColor: satSelectedBackgroundColor,
    satActiveBackgroundColor: satActiveBackgroundColor,
    satCorrectColor: satCorrectColor,
    satCorrectBorderColor: satCorrectBorderColor,
    satCorrectBackgroundColor: satCorrectBackgroundColor,
    satIncorrectColor: satIncorrectColor,
    satIncorrectBorderColor: satIncorrectBorderColor,
    satIncorrectBackgroundColor: satIncorrectBackgroundColor,
    zIndexScratchPad: zIndexScratchPad,
    zIndexAboveScratchpad: zIndexAboveScratchpad$1,
    zIndexInteractiveComponent: zIndexInteractiveComponent$1,
    zIndexCurrentlyDragging: zIndexCurrentlyDragging,
    zIndexCalculator: zIndexCalculator,
    phoneMargin: phoneMargin,
    negativePhoneMargin: negativePhoneMargin,
    hintBorderWidth: hintBorderWidth,
    baseUnitPx: baseUnitPx,
    interactiveSizes: interactiveSizes$1,
    circleSize: circleSize$1,
    radioMarginWidth: radioMarginWidth$1,
    warningColor: warningColor,
    warningColorHover: warningColorHover,
    warningColorActive: warningColorActive,
    publishBlockingErrorColor: publishBlockingErrorColor,
    radioBorderColor: radioBorderColor$2,
    checkedColor: checkedColor$1,
    articleMaxWidthInPx: articleMaxWidthInPx,
    articleMaxWidthTableInPx: articleMaxWidthTableInPx
});

/* eslint-disable react/prop-types */
const MIN_VIEWPORT_HEIGHT = 480;
const FixedToResponsive = createReactClass__default["default"]({
  displayName: "FixedToResponsive",
  propTypes: {
    width: PropTypes__default["default"].number.isRequired,
    height: PropTypes__default["default"].number.isRequired,
    className: PropTypes__default["default"].string,
    constrainHeight: PropTypes__default["default"].bool,
    allowFullBleed: PropTypes__default["default"].bool
  },
  getDefaultProps: function () {
    return {
      className: "",
      constrainHeight: false,
      allowFullBleed: false
    };
  },
  getInitialState: function () {
    return {
      viewportHeight: null,
      viewportWidth: null
    };
  },
  componentDidMount: function () {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true; // Cache viewport sizes instead of computing on each render.
    // We setState() in componentDidMount(), even though it's a React
    // anti-pattern, because we do actually want to trigger a re-render
    // after the initial render (because initial render may be
    // server-side).
    // TODO(david): Don't do this for each image. Do this once per page.

    if (window.innerHeight < MIN_VIEWPORT_HEIGHT) {
      // There is a weird issue when this gets rendered in an Android
      // webview where window.innerHeight might be initially very small,
      // like 46, but seems to be good after ~400ms.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(this._cacheViewportSize, 800);
    } else {
      this._cacheViewportSize();
    }
  },
  componentWillUnmount: function () {
    this._isMounted = false;
  },
  _cacheViewportSize: function () {
    if (this._isMounted) {
      this.setState({
        viewportHeight: Math.max(MIN_VIEWPORT_HEIGHT, window.innerHeight),
        viewportWidth: window.innerWidth
      });
    }
  },
  render: function () {
    // The ideal behavior for responsified, fixed size child components is
    // that they shrink when they need to (while preserving aspect ratio)
    // but never grow larger than their original dimensions. We accomplish
    // this by absolutely positioning the children and telling them to fill
    // up all of a space that has the correct aspect ratio.
    const aspectRatio = this.props.width / this.props.height; // This works because padding percentages are interpreted in terms of
    // the width of the containing block, so:
    //     (fixed height / fixed width) * display width = display height
    // Based on http://refills.bourbon.io/components/#video && medium.com

    const spacer = /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        // $FlowFixMe[unsafe-addition]
        paddingBottom: (1 / aspectRatio).toFixed(4) * 100 + "%"
      }
    });
    let {
      width,
      height
    } = this.props; // Constrain height to be at most 2/3 viewport height, maintaining
    // aspect ratio.

    if (this.props.constrainHeight && this.state.viewportHeight) {
      const maxHeight = 2 / 3 * this.state.viewportHeight;

      if (this.props.height >= maxHeight) {
        height = maxHeight;
        width = maxHeight * aspectRatio;
      }
    } // Prevent child components from growing (aka "the Peter Pan effect")


    const style = {
      maxWidth: width,
      maxHeight: height
    }; // NOTE(jeremy): This depends on styles defined in perseus-renderer.less

    const className = classNames__default["default"]("fixed-to-responsive", this.props.className);
    const container = /*#__PURE__*/React__namespace.createElement("div", {
      className: className,
      style: style
    }, spacer, this.props.children);
    const shouldFullBleed = this.props.allowFullBleed && this.state.viewportWidth && width >= this.state.viewportWidth;

    if (shouldFullBleed) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        style: {
          marginLeft: negativePhoneMargin,
          marginRight: negativePhoneMargin
        }
      }, container);
    }

    return container;
  }
});

/* eslint-disable @babel/no-invalid-this */
/* Local helper methods. */

function getKey(eventName, id) {
  return eventName + ":" + id;
}

function getEventName(key) {
  return key.split(":")[0];
}

const MovableHelperMethods = {
  /**
   * Fire an onSomething type event to all functions in listeners
   */
  _fireEvent: function (listeners, currentValue, previousValue) {
    ___default["default"].invoke(listeners, "call", this, currentValue, previousValue);
  },

  /**
   * Combine the array of constraints functions
   * Returns either an [x, y] coordinate or false
   */
  _applyConstraints: function (current, previous, extraOptions) {
    let skipRemaining = false;
    return ___default["default"].reduce(this.state.constraints, (memo, constraint) => {
      // A move that has been cancelled won't be propagated to later
      // constraints calls
      if (memo === false) {
        return false;
      }

      if (skipRemaining) {
        return memo;
      }

      const result = constraint.call(this, memo, previous, {
        onSkipRemaining: () => {
          skipRemaining = true;
        },
        ...extraOptions
      });

      if (result === false) {
        // Returning false cancels the move
        return false;
      }

      if (kmath.point.is(result, 2)) {
        // Returning a coord from constraints overrides the move
        return result;
      }

      if (result === true || result == null) {
        // Returning true or undefined allow the move to occur
        return memo;
      } // Anything else is an error


      throw new PerseusError("Constraint returned invalid result: " + result, Errors.Internal);
    }, current, this);
  },

  /**
   * Call all draw functions, and update our prevState for the next
   * draw function
   */
  draw: function () {
    const currState = this.cloneState();

    MovableHelperMethods._fireEvent.call(this, this.state.draw, currState, this.prevState);

    this.prevState = currState;
  },

  /**
   * Add a listener to any event: startMove, constraints, onMove, onMoveEnd,
   * etc. If a listener is already bound to the given eventName and id, then
   * it is overwritten by func.
   *
   * eventName: the string name of the event to listen to. one of:
   *   "onMoveStart", "onMove", "onMoveEnd", "draw", "remove"
   *
   * id: a string id that can be used to remove this event at a later time
   *   note: adding multiple listeners with the same id is undefined behavior
   *
   * func: the function to call when the event happens, which is called
   *   with the event's standard parameters [usually (coord, prevCoord) or
   *   (state, prevState)]
   */
  listen: function (eventName, id, func) {
    this._listenerMap = this._listenerMap || {}; // If there's an existing handler, replace it by using its index in
    // `this.state[eventName]`; otherwise, add this handler to the end

    const key = getKey(eventName, id);
    const index = this._listenerMap[key] = this._listenerMap[key] || this.state[eventName].length;
    this.state[eventName][index] = func;
  },

  /**
   * Remove a previously added listener, by the id specified in the
   * corresponding listen() call
   *
   * If the given id has not been registered already, this is a no-op
   */
  unlisten: function (eventName, id) {
    this._listenerMap = this._listenerMap || {};
    const key = getKey(eventName, id);
    const index = this._listenerMap[key];

    if (index !== undefined) {
      // Remove handler from list of event handlers and listenerMap
      this.state[eventName].splice(index, 1);
      delete this._listenerMap[key]; // Re-index existing events: if they occur after `index`, decrement

      const keys = ___default["default"].keys(this._listenerMap);

      ___default["default"].each(keys, function (key) {
        if (getEventName(key) === eventName && this._listenerMap[key] > index) {
          this._listenerMap[key]--;
        }
      }, this);
    }
  }
};

/**
 * Utility functions for writing Interactive2 movablethings
 */
/**
 * Compute the correct vendor-prefixed `transform`.
 */

let prefixedTransform = null;

function computePrefixedTransform() {
  // Temporary element for testing prefix validity
  const el = document.createElement("div");
  const prefixes = ["transform", "msTransform", "MozTransform", "WebkitTransform", "OTransform"];
  let correctPrefix = null;

  ___default["default"].each(prefixes, function (prefix) {
    if (typeof el.style[prefix] !== "undefined") {
      correctPrefix = prefix;
    }
  });

  return correctPrefix;
}
/**
 * Compute whether the browser can use 3d transforms by trying to use the
 * translateZ transformation.
 */


let canUse3dTransform = null;

function computeCanUse3dTransform() {
  const el = document.createElement("div");
  const prefix = InteractiveUtil.getPrefixedTransform(); // Prefix could be null.
  // $FlowFixMe[incompatible-type]

  el.style[prefix] = "translateZ(0px)"; // $FlowFixMe[incompatible-type]

  return !!el.style[prefix];
}

const InteractiveUtil = {
  assert: function (isTrue, message) {
    if (!isTrue) {
      throw new PerseusError("Assertion Error" + (message ? ": " + message : ""), Errors.Internal);
    }
  },

  /**
   * Create getters for this.state, based on the default state, `defaults`
   */
  createGettersFor: function (Class, defaults) {
    ___default["default"].each(___default["default"].keys(defaults), function (key) {
      if (Class.prototype[key] === undefined) {
        Class.prototype[key] = function () {
          return this.state[key];
        };
      }
    });
  },

  /**
   * Add MovableHelperMethods methods to a MovableThing class
   */
  addMovableHelperMethodsTo: function (Class) {
    ___default["default"].each(MovableHelperMethods, function (methodFunc, methodName) {
      if (Class.prototype[methodName] === undefined) {
        Class.prototype[methodName] = methodFunc;
      }
    });
  },

  /**
   * Turn a function or an array of functions into an array of functions
   */
  arrayify: function (funcOrArray) {
    if (funcOrArray == null) {
      return [];
    }

    if (___default["default"].isArray(funcOrArray)) {
      return ___default["default"].filter(___default["default"].flatten(funcOrArray), ___default["default"].identity);
    }

    return [funcOrArray];
  },

  /**
   * Convert all function-or-array arguments to arrays of functions
   */
  normalizeOptions: function (arrayOptionNames, options) {
    // TODO(jack): Having to clone here is annoying; this
    // function should really just modify this.state in place
    // (and maybe be a function on MovableHelperMethods to get access
    // to this.state), which would also be nicer because we could
    // normalizeOptions once in this.modify
    const result = ___default["default"].clone(options);

    ___default["default"].each(arrayOptionNames, function (eventName) {
      const funcOrArray = options[eventName]; // Only propagate values which were set; not present values
      // shouldn't be added to options because we'd like them to
      // fall through to defaults

      if (funcOrArray !== undefined) {
        const funcArray = InteractiveUtil.arrayify(funcOrArray);
        result[eventName] = funcArray;
      }
    });

    return result;
  },

  /**
   * Get the correct vendor-prefixed `transform`.
   */
  getPrefixedTransform: function () {
    // Cache result to avoid re-computation
    prefixedTransform = prefixedTransform || computePrefixedTransform();
    return prefixedTransform;
  },

  /**
   * Get whether the browser can use 3d transforms.
   */
  getCanUse3dTransform: function () {
    if (canUse3dTransform == null) {
      canUse3dTransform = computeCanUse3dTransform();
    }

    return canUse3dTransform;
  }
};

var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var raphael = {exports: {}};

/*!
 * Raphael 1.5.2 - JavaScript Vector Library
 *
 * Copyright (c) 2010 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
 */

(function () {
  var setAttr;

  if ("".trim) {
    setAttr = function (node, att, value) {
      node.setAttribute(att, String(value).trim());
    };
  } else {
    setAttr = function (node, att, value) {
      node.setAttribute(att, String(value));
    };
  }

  function R() {
    if (R.is(arguments[0], array)) {
      var a = arguments[0],
          cnv = create[apply](R, a.splice(0, 3 + R.is(a[0], nu))),
          res = cnv.set();

      for (var i = 0, ii = a[length]; i < ii; i++) {
        var j = a[i] || {};
        elements[has](j.type) && res[push](cnv[j.type]().attr(j));
      }

      return res;
    }

    return create[apply](R, arguments);
  }

  R.version = "1.5.2";

  var separator = /[, ]+/,
      elements = {
    circle: 1,
    rect: 1,
    path: 1,
    ellipse: 1,
    text: 1,
    image: 1
  },
      formatrg = /\{(\d+)\}/g,
      proto = "prototype",
      has = "hasOwnProperty",
      doc = document,
      win = window,
      oldRaphael = {
    was: Object[proto][has].call(win, "Raphael"),
    is: win.Raphael
  },
      Paper = function () {
    this.customAttributes = {};
  },
      paperproto,
      appendChild = "appendChild",
      apply = "apply",
      concat = "concat",
      supportsTouch = ("createTouch" in doc),
      E = "",
      S = " ",
      Str = String,
      split = "split",
      events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend orientationchange touchcancel gesturestart gesturechange gestureend"[split](S),
      touchMap = {
    mousedown: "touchstart",
    mousemove: "touchmove",
    mouseup: "touchend"
  },
      join = "join",
      length = "length",
      lowerCase = Str[proto].toLowerCase,
      math = Math,
      mmax = math.max,
      mmin = math.min,
      abs = math.abs,
      pow = math.pow,
      PI = math.PI,
      nu = "number",
      string = "string",
      array = "array",
      toString = "toString",
      fillString = "fill",
      objectToString = Object[proto][toString],
      push = "push",
      ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
      colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
      isnan = {
    "NaN": 1,
    "Infinity": 1,
    "-Infinity": 1
  },
      bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
      round = math.round,
      toFloat = parseFloat,
      toInt = parseInt,
      ms = " progid:DXImageTransform.Microsoft",
      upperCase = Str[proto].toUpperCase,
      availableAttrs = {
    blur: 0,
    "clip-rect": "0 0 1e9 1e9",
    cursor: "default",
    cx: 0,
    cy: 0,
    fill: "#fff",
    "fill-opacity": 1,
    font: '10px "Arial"',
    "font-family": '"Arial"',
    "font-size": "10",
    "font-style": "normal",
    "font-weight": 400,
    gradient: 0,
    height: 0,
    href: "http://raphaeljs.com/",
    opacity: 1,
    path: "M0,0",
    r: 0,
    rotation: 0,
    rx: 0,
    ry: 0,
    scale: "1 1",
    src: "",
    stroke: "#000",
    "stroke-dasharray": "",
    "stroke-linecap": "butt",
    "stroke-linejoin": "butt",
    "stroke-miterlimit": 0,
    "stroke-opacity": 1,
    "stroke-width": 1,
    target: "_blank",
    "text-anchor": "middle",
    title: "Raphael",
    translation: "0 0",
    width: 0,
    x: 0,
    y: 0
  },
      availableAnimAttrs = {
    along: "along",
    blur: nu,
    "clip-rect": "csv",
    cx: nu,
    cy: nu,
    fill: "colour",
    "fill-opacity": nu,
    "font-size": nu,
    height: nu,
    opacity: nu,
    path: "path",
    r: nu,
    rotation: "csv",
    rx: nu,
    ry: nu,
    scale: "csv",
    stroke: "colour",
    "stroke-opacity": nu,
    "stroke-width": nu,
    translation: "csv",
    width: nu,
    x: nu,
    y: nu
  },
      rp = "replace",
      animKeyFrames = /^(from|to|\d+%?)$/,
      commaSpaces = /\s*,\s*/,
      hsrg = {
    hs: 1,
    rg: 1
  },
      p2s = /,?([achlmqrstvxz]),?/gi,
      pathCommand = /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
      pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
      radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/,
      sortByKey = function (a, b) {
    return a.key - b.key;
  };

  R.type = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML";

  if (R.type == "VML") {
    var d = doc.createElement("div"),
        b;
    d.innerHTML = '<v:shape adj="1"/>';
    b = d.firstChild;
    b.style.behavior = "url(#default#VML)";

    if (!(b && typeof b.adj == "object")) {
      return R.type = null;
    }

    d = null;
  }

  R.svg = !(R.vml = R.type == "VML");
  Paper[proto] = R[proto];
  paperproto = Paper[proto];
  R._id = 0;
  R._oid = 0;
  R.fn = {};

  R.is = function (o, type) {
    type = lowerCase.call(type);

    if (type == "finite") {
      return !isnan[has](+o);
    }

    return type == "null" && o === null || type == typeof o || type == "object" && o === Object(o) || type == "array" && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
  };

  R.angle = function (x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
      var x = x1 - x2,
          y = y1 - y2;

      if (!x && !y) {
        return 0;
      }

      return ((x < 0) * 180 + math.atan(-y / -x) * 180 / PI + 360) % 360;
    } else {
      return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
    }
  };

  R.rad = function (deg) {
    return deg % 360 * PI / 180;
  };

  R.deg = function (rad) {
    return rad * 180 / PI % 360;
  };

  R.snapTo = function (values, value, tolerance) {
    tolerance = R.is(tolerance, "finite") ? tolerance : 10;

    if (R.is(values, array)) {
      var i = values.length;

      while (i--) if (abs(values[i] - value) <= tolerance) {
        return values[i];
      }
    } else {
      values = +values;
      var rem = value % values;

      if (rem < tolerance) {
        return value - rem;
      }

      if (rem > values - tolerance) {
        return value - rem + values;
      }
    }

    return value;
  };

  function createUUID() {
    // http://www.ietf.org/rfc/rfc4122.txt
    var s = [],
        i = 0;

    for (; i < 32; i++) {
      s[i] = (~~(math.random() * 16))[toString](16);
    }

    s[12] = 4; // bits 12-15 of the time_hi_and_version field to 0010

    s[16] = (s[16] & 3 | 8)[toString](16); // bits 6-7 of the clock_seq_hi_and_reserved to 01

    return "r-" + s[join]("");
  }

  R.setWindow = function (newwin) {
    win = newwin;
    doc = win.document;
  }; // colour utilities


  var toHex = function (color) {
    if (R.vml) {
      // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
      var trim = /^\s+|\s+$/g;
      var bod;

      try {
        var docum = new ActiveXObject("htmlfile");
        docum.write("<body>");
        docum.close();
        bod = docum.body;
      } catch (e) {
        bod = createPopup().document.body;
      }

      var range = bod.createTextRange();
      toHex = cacher(function (color) {
        try {
          bod.style.color = Str(color)[rp](trim, E);
          var value = range.queryCommandValue("ForeColor");
          value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16;
          return "#" + ("000000" + value[toString](16)).slice(-6);
        } catch (e) {
          return "none";
        }
      });
    } else {
      var i = doc.createElement("i");
      i.title = "Rapha\xebl Colour Picker";
      i.style.display = "none";
      doc.body[appendChild](i);
      toHex = cacher(function (color) {
        i.style.color = color;
        return doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
      });
    }

    return toHex(color);
  },
      hsbtoString = function () {
    return "hsb(" + [this.h, this.s, this.b] + ")";
  },
      hsltoString = function () {
    return "hsl(" + [this.h, this.s, this.l] + ")";
  },
      rgbtoString = function () {
    return this.hex;
  };

  R.hsb2rgb = function (h, s, b, o) {
    if (R.is(h, "object") && "h" in h && "s" in h && "b" in h) {
      b = h.b;
      s = h.s;
      h = h.h;
      o = h.o;
    }

    return R.hsl2rgb(h, s, b / 2, o);
  };

  R.hsl2rgb = function (h, s, l, o) {
    if (R.is(h, "object") && "h" in h && "s" in h && "l" in h) {
      l = h.l;
      s = h.s;
      h = h.h;
    }

    if (h > 1 || s > 1 || l > 1) {
      h /= 360;
      s /= 100;
      l /= 100;
    }

    var rgb = {},
        channels = ["r", "g", "b"],
        t2,
        t1,
        t3;

    if (!s) {
      rgb = {
        r: l,
        g: l,
        b: l
      };
    } else {
      if (l < .5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (t3 * 6 < 1) {
          rgb[channels[i]] = t1 + (t2 - t1) * 6 * t3;
        } else if (t3 * 2 < 1) {
          rgb[channels[i]] = t2;
        } else if (t3 * 3 < 2) {
          rgb[channels[i]] = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          rgb[channels[i]] = t1;
        }
      }
    }

    rgb.r *= 255;
    rgb.g *= 255;
    rgb.b *= 255;
    rgb.hex = "#" + (16777216 | rgb.b | rgb.g << 8 | rgb.r << 16).toString(16).slice(1);
    R.is(o, "finite") && (rgb.opacity = o);
    rgb.toString = rgbtoString;
    return rgb;
  };

  R.rgb2hsb = function (red, green, blue) {
    if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
      blue = red.b;
      green = red.g;
      red = red.r;
    }

    if (green == null && R.is(red, string)) {
      var clr = R.getRGB(red);
      red = clr.r;
      green = clr.g;
      blue = clr.b;
    }

    if (red > 1 || green > 1 || blue > 1) {
      red /= 255;
      green /= 255;
      blue /= 255;
    }

    var max = mmax(red, green, blue),
        min = mmin(red, green, blue),
        hue,
        saturation,
        brightness = max;

    if (min == max) {
      return {
        h: 0,
        s: 0,
        b: max,
        toString: hsbtoString
      };
    } else {
      var delta = max - min;
      saturation = delta / max;

      if (red == max) {
        hue = (green - blue) / delta;
      } else if (green == max) {
        hue = 2 + (blue - red) / delta;
      } else {
        hue = 4 + (red - green) / delta;
      }

      hue /= 6;
      hue < 0 && hue++;
      hue > 1 && hue--;
    }

    return {
      h: hue,
      s: saturation,
      b: brightness,
      toString: hsbtoString
    };
  };

  R.rgb2hsl = function (red, green, blue) {
    if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
      blue = red.b;
      green = red.g;
      red = red.r;
    }

    if (green == null && R.is(red, string)) {
      var clr = R.getRGB(red);
      red = clr.r;
      green = clr.g;
      blue = clr.b;
    }

    if (red > 1 || green > 1 || blue > 1) {
      red /= 255;
      green /= 255;
      blue /= 255;
    }

    var max = mmax(red, green, blue),
        min = mmin(red, green, blue),
        h,
        s,
        l = (max + min) / 2,
        hsl;

    if (min == max) {
      hsl = {
        h: 0,
        s: 0,
        l: l
      };
    } else {
      var delta = max - min;
      s = l < .5 ? delta / (max + min) : delta / (2 - max - min);

      if (red == max) {
        h = (green - blue) / delta;
      } else if (green == max) {
        h = 2 + (blue - red) / delta;
      } else {
        h = 4 + (red - green) / delta;
      }

      h /= 6;
      h < 0 && h++;
      h > 1 && h--;
      hsl = {
        h: h,
        s: s,
        l: l
      };
    }

    hsl.toString = hsltoString;
    return hsl;
  };

  R._path2string = function () {
    return this.join(",")[rp](p2s, "$1");
  };

  function cacher(f, scope, postprocessor) {
    function newf() {
      var arg = Array[proto].slice.call(arguments, 0),
          args = arg[join]("\u25ba"),
          cache = newf.cache = newf.cache || {},
          count = newf.count = newf.count || [];

      if (cache[has](args)) {
        return postprocessor ? postprocessor(cache[args]) : cache[args];
      }

      count[length] >= 1e3 && delete cache[count.shift()];
      count[push](args);
      cache[args] = f[apply](scope, arg);
      return postprocessor ? postprocessor(cache[args]) : cache[args];
    }

    return newf;
  }

  R.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: "none",
        error: 1
      };
    }

    if (colour == "none") {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: "none"
      };
    }

    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
    var red,
        green,
        blue,
        opacity,
        t,
        values,
        rgb = colour.match(colourRegExp);

    if (rgb) {
      if (rgb[2]) {
        blue = toInt(rgb[2].substring(5), 16);
        green = toInt(rgb[2].substring(3, 5), 16);
        red = toInt(rgb[2].substring(1, 3), 16);
      }

      if (rgb[3]) {
        blue = toInt((t = rgb[3].charAt(3)) + t, 16);
        green = toInt((t = rgb[3].charAt(2)) + t, 16);
        red = toInt((t = rgb[3].charAt(1)) + t, 16);
      }

      if (rgb[4]) {
        values = rgb[4][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
      }

      if (rgb[5]) {
        values = rgb[5][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        return R.hsb2rgb(red, green, blue, opacity);
      }

      if (rgb[6]) {
        values = rgb[6][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == "%" && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == "%" && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == "%" && (blue *= 2.55);
        (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        return R.hsl2rgb(red, green, blue, opacity);
      }

      rgb = {
        r: red,
        g: green,
        b: blue
      };
      rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
      R.is(opacity, "finite") && (rgb.opacity = opacity);
      return rgb;
    }

    return {
      r: -1,
      g: -1,
      b: -1,
      hex: "none",
      error: 1
    };
  }, R);

  R.getColor = function (value) {
    var start = this.getColor.start = this.getColor.start || {
      h: 0,
      s: 1,
      b: value || .75
    },
        rgb = this.hsb2rgb(start.h, start.s, start.b);
    start.h += .075;

    if (start.h > 1) {
      start.h = 0;
      start.s -= .2;
      start.s <= 0 && (this.getColor.start = {
        h: 0,
        s: 1,
        b: start.b
      });
    }

    return rgb.hex;
  };

  R.getColor.reset = function () {
    delete this.start;
  }; // path utilities


  R.parsePathString = cacher(function (pathString) {
    if (!pathString) {
      return null;
    }

    var paramCounts = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    },
        data = [];

    if (R.is(pathString, array) && R.is(pathString[0], array)) {
      // rough assumption
      data = pathClone(pathString);
    }

    if (!data[length]) {
      Str(pathString)[rp](pathCommand, function (a, b, c) {
        var params = [],
            name = lowerCase.call(b);
        c[rp](pathValues, function (a, b) {
          b && params[push](+b);
        });

        if (name == "m" && params[length] > 2) {
          data[push]([b][concat](params.splice(0, 2)));
          name = "l";
          b = b == "m" ? "l" : "L";
        }

        while (params[length] >= paramCounts[name]) {
          data[push]([b][concat](params.splice(0, paramCounts[name])));

          if (!paramCounts[name]) {
            break;
          }
        }
      });
    }

    data[toString] = R._path2string;
    return data;
  });

  R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t,
        x = pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
        y = pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y,
        mx = p1x + 2 * t * (c1x - p1x) + t * t * (c2x - 2 * c1x + p1x),
        my = p1y + 2 * t * (c1y - p1y) + t * t * (c2y - 2 * c1y + p1y),
        nx = c1x + 2 * t * (c2x - c1x) + t * t * (p2x - 2 * c2x + c1x),
        ny = c1y + 2 * t * (c2y - c1y) + t * t * (p2y - 2 * c2y + c1y),
        ax = (1 - t) * p1x + t * c1x,
        ay = (1 - t) * p1y + t * c1y,
        cx = (1 - t) * c2x + t * p2x,
        cy = (1 - t) * c2y + t * p2y,
        alpha = 90 - math.atan((mx - nx) / (my - ny)) * 180 / PI;
    (mx > nx || my < ny) && (alpha += 180);
    return {
      x: x,
      y: y,
      m: {
        x: mx,
        y: my
      },
      n: {
        x: nx,
        y: ny
      },
      start: {
        x: ax,
        y: ay
      },
      end: {
        x: cx,
        y: cy
      },
      alpha: alpha
    };
  };

  var pathDimensions = cacher(function (path) {
    if (!path) {
      return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }

    path = path2curve(path);
    var x = 0,
        y = 0,
        X = [],
        Y = [],
        p;

    for (var i = 0, ii = path[length]; i < ii; i++) {
      p = path[i];

      if (p[0] == "M") {
        x = p[1];
        y = p[2];
        X[push](x);
        Y[push](y);
      } else {
        var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
        X = X[concat](dim.min.x, dim.max.x);
        Y = Y[concat](dim.min.y, dim.max.y);
        x = p[5];
        y = p[6];
      }
    }

    var xmin = mmin[apply](0, X),
        ymin = mmin[apply](0, Y);
    return {
      x: xmin,
      y: ymin,
      width: mmax[apply](0, X) - xmin,
      height: mmax[apply](0, Y) - ymin
    };
  }),
      pathClone = function (pathArray) {
    var res = [];

    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
      // rough assumption
      pathArray = R.parsePathString(pathArray);
    }

    for (var i = 0, ii = pathArray[length]; i < ii; i++) {
      res[i] = [];

      for (var j = 0, jj = pathArray[i][length]; j < jj; j++) {
        res[i][j] = pathArray[i][j];
      }
    }

    res[toString] = R._path2string;
    return res;
  },
      pathToRelative = cacher(function (pathArray) {
    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
      // rough assumption
      pathArray = R.parsePathString(pathArray);
    }

    var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;

    if (pathArray[0][0] == "M") {
      x = pathArray[0][1];
      y = pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[push](["M", x, y]);
    }

    for (var i = start, ii = pathArray[length]; i < ii; i++) {
      var r = res[i] = [],
          pa = pathArray[i];

      if (pa[0] != lowerCase.call(pa[0])) {
        r[0] = lowerCase.call(pa[0]);

        switch (r[0]) {
          case "a":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +(pa[6] - x).toFixed(3);
            r[7] = +(pa[7] - y).toFixed(3);
            break;

          case "v":
            r[1] = +(pa[1] - y).toFixed(3);
            break;

          case "m":
            mx = pa[1];
            my = pa[2];

          default:
            for (var j = 1, jj = pa[length]; j < jj; j++) {
              r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
            }

        }
      } else {
        r = res[i] = [];

        if (pa[0] == "m") {
          mx = pa[1] + x;
          my = pa[2] + y;
        }

        for (var k = 0, kk = pa[length]; k < kk; k++) {
          res[i][k] = pa[k];
        }
      }

      var len = res[i][length];

      switch (res[i][0]) {
        case "z":
          x = mx;
          y = my;
          break;

        case "h":
          x += +res[i][len - 1];
          break;

        case "v":
          y += +res[i][len - 1];
          break;

        default:
          x += +res[i][len - 2];
          y += +res[i][len - 1];
      }
    }

    res[toString] = R._path2string;
    return res;
  }, 0, pathClone),
      pathToAbsolute = cacher(function (pathArray) {
    if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
      // rough assumption
      pathArray = R.parsePathString(pathArray);
    }

    var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;

    if (pathArray[0][0] == "M") {
      x = +pathArray[0][1];
      y = +pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[0] = ["M", x, y];
    }

    for (var i = start, ii = pathArray[length]; i < ii; i++) {
      var r = res[i] = [],
          pa = pathArray[i];

      if (pa[0] != upperCase.call(pa[0])) {
        r[0] = upperCase.call(pa[0]);

        switch (r[0]) {
          case "A":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +(pa[6] + x);
            r[7] = +(pa[7] + y);
            break;

          case "V":
            r[1] = +pa[1] + y;
            break;

          case "H":
            r[1] = +pa[1] + x;
            break;

          case "M":
            mx = +pa[1] + x;
            my = +pa[2] + y;

          default:
            for (var j = 1, jj = pa[length]; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }

        }
      } else {
        for (var k = 0, kk = pa[length]; k < kk; k++) {
          res[i][k] = pa[k];
        }
      }

      switch (r[0]) {
        case "Z":
          x = mx;
          y = my;
          break;

        case "H":
          x = r[1];
          break;

        case "V":
          y = r[1];
          break;

        case "M":
          mx = res[i][res[i][length] - 2];
          my = res[i][res[i][length] - 1];

        default:
          x = res[i][res[i][length] - 2];
          y = res[i][res[i][length] - 1];
      }
    }

    res[toString] = R._path2string;
    return res;
  }, null, pathClone),
      l2c = function (x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
  },
      q2c = function (x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3,
        _23 = 2 / 3;

    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
  },
      a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    var _120 = PI * 120 / 180,
        rad = PI / 180 * (+angle || 0),
        res = [],
        xy,
        rotate = cacher(function (x, y, rad) {
      var X = x * math.cos(rad) - y * math.sin(rad),
          Y = x * math.sin(rad) + y * math.cos(rad);
      return {
        x: X,
        y: Y
      };
    });

    if (!recursive) {
      xy = rotate(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      xy = rotate(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;
      var x = (x1 - x2) / 2,
          y = (y1 - y2) / 2;
      var h = x * x / (rx * rx) + y * y / (ry * ry);

      if (h > 1) {
        h = math.sqrt(h);
        rx = h * rx;
        ry = h * ry;
      }

      var rx2 = rx * rx,
          ry2 = ry * ry,
          k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
          cx = k * rx * y / ry + (x1 + x2) / 2,
          cy = k * -ry * x / rx + (y1 + y2) / 2,
          f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
          f2 = math.asin(((y2 - cy) / ry).toFixed(9));
      f1 = x1 < cx ? PI - f1 : f1;
      f2 = x2 < cx ? PI - f2 : f2;
      f1 < 0 && (f1 = PI * 2 + f1);
      f2 < 0 && (f2 = PI * 2 + f2);

      if (sweep_flag && f1 > f2) {
        f1 = f1 - PI * 2;
      }

      if (!sweep_flag && f2 > f1) {
        f2 = f2 - PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }

    var df = f2 - f1;

    if (abs(df) > _120) {
      var f2old = f2,
          x2old = x2,
          y2old = y2;
      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * math.cos(f2);
      y2 = cy + ry * math.sin(f2);
      res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }

    df = f2 - f1;
    var c1 = math.cos(f1),
        s1 = math.sin(f1),
        c2 = math.cos(f2),
        s2 = math.sin(f2),
        t = math.tan(df / 4),
        hx = 4 / 3 * rx * t,
        hy = 4 / 3 * ry * t,
        m1 = [x1, y1],
        m2 = [x1 + hx * s1, y1 - hy * c1],
        m3 = [x2 + hx * s2, y2 - hy * c2],
        m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];

    if (recursive) {
      return [m2, m3, m4][concat](res);
    } else {
      res = [m2, m3, m4][concat](res)[join]()[split](",");
      var newres = [];

      for (var i = 0, ii = res[length]; i < ii; i++) {
        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
      }

      return newres;
    }
  },
      findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    return {
      x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
      y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
    };
  },
      curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x),
        b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
        c = p1x - c1x,
        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
        y = [p1y, p2y],
        x = [p1x, p2x],
        dot;
    abs(t1) > "1e12" && (t1 = .5);
    abs(t2) > "1e12" && (t2 = .5);

    if (t1 > 0 && t1 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
      x[push](dot.x);
      y[push](dot.y);
    }

    if (t2 > 0 && t2 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
      x[push](dot.x);
      y[push](dot.y);
    }

    a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
    b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
    c = p1y - c1y;
    t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
    t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
    abs(t1) > "1e12" && (t1 = .5);
    abs(t2) > "1e12" && (t2 = .5);

    if (t1 > 0 && t1 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
      x[push](dot.x);
      y[push](dot.y);
    }

    if (t2 > 0 && t2 < 1) {
      dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
      x[push](dot.x);
      y[push](dot.y);
    }

    return {
      min: {
        x: mmin[apply](0, x),
        y: mmin[apply](0, y)
      },
      max: {
        x: mmax[apply](0, x),
        y: mmax[apply](0, y)
      }
    };
  }),
      path2curve = cacher(function (path, path2) {
    var p = pathToAbsolute(path),
        p2 = path2 && pathToAbsolute(path2),
        attrs = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    },
        attrs2 = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    },
        processPath = function (path, d) {
      var nx, ny;

      if (!path) {
        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
      }

      !(path[0] in {
        T: 1,
        Q: 1
      }) && (d.qx = d.qy = null);

      switch (path[0]) {
        case "M":
          d.X = path[1];
          d.Y = path[2];
          break;

        case "A":
          path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
          break;

        case "S":
          nx = d.x + (d.x - (d.bx || d.x));
          ny = d.y + (d.y - (d.by || d.y));
          path = ["C", nx, ny][concat](path.slice(1));
          break;

        case "T":
          d.qx = d.x + (d.x - (d.qx || d.x));
          d.qy = d.y + (d.y - (d.qy || d.y));
          path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
          break;

        case "Q":
          d.qx = path[1];
          d.qy = path[2];
          path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
          break;

        case "L":
          path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
          break;

        case "H":
          path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
          break;

        case "V":
          path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
          break;

        case "Z":
          path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
          break;
      }

      return path;
    },
        fixArc = function (pp, i) {
      if (pp[i][length] > 7) {
        pp[i].shift();
        var pi = pp[i];

        while (pi[length]) {
          pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
        }

        pp.splice(i, 1);
        ii = mmax(p[length], p2 && p2[length] || 0);
      }
    },
        fixM = function (path1, path2, a1, a2, i) {
      if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
        path2.splice(i, 0, ["M", a2.x, a2.y]);
        a1.bx = 0;
        a1.by = 0;
        a1.x = path1[i][1];
        a1.y = path1[i][2];
        ii = mmax(p[length], p2 && p2[length] || 0);
      }
    };

    for (var i = 0, ii = mmax(p[length], p2 && p2[length] || 0); i < ii; i++) {
      p[i] = processPath(p[i], attrs);
      fixArc(p, i);
      p2 && (p2[i] = processPath(p2[i], attrs2));
      p2 && fixArc(p2, i);
      fixM(p, p2, attrs, attrs2, i);
      fixM(p2, p, attrs2, attrs, i);
      var seg = p[i],
          seg2 = p2 && p2[i],
          seglen = seg[length],
          seg2len = p2 && seg2[length];
      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
      attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
      attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
      attrs2.x = p2 && seg2[seg2len - 2];
      attrs2.y = p2 && seg2[seg2len - 1];
    }

    return p2 ? [p, p2] : p;
  }, null, pathClone),
      parseDots = cacher(function (gradient) {
    var dots = [];

    for (var i = 0, ii = gradient[length]; i < ii; i++) {
      var dot = {},
          par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
      dot.color = R.getRGB(par[1]);

      if (dot.color.error) {
        return null;
      }

      dot.color = dot.color.hex;
      par[2] && (dot.offset = par[2] + "%");
      dots[push](dot);
    }

    for (i = 1, ii = dots[length] - 1; i < ii; i++) {
      if (!dots[i].offset) {
        var start = toFloat(dots[i - 1].offset || 0),
            end = 0;

        for (var j = i + 1; j < ii; j++) {
          if (dots[j].offset) {
            end = dots[j].offset;
            break;
          }
        }

        if (!end) {
          end = 100;
          j = ii;
        }

        end = toFloat(end);
        var d = (end - start) / (j - i + 1);

        for (; i < j; i++) {
          start += d;
          dots[i].offset = start + "%";
        }
      }
    }

    return dots;
  }),
      getContainer = function (x, y, w, h) {
    var container;

    if (R.is(x, string) || R.is(x, "object")) {
      container = R.is(x, string) ? doc.getElementById(x) : x;

      if (container.tagName) {
        if (y == null) {
          return {
            container: container,
            width: container.style.pixelWidth || container.offsetWidth,
            height: container.style.pixelHeight || container.offsetHeight
          };
        } else {
          return {
            container: container,
            width: y,
            height: w
          };
        }
      }
    } else {
      return {
        container: 1,
        x: x,
        y: y,
        width: w,
        height: h
      };
    }
  },
      plugins = function (con, add) {
    var that = this;

    for (var prop in add) {
      if (add[has](prop) && !(prop in con)) {
        switch (typeof add[prop]) {
          case "function":
            (function (f) {
              con[prop] = con === that ? f : function () {
                return f[apply](that, arguments);
              };
            })(add[prop]);

            break;

          case "object":
            con[prop] = con[prop] || {};
            plugins.call(this, con[prop], add[prop]);
            break;

          default:
            con[prop] = add[prop];
            break;
        }
      }
    }
  },
      tear = function (el, paper) {
    el == paper.top && (paper.top = el.prev);
    el == paper.bottom && (paper.bottom = el.next);
    el.next && (el.next.prev = el.prev);
    el.prev && (el.prev.next = el.next);
  },
      tofront = function (el, paper) {
    if (paper.top === el) {
      return;
    }

    tear(el, paper);
    el.next = null;
    el.prev = paper.top;
    paper.top.next = el;
    paper.top = el;
  },
      toback = function (el, paper) {
    if (paper.bottom === el) {
      return;
    }

    tear(el, paper);
    el.next = paper.bottom;
    el.prev = null;
    paper.bottom.prev = el;
    paper.bottom = el;
  },
      insertafter = function (el, el2, paper) {
    tear(el, paper);
    el2 == paper.top && (paper.top = el);
    el2.next && (el2.next.prev = el);
    el.next = el2.next;
    el.prev = el2;
    el2.next = el;
  },
      insertbefore = function (el, el2, paper) {
    tear(el, paper);
    el2 == paper.bottom && (paper.bottom = el);
    el2.prev && (el2.prev.next = el);
    el.prev = el2.prev;
    el2.prev = el;
    el.next = el2;
  },
      removed = function (methodname) {
    return function () {
      throw new Error("Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object");
    };
  };

  R.pathToRelative = pathToRelative; // SVG

  if (R.svg) {
    paperproto.svgns = "http://www.w3.org/2000/svg";
    paperproto.xlink = "http://www.w3.org/1999/xlink";

    round = function (num) {
      return +num + (~~num === num) * .5;
    };

    var $ = function (el, attr) {
      if (attr) {
        for (var key in attr) {
          if (attr[has](key)) {
            setAttr(el, key, Str(attr[key]));
          }
        }
      } else {
        el = doc.createElementNS(paperproto.svgns, el);
        el.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
        return el;
      }
    };

    R[toString] = function () {
      return "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };

    var thePath = function (pathString, SVG) {
      var el = $("path");
      SVG.canvas && SVG.canvas[appendChild](el);
      var p = new Element(el, SVG);
      p.type = "path";
      setFillAndStroke(p, {
        fill: "none",
        stroke: "#000",
        path: pathString
      });
      return p;
    };

    var addGradientFill = function (o, gradient, SVG) {
      var type = "linear",
          fx = .5,
          fy = .5,
          s = o.style;
      gradient = Str(gradient)[rp](radial_gradient, function (all, _fx, _fy) {
        type = "radial";

        if (_fx && _fy) {
          fx = toFloat(_fx);
          fy = toFloat(_fy);
          var dir = (fy > .5) * 2 - 1;
          pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) && fy != .5 && (fy = fy.toFixed(5) - 1e-5 * dir);
        }

        return E;
      });
      gradient = gradient[split](/\s*\-\s*/);

      if (type == "linear") {
        var angle = gradient.shift();
        angle = -toFloat(angle);

        if (isNaN(angle)) {
          return null;
        }

        var vector = [0, 0, math.cos(angle * PI / 180), math.sin(angle * PI / 180)],
            max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
        vector[2] *= max;
        vector[3] *= max;

        if (vector[2] < 0) {
          vector[0] = -vector[2];
          vector[2] = 0;
        }

        if (vector[3] < 0) {
          vector[1] = -vector[3];
          vector[3] = 0;
        }
      }

      var dots = parseDots(gradient);

      if (!dots) {
        return null;
      }

      var id = o.getAttribute(fillString);
      id = id.match(/^url\(#(.*)\)$/);
      id && SVG.defs.removeChild(doc.getElementById(id[1]));
      var el = $(type + "Gradient");
      el.id = createUUID();
      $(el, type == "radial" ? {
        fx: fx,
        fy: fy
      } : {
        x1: vector[0],
        y1: vector[1],
        x2: vector[2],
        y2: vector[3]
      });
      SVG.defs[appendChild](el);

      for (var i = 0, ii = dots[length]; i < ii; i++) {
        var stop = $("stop");
        $(stop, {
          offset: dots[i].offset ? dots[i].offset : !i ? "0%" : "100%",
          "stop-color": dots[i].color || "#fff"
        });
        el[appendChild](stop);
      }

      $(o, {
        fill: "url(#" + el.id + ")",
        opacity: 1,
        "fill-opacity": 1
      });
      s.fill = E;
      s.opacity = 1;
      s.fillOpacity = 1;
      return 1;
    };

    var updatePosition = function (o) {
      var bbox = o.getBBox();
      $(o.pattern, {
        patternTransform: R.format("translate({0},{1})", bbox.x, bbox.y)
      });
    };

    var setFillAndStroke = function (o, params) {
      var dasharray = {
        "": [0],
        "none": [0],
        "-": [3, 1],
        ".": [1, 1],
        "-.": [3, 1, 1, 1],
        "-..": [3, 1, 1, 1, 1, 1],
        ". ": [1, 3],
        "- ": [4, 3],
        "--": [8, 3],
        "- .": [4, 3, 1, 3],
        "--.": [8, 3, 1, 3],
        "--..": [8, 3, 1, 3, 1, 3]
      },
          node = o.node,
          attrs = o.attrs,
          rot = o.rotate(),
          addDashes = function (o, value) {
        value = dasharray[lowerCase.call(value)];

        if (value) {
          var width = o.attrs["stroke-width"] || "1",
              butt = {
            round: width,
            square: width,
            butt: 0
          }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
              dashes = [];
          var i = value[length];

          while (i--) {
            dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
          }

          $(node, {
            "stroke-dasharray": dashes[join](",")
          });
        }
      };

      params[has]("rotation") && (rot = params.rotation);
      var rotxy = Str(rot)[split](separator);

      if (!(rotxy.length - 1)) {
        rotxy = null;
      } else {
        rotxy[1] = +rotxy[1];
        rotxy[2] = +rotxy[2];
      }

      toFloat(rot) && o.rotate(0, true);

      for (var att in params) {
        if (params[has](att)) {
          if (!availableAttrs[has](att)) {
            continue;
          }

          var value = params[att];
          attrs[att] = value;

          switch (att) {
            case "blur":
              o.blur(value);
              break;

            case "rotation":
              o.rotate(value, true);
              break;

            case "href":
            case "title":
            case "target":
              var pn = node.parentNode;

              if (lowerCase.call(pn.tagName) != "a") {
                var hl = $("a");
                pn.insertBefore(hl, node);
                hl[appendChild](node);
                pn = hl;
              }

              if (att == "target" && value == "blank") {
                pn.setAttributeNS(o.paper.xlink, "show", "new");
              } else {
                pn.setAttributeNS(o.paper.xlink, att, value);
              }

              break;

            case "cursor":
              node.style.cursor = value;
              break;

            case "clip-rect":
              var rect = Str(value)[split](separator);

              if (rect[length] == 4) {
                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                var el = $("clipPath"),
                    rc = $("rect");
                el.id = createUUID();
                $(rc, {
                  x: rect[0],
                  y: rect[1],
                  width: rect[2],
                  height: rect[3]
                });
                el[appendChild](rc);
                o.paper.defs[appendChild](el);
                $(node, {
                  "clip-path": "url(#" + el.id + ")"
                });
                o.clip = rc;
              }

              if (!value) {
                var clip = doc.getElementById(node.getAttribute("clip-path")[rp](/(^url\(#|\)$)/g, E));
                clip && clip.parentNode.removeChild(clip);
                $(node, {
                  "clip-path": E
                });
                delete o.clip;
              }

              break;

            case "path":
              if (o.type == "path") {
                $(node, {
                  d: value ? attrs.path = pathToAbsolute(value) : "M0,0"
                });
              }

              break;

            case "width":
              setAttr(node, att, value);

              if (attrs.fx) {
                att = "x";
                value = attrs.x;
              } else {
                break;
              }

            case "x":
              if (attrs.fx) {
                value = -attrs.x - (attrs.width || 0);
              }

            case "rx":
              if (att == "rx" && o.type == "rect") {
                break;
              }

            case "cx":
              rotxy && (att == "x" || att == "cx") && (rotxy[1] += value - attrs[att]);
              setAttr(node, att, value);
              o.pattern && updatePosition(o);
              break;

            case "height":
              setAttr(node, att, value);

              if (attrs.fy) {
                att = "y";
                value = attrs.y;
              } else {
                break;
              }

            case "y":
              if (attrs.fy) {
                value = -attrs.y - (attrs.height || 0);
              }

            case "ry":
              if (att == "ry" && o.type == "rect") {
                break;
              }

            case "cy":
              rotxy && (att == "y" || att == "cy") && (rotxy[2] += value - attrs[att]);
              setAttr(node, att, value);
              o.pattern && updatePosition(o);
              break;

            case "r":
              if (o.type == "rect") {
                $(node, {
                  rx: value,
                  ry: value
                });
              } else {
                setAttr(node, att, value);
              }

              break;

            case "src":
              if (o.type == "image") {
                node.setAttributeNS(o.paper.xlink, "href", value);
              }

              break;

            case "stroke-width":
              node.style.strokeWidth = value; // Need following line for Firefox

              setAttr(node, att, value);

              if (attrs["stroke-dasharray"]) {
                addDashes(o, attrs["stroke-dasharray"]);
              }

              break;

            case "stroke-dasharray":
              addDashes(o, value);
              break;

            case "translation":
              var xy = Str(value)[split](separator);
              xy[0] = +xy[0] || 0;
              xy[1] = +xy[1] || 0;

              if (rotxy) {
                rotxy[1] += xy[0];
                rotxy[2] += xy[1];
              }

              translate.call(o, xy[0], xy[1]);
              break;

            case "scale":
              xy = Str(value)[split](separator);
              o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, isNaN(toFloat(xy[2])) ? null : +xy[2], isNaN(toFloat(xy[3])) ? null : +xy[3]);
              break;

            case fillString:
              var isURL = Str(value).match(ISURL);

              if (isURL) {
                el = $("pattern");
                var ig = $("image");
                el.id = createUUID();
                $(el, {
                  x: 0,
                  y: 0,
                  patternUnits: "userSpaceOnUse",
                  height: 1,
                  width: 1
                });
                $(ig, {
                  x: 0,
                  y: 0
                });
                ig.setAttributeNS(o.paper.xlink, "href", isURL[1]);
                el[appendChild](ig);
                var img = doc.createElement("img");
                img.style.cssText = "position:absolute;left:-9999em;top-9999em";

                img.onload = function () {
                  $(el, {
                    width: this.offsetWidth,
                    height: this.offsetHeight
                  });
                  $(ig, {
                    width: this.offsetWidth,
                    height: this.offsetHeight
                  });
                  doc.body.removeChild(this);
                  o.paper.safari();
                };

                doc.body[appendChild](img);
                img.src = isURL[1];
                o.paper.defs[appendChild](el);
                node.style.fill = "url(#" + el.id + ")";
                $(node, {
                  fill: "url(#" + el.id + ")"
                });
                o.pattern = el;
                o.pattern && updatePosition(o);
                break;
              }

              var clr = R.getRGB(value);

              if (!clr.error) {
                delete params.gradient;
                delete attrs.gradient;
                !R.is(attrs.opacity, "undefined") && R.is(params.opacity, "undefined") && $(node, {
                  opacity: attrs.opacity
                });
                !R.is(attrs["fill-opacity"], "undefined") && R.is(params["fill-opacity"], "undefined") && $(node, {
                  "fill-opacity": attrs["fill-opacity"]
                });
              } else if (({
                circle: 1,
                ellipse: 1
              }[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper)) {
                attrs.gradient = value;
                attrs.fill = "none";
                break;
              }

              clr[has]("opacity") && $(node, {
                "fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
              });

            case "stroke":
              clr = R.getRGB(value);
              setAttr(node, att, clr.hex);
              att == "stroke" && clr[has]("opacity") && $(node, {
                "stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
              });
              break;

            case "gradient":
              (({
                circle: 1,
                ellipse: 1
              })[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper);
              break;

            case "opacity":
              if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                $(node, {
                  "stroke-opacity": value > 1 ? value / 100 : value
                });
              }

            // fall

            case "fill-opacity":
              if (attrs.gradient) {
                var gradient = doc.getElementById(node.getAttribute(fillString)[rp](/^url\(#|\)$/g, E));

                if (gradient) {
                  var stops = gradient.getElementsByTagName("stop");
                  setAttr(stops[stops[length] - 1], "stop-opacity", value);
                }

                break;
              }

            default:
              att == "font-size" && (value = toInt(value, 10) + "px");
              var cssrule = att[rp](/(\-.)/g, function (w) {
                return upperCase.call(w.substring(1));
              });
              node.style[cssrule] = value; // Need following line for Firefox

              setAttr(node, att, value);
              break;
          }
        }
      }

      tuneText(o, params);

      if (rotxy) {
        o.rotate(rotxy.join(S));
      } else {
        toFloat(rot) && o.rotate(rot, true);
      }
    };

    var leading = 1.2,
        tuneText = function (el, params) {
      if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
        return;
      }

      var a = el.attrs,
          node = el.node,
          fontSize = node.firstChild ? toInt(doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

      if (params[has]("text")) {
        a.text = params.text;

        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }

        var texts = Str(params.text)[split]("\n");

        for (var i = 0, ii = texts[length]; i < ii; i++) if (texts[i]) {
          var tspan = $("tspan");
          i && $(tspan, {
            dy: fontSize * leading,
            x: a.x
          });
          tspan[appendChild](doc.createTextNode(texts[i]));
          node[appendChild](tspan);
        }
      } else {
        texts = node.getElementsByTagName("tspan");

        for (i = 0, ii = texts[length]; i < ii; i++) {
          i && $(texts[i], {
            dy: fontSize * leading,
            x: a.x
          });
        }
      }

      $(node, {
        y: a.y
      });
      var bb = el.getBBox(),
          dif = a.y - (bb.y + bb.height / 2);
      dif && R.is(dif, "finite") && $(node, {
        y: a.y + dif
      });
    },
        Element = function (node, svg) {
      this[0] = node;
      this.id = R._oid++;
      this.node = node;
      node.raphael = this;
      this.paper = svg;
      this.attrs = this.attrs || {};
      this.transformations = []; // rotate, translate, scale

      this._ = {
        tx: 0,
        ty: 0,
        rt: {
          deg: 0,
          cx: 0,
          cy: 0
        },
        sx: 1,
        sy: 1
      };
      !svg.bottom && (svg.bottom = this);
      this.prev = svg.top;
      svg.top && (svg.top.next = this);
      svg.top = this;
      this.next = null;
    };

    var elproto = Element[proto];

    Element[proto].rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }

      if (deg == null) {
        if (this._.rt.cx) {
          return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
        }

        return this._.rt.deg;
      }

      var bbox = this.getBBox();
      deg = Str(deg)[split](separator);

      if (deg[length] - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }

      deg = toFloat(deg[0]);

      if (cx != null && cx !== false) {
        this._.rt.deg = deg;
      } else {
        this._.rt.deg += deg;
      }

      cy == null && (cx = null);
      this._.rt.cx = cx;
      this._.rt.cy = cy;
      cx = cx == null ? bbox.x + bbox.width / 2 : cx;
      cy = cy == null ? bbox.y + bbox.height / 2 : cy;

      if (this._.rt.deg) {
        this.transformations[0] = R.format("rotate({0} {1} {2})", this._.rt.deg, cx, cy);
        this.clip && $(this.clip, {
          transform: R.format("rotate({0} {1} {2})", -this._.rt.deg, cx, cy)
        });
      } else {
        this.transformations[0] = E;
        this.clip && $(this.clip, {
          transform: E
        });
      }

      $(this.node, {
        transform: this.transformations[join](S)
      });
      return this;
    };

    Element[proto].hide = function () {
      !this.removed && (this.node.style.display = "none");
      return this;
    };

    Element[proto].show = function () {
      !this.removed && (this.node.style.display = "");
      return this;
    };

    Element[proto].remove = function () {
      if (this.removed) {
        return;
      }

      tear(this, this.paper);
      this.node.parentNode.removeChild(this.node);

      for (var i in this) {
        delete this[i];
      }

      this.removed = true;
    };

    Element[proto].getBBox = function () {
      if (this.removed) {
        return this;
      }

      if (this.type == "path") {
        return pathDimensions(this.attrs.path);
      }

      if (this.node.style.display == "none") {
        this.show();
        var hide = true;
      }

      var bbox = {};

      try {
        bbox = this.node.getBBox();
      } catch (e) {// Firefox 3.0.x plays badly here
      } finally {
        bbox = bbox || {};
      }

      if (this.type == "text") {
        bbox = {
          x: bbox.x,
          y: Infinity,
          width: 0,
          height: 0
        };

        for (var i = 0, ii = this.node.getNumberOfChars(); i < ii; i++) {
          var bb = this.node.getExtentOfChar(i);
          bb.y < bbox.y && (bbox.y = bb.y);
          bb.y + bb.height - bbox.y > bbox.height && (bbox.height = bb.y + bb.height - bbox.y);
          bb.x + bb.width - bbox.x > bbox.width && (bbox.width = bb.x + bb.width - bbox.x);
        }
      }

      hide && this.hide();
      return bbox;
    };

    Element[proto].attr = function (name, value) {
      if (this.removed) {
        return this;
      }

      if (name == null) {
        var res = {};

        for (var i in this.attrs) if (this.attrs[has](i)) {
          res[i] = this.attrs[i];
        }

        this._.rt.deg && (res.rotation = this.rotate());
        (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
        return res;
      }

      if (value == null && R.is(name, string)) {
        if (name == "translation") {
          return translate.call(this);
        }

        if (name == "rotation") {
          return this.rotate();
        }

        if (name == "scale") {
          return this.scale();
        }

        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
          return this.attrs.gradient;
        }

        return this.attrs[name];
      }

      if (value == null && R.is(name, array)) {
        var values = {};

        for (var j = 0, jj = name.length; j < jj; j++) {
          values[name[j]] = this.attr(name[j]);
        }

        return values;
      }

      if (value != null) {
        var params = {};
        params[name] = value;
      } else if (name != null && R.is(name, "object")) {
        params = name;
      }

      for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
        var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
        this.attrs[key] = params[key];

        for (var subkey in par) if (par[has](subkey)) {
          params[subkey] = par[subkey];
        }
      }

      setFillAndStroke(this, params);
      return this;
    };

    Element[proto].toFront = function () {
      if (this.removed) {
        return this;
      }

      this.node.parentNode[appendChild](this.node);
      var svg = this.paper;
      svg.top != this && tofront(this, svg);
      return this;
    };

    Element[proto].toBack = function () {
      if (this.removed) {
        return this;
      }

      if (this.node.parentNode.firstChild != this.node) {
        this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
        toback(this, this.paper);
        this.paper;
      }

      return this;
    };

    Element[proto].insertAfter = function (element) {
      if (this.removed) {
        return this;
      }

      var node = element.node || element[element.length - 1].node;

      if (node.nextSibling) {
        node.parentNode.insertBefore(this.node, node.nextSibling);
      } else {
        node.parentNode[appendChild](this.node);
      }

      insertafter(this, element, this.paper);
      return this;
    };

    Element[proto].insertBefore = function (element) {
      if (this.removed) {
        return this;
      }

      var node = element.node || element[0].node;
      node.parentNode.insertBefore(this.node, node);
      insertbefore(this, element, this.paper);
      return this;
    };

    Element[proto].blur = function (size) {
      // Experimental. No Safari support. Use it on your own risk.
      var t = this;

      if (+size !== 0) {
        var fltr = $("filter"),
            blur = $("feGaussianBlur");
        t.attrs.blur = size;
        fltr.id = createUUID();
        $(blur, {
          stdDeviation: +size || 1.5
        });
        fltr.appendChild(blur);
        t.paper.defs.appendChild(fltr);
        t._blur = fltr;
        $(t.node, {
          filter: "url(#" + fltr.id + ")"
        });
      } else {
        if (t._blur) {
          t._blur.parentNode.removeChild(t._blur);

          delete t._blur;
          delete t.attrs.blur;
        }

        t.node.removeAttribute("filter");
      }
    };

    var theCircle = function (svg, x, y, r) {
      var el = $("circle");
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        cx: x,
        cy: y,
        r: r,
        fill: "none",
        stroke: "#000"
      };
      res.type = "circle";
      $(el, res.attrs);
      return res;
    },
        theRect = function (svg, x, y, w, h, r) {
      var el = $("rect");
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        width: w,
        height: h,
        r: r || 0,
        rx: r || 0,
        ry: r || 0,
        fill: "none",
        stroke: "#000"
      };
      res.type = "rect";
      $(el, res.attrs);
      return res;
    },
        theEllipse = function (svg, x, y, rx, ry) {
      var el = $("ellipse");
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        cx: x,
        cy: y,
        rx: rx,
        ry: ry,
        fill: "none",
        stroke: "#000"
      };
      res.type = "ellipse";
      $(el, res.attrs);
      return res;
    },
        theImage = function (svg, src, x, y, w, h) {
      var el = $("image");
      $(el, {
        x: x,
        y: y,
        width: w,
        height: h,
        preserveAspectRatio: "none"
      });
      el.setAttributeNS(svg.xlink, "href", src);
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        width: w,
        height: h,
        src: src
      };
      res.type = "image";
      return res;
    },
        theText = function (svg, x, y, text) {
      var el = $("text");
      $(el, {
        x: x,
        y: y,
        "text-anchor": "middle"
      });
      svg.canvas && svg.canvas[appendChild](el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        "text-anchor": "middle",
        text: text,
        font: availableAttrs.font,
        stroke: "none",
        fill: "#000"
      };
      res.type = "text";
      setFillAndStroke(res, res.attrs);
      return res;
    },
        setSize = function (width, height) {
      this.width = width || this.width;
      this.height = height || this.height;
      setAttr(this.canvas, "width", this.width);
      setAttr(this.canvas, "height", this.height);
      return this;
    },
        create = function () {
      var con = getContainer[apply](0, arguments),
          container = con && con.container,
          x = con.x,
          y = con.y,
          width = con.width,
          height = con.height;

      if (!container) {
        throw new Error("SVG container not found.");
      }

      var cnvs = $("svg");
      x = x || 0;
      y = y || 0;
      width = width || 512;
      height = height || 342;
      $(cnvs, {
        xmlns: "http://www.w3.org/2000/svg",
        version: 1.1,
        width: width,
        height: height
      });

      if (container == 1) {
        cnvs.style.cssText = "position:absolute;left:" + x + "px;top:" + y + "px";
        doc.body[appendChild](cnvs);
      } else {
        if (container.firstChild) {
          container.insertBefore(cnvs, container.firstChild);
        } else {
          container[appendChild](cnvs);
        }
      }

      container = new Paper();
      container.width = width;
      container.height = height;
      container.canvas = cnvs;
      plugins.call(container, container, R.fn);
      container.clear();
      return container;
    };

    paperproto.clear = function () {
      var c = this.canvas;

      while (c.firstChild) {
        c.removeChild(c.firstChild);
      }

      this.bottom = this.top = null;
      (this.desc = $("desc"))[appendChild](doc.createTextNode("Created with Rapha\xebl"));
      c[appendChild](this.desc);
      c[appendChild](this.defs = $("defs"));
    };

    paperproto.remove = function () {
      this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);

      for (var i in this) {
        this[i] = removed(i);
      }
    };
  } // VML


  if (R.vml) {
    var map = {
      M: "m",
      L: "l",
      C: "c",
      Z: "x",
      m: "t",
      l: "r",
      c: "v",
      z: "x"
    },
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        coordsize = 1e3 + S + 1e3,
        zoom = 10,
        pathlike = {
      path: 1,
      rect: 1
    },
        path2vml = function (path) {
      var total = /[ahqstv]/ig,
          command = pathToAbsolute;
      Str(path).match(total) && (command = path2curve);
      total = /[clmz]/g;

      if (command == pathToAbsolute && !Str(path).match(total)) {
        var res = Str(path)[rp](bites, function (all, command, args) {
          var vals = [],
              isMove = lowerCase.call(command) == "m",
              res = map[command];
          args[rp](val, function (value) {
            if (isMove && vals[length] == 2) {
              res += vals + map[command == "m" ? "l" : "L"];
              vals = [];
            }

            vals[push](round(value * zoom));
          });
          return res + vals;
        });
        return res;
      }

      var pa = command(path),
          p,
          r;
      res = [];

      for (var i = 0, ii = pa[length]; i < ii; i++) {
        p = pa[i];
        r = lowerCase.call(pa[i][0]);
        r == "z" && (r = "x");

        for (var j = 1, jj = p[length]; j < jj; j++) {
          r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
        }

        res[push](r);
      }

      return res[join](S);
    };

    R[toString] = function () {
      return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };

    thePath = function (pathString, vml) {
      var g = createNode("group");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = vml.coordsize;
      g.coordorigin = vml.coordorigin;
      var el = createNode("shape"),
          ol = el.style;
      ol.width = vml.width + "px";
      ol.height = vml.height + "px";
      el.coordsize = coordsize;
      el.coordorigin = vml.coordorigin;
      g[appendChild](el);
      var p = new Element(el, g, vml),
          attr = {
        fill: "none",
        stroke: "#000"
      };
      pathString && (attr.path = pathString);
      p.type = "path";
      p.path = [];
      p.Path = E;
      setFillAndStroke(p, attr);
      vml.canvas[appendChild](g);
      return p;
    };

    setFillAndStroke = function (o, params) {
      o.attrs = o.attrs || {};
      var node = o.node,
          a = o.attrs,
          s = node.style,
          xy,
          newpath = (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.r != a.r) && o.type == "rect",
          res = o;

      for (var par in params) if (params[has](par)) {
        a[par] = params[par];
      }

      if (newpath) {
        a.path = rectPath(a.x, a.y, a.width, a.height, a.r);
        o.X = a.x;
        o.Y = a.y;
        o.W = a.width;
        o.H = a.height;
      }

      params.href && (node.href = params.href);
      params.title && (node.title = params.title);
      params.target && (node.target = params.target);
      params.cursor && (s.cursor = params.cursor);
      "blur" in params && o.blur(params.blur);

      if (params.path && o.type == "path" || newpath) {
        node.path = path2vml(a.path);
      }

      if (params.rotation != null) {
        o.rotate(params.rotation, true);
      }

      if (params.translation) {
        xy = Str(params.translation)[split](separator);
        translate.call(o, xy[0], xy[1]);

        if (o._.rt.cx != null) {
          o._.rt.cx += +xy[0];
          o._.rt.cy += +xy[1];
          o.setBox(o.attrs, xy[0], xy[1]);
        }
      }

      if (params.scale) {
        xy = Str(params.scale)[split](separator);
        o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, +xy[2] || null, +xy[3] || null);
      }

      if ("clip-rect" in params) {
        var rect = Str(params["clip-rect"])[split](separator);

        if (rect[length] == 4) {
          rect[2] = +rect[2] + +rect[0];
          rect[3] = +rect[3] + +rect[1];
          var div = node.clipRect || doc.createElement("div"),
              dstyle = div.style,
              group = node.parentNode;
          dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);

          if (!node.clipRect) {
            dstyle.position = "absolute";
            dstyle.top = 0;
            dstyle.left = 0;
            dstyle.width = o.paper.width + "px";
            dstyle.height = o.paper.height + "px";
            group.parentNode.insertBefore(div, group);
            div[appendChild](group);
            node.clipRect = div;
          }
        }

        if (!params["clip-rect"]) {
          node.clipRect && (node.clipRect.style.clip = E);
        }
      }

      if (o.type == "image" && params.src) {
        node.src = params.src;
      }

      if (o.type == "image" && params.opacity) {
        node.filterOpacity = ms + ".Alpha(opacity=" + params.opacity * 100 + ")";
        s.filter = (node.filterMatrix || E) + (node.filterOpacity || E);
      }

      params.font && (s.font = params.font);
      params["font-family"] && (s.fontFamily = '"' + params["font-family"][split](",")[0][rp](/^['"]+|['"]+$/g, E) + '"');
      params["font-size"] && (s.fontSize = params["font-size"]);
      params["font-weight"] && (s.fontWeight = params["font-weight"]);
      params["font-style"] && (s.fontStyle = params["font-style"]);

      if (params.opacity != null || params["stroke-width"] != null || params.fill != null || params.stroke != null || params["stroke-width"] != null || params["stroke-opacity"] != null || params["fill-opacity"] != null || params["stroke-dasharray"] != null || params["stroke-miterlimit"] != null || params["stroke-linejoin"] != null || params["stroke-linecap"] != null) {
        node = o.shape || node;
        var fill = node.getElementsByTagName(fillString) && node.getElementsByTagName(fillString)[0],
            newfill = false;
        !fill && (newfill = fill = createNode(fillString));

        if ("fill-opacity" in params || "opacity" in params) {
          var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
          opacity = mmin(mmax(opacity, 0), 1);
          fill.opacity = opacity;
        }

        params.fill && (fill.on = true);

        if (fill.on == null || params.fill == "none") {
          fill.on = false;
        }

        if (fill.on && params.fill) {
          var isURL = params.fill.match(ISURL);

          if (isURL) {
            fill.src = isURL[1];
            fill.type = "tile";
          } else {
            fill.color = R.getRGB(params.fill).hex;
            fill.src = E;
            fill.type = "solid";

            if (R.getRGB(params.fill).error && (res.type in {
              circle: 1,
              ellipse: 1
            } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill)) {
              a.fill = "none";
              a.gradient = params.fill;
            }
          }
        }

        newfill && node[appendChild](fill);
        var stroke = node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0],
            newstroke = false;
        !stroke && (newstroke = stroke = createNode("stroke"));

        if (params.stroke && params.stroke != "none" || params["stroke-width"] || params["stroke-opacity"] != null || params["stroke-dasharray"] || params["stroke-miterlimit"] || params["stroke-linejoin"] || params["stroke-linecap"]) {
          stroke.on = true;
        }

        (params.stroke == "none" || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
        var strokeColor = R.getRGB(params.stroke);
        stroke.on && params.stroke && (stroke.color = strokeColor.hex);
        opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
        var width = (toFloat(params["stroke-width"]) || 1) * .75;
        opacity = mmin(mmax(opacity, 0), 1);
        params["stroke-width"] == null && (width = a["stroke-width"]);
        params["stroke-width"] && (stroke.weight = width);
        width && width < 1 && (opacity *= width) && (stroke.weight = 1);
        stroke.opacity = opacity;
        params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
        stroke.miterlimit = params["stroke-miterlimit"] || 8;
        params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");

        if (params["stroke-dasharray"]) {
          var dasharray = {
            "-": "shortdash",
            ".": "shortdot",
            "-.": "shortdashdot",
            "-..": "shortdashdotdot",
            ". ": "dot",
            "- ": "dash",
            "--": "longdash",
            "- .": "dashdot",
            "--.": "longdashdot",
            "--..": "longdashdotdot"
          };
          stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
        }

        newstroke && node[appendChild](stroke);
      }

      if (res.type == "text") {
        s = res.paper.span.style;
        a.font && (s.font = a.font);
        a["font-family"] && (s.fontFamily = a["font-family"]);
        a["font-size"] && (s.fontSize = a["font-size"]);
        a["font-weight"] && (s.fontWeight = a["font-weight"]);
        a["font-style"] && (s.fontStyle = a["font-style"]);
        res.node.string && (res.paper.span.innerHTML = Str(res.node.string)[rp](/</g, "&#60;")[rp](/&/g, "&#38;")[rp](/\n/g, "<br>"));
        res.W = a.w = res.paper.span.offsetWidth;
        res.H = a.h = res.paper.span.offsetHeight;
        res.X = a.x;
        res.Y = a.y + round(res.H / 2); // text-anchor emulationm

        switch (a["text-anchor"]) {
          case "start":
            res.node.style["v-text-align"] = "left";
            res.bbx = round(res.W / 2);
            break;

          case "end":
            res.node.style["v-text-align"] = "right";
            res.bbx = -round(res.W / 2);
            break;

          default:
            res.node.style["v-text-align"] = "center";
            break;
        }
      }
    };

    addGradientFill = function (o, gradient) {
      o.attrs = o.attrs || {};
      o.attrs;
          var fill,
          type = "linear",
          fxfy = ".5 .5";
      o.attrs.gradient = gradient;
      gradient = Str(gradient)[rp](radial_gradient, function (all, fx, fy) {
        type = "radial";

        if (fx && fy) {
          fx = toFloat(fx);
          fy = toFloat(fy);
          pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
          fxfy = fx + S + fy;
        }

        return E;
      });
      gradient = gradient[split](/\s*\-\s*/);

      if (type == "linear") {
        var angle = gradient.shift();
        angle = -toFloat(angle);

        if (isNaN(angle)) {
          return null;
        }
      }

      var dots = parseDots(gradient);

      if (!dots) {
        return null;
      }

      o = o.shape || o.node;
      fill = o.getElementsByTagName(fillString)[0] || createNode(fillString);
      !fill.parentNode && o.appendChild(fill);

      if (dots[length]) {
        fill.on = true;
        fill.method = "none";
        fill.color = dots[0].color;
        fill.color2 = dots[dots[length] - 1].color;
        var clrs = [];

        for (var i = 0, ii = dots[length]; i < ii; i++) {
          dots[i].offset && clrs[push](dots[i].offset + S + dots[i].color);
        }

        fill.colors && (fill.colors.value = clrs[length] ? clrs[join]() : "0% " + fill.color);

        if (type == "radial") {
          fill.type = "gradientradial";
          fill.focus = "100%";
          fill.focussize = fxfy;
          fill.focusposition = fxfy;
        } else {
          fill.type = "gradient";
          fill.angle = (270 - angle) % 360;
        }
      }

      return 1;
    };

    Element = function (node, group, vml) {
      this[0] = node;
      this.id = R._oid++;
      this.node = node;
      node.raphael = this;
      this.X = 0;
      this.Y = 0;
      this.attrs = {};
      this.Group = group;
      this.paper = vml;
      this._ = {
        tx: 0,
        ty: 0,
        rt: {
          deg: 0
        },
        sx: 1,
        sy: 1
      };
      !vml.bottom && (vml.bottom = this);
      this.prev = vml.top;
      vml.top && (vml.top.next = this);
      vml.top = this;
      this.next = null;
    };

    elproto = Element[proto];

    elproto.rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }

      if (deg == null) {
        if (this._.rt.cx) {
          return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
        }

        return this._.rt.deg;
      }

      deg = Str(deg)[split](separator);

      if (deg[length] - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }

      deg = toFloat(deg[0]);

      if (cx != null) {
        this._.rt.deg = deg;
      } else {
        this._.rt.deg += deg;
      }

      cy == null && (cx = null);
      this._.rt.cx = cx;
      this._.rt.cy = cy;
      this.setBox(this.attrs, cx, cy);
      this.Group.style.rotation = this._.rt.deg; // gradient fix for rotation. TODO
      // var fill = (this.shape || this.node).getElementsByTagName(fillString);
      // fill = fill[0] || {};
      // var b = ((360 - this._.rt.deg) - 270) % 360;
      // !R.is(fill.angle, "undefined") && (fill.angle = b);

      return this;
    };

    elproto.setBox = function (params, cx, cy) {
      if (this.removed) {
        return this;
      }

      var gs = this.Group.style,
          os = this.shape && this.shape.style || this.node.style;
      params = params || {};

      for (var i in params) if (params[has](i)) {
        this.attrs[i] = params[i];
      }

      cx = cx || this._.rt.cx;
      cy = cy || this._.rt.cy;
      var attr = this.attrs,
          x,
          y,
          w,
          h;

      switch (this.type) {
        case "circle":
          x = attr.cx - attr.r;
          y = attr.cy - attr.r;
          w = h = attr.r * 2;
          break;

        case "ellipse":
          x = attr.cx - attr.rx;
          y = attr.cy - attr.ry;
          w = attr.rx * 2;
          h = attr.ry * 2;
          break;

        case "image":
          x = +attr.x;
          y = +attr.y;
          w = attr.width || 0;
          h = attr.height || 0;
          break;

        case "text":
          this.textpath.v = ["m", round(attr.x), ", ", round(attr.y - 2), "l", round(attr.x) + 1, ", ", round(attr.y - 2)][join](E);
          x = attr.x - round(this.W / 2);
          y = attr.y - this.H / 2;
          w = this.W;
          h = this.H;
          break;

        case "rect":
        case "path":
          if (!this.attrs.path) {
            x = 0;
            y = 0;
            w = this.paper.width;
            h = this.paper.height;
          } else {
            var dim = pathDimensions(this.attrs.path);
            x = dim.x;
            y = dim.y;
            w = dim.width;
            h = dim.height;
          }

          break;

        default:
          x = 0;
          y = 0;
          w = this.paper.width;
          h = this.paper.height;
          break;
      }

      cx = cx == null ? x + w / 2 : cx;
      cy = cy == null ? y + h / 2 : cy;
      var left = cx - this.paper.width / 2,
          top = cy - this.paper.height / 2,
          t;
      gs.left != (t = left + "px") && (gs.left = t);
      gs.top != (t = top + "px") && (gs.top = t);
      this.X = pathlike[has](this.type) ? -left : x;
      this.Y = pathlike[has](this.type) ? -top : y;
      this.W = w;
      this.H = h;

      if (pathlike[has](this.type)) {
        os.left != (t = -left * zoom + "px") && (os.left = t);
        os.top != (t = -top * zoom + "px") && (os.top = t);
      } else if (this.type == "text") {
        os.left != (t = -left + "px") && (os.left = t);
        os.top != (t = -top + "px") && (os.top = t);
      } else {
        gs.width != (t = this.paper.width + "px") && (gs.width = t);
        gs.height != (t = this.paper.height + "px") && (gs.height = t);
        os.left != (t = x - left + "px") && (os.left = t);
        os.top != (t = y - top + "px") && (os.top = t);
        os.width != (t = w + "px") && (os.width = t);
        os.height != (t = h + "px") && (os.height = t);
      }
    };

    elproto.hide = function () {
      !this.removed && (this.Group.style.display = "none");
      return this;
    };

    elproto.show = function () {
      !this.removed && (this.Group.style.display = "block");
      return this;
    };

    elproto.getBBox = function () {
      if (this.removed) {
        return this;
      }

      if (pathlike[has](this.type)) {
        return pathDimensions(this.attrs.path);
      }

      return {
        x: this.X + (this.bbx || 0),
        y: this.Y,
        width: this.W,
        height: this.H
      };
    };

    elproto.remove = function () {
      if (this.removed) {
        return;
      }

      tear(this, this.paper);
      this.node.parentNode.removeChild(this.node);
      this.Group.parentNode.removeChild(this.Group);
      this.shape && this.shape.parentNode.removeChild(this.shape);

      for (var i in this) {
        delete this[i];
      }

      this.removed = true;
    };

    elproto.attr = function (name, value) {
      if (this.removed) {
        return this;
      }

      if (name == null) {
        var res = {};

        for (var i in this.attrs) if (this.attrs[has](i)) {
          res[i] = this.attrs[i];
        }

        this._.rt.deg && (res.rotation = this.rotate());
        (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
        return res;
      }

      if (value == null && R.is(name, "string")) {
        if (name == "translation") {
          return translate.call(this);
        }

        if (name == "rotation") {
          return this.rotate();
        }

        if (name == "scale") {
          return this.scale();
        }

        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
          return this.attrs.gradient;
        }

        return this.attrs[name];
      }

      if (this.attrs && value == null && R.is(name, array)) {
        var ii,
            values = {};

        for (i = 0, ii = name[length]; i < ii; i++) {
          values[name[i]] = this.attr(name[i]);
        }

        return values;
      }

      var params;

      if (value != null) {
        params = {};
        params[name] = value;
      }

      value == null && R.is(name, "object") && (params = name);

      if (params) {
        for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
          var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
          this.attrs[key] = params[key];

          for (var subkey in par) if (par[has](subkey)) {
            params[subkey] = par[subkey];
          }
        }

        if (params.text && this.type == "text") {
          this.node.string = params.text;
        }

        setFillAndStroke(this, params);

        if (params.gradient && ({
          circle: 1,
          ellipse: 1
        }[has](this.type) || Str(params.gradient).charAt() != "r")) {
          addGradientFill(this, params.gradient);
        }

        (!pathlike[has](this.type) || this._.rt.deg) && this.setBox(this.attrs);
      }

      return this;
    };

    elproto.toFront = function () {
      !this.removed && this.Group.parentNode[appendChild](this.Group);
      this.paper.top != this && tofront(this, this.paper);
      return this;
    };

    elproto.toBack = function () {
      if (this.removed) {
        return this;
      }

      if (this.Group.parentNode.firstChild != this.Group) {
        this.Group.parentNode.insertBefore(this.Group, this.Group.parentNode.firstChild);
        toback(this, this.paper);
      }

      return this;
    };

    elproto.insertAfter = function (element) {
      if (this.removed) {
        return this;
      }

      if (element.constructor == Set) {
        element = element[element.length - 1];
      }

      if (element.Group.nextSibling) {
        element.Group.parentNode.insertBefore(this.Group, element.Group.nextSibling);
      } else {
        element.Group.parentNode[appendChild](this.Group);
      }

      insertafter(this, element, this.paper);
      return this;
    };

    elproto.insertBefore = function (element) {
      if (this.removed) {
        return this;
      }

      if (element.constructor == Set) {
        element = element[0];
      }

      element.Group.parentNode.insertBefore(this.Group, element.Group);
      insertbefore(this, element, this.paper);
      return this;
    };

    elproto.blur = function (size) {
      var s = this.node.runtimeStyle,
          f = s.filter;
      f = f.replace(blurregexp, E);

      if (+size !== 0) {
        this.attrs.blur = size;
        s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
        s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
      } else {
        s.filter = f;
        s.margin = 0;
        delete this.attrs.blur;
      }
    };

    theCircle = function (vml, x, y, r) {
      var g = createNode("group"),
          o = createNode("oval");
          o.style;
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "circle";
      setFillAndStroke(res, {
        stroke: "#000",
        fill: "none"
      });
      res.attrs.cx = x;
      res.attrs.cy = y;
      res.attrs.r = r;
      res.setBox({
        x: x - r,
        y: y - r,
        width: r * 2,
        height: r * 2
      });
      vml.canvas[appendChild](g);
      return res;
    };

    function rectPath(x, y, w, h, r) {
      if (r) {
        return R.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", x + r, y, w - r * 2, r, -r, h - r * 2, r * 2 - w, r * 2 - h);
      } else {
        return R.format("M{0},{1}l{2},0,0,{3},{4},0z", x, y, w, h, -w);
      }
    }

    theRect = function (vml, x, y, w, h, r) {
      var path = rectPath(x, y, w, h, r),
          res = vml.path(path),
          a = res.attrs;
      res.X = a.x = x;
      res.Y = a.y = y;
      res.W = a.width = w;
      res.H = a.height = h;
      a.r = r;
      a.path = path;
      res.type = "rect";
      return res;
    };

    theEllipse = function (vml, x, y, rx, ry) {
      var g = createNode("group"),
          o = createNode("oval");
          o.style;
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "ellipse";
      setFillAndStroke(res, {
        stroke: "#000"
      });
      res.attrs.cx = x;
      res.attrs.cy = y;
      res.attrs.rx = rx;
      res.attrs.ry = ry;
      res.setBox({
        x: x - rx,
        y: y - ry,
        width: rx * 2,
        height: ry * 2
      });
      vml.canvas[appendChild](g);
      return res;
    };

    theImage = function (vml, src, x, y, w, h) {
      var g = createNode("group"),
          o = createNode("image");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      o.src = src;
      g[appendChild](o);
      var res = new Element(o, g, vml);
      res.type = "image";
      res.attrs.src = src;
      res.attrs.x = x;
      res.attrs.y = y;
      res.attrs.w = w;
      res.attrs.h = h;
      res.setBox({
        x: x,
        y: y,
        width: w,
        height: h
      });
      vml.canvas[appendChild](g);
      return res;
    };

    theText = function (vml, x, y, text) {
      var g = createNode("group"),
          el = createNode("shape"),
          ol = el.style,
          path = createNode("path");
          path.style;
          var o = createNode("textpath");
      g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
      g.coordsize = coordsize;
      g.coordorigin = vml.coordorigin;
      path.v = R.format("m{0},{1}l{2},{1}", round(x * 10), round(y * 10), round(x * 10) + 1);
      path.textpathok = true;
      ol.width = vml.width;
      ol.height = vml.height;
      o.string = Str(text);
      o.on = true;
      el[appendChild](o);
      el[appendChild](path);
      g[appendChild](el);
      var res = new Element(o, g, vml);
      res.shape = el;
      res.textpath = path;
      res.type = "text";
      res.attrs.text = text;
      res.attrs.x = x;
      res.attrs.y = y;
      res.attrs.w = 1;
      res.attrs.h = 1;
      setFillAndStroke(res, {
        font: availableAttrs.font,
        stroke: "none",
        fill: "#000"
      });
      res.setBox();
      vml.canvas[appendChild](g);
      return res;
    };

    setSize = function (width, height) {
      var cs = this.canvas.style;
      width == +width && (width += "px");
      height == +height && (height += "px");
      cs.width = width;
      cs.height = height;
      cs.clip = "rect(0 " + width + " " + height + " 0)";
      return this;
    };

    var createNode;
    doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");

    try {
      !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");

      createNode = function (tagName) {
        return doc.createElement('<rvml:' + tagName + ' class="rvml">');
      };
    } catch (e) {
      createNode = function (tagName) {
        return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
      };
    }

    create = function () {
      var con = getContainer[apply](0, arguments),
          container = con.container,
          height = con.height,
          width = con.width,
          x = con.x,
          y = con.y;

      if (!container) {
        throw new Error("VML container not found.");
      }

      var res = new Paper(),
          c = res.canvas = doc.createElement("div"),
          cs = c.style;
      x = x || 0;
      y = y || 0;
      width = width || 512;
      height = height || 342;
      width == +width && (width += "px");
      height == +height && (height += "px");
      res.width = 1e3;
      res.height = 1e3;
      res.coordsize = zoom * 1e3 + S + zoom * 1e3;
      res.coordorigin = "0 0";
      res.span = doc.createElement("span");
      res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
      c[appendChild](res.span);
      cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);

      if (container == 1) {
        doc.body[appendChild](c);
        cs.left = x + "px";
        cs.top = y + "px";
        cs.position = "absolute";
      } else {
        if (container.firstChild) {
          container.insertBefore(c, container.firstChild);
        } else {
          container[appendChild](c);
        }
      }

      plugins.call(res, res, R.fn);
      return res;
    };

    paperproto.clear = function () {
      this.canvas.innerHTML = E;
      this.span = doc.createElement("span");
      this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
      this.canvas[appendChild](this.span);
      this.bottom = this.top = null;
    };

    paperproto.remove = function () {
      this.canvas.parentNode.removeChild(this.canvas);

      for (var i in this) {
        this[i] = removed(i);
      }

      return true;
    };
  } // rest
  // WebKit rendering bug workaround method


  var version = navigator.userAgent.match(/Version\/(.*?)\s/);

  if (navigator.vendor == "Apple Computer, Inc." && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP")) {
    paperproto.safari = function () {
      var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
        stroke: "none"
      });
      win.setTimeout(function () {
        rect.remove();
      });
    };
  } else {
    paperproto.safari = function () {};
  } // Events


  var preventDefault = function () {
    this.returnValue = false;
  },
      preventTouch = function () {
    return this.originalEvent.preventDefault();
  },
      stopPropagation = function () {
    this.cancelBubble = true;
  },
      stopTouch = function () {
    return this.originalEvent.stopPropagation();
  },
      addEvent = function () {
    if (doc.addEventListener) {
      return function (obj, type, fn, element) {
        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type;

        var f = function (e) {
          if (supportsTouch && touchMap[has](type)) {
            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
              if (e.targetTouches[i].target == obj) {
                var olde = e;
                e = e.targetTouches[i];
                e.originalEvent = olde;
                e.preventDefault = preventTouch;
                e.stopPropagation = stopTouch;
                break;
              }
            }
          }

          return fn.call(element, e);
        };

        obj.addEventListener(realName, f, false);
        return function () {
          obj.removeEventListener(realName, f, false);
          return true;
        };
      };
    } else if (doc.attachEvent) {
      return function (obj, type, fn, element) {
        var f = function (e) {
          e = e || win.event;
          e.preventDefault = e.preventDefault || preventDefault;
          e.stopPropagation = e.stopPropagation || stopPropagation;
          return fn.call(element, e);
        };

        obj.attachEvent("on" + type, f);

        var detacher = function () {
          obj.detachEvent("on" + type, f);
          return true;
        };

        return detacher;
      };
    }
  }(),
      drag = [],
      dragMove = function (e) {
    var x = e.clientX,
        y = e.clientY,
        scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
        scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft,
        dragi,
        j = drag.length;

    while (j--) {
      dragi = drag[j];

      if (supportsTouch) {
        var i = e.touches.length,
            touch;

        while (i--) {
          touch = e.touches[i];

          if (touch.identifier == dragi.el._drag.id) {
            x = touch.clientX;
            y = touch.clientY;
            (e.originalEvent ? e.originalEvent : e).preventDefault();
            break;
          }
        }
      } else {
        e.preventDefault();
      }

      x += scrollX;
      y += scrollY;
      dragi.move && dragi.move.call(dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
    }
  },
      dragUp = function (e) {
    R.unmousemove(dragMove).unmouseup(dragUp);
    var i = drag.length,
        dragi;

    while (i--) {
      dragi = drag[i];
      dragi.el._drag = {};
      dragi.end && dragi.end.call(dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
    }

    drag = [];
  };

  for (var i = events[length]; i--;) {
    (function (eventName) {
      R[eventName] = Element[proto][eventName] = function (fn, scope) {
        if (R.is(fn, "function")) {
          this.events = this.events || [];
          this.events.push({
            name: eventName,
            f: fn,
            unbind: addEvent(this.shape || this.node || doc, eventName, fn, scope || this)
          });
        }

        return this;
      };

      R["un" + eventName] = Element[proto]["un" + eventName] = function (fn) {
        var events = this.events,
            l = events[length];

        while (l--) if (events[l].name == eventName && events[l].f == fn) {
          events[l].unbind();
          events.splice(l, 1);
          !events.length && delete this.events;
          return this;
        }

        return this;
      };
    })(events[i]);
  }

  elproto.hover = function (f_in, f_out, scope_in, scope_out) {
    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
  };

  elproto.unhover = function (f_in, f_out) {
    return this.unmouseover(f_in).unmouseout(f_out);
  };

  elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
    this._drag = {};
    this.mousedown(function (e) {
      (e.originalEvent || e).preventDefault();
      var scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
          scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft;
      this._drag.x = e.clientX + scrollX;
      this._drag.y = e.clientY + scrollY;
      this._drag.id = e.identifier;
      onstart && onstart.call(start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
      !drag.length && R.mousemove(dragMove).mouseup(dragUp);
      drag.push({
        el: this,
        move: onmove,
        end: onend,
        move_scope: move_scope,
        start_scope: start_scope,
        end_scope: end_scope
      });
    });
    return this;
  };

  elproto.undrag = function (onmove, onstart, onend) {
    var i = drag.length;

    while (i--) {
      drag[i].el == this && drag[i].move == onmove && drag[i].end == onend && drag.splice(i++, 1);
    }

    !drag.length && R.unmousemove(dragMove).unmouseup(dragUp);
  };

  paperproto.circle = function (x, y, r) {
    return theCircle(this, x || 0, y || 0, r || 0);
  };

  paperproto.rect = function (x, y, w, h, r) {
    return theRect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
  };

  paperproto.ellipse = function (x, y, rx, ry) {
    return theEllipse(this, x || 0, y || 0, rx || 0, ry || 0);
  };

  paperproto.path = function (pathString) {
    pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
    return thePath(R.format[apply](R, arguments), this);
  };

  paperproto.image = function (src, x, y, w, h) {
    return theImage(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
  };

  paperproto.text = function (x, y, text) {
    return theText(this, x || 0, y || 0, Str(text));
  };

  paperproto.set = function (itemsArray) {
    arguments[length] > 1 && (itemsArray = Array[proto].splice.call(arguments, 0, arguments[length]));
    return new Set(itemsArray);
  };

  paperproto.setSize = setSize;
  paperproto.top = paperproto.bottom = null;
  paperproto.raphael = R;

  function x_y() {
    return this.x + S + this.y;
  }

  elproto.resetScale = function () {
    if (this.removed) {
      return this;
    }

    this._.sx = 1;
    this._.sy = 1;
    this.attrs.scale = "1 1";
  };

  elproto.scale = function (x, y, cx, cy) {
    if (this.removed) {
      return this;
    }

    if (x == null && y == null) {
      return {
        x: this._.sx,
        y: this._.sy,
        toString: x_y
      };
    }

    y = y || x;
    !+y && (y = x);
    var dx,
        dy,
        a = this.attrs;

    if (x != 0) {
      var bb = this.getBBox(),
          rcx = bb.x + bb.width / 2,
          rcy = bb.y + bb.height / 2,
          kx = abs(x / this._.sx),
          ky = abs(y / this._.sy);
      cx = +cx || cx == 0 ? cx : rcx;
      cy = +cy || cy == 0 ? cy : rcy;
      var posx = this._.sx > 0,
          posy = this._.sy > 0,
          dirx = ~~(x / abs(x)),
          diry = ~~(y / abs(y)),
          dkx = kx * dirx,
          dky = ky * diry,
          s = this.node.style,
          ncx = cx + abs(rcx - cx) * dkx * (rcx > cx == posx ? 1 : -1),
          ncy = cy + abs(rcy - cy) * dky * (rcy > cy == posy ? 1 : -1),
          fr = x * dirx > y * diry ? ky : kx;

      switch (this.type) {
        case "rect":
        case "image":
          var neww = a.width * kx,
              newh = a.height * ky;
          this.attr({
            height: newh,
            r: a.r * fr,
            width: neww,
            x: ncx - neww / 2,
            y: ncy - newh / 2
          });
          break;

        case "circle":
        case "ellipse":
          this.attr({
            rx: a.rx * kx,
            ry: a.ry * ky,
            r: a.r * fr,
            cx: ncx,
            cy: ncy
          });
          break;

        case "text":
          this.attr({
            x: ncx,
            y: ncy
          });
          break;

        case "path":
          var path = pathToRelative(a.path),
              skip = true,
              fx = posx ? dkx : kx,
              fy = posy ? dky : ky;

          for (var i = 0, ii = path[length]; i < ii; i++) {
            var p = path[i],
                P0 = upperCase.call(p[0]);

            if (P0 == "M" && skip) {
              continue;
            } else {
              skip = false;
            }

            if (P0 == "A") {
              p[path[i][length] - 2] *= fx;
              p[path[i][length] - 1] *= fy;
              p[1] *= kx;
              p[2] *= ky;
              p[5] = +(dirx + diry ? !!+p[5] : !+p[5]);
            } else if (P0 == "H") {
              for (var j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= fx;
              }
            } else if (P0 == "V") {
              for (j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= fy;
              }
            } else {
              for (j = 1, jj = p[length]; j < jj; j++) {
                p[j] *= j % 2 ? fx : fy;
              }
            }
          }

          var dim2 = pathDimensions(path);
          dx = ncx - dim2.x - dim2.width / 2;
          dy = ncy - dim2.y - dim2.height / 2;
          path[0][1] += dx;
          path[0][2] += dy;
          this.attr({
            path: path
          });
          break;
      }

      if (this.type in {
        text: 1,
        image: 1
      } && (dirx != 1 || diry != 1)) {
        if (this.transformations) {
          this.transformations[2] = "scale("[concat](dirx, ",", diry, ")");
          setAttr(this.node, "transform", this.transformations[join](S));
          dx = dirx == -1 ? -a.x - (neww || 0) : a.x;
          dy = diry == -1 ? -a.y - (newh || 0) : a.y;
          this.attr({
            x: dx,
            y: dy
          });
          a.fx = dirx - 1;
          a.fy = diry - 1;
        } else {
          this.node.filterMatrix = ms + ".Matrix(M11="[concat](dirx, ", M12=0, M21=0, M22=", diry, ", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");
          s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
        }
      } else {
        if (this.transformations) {
          this.transformations[2] = E;
          setAttr(this.node, "transform", this.transformations[join](S));
          a.fx = 0;
          a.fy = 0;
        } else {
          this.node.filterMatrix = E;
          s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
        }
      }

      a.scale = [x, y, cx, cy][join](S);
      this._.sx = x;
      this._.sy = y;
    }

    return this;
  };

  elproto.clone = function () {
    if (this.removed) {
      return null;
    }

    var attr = this.attr();
    delete attr.scale;
    delete attr.translation;
    return this.paper[this.type]().attr(attr);
  };

  var curveslengths = {},
      getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
    // Is this a straight line?
    // Added for huge speed improvements
    if (p1x === c1x && p1y === c1y && c2x === p2x && c2y == p2y) {
      var dx = p2x - p1x,
          dy = p2y - p1y;
      var totalLength = Math.sqrt(dx * dx + dy * dy);

      if (length == null) {
        return totalLength;
      } else {
        var fract = length / totalLength;
        return {
          start: {
            x: p1x,
            y: p1y
          },
          m: {
            x: p1x,
            y: p1y
          },
          n: {
            x: p2x,
            y: p2y
          },
          end: {
            x: p2x,
            y: p2y
          },
          x: p1x + fract * dx,
          y: p1y + fract * dy,
          alpha: 90 - math.atan(dx / dy) * 180 / PI
        };
      }
    }

    var len = 0,
        precision = 100,
        name = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y].join(),
        cache = curveslengths[name],
        old,
        dot;
    !cache && (curveslengths[name] = cache = {
      data: []
    });
    cache.timer && clearTimeout(cache.timer);
    cache.timer = setTimeout(function () {
      delete curveslengths[name];
    }, 2000);

    if (length != null) {
      var total = getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
      precision = ~~total * 10;
    }

    for (var i = 0; i < precision + 1; i++) {
      if (cache.data[length] > i) {
        dot = cache.data[i * precision];
      } else {
        dot = R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, i / precision);
        cache.data[i] = dot;
      }

      i && (len += pow(pow(old.x - dot.x, 2) + pow(old.y - dot.y, 2), .5));

      if (length != null && len >= length) {
        return dot;
      }

      old = dot;
    }

    if (length == null) {
      return len;
    }
  },
      getLengthFactory = function (istotal, subpath) {
    return function (path, length, onlystart) {
      path = path2curve(path);
      var x,
          y,
          p,
          l,
          sp = "",
          subpaths = {},
          point,
          len = 0;

      for (var i = 0, ii = path.length; i < ii; i++) {
        p = path[i];

        if (p[0] == "M") {
          x = +p[1];
          y = +p[2];
        } else {
          l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);

          if (len + l > length) {
            if (subpath && !subpaths.start) {
              point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
              sp += ["C", point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];

              if (onlystart) {
                return sp;
              }

              subpaths.start = sp;
              sp = ["M", point.x, point.y + "C", point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]][join]();
              len += l;
              x = +p[5];
              y = +p[6];
              continue;
            }

            if (!istotal && !subpath) {
              point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
              return {
                x: point.x,
                y: point.y,
                alpha: point.alpha
              };
            }
          }

          len += l;
          x = +p[5];
          y = +p[6];
        }

        sp += p;
      }

      subpaths.end = sp;
      point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[1], p[2], p[3], p[4], p[5], p[6], 1);
      point.alpha && (point = {
        x: point.x,
        y: point.y,
        alpha: point.alpha
      });
      return point;
    };
  };

  var getTotalLength = getLengthFactory(1),
      getPointAtLength = getLengthFactory(),
      getSubpathsAtLength = getLengthFactory(0, 1);

  elproto.getTotalLength = function () {
    if (this.type != "path") {
      return;
    }

    if (this.node.getTotalLength) {
      return this.node.getTotalLength();
    }

    return getTotalLength(this.attrs.path);
  };

  elproto.getPointAtLength = function (length) {
    if (this.type != "path") {
      return;
    }

    return getPointAtLength(this.attrs.path, length);
  };

  elproto.getSubpath = function (from, to) {
    if (this.type != "path") {
      return;
    }

    if (abs(this.getTotalLength() - to) < "1e-6") {
      return getSubpathsAtLength(this.attrs.path, from).end;
    }

    var a = getSubpathsAtLength(this.attrs.path, to, 1);
    return from ? getSubpathsAtLength(a, from).end : a;
  }; // animation easing formulas


  R.easing_formulas = {
    linear: function (n) {
      return n;
    },
    "<": function (n) {
      return pow(n, 3);
    },
    ">": function (n) {
      return pow(n - 1, 3) + 1;
    },
    "<>": function (n) {
      n = n * 2;

      if (n < 1) {
        return pow(n, 3) / 2;
      }

      n -= 2;
      return (pow(n, 3) + 2) / 2;
    },
    backIn: function (n) {
      var s = 1.70158;
      return n * n * ((s + 1) * n - s);
    },
    backOut: function (n) {
      n = n - 1;
      var s = 1.70158;
      return n * n * ((s + 1) * n + s) + 1;
    },
    elastic: function (n) {
      if (n == 0 || n == 1) {
        return n;
      }

      var p = .3,
          s = p / 4;
      return pow(2, -10 * n) * math.sin((n - s) * (2 * PI) / p) + 1;
    },
    bounce: function (n) {
      var s = 7.5625,
          p = 2.75,
          l;

      if (n < 1 / p) {
        l = s * n * n;
      } else {
        if (n < 2 / p) {
          n -= 1.5 / p;
          l = s * n * n + .75;
        } else {
          if (n < 2.5 / p) {
            n -= 2.25 / p;
            l = s * n * n + .9375;
          } else {
            n -= 2.625 / p;
            l = s * n * n + .984375;
          }
        }
      }

      return l;
    }
  };

  var animationElements = [],
      animation = function () {
    var Now = +new Date();

    for (var l = 0; l < animationElements[length]; l++) {
      var e = animationElements[l];

      if (e.stop || e.el.removed) {
        continue;
      }

      var time = Now - e.start,
          ms = e.ms,
          easing = e.easing,
          from = e.from,
          diff = e.diff,
          to = e.to,
          t = e.t,
          that = e.el,
          set = {},
          now;

      if (time < ms) {
        var pos = easing(time / ms);

        for (var attr in from) if (from[has](attr)) {
          switch (availableAnimAttrs[attr]) {
            case "along":
              now = pos * ms * diff[attr];
              to.back && (now = to.len - now);
              var point = getPointAtLength(to[attr], now);
              that.translate(diff.sx - diff.x || 0, diff.sy - diff.y || 0);
              diff.x = point.x;
              diff.y = point.y;
              that.translate(point.x - diff.sx, point.y - diff.sy);
              to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
              break;

            case nu:
              now = +from[attr] + pos * ms * diff[attr];
              break;

            case "colour":
              now = "rgb(" + [upto255(round(from[attr].r + pos * ms * diff[attr].r)), upto255(round(from[attr].g + pos * ms * diff[attr].g)), upto255(round(from[attr].b + pos * ms * diff[attr].b))][join](",") + ")";
              break;

            case "path":
              now = [];

              for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                now[i] = [from[attr][i][0]];

                for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                  now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                }

                now[i] = now[i][join](S);
              }

              now = now[join](S);
              break;

            case "csv":
              switch (attr) {
                case "translation":
                  var x = pos * ms * diff[attr][0] - t.x,
                      y = pos * ms * diff[attr][1] - t.y;
                  t.x += x;
                  t.y += y;
                  now = x + S + y;
                  break;

                case "rotation":
                  now = +from[attr][0] + pos * ms * diff[attr][0];
                  from[attr][1] && (now += "," + from[attr][1] + "," + from[attr][2]);
                  break;

                case "scale":
                  now = [+from[attr][0] + pos * ms * diff[attr][0], +from[attr][1] + pos * ms * diff[attr][1], 2 in to[attr] ? to[attr][2] : E, 3 in to[attr] ? to[attr][3] : E][join](S);
                  break;

                case "clip-rect":
                  now = [];
                  i = 4;

                  while (i--) {
                    now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                  }

                  break;
              }

              break;

            default:
              var from2 = [].concat(from[attr]);
              now = [];
              i = that.paper.customAttributes[attr].length;

              while (i--) {
                now[i] = +from2[i] + pos * ms * diff[attr][i];
              }

              break;
          }

          set[attr] = now;
        }

        that.attr(set);
        that._run && that._run.call(that);
      } else {
        if (to.along) {
          point = getPointAtLength(to.along, to.len * !to.back);
          that.translate(diff.sx - (diff.x || 0) + point.x - diff.sx, diff.sy - (diff.y || 0) + point.y - diff.sy);
          to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
        }

        (t.x || t.y) && that.translate(-t.x, -t.y);
        to.scale && (to.scale += E);
        that.attr(to);
        animationElements.splice(l--, 1);
      }
    }

    R.svg && that && that.paper && that.paper.safari();
    animationElements[length] && setTimeout(animation);
  },
      keyframesRun = function (attr, element, time, prev, prevcallback) {
    var dif = time - prev;
    element.timeouts.push(setTimeout(function () {
      R.is(prevcallback, "function") && prevcallback.call(element);
      element.animate(attr, dif, attr.easing);
    }, prev));
  },
      upto255 = function (color) {
    return mmax(mmin(color, 255), 0);
  },
      translate = function (x, y) {
    if (x == null) {
      return {
        x: this._.tx,
        y: this._.ty,
        toString: x_y
      };
    }

    this._.tx += +x;
    this._.ty += +y;

    switch (this.type) {
      case "circle":
      case "ellipse":
        this.attr({
          cx: +x + this.attrs.cx,
          cy: +y + this.attrs.cy
        });
        break;

      case "rect":
      case "image":
      case "text":
        this.attr({
          x: +x + this.attrs.x,
          y: +y + this.attrs.y
        });
        break;

      case "path":
        var path = pathToRelative(this.attrs.path);
        path[0][1] += +x;
        path[0][2] += +y;
        this.attr({
          path: path
        });
        break;
    }

    return this;
  };

  elproto.animateWith = function (element, params, ms, easing, callback) {
    for (var i = 0, ii = animationElements.length; i < ii; i++) {
      if (animationElements[i].el.id == element.id) {
        params.start = animationElements[i].start;
      }
    }

    return this.animate(params, ms, easing, callback);
  };

  elproto.animateAlong = along();
  elproto.animateAlongBack = along(1);

  function along(isBack) {
    return function (path, ms, rotate, callback) {
      var params = {
        back: isBack
      };
      R.is(rotate, "function") ? callback = rotate : params.rot = rotate;
      path && path.constructor == Element && (path = path.attrs.path);
      path && (params.along = path);
      return this.animate(params, ms, callback);
    };
  }

  function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
    var cx = 3 * p1x,
        bx = 3 * (p2x - p1x) - cx,
        ax = 1 - cx - bx,
        cy = 3 * p1y,
        by = 3 * (p2y - p1y) - cy,
        ay = 1 - cy - by;

    function sampleCurveX(t) {
      return ((ax * t + bx) * t + cx) * t;
    }

    function solve(x, epsilon) {
      var t = solveCurveX(x, epsilon);
      return ((ay * t + by) * t + cy) * t;
    }

    function solveCurveX(x, epsilon) {
      var t0, t1, t2, x2, d2, i;

      for (t2 = x, i = 0; i < 8; i++) {
        x2 = sampleCurveX(t2) - x;

        if (abs(x2) < epsilon) {
          return t2;
        }

        d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;

        if (abs(d2) < 1e-6) {
          break;
        }

        t2 = t2 - x2 / d2;
      }

      t0 = 0;
      t1 = 1;
      t2 = x;

      if (t2 < t0) {
        return t0;
      }

      if (t2 > t1) {
        return t1;
      }

      while (t0 < t1) {
        x2 = sampleCurveX(t2);

        if (abs(x2 - x) < epsilon) {
          return t2;
        }

        if (x > x2) {
          t0 = t2;
        } else {
          t1 = t2;
        }

        t2 = (t1 - t0) / 2 + t0;
      }

      return t2;
    }

    return solve(t, 1 / (200 * duration));
  }

  elproto.onAnimation = function (f) {
    this._run = f || 0;
    return this;
  };

  elproto.animate = function (params, ms, easing, callback) {
    var element = this;
    element.timeouts = element.timeouts || [];

    if (R.is(easing, "function") || !easing) {
      callback = easing || null;
    }

    if (element.removed) {
      callback && callback.call(element);
      return element;
    }

    var from = {},
        to = {},
        animateable = false,
        diff = {};

    for (var attr in params) if (params[has](attr)) {
      if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
        animateable = true;
        from[attr] = element.attr(attr);
        from[attr] == null && (from[attr] = availableAttrs[attr]);
        to[attr] = params[attr];

        switch (availableAnimAttrs[attr]) {
          case "along":
            var len = getTotalLength(params[attr]);
            var point = getPointAtLength(params[attr], len * !!params.back);
            var bb = element.getBBox();
            diff[attr] = len / ms;
            diff.tx = bb.x;
            diff.ty = bb.y;
            diff.sx = point.x;
            diff.sy = point.y;
            to.rot = params.rot;
            to.back = params.back;
            to.len = len;
            params.rot && (diff.r = toFloat(element.rotate()) || 0);
            break;

          case nu:
            diff[attr] = (to[attr] - from[attr]) / ms;
            break;

          case "colour":
            from[attr] = R.getRGB(from[attr]);
            var toColour = R.getRGB(to[attr]);
            diff[attr] = {
              r: (toColour.r - from[attr].r) / ms,
              g: (toColour.g - from[attr].g) / ms,
              b: (toColour.b - from[attr].b) / ms
            };
            break;

          case "path":
            var pathes = path2curve(from[attr], to[attr]);
            from[attr] = pathes[0];
            var toPath = pathes[1];
            diff[attr] = [];

            for (var i = 0, ii = from[attr][length]; i < ii; i++) {
              diff[attr][i] = [0];

              for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
              }
            }

            break;

          case "csv":
            var values = Str(params[attr])[split](separator),
                from2 = Str(from[attr])[split](separator);

            switch (attr) {
              case "translation":
                from[attr] = [0, 0];
                diff[attr] = [values[0] / ms, values[1] / ms];
                break;

              case "rotation":
                from[attr] = from2[1] == values[1] && from2[2] == values[2] ? from2 : [0, values[1], values[2]];
                diff[attr] = [(values[0] - from[attr][0]) / ms, 0, 0];
                break;

              case "scale":
                params[attr] = values;
                from[attr] = Str(from[attr])[split](separator);
                diff[attr] = [(values[0] - from[attr][0]) / ms, (values[1] - from[attr][1]) / ms, 0, 0];
                break;

              case "clip-rect":
                from[attr] = Str(from[attr])[split](separator);
                diff[attr] = [];
                i = 4;

                while (i--) {
                  diff[attr][i] = (values[i] - from[attr][i]) / ms;
                }

                break;
            }

            to[attr] = values;
            break;

          default:
            values = [].concat(params[attr]);
            from2 = [].concat(from[attr]);
            diff[attr] = [];
            i = element.paper.customAttributes[attr][length];

            while (i--) {
              diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
            }

            break;
        }
      }
    }

    if (!animateable) {
      var attrs = [],
          lastcall;

      for (var key in params) if (params[has](key) && animKeyFrames.test(key)) {
        attr = {
          value: params[key]
        };
        key == "from" && (key = 0);
        key == "to" && (key = 100);
        attr.key = toInt(key, 10);
        attrs.push(attr);
      }

      attrs.sort(sortByKey);

      if (attrs[0].key) {
        attrs.unshift({
          key: 0,
          value: element.attrs
        });
      }

      for (i = 0, ii = attrs[length]; i < ii; i++) {
        keyframesRun(attrs[i].value, element, ms / 100 * attrs[i].key, ms / 100 * (attrs[i - 1] && attrs[i - 1].key || 0), attrs[i - 1] && attrs[i - 1].value.callback);
      }

      lastcall = attrs[attrs[length] - 1].value.callback;

      if (lastcall) {
        element.timeouts.push(setTimeout(function () {
          lastcall.call(element);
        }, ms));
      }
    } else {
      var easyeasy = R.easing_formulas[easing];

      if (!easyeasy) {
        easyeasy = Str(easing).match(bezierrg);

        if (easyeasy && easyeasy[length] == 5) {
          var curve = easyeasy;

          easyeasy = function (t) {
            return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
          };
        } else {
          easyeasy = function (t) {
            return t;
          };
        }
      }

      animationElements.push({
        start: params.start || +new Date(),
        ms: ms,
        easing: easyeasy,
        from: from,
        diff: diff,
        to: to,
        el: element,
        t: {
          x: 0,
          y: 0
        }
      });
      R.is(callback, "function") && (element._ac = setTimeout(function () {
        callback.call(element);
      }, ms));
      animationElements[length] == 1 && setTimeout(animation);
    }

    return this;
  };

  elproto.stop = function () {
    for (var i = 0; i < animationElements.length; i++) {
      animationElements[i].el.id == this.id && animationElements.splice(i--, 1);
    }

    for (i = 0, ii = this.timeouts && this.timeouts.length; i < ii; i++) {
      clearTimeout(this.timeouts[i]);
    }

    this.timeouts = [];
    clearTimeout(this._ac);
    delete this._ac;
    return this;
  };

  elproto.translate = function (x, y) {
    return this.attr({
      translation: x + " " + y
    });
  };

  elproto[toString] = function () {
    return "Rapha\xebl\u2019s object";
  };

  R.ae = animationElements; // Set

  var Set = function (items) {
    this.items = [];
    this[length] = 0;
    this.type = "set";

    if (items) {
      for (var i = 0, ii = items[length]; i < ii; i++) {
        if (items[i] && (items[i].constructor == Element || items[i].constructor == Set)) {
          this[this.items[length]] = this.items[this.items[length]] = items[i];
          this[length]++;
        }
      }
    }
  };

  Set[proto][push] = function () {
    var item, len;

    for (var i = 0, ii = arguments[length]; i < ii; i++) {
      item = arguments[i];

      if (item && (item.constructor == Element || item.constructor == Set)) {
        len = this.items[length];
        this[len] = this.items[len] = item;
        this[length]++;
      }
    }

    return this;
  };

  Set[proto].pop = function () {
    delete this[this[length]--];
    return this.items.pop();
  };

  for (var method in elproto) if (elproto[has](method)) {
    Set[proto][method] = function (methodname) {
      return function () {
        for (var i = 0, ii = this.items[length]; i < ii; i++) {
          this.items[i][methodname][apply](this.items[i], arguments);
        }

        return this;
      };
    }(method);
  }

  Set[proto].attr = function (name, value) {
    if (name && R.is(name, array) && R.is(name[0], "object")) {
      for (var j = 0, jj = name[length]; j < jj; j++) {
        this.items[j].attr(name[j]);
      }
    } else {
      for (var i = 0, ii = this.items[length]; i < ii; i++) {
        this.items[i].attr(name, value);
      }
    }

    return this;
  };

  Set[proto].animate = function (params, ms, easing, callback) {
    (R.is(easing, "function") || !easing) && (callback = easing || null);
    var len = this.items[length],
        i = len,
        item,
        set = this,
        collector;
    callback && (collector = function () {
      ! --len && callback.call(set);
    });
    easing = R.is(easing, string) ? easing : collector;
    item = this.items[--i].animate(params, ms, easing, collector);

    while (i--) {
      this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, params, ms, easing, collector);
    }

    return this;
  };

  Set[proto].insertAfter = function (el) {
    var i = this.items[length];

    while (i--) {
      this.items[i].insertAfter(el);
    }

    return this;
  };

  Set[proto].getBBox = function () {
    var x = [],
        y = [],
        w = [],
        h = [];

    for (var i = this.items[length]; i--;) {
      var box = this.items[i].getBBox();
      x[push](box.x);
      y[push](box.y);
      w[push](box.x + box.width);
      h[push](box.y + box.height);
    }

    x = mmin[apply](0, x);
    y = mmin[apply](0, y);
    return {
      x: x,
      y: y,
      width: mmax[apply](0, w) - x,
      height: mmax[apply](0, h) - y
    };
  };

  Set[proto].clone = function (s) {
    s = new Set();

    for (var i = 0, ii = this.items[length]; i < ii; i++) {
      s[push](this.items[i].clone());
    }

    return s;
  };

  R.registerFont = function (font) {
    if (!font.face) {
      return font;
    }

    this.fonts = this.fonts || {};
    var fontcopy = {
      w: font.w,
      face: {},
      glyphs: {}
    },
        family = font.face["font-family"];

    for (var prop in font.face) if (font.face[has](prop)) {
      fontcopy.face[prop] = font.face[prop];
    }

    if (this.fonts[family]) {
      this.fonts[family][push](fontcopy);
    } else {
      this.fonts[family] = [fontcopy];
    }

    if (!font.svg) {
      fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);

      for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
        var path = font.glyphs[glyph];
        fontcopy.glyphs[glyph] = {
          w: path.w,
          k: {},
          d: path.d && "M" + path.d[rp](/[mlcxtrv]/g, function (command) {
            return {
              l: "L",
              c: "C",
              x: "z",
              t: "m",
              r: "l",
              v: "c"
            }[command] || "M";
          }) + "z"
        };

        if (path.k) {
          for (var k in path.k) if (path[has](k)) {
            fontcopy.glyphs[glyph].k[k] = path.k[k];
          }
        }
      }
    }

    return font;
  };

  paperproto.getFont = function (family, weight, style, stretch) {
    stretch = stretch || "normal";
    style = style || "normal";
    weight = +weight || {
      normal: 400,
      bold: 700,
      lighter: 300,
      bolder: 800
    }[weight] || 400;

    if (!R.fonts) {
      return;
    }

    var font = R.fonts[family];

    if (!font) {
      var name = new RegExp("(^|\\s)" + family[rp](/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");

      for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
        if (name.test(fontName)) {
          font = R.fonts[fontName];
          break;
        }
      }
    }

    var thefont;

    if (font) {
      for (var i = 0, ii = font[length]; i < ii; i++) {
        thefont = font[i];

        if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
          break;
        }
      }
    }

    return thefont;
  };

  paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
    origin = origin || "middle"; // baseline|middle

    letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
    var out = this.set(),
        letters = Str(string)[split](E),
        shift = 0,
        scale;
    R.is(font, string) && (font = this.getFont(font));

    if (font) {
      scale = (size || 16) / font.face["units-per-em"];
      var bb = font.face.bbox.split(separator),
          top = +bb[0],
          height = +bb[1] + (origin == "baseline" ? bb[3] - bb[1] + +font.face.descent : (bb[3] - bb[1]) / 2);

      for (var i = 0, ii = letters[length]; i < ii; i++) {
        var prev = i && font.glyphs[letters[i - 1]] || {},
            curr = font.glyphs[letters[i]];
        shift += i ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
        curr && curr.d && out[push](this.path(curr.d).attr({
          fill: "#000",
          stroke: "none",
          translation: [shift, 0]
        }));
      }

      out.scale(scale, scale, top, height).translate(x - top, y - height);
    }

    return out;
  };

  R.format = function (token, params) {
    var args = R.is(params, array) ? [0][concat](params) : arguments;
    token && R.is(token, string) && args[length] - 1 && (token = token[rp](formatrg, function (str, i) {
      return args[++i] == null ? E : args[i];
    }));
    return token || E;
  };

  R.ninja = function () {
    oldRaphael.was ? win.Raphael = oldRaphael.is : Raphael = undefined;
    return R;
  };

  R.el = elproto;
  R.st = Set[proto];
  raphael.exports = R;
})();

/**
 * Color constants we use throughout Perseus (originally on KhanUtil).
 *
 * Note that if the color palette changes substantially, it may also need to be
 * updated in khan-exercises and cherry-picked into graphie-to-png's
 * khan-exercises submodule, as graphie-to-png still relies on the palette
 * provided on KhanUtil.
 */
const KhanColors = {
  BLUE: "#6495ED",
  ORANGE: "#FFA500",
  PINK: "#FF00AF",
  GREEN: "#28AE7B",
  PURPLE: "#9D38BD",
  RED: "#DF0030",
  GRAY: "gray",
  BLACK: "black",
  LIGHT_BLUE: "#9AB8ED",
  LIGHT_ORANGE: "#EDD19B",
  LIGHT_PINK: "#ED9BD3",
  LIGHT_GREEN: "#9BEDCE",
  LIGHT_PURPLE: "#DA9BED",
  LIGHT_RED: "#ED9AAC",
  LIGHT_GRAY: "#ED9B9B",
  LIGHT_BLACK: "#ED9B9B",
  GRAY10: "#D6D6D6",
  GRAY20: "#CDCDCD",
  GRAY30: "#B3B3B3",
  GRAY40: "#9A9A9A",
  GRAY50: "#808080",
  GRAY60: "#666666",
  GRAY70: "#4D4D4D",
  GRAY80: "#333333",
  GRAY90: "#1A1A1A",
  BLUE_A: "#CCFAFF",
  BLUE_B: "#80F6FF",
  BLUE_C: "#63D9EA",
  BLUE_D: "#11ACCD",
  BLUE_E: "#0C7F99",
  TEAL_A: "#94FFF5",
  TEAL_B: "#26EDD5",
  TEAL_C: "#01D1C1",
  TEAL_D: "#01A995",
  TEAL_E: "#208170",
  GREEN_A: "#B6FFB0",
  GREEN_B: "#8AF281",
  GREEN_C: "#74CF70",
  GREEN_D: "#1FAB54",
  GREEN_E: "#0D923F",
  GOLD_A: "#FFD0A9",
  GOLD_B: "#FFBB71",
  GOLD_C: "#FF9C39",
  GOLD_D: "#E07D10",
  GOLD_E: "#A75A05",
  RED_A: "#FCA9A9",
  RED_B: "#FF8482",
  RED_C: "#F9685D",
  RED_D: "#E84D39",
  RED_E: "#BC2612",
  MAROON_A: "#FFBDE0",
  MAROON_B: "#FF92C6",
  MAROON_C: "#ED5FA6",
  MAROON_D: "#CA337C",
  MAROON_E: "#9E034E",
  PURPLE_A: "#DDD7FF",
  PURPLE_B: "#C6B9FC",
  PURPLE_C: "#AA87FF",
  PURPLE_D: "#7854AB",
  PURPLE_E: "#543B78",
  MINT_A: "#F5F9E8",
  MINT_B: "#EDF2DF",
  MINT_C: "#E0E5CC",
  GRAY_A: "#F6F7F7",
  GRAY_B: "#F0F1F2",
  GRAY_C: "#E3E5E6",
  GRAY_D: "#D6D8DA",
  GRAY_E: "#BABEC2",
  GRAY_F: "#888D93",
  GRAY_G: "#626569",
  GRAY_H: "#3B3E40",
  GRAY_I: "#21242C",
  KA_BLUE: "#314453",
  KA_GREEN: "#71B307",
  // Don't actually use _BACKGROUND! Make things transparent instead. The
  // background color used in exercises is subject to change at the whim
  // of any redesigns.
  _BACKGROUND: "#FDFDFD",
  // TODO(eater): Get rid of this altogether.
  INTERACTING: "#71B307",
  // KA_GREEN
  INTERACTIVE: "#71B307",
  // KA_GREEN
  DYNAMIC: "#6495ED" // BLUE

};

/* global MathJax */

function findChildOrAdd(elem, className) {
  const $child = $__default["default"](elem).find("." + className);

  if ($child.length === 0) {
    return $__default["default"]("<span>").addClass(className).appendTo($__default["default"](elem));
  }

  return $child;
}

function doCallback(elem, callback) {
  let tries = 0;

  (function check() {
    const height = elem.scrollHeight; // Heuristic to guess if the font has kicked in
    // so we have box metrics (magic number ick,
    // but this seems to work mostly-consistently)

    if (height > 18 || tries >= 10) {
      callback();
    } else {
      tries++; // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax

      setTimeout(check, 100);
    }
  })();
}

var Tex$1 = {
  // Process a node and add math inside of it. This attempts to use KaTeX to
  // format the math, and if that fails it falls back to MathJax.
  //
  // elem: The element which the math should be added to.
  //
  // text: The text that should be formatted inside of the node. If the node
  //       has already had math formatted inside of it before, this doesn't
  //       have to be provided. If this is not provided, and the node hasn't
  //       been formatted before, the text content of the node is used.
  //
  // force: (optional) if the node has been processed before, then it will
  //        not be formatted again, unless this argument is true
  //
  // callback: (optional) a callback to be run after the math has been
  //           processed
  processMath: async function (elem, text, force, callback) {
    const $elem = $__default["default"](elem); // Only process if it hasn't been done before, or it is forced

    if ($elem.attr("data-math-formula") == null || force) {
      const $katexHolder = findChildOrAdd($elem, "katex-holder");
      const $mathjaxHolder = findChildOrAdd($elem, "mathjax-holder"); // Search for MathJax-y script tags inside of the node. These are
      // used by MathJax to denote the formula to be typeset. Before, we
      // would update the formula by updating the contents of the script
      // tag, which shouldn't happen any more, but we manage them just in
      // case.

      const script = $mathjaxHolder.find("script[type='math/tex']")[0]; // If text wasn't provided, we look in two places

      if (text == null) {
        if ($elem.attr("data-math-formula")) {
          // The old typeset formula
          text = $elem.attr("data-math-formula");
        } else if (script) {
          // The contents of the <script> tag
          text = script.text || script.textContent;
        }
      }

      text = text != null ? text + "" : ""; // Attempt to clean up some of the math

      text = KhanMath.cleanMath(text); // Store the formula that we're using

      $elem.attr("data-math-formula", text);
      const katex = await getDependencies().getKaTeX(); // Try to process the nodes with KaTeX first

      try {
        // Don't use the `trust: true` setting with KaTeX.  There is a
        // security issue with it as outlined in https://hackerone.com/reports/844216.
        // See https://khanacademy.atlassian.net/browse/FEI-2225 for
        // additional context.
        katex.render(text, $katexHolder[0], {
          colorIsTextColor: true
        }); // If that worked, and we previously formatted with
        // mathjax, do some mathjax cleanup

        if ($elem.attr("data-math-type") === "mathjax") {
          // Remove the old mathjax stuff
          // $FlowIgnore[cannot-resolve-name] MathJax is a known global
          if (typeof MathJax !== "undefined") {
            const jax = MathJax.Hub.getJaxFor(script);

            if (jax) {
              const e = jax.SourceElement();

              if (e.previousSibling && e.previousSibling.className) {
                jax.Remove();
              }
            }
          }
        }

        $elem.attr("data-math-type", "katex"); // Call the callback

        if (callback) {
          doCallback(elem, callback);
        }

        return;
      } catch (err) {
        getDependencies().logKaTeXError(text, err);

        if (err instanceof katex.ParseError) {
          throw err;
        }
      } // Otherwise, fallback to MathJax
      // (Note: we don't need to do any katex cleanup here, because
      // KaTeX is smart and cleans itself up)


      $elem.attr("data-math-type", "mathjax"); // Update the script tag, or add one if necessary

      if (!script) {
        $mathjaxHolder.append("<script type='math/tex'>" + text.replace(/<\//g, "< /") + "</script>");
      } else {
        if ("text" in script) {
          // IE8, etc
          script.text = text;
        } else {
          script.textContent = text;
        }
      } // $FlowIgnore[cannot-resolve-name] MathJax is a known global


      if (typeof MathJax !== "undefined") {
        // Put the process, a debug log, and the callback into the
        // MathJax queue
        MathJax.Hub.Queue(["Reprocess", MathJax.Hub, $mathjaxHolder[0]]);

        if (callback) {
          MathJax.Hub.Queue(function () {
            const cb = MathJax.Callback(function () {});
            doCallback(elem, function () {
              callback();
              cb();
            });
            return cb;
          });
        }
      }
    }
  },
  // Function to restore a node to a non-math-processed state
  cleanupMath: function (elem) {
    const $elem = $__default["default"](elem); // Only mess with it if it's been processed before

    if ($elem.attr("data-math-formula")) {
      // Remove MathJax remnants
      // $FlowIgnore[cannot-resolve-name] MathJax is a known global
      if (typeof MathJax !== "undefined") {
        const jax = MathJax.Hub.getJaxFor($elem.find("script")[0]);

        if (jax) {
          const e = jax.SourceElement();

          if (e.previousSibling && e.previousSibling.className) {
            jax.Remove();
          }
        }
      }

      $elem.text($elem.attr("data-math-formula"));
      $elem.attr("data-math-formula", null);
      $elem.attr("data-math-type", null);
    }

    return elem;
  },
  // Function to retrieve the formula of a typeset math node
  retrieveMathFormula: function (elem) {
    return $__default["default"](elem).attr("data-math-formula");
  }
};

/* eslint-disable @babel/no-invalid-this */
const {
  processMath: processMath$1
} = Tex$1;
/* Convert cartesian coordinates [x, y] to polar coordinates [r,
 * theta], with theta in degrees, or in radians if angleInRadians is
 * specified.
 */

function cartToPolar(coord, angleInRadians) {
  const r = Math.sqrt(Math.pow(coord[0], 2) + Math.pow(coord[1], 2));
  let theta = Math.atan2(coord[1], coord[0]); // convert angle range from [-pi, pi] to [0, 2pi]

  if (theta < 0) {
    theta += 2 * Math.PI;
  }

  if (!angleInRadians) {
    theta = theta * 180 / Math.PI;
  }

  return [r, theta];
}

function polar(r, th) {
  if (typeof r === "number") {
    r = [r, r];
  }

  th = th * Math.PI / 180;
  return [r[0] * Math.cos(th), r[1] * Math.sin(th)];
}

const GraphUtils = {
  unscaledSvgPath: function (points) {
    // If this is an empty closed path, return "" instead of "z", which
    // would give an error
    if (points[0] === true) {
      return "";
    }

    return $__default["default"].map(points, function (point, i) {
      if (point === true) {
        return "z";
      }

      return (i === 0 ? "M" : "L") + point[0] + " " + point[1];
    }).join("");
  },
  getDistance: function (point1, point2) {
    return kmath.point.distanceToPoint(point1, point2);
  },

  /**
   * Return the difference between two sets of coordinates
   */
  coordDiff: function (startCoord, endCoord) {
    return ___default["default"].map(endCoord, function (val, i) {
      return endCoord[i] - startCoord[i];
    });
  },

  /**
   * Round the given coordinates to a given snap value
   * (e.g., nearest 0.2 increment)
   */
  snapCoord: function (coord, snap) {
    return ___default["default"].map(coord, function (val, i) {
      return KhanMath.roundToNearest(snap[i], val);
    });
  },
  // Find the angle in degrees between two or three points
  findAngle: function (point1, point2, vertex) {
    if (vertex === undefined) {
      const x = point1[0] - point2[0];
      const y = point1[1] - point2[1];

      if (!x && !y) {
        return 0;
      }

      return (180 + Math.atan2(-y, -x) * 180 / Math.PI + 360) % 360;
    }

    return GraphUtils.findAngle(point1, vertex) - GraphUtils.findAngle(point2, vertex);
  },
  graphs: {}
};

const Graphie$1 = GraphUtils.Graphie = function () {};

___default["default"].extend(Graphie$1.prototype, {
  cartToPolar: cartToPolar,
  polar: polar
});

const labelDirections = {
  center: [-0.5, -0.5],
  above: [-0.5, -1.0],
  "above right": [0.0, -1.0],
  right: [0.0, -0.5],
  "below right": [0.0, 0.0],
  below: [-0.5, 0.0],
  "below left": [-1.0, 0.0],
  left: [-1.0, -0.5],
  "above left": [-1.0, -1.0]
};
/**
 * Safari applies some SVG-specific styles to things that are not SVGs, so we
 * need to exclude those styles from things that are not SVGs.
 *
 * To see this behavior in action, open https://codepen.io/anon/pen/zENEoa in
 * Safari.
 *
 * Usage `$.extend({}, someStyles, SVG_SPECIFIC_STYLE_MASK)`
 */

const SVG_SPECIFIC_STYLE_MASK = {
  "stroke-width": null
};

GraphUtils.createGraphie = function (el) {
  let xScale = 40;
  let yScale = 40;
  let xRange;
  let yRange;
  $__default["default"](el).css("position", "relative");
  const raphael$1 = raphael.exports(el); // For a sometimes-reproducible IE8 bug; doesn't affect SVG browsers at all

  $__default["default"](el).children("div").css("position", "absolute"); // Set up some reasonable defaults

  let currentStyle = {
    "stroke-width": 2,
    fill: "none"
  };

  const scaleVector = function (point) {
    if (typeof point === "number") {
      return scaleVector([point, point]);
    }

    const x = point[0];
    const y = point[1];
    return [x * xScale, y * yScale];
  };

  const scalePoint = function scalePoint(point) {
    if (typeof point === "number") {
      return scalePoint([point, point]);
    }

    const x = point[0];
    const y = point[1];
    return [(x - xRange[0]) * xScale, (yRange[1] - y) * yScale];
  };

  const unscalePoint = function (point) {
    if (typeof point === "number") {
      return unscalePoint([point, point]);
    }

    const x = point[0];
    const y = point[1];
    return [x / xScale + xRange[0], yRange[1] - y / yScale];
  };

  const unscaleVector = function (point) {
    if (typeof point === "number") {
      return unscaleVector([point, point]);
    }

    return [point[0] / xScale, point[1] / yScale];
  };

  const setLabelMargins = function (span, size) {
    const $span = $__default["default"](span);
    const direction = $span.data("labelDirection");
    let [width, height] = size; // This can happen when a span
    // is invisible but we still want to update the CSS. At worst, we will
    // be off by a few pixels instead of in a different position entirely.

    if (width === 0 && height === 0) {
      [width, height] = [1, 1];
      Log.log("Label size was 0x0 in graphie.js; using 1x1 instead");
    }

    $span.css("visibility", "");

    if (typeof direction === "number") {
      const x = Math.cos(direction);
      const y = Math.sin(direction);
      const scale = Math.min(width / 2 / Math.abs(x), height / 2 / Math.abs(y));
      $span.css({
        marginLeft: -width / 2 + x * scale,
        marginTop: -height / 2 - y * scale
      });
    } else {
      const multipliers = labelDirections[direction || "center"];
      $span.css({
        marginLeft: Math.round(width * multipliers[0]),
        marginTop: Math.round(height * multipliers[1])
      });
    }
  };

  const svgPath = function (points, alreadyScaled) {
    return $__default["default"].map(points, function (point, i) {
      if (point === true) {
        return "z";
      }

      const scaled = alreadyScaled ? point : scalePoint(point);
      return (i === 0 ? "M" : "L") + KhanMath.bound(scaled[0]) + " " + KhanMath.bound(scaled[1]);
    }).join("");
  };

  const svgParabolaPath = function (a, b, c) {
    const computeParabola = function (x) {
      return (a * x + b) * x + c;
    }; // If points are collinear, plot a line instead


    if (a === 0) {
      const points = ___default["default"].map(xRange, function (x) {
        return [x, computeParabola(x)];
      });

      return svgPath(points);
    } // Calculate x coordinates of points on parabola


    const xVertex = -b / (2 * a);
    const distToEdge = Math.max(Math.abs(xVertex - xRange[0]), Math.abs(xVertex - xRange[1])); // To guarantee that drawn parabola to spans the viewport, use a point
    // on the edge of the graph furtherest from the vertex

    const xPoint = xVertex + distToEdge; // Compute parabola and other point on the curve

    const vertex = [xVertex, computeParabola(xVertex)];
    const point = [xPoint, computeParabola(xPoint)]; // Calculate SVG 'control' point, defined by spec

    const control = [vertex[0], vertex[1] - (point[1] - vertex[1])]; // Calculate mirror points across parabola's axis of symmetry

    const dx = Math.abs(vertex[0] - point[0]);
    const left = [vertex[0] - dx, point[1]];
    const right = [vertex[0] + dx, point[1]]; // Scale and bound

    const points = ___default["default"].map([left, control, right], scalePoint);

    const values = ___default["default"].map(___default["default"].flatten(points), KhanMath.bound);

    return "M" + values[0] + "," + values[1] + " Q" + values[2] + "," + values[3] + " " + values[4] + "," + values[5];
  };

  const svgSinusoidPath = function (a, b, c, d) {
    // Plot a sinusoid of the form: f(x) = a * sin(b * x - c) + d
    const quarterPeriod = Math.abs(Math.PI / (2 * b));

    const computeSine = function (x) {
      return a * Math.sin(b * x - c) + d;
    };

    const computeDerivative = function (x) {
      return a * b * Math.cos(c - b * x);
    };

    const coordsForOffset = function (initial, i) {
      // Return the cubic coordinates (including the two anchor and two
      // control points) for the ith portion of the sinusoid.
      const x0 = initial + quarterPeriod * i;
      const x1 = x0 + quarterPeriod; // Interpolate using derivative technique
      // See: http://stackoverflow.com/questions/13932704/how-to-draw-sine-waves-with-svg-js

      const xCoords = [x0, x0 * 2 / 3 + x1 * 1 / 3, x0 * 1 / 3 + x1 * 2 / 3, x1];
      const yCoords = [computeSine(x0), computeSine(x0) + computeDerivative(x0) * (x1 - x0) / 3, computeSine(x1) - computeDerivative(x1) * (x1 - x0) / 3, computeSine(x1)]; // Zip and scale

      return ___default["default"].map(___default["default"].zip(xCoords, yCoords), scalePoint);
    }; // How many quarter-periods do we need to span the graph?


    const extent = xRange[1] - xRange[0];
    const numQuarterPeriods = Math.ceil(extent / quarterPeriod) + 1; // Find starting coordinate: first anchor point curve left of xRange[0]

    let initial = c / b;
    const distToEdge = initial - xRange[0];
    initial -= quarterPeriod * Math.ceil(distToEdge / quarterPeriod); // First portion of path is special-case, requiring move-to ('M')

    let coords = coordsForOffset(initial, 0);
    let path = "M" + coords[0][0] + "," + coords[0][1] + " C" + coords[1][0] + "," + coords[1][1] + " " + coords[2][0] + "," + coords[2][1] + " " + coords[3][0] + "," + coords[3][1];

    for (let i = 1; i < numQuarterPeriods; i++) {
      coords = coordsForOffset(initial, i);
      path += " C" + coords[1][0] + "," + coords[1][1] + " " + coords[2][0] + "," + coords[2][1] + " " + coords[3][0] + "," + coords[3][1];
    }

    return path;
  }; // `svgPath` is independent of graphie range, so we export it independently


  GraphUtils.svgPath = svgPath;

  const processAttributes = function (attrs) {
    const transformers = {
      scale: function (scale) {
        if (typeof scale === "number") {
          scale = [scale, scale];
        }

        xScale = scale[0];
        yScale = scale[1]; // Update the canvas size

        raphael$1.setSize((xRange[1] - xRange[0]) * xScale, (yRange[1] - yRange[0]) * yScale);
      },
      clipRect: function (pair) {
        const point = pair[0];
        const size = pair[1];
        point[1] += size[1]; // because our coordinates are flipped

        return {
          "clip-rect": scalePoint(point).concat(scaleVector(size)).join(" ")
        };
      },
      strokeWidth: function (val) {
        return {
          "stroke-width": parseFloat(val)
        };
      },
      rx: function (val) {
        return {
          rx: scaleVector([val, 0])[0]
        };
      },
      ry: function (val) {
        return {
          ry: scaleVector([0, val])[1]
        };
      },
      r: function (val) {
        const scaled = scaleVector([val, val]);
        return {
          rx: scaled[0],
          ry: scaled[1]
        };
      }
    };
    const processed = {};
    $__default["default"].each(attrs || {}, function (key, value) {
      const transformer = transformers[key];

      if (typeof transformer === "function") {
        $__default["default"].extend(processed, transformer(value));
      } else {
        const dasherized = key.replace(/([A-Z]+)([A-Z][a-z])/g, "$1-$2").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
        processed[dasherized] = value;
      }
    });
    return processed;
  };

  const addArrowheads = function arrows(path) {
    const type = path.constructor.prototype;

    if (type === raphael.exports.el) {
      if (path.type === "path" && typeof path.arrowheadsDrawn === "undefined") {
        const w = path.attr("stroke-width");
        const s = 0.6 + 0.4 * w;
        const l = path.getTotalLength();
        const set = raphael$1.set();
        const head = raphael$1.path(graphie.isMobile ? "M-4,4 C-4,4 -0.25,0 -0.25,0 C-0.25,0 -4,-4 -4,-4" : "M-3 4 C-2.75 2.5 0 0.25 0.75 0C0 -0.25 -2.75 -2.5 -3 -4");
        const end = path.getPointAtLength(l - 0.4);
        const almostTheEnd = path.getPointAtLength(l - 0.75 * s);
        const angle = Math.atan2(end.y - almostTheEnd.y, end.x - almostTheEnd.x) * 180 / Math.PI;
        const attrs = path.attr();
        delete attrs.path;
        let subpath = path.getSubpath(0, l - 0.75 * s);
        subpath = raphael$1.path(subpath).attr(attrs);
        subpath.arrowheadsDrawn = true;
        path.remove(); // For some unknown reason 0 doesn't work for the rotation
        // origin so we use a tiny number.

        head.rotate(angle, graphie.isMobile ? 1e-5 : 0.75, 0).scale(s, s, 0.75, 0).translate(almostTheEnd.x, almostTheEnd.y).attr(attrs).attr({
          "stroke-linejoin": "round",
          "stroke-linecap": "round"
        });
        head.arrowheadsDrawn = true;
        set.push(subpath);
        set.push(head);
        return set;
      }
    } else if (type === raphael.exports.st) {
      for (let i = 0, l = path.items.length; i < l; i++) {
        arrows(path.items[i]);
      }
    }

    return path;
  };

  const drawingTools = {
    circle: function (center, radius) {
      return raphael$1.ellipse(...scalePoint(center).concat(scaleVector([radius, radius])));
    },
    // (x, y) is coordinate of bottom left corner
    rect: function (x, y, width, height) {
      // Raphael needs (x, y) to be coordinate of upper left corner
      const corner = scalePoint([x, y + height]);
      const dims = scaleVector([width, height]);
      const elem = raphael$1.rect(...corner.concat(dims));

      if (graphie.isMobile) {
        elem.node.style.shapeRendering = "crispEdges";
      }

      return elem;
    },
    ellipse: function (center, radii) {
      return raphael$1.ellipse(...scalePoint(center).concat(scaleVector(radii)));
    },
    fixedEllipse: function (center, // Different type than Coord, this is radiusX, radiusY
    radii, maxScale, padding) {
      // Scale point and radius
      const scaledPoint = scalePoint(center);
      const scaledRadii = scaleVector(radii);
      const width = 2 * scaledRadii[0] * maxScale + padding;
      const height = 2 * scaledRadii[1] * maxScale + padding; // Calculate absolute left, top

      const left = scaledPoint[0] - width / 2;
      const top = scaledPoint[1] - height / 2; // Wrap in <div>

      const wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px"
      }); // wrapper.setAttribute("data-graphie-type", "ellipse");
      // Create Raphael canvas

      const localRaphael = raphael.exports(wrapper, width, height);
      const visibleShape = localRaphael.ellipse(width / 2, height / 2, scaledRadii[0], scaledRadii[1]);
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    arc: function (center, radius, startAngle, endAngle, sector) {
      startAngle = (startAngle % 360 + 360) % 360;
      endAngle = (endAngle % 360 + 360) % 360;
      const cent = scalePoint(center);
      const radii = scaleVector(radius);
      const startVector = polar(radius, startAngle);
      const endVector = polar(radius, endAngle);
      const startPoint = scalePoint([center[0] + startVector[0], center[1] + startVector[1]]);
      const endPoint = scalePoint([center[0] + endVector[0], center[1] + endVector[1]]);
      const largeAngle = ((endAngle - startAngle) % 360 + 360) % 360 > 180;
      return raphael$1.path("M" + startPoint.join(" ") + "A" + radii.join(" ") + " 0 " + ( // ellipse rotation
      largeAngle ? 1 : 0) + " 0 " + // sweep flag
      endPoint.join(" ") + (sector ? "L" + cent.join(" ") + "z" : ""));
    },
    path: function (points) {
      const p = raphael$1.path(svgPath(points));
      p.graphiePath = points;
      return p;
    },
    fixedPath: function (points, center, createPath) {
      points = ___default["default"].map(points, scalePoint);
      center = center ? scalePoint(center) : null;
      createPath = createPath || svgPath;

      const pathLeft = ___default["default"].min(___default["default"].pluck(points, 0));

      const pathRight = ___default["default"].max(___default["default"].pluck(points, 0));

      const pathTop = ___default["default"].min(___default["default"].pluck(points, 1));

      const pathBottom = ___default["default"].max(___default["default"].pluck(points, 1)); // Apply padding to line


      const padding = [4, 4]; // Calculate and apply additional offset

      const extraOffset = [pathLeft, pathTop]; // Apply padding and offset to points

      points = ___default["default"].map(points, function (point) {
        return kmath.vector.add(kmath.vector.subtract(point, extraOffset), kmath.vector.scale(padding, 0.5));
      }); // Calculate <div> dimensions

      const width = pathRight - pathLeft + padding[0];
      const height = pathBottom - pathTop + padding[1];
      const left = extraOffset[0] - padding[0] / 2;
      const top = extraOffset[1] - padding[1] / 2; // Create <div>

      const wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px",
        // If user specified a center, set it
        transformOrigin: center ? width / 2 + center[0] + "px " + (height / 2 + center[1]) + "px" : null
      }); // Create Raphael canvas

      const localRaphael = raphael.exports(wrapper, width, height); // Calculate path

      const visibleShape = localRaphael.path(createPath(points));
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    scaledPath: function (points) {
      const p = raphael$1.path(svgPath(points,
      /* alreadyScaled */
      true));
      p.graphiePath = points;
      return p;
    },
    line: function (start, end) {
      const l = this.path([start, end]);

      if (graphie.isMobile) {
        l.node.style.shapeRendering = "crispEdges";
      }

      return l;
    },
    parabola: function (a, b, c) {
      // Plot a parabola of the form: f(x) = (a * x + b) * x + c
      return raphael$1.path(svgParabolaPath(a, b, c));
    },
    fixedLine: function (start, end, thickness) {
      // Apply padding to line
      const padding = [thickness, thickness]; // Scale points to get values in pixels

      start = scalePoint(start);
      end = scalePoint(end); // Calculate and apply additional offset

      const extraOffset = [Math.min(start[0], end[0]), Math.min(start[1], end[1])]; // Apply padding and offset to start, end points

      start = kmath.vector.add(kmath.vector.subtract(start, extraOffset), kmath.vector.scale(padding, 0.5));
      end = kmath.vector.add(kmath.vector.subtract(end, extraOffset), kmath.vector.scale(padding, 0.5)); // Calculate <div> dimensions

      const left = extraOffset[0] - padding[0] / 2;
      const top = extraOffset[1] - padding[1] / 2;
      const width = Math.abs(start[0] - end[0]) + padding[0];
      const height = Math.abs(start[1] - end[1]) + padding[1]; // Create <div>

      const wrapper = document.createElement("div");
      $__default["default"](wrapper).css({
        position: "absolute",
        width: width + "px",
        height: height + "px",
        left: left + "px",
        top: top + "px",
        // Outsiders should feel like the line's 'origin' (i.e., for
        // rotation) is the starting point
        transformOrigin: start[0] + "px " + start[1] + "px"
      }); // Create Raphael canvas

      const localRaphael = raphael.exports(wrapper, width, height); // Calculate path

      const path = "M" + start[0] + " " + start[1] + " " + "L" + end[0] + " " + end[1];
      const visibleShape = localRaphael.path(path);
      visibleShape.graphiePath = [start, end];
      return {
        wrapper: wrapper,
        visibleShape: visibleShape
      };
    },
    sinusoid: function (a, b, c, d) {
      // Plot a sinusoid of the form: f(x) = a * sin(b * x - c) + d
      return raphael$1.path(svgSinusoidPath(a, b, c, d));
    },
    grid: function (xr, yr) {
      const step = currentStyle.step || [1, 1];
      const set = raphael$1.set();
      let x = step[0] * Math.ceil(xr[0] / step[0]);

      for (; x <= xr[1]; x += step[0]) {
        set.push(this.line([x, yr[0]], [x, yr[1]]));
      }

      let y = step[1] * Math.ceil(yr[0] / step[1]);

      for (; y <= yr[1]; y += step[1]) {
        set.push(this.line([xr[0], y], [xr[1], y]));
      }

      return set;
    },
    label: function (point, text, direction, latex) {
      latex = typeof latex === "undefined" || latex;
      const $span = $__default["default"]("<span>").addClass("graphie-label");
      const pad = currentStyle["label-distance"];
      $span.css($__default["default"].extend({}, {
        position: "absolute",
        padding: (pad != null ? pad : 7) + "px",
        color: "black"
      })).data("labelDirection", direction).appendTo(el);

      $span.setPosition = function (point) {
        const scaledPoint = scalePoint(point);
        $span.css({
          left: scaledPoint[0],
          top: scaledPoint[1]
        });
      };

      $span.setPosition(point);
      const span = $span[0];

      $span.processMath = function (math, force) {
        processMath$1(span, math, force, function () {
          const width = span.scrollWidth;
          const height = span.scrollHeight;
          setLabelMargins(span, [width, height]);
        });
      };

      $span.processText = function (text) {
        $span.html(text);
        const width = span.scrollWidth;
        const height = span.scrollHeight;
        setLabelMargins(span, [width, height]);
      };

      if (latex) {
        $span.processMath(text,
        /* force */
        false);
      } else {
        $span.processText(text);
      }

      return $span;
    },
    plotParametric: function (fn, range, shade, fn2) {
      // Note: fn2 should only be set if 'shade' is true, as it denotes
      // the function between which fn should have its area shaded.
      // In general, plotParametric shouldn't be used to shade the area
      // between two arbitrary parametrics functions over an interval,
      // as the method assumes that fn and fn2 are both of the form
      // fn(t) = (t, fn'(t)) for some initial fn'.
      fn2 = fn2 || function (t) {
        return [t, 0];
      }; // We truncate to 500,000, since anything bigger causes
      // overflow in the firefox svg renderer.  This is safe
      // since 500,000 is outside the viewport anyway.  We
      // write these functions the way we do to handle undefined.


      const clipper = xy => {
        if (Math.abs(xy[1]) > 500000) {
          return [xy[0], Math.min(Math.max(xy[1], -500000), 500000)];
        }

        return xy;
      };

      const clippedFn = x => clipper(fn(x));

      const clippedFn2 = x => clipper(fn2(x));

      if (!currentStyle.strokeLinejoin) {
        currentStyle.strokeLinejoin = "round";
      }

      if (!currentStyle.strokeLinecap) {
        currentStyle.strokeLinecap = "round";
      }

      const min = range[0];
      const max = range[1];
      let step = (max - min) / (currentStyle["plot-points"] || 800);

      if (step === 0) {
        step = 1;
      }

      const paths = raphael$1.set();
      let points = [];
      let lastDiff = GraphUtils.coordDiff(clippedFn(min), clippedFn2(min));
      let lastFlip = min;

      for (let t = min; t <= max; t += step) {
        const top = clippedFn(t);
        const bottom = clippedFn2(t);
        const diff = GraphUtils.coordDiff(top, bottom); // Find points where it flips
        // Create path that sketches area between the two functions

        if ( // if there is an asymptote here, meaning that the graph
        // switches signs and has a large difference
        diff[1] < 0 !== lastDiff[1] < 0 && Math.abs(diff[1] - lastDiff[1]) > 2 * yScale || // or the function is undefined
        isNaN(diff[1])) {
          // split the path at this point, and draw it
          if (shade) {
            points.push(top); // backtrack to draw paired function

            for (let u = t - step; u >= lastFlip; u -= step) {
              points.push(clippedFn2(u));
            }

            lastFlip = t;
          }

          paths.push(this.path(points)); // restart the path, excluding this point

          points = [];

          if (shade) {
            points.push(top);
          }
        } else {
          // otherwise, just add the point to the path
          points.push(top);
        }

        lastDiff = diff;
      }

      if (shade) {
        // backtrack to draw paired function
        for (let u = max - step; u >= lastFlip; u -= step) {
          points.push(clippedFn2(u));
        }
      }

      paths.push(this.path(points));
      return paths;
    },
    plotPolar: function (fn, range) {
      const min = range[0];
      const max = range[1]; // There is probably a better heuristic for this

      if (!currentStyle["plot-points"]) {
        currentStyle["plot-points"] = 2 * (max - min) * xScale;
      }

      return this.plotParametric(function (th) {
        return polar(fn(th), th * 180 / Math.PI);
      }, range);
    },
    plot: function (fn, range, swapAxes, shade, fn2) {
      const min = range[0];
      const max = range[1];

      if (!currentStyle["plot-points"]) {
        currentStyle["plot-points"] = 2 * (max - min) * xScale;
      }

      if (swapAxes) {
        if (fn2) {
          // TODO(charlie): support swapped axis area shading
          throw new PerseusError("Can't shade area between functions with swapped axes.", Errors.Internal);
        }

        return this.plotParametric(function (y) {
          return [fn(y), y];
        }, range, shade);
      }

      if (fn2) {
        if (shade) {
          return this.plotParametric(function (x) {
            return [x, fn(x)];
          }, range, shade, function (x) {
            return [x, fn2(x)];
          });
        }

        throw new PerseusError("fn2 should only be set when 'shade' is True.", Errors.Internal);
      }

      return this.plotParametric(function (x) {
        return [x, fn(x)];
      }, range, shade);
    },

    /**
     * Given a piecewise function, return a Raphael set of paths that
     * can be used to draw the function, e.g. using style().
     * Calls plotParametric.
     *
     * @param  {[]} fnArray    array of functions which when called
     *                         with a parameter i return the value of
     *                         the function at i
     * @param  {[]} rangeArray array of ranges over which the
     *                         corresponding functions are defined
     * @return {Raphael set}
     */
    plotPiecewise: function (fnArray, rangeArray) {
      const paths = raphael$1.set();
      const self = this;

      ___default["default"].times(fnArray.length, function (i) {
        const fn = fnArray[i];
        const range = rangeArray[i];
        const fnPaths = self.plotParametric(function (x) {
          return [x, fn(x)];
        }, range);

        ___default["default"].each(fnPaths, function (fnPath) {
          paths.push(fnPath);
        });
      });

      return paths;
    },

    /**
     * Given an array of coordinates of the form [x, y], create and
     * return a Raphael set of Raphael circle objects at those
     * coordinates
     *
     * @param  {Array of arrays} endpointArray
     * @return {Raphael set}
     */
    plotEndpointCircles: function (endpointArray) {
      const circles = raphael$1.set();
      const self = this;

      ___default["default"].each(endpointArray, function (coord, i) {
        circles.push(self.circle(coord, 0.15));
      });

      return circles;
    },
    plotAsymptotes: function (fn, range) {
      const min = range[0];
      const max = range[1];
      const step = (max - min) / (currentStyle["plot-points"] || 800);
      const asymptotes = raphael$1.set();
      let lastVal = fn(min);

      for (let t = min; t <= max; t += step) {
        const funcVal = fn(t);

        if (funcVal < 0 !== lastVal < 0 && Math.abs(funcVal - lastVal) > 2 * yScale) {
          asymptotes.push(this.line([t, yScale], [t, -yScale]));
        }

        lastVal = funcVal;
      }

      return asymptotes;
    }
  }; // $FlowFixMe[invalid-constructor]

  const graphie = new Graphie$1();

  ___default["default"].extend(graphie, {
    raphael: raphael$1,
    init: function (options) {
      let scale = options.scale || [40, 40];
      scale = typeof scale === "number" ? [scale, scale] : scale;
      xScale = scale[0];
      yScale = scale[1];

      if (options.range == null) {
        throw new PerseusError("range should be specified in graph init", Errors.Internal);
      }

      xRange = options.range[0];
      yRange = options.range[1];
      const w = (xRange[1] - xRange[0]) * xScale;
      const h = (yRange[1] - yRange[0]) * yScale;
      raphael$1.setSize(w, h);
      $__default["default"](el).css({
        width: w,
        height: h
      });
      this.range = options.range;
      this.scale = scale;
      this.dimensions = [w, h];
      this.xpixels = w;
      this.ypixels = h;
      this.isMobile = options.isMobile;
      return this;
    },
    style: function (attrs, fn) {
      const processed = processAttributes(attrs);

      if (typeof fn === "function") {
        const oldStyle = currentStyle;
        currentStyle = $__default["default"].extend({}, currentStyle, processed);
        const result = fn.call(graphie);
        currentStyle = oldStyle;
        return result;
      }

      $__default["default"].extend(currentStyle, processed);
    },
    scalePoint: scalePoint,
    scaleVector: scaleVector,
    unscalePoint: unscalePoint,
    unscaleVector: unscaleVector,
    // Custom SVG path functions that are dependent on graphie range
    // `svgPath`, while independent of range, is exported for consistency
    svgPath: svgPath,
    svgParabolaPath: svgParabolaPath,
    svgSinusoidPath: svgSinusoidPath
  });

  $__default["default"].each(drawingTools, function (name) {
    graphie[name] = function () {
      const last = arguments[arguments.length - 1];
      const oldStyle = currentStyle;
      let result; // The last argument is probably trying to change the style

      if (typeof last === "object" && !___default["default"].isArray(last)) {
        currentStyle = { ...currentStyle,
          ...processAttributes(last)
        }; // $FlowFixMe[method-unbinding]

        const rest = [].slice.call(arguments, 0, arguments.length - 1);
        result = drawingTools[name](...rest);
      } else {
        currentStyle = $__default["default"].extend({}, currentStyle);
        result = drawingTools[name](...arguments);
      } // Bad heuristic for recognizing Raphael elements and sets


      const type = result.constructor.prototype;

      if (type === raphael.exports.el || type === raphael.exports.st) {
        result.attr(currentStyle);

        if (currentStyle.arrows) {
          result = addArrowheads(result);
        }
      } else if (result instanceof $__default["default"]) {
        // We assume that if it's not a Raphael element/set, it
        // does not contain SVG.
        result.css({ ...currentStyle,
          ...SVG_SPECIFIC_STYLE_MASK
        });
      }

      currentStyle = oldStyle;
      return result;
    };
  }); // Initializes graphie settings for a graph and draws the basic graph
  // features (axes, grid, tick marks, and axis labels)
  // Options expected are:
  // - range: [[a, b], [c, d]] or [a, b]
  // - scale: [a, b] or number
  // - gridOpacity: number (0 - 1)
  // - gridStep: [a, b] or number (relative to units)
  // - tickStep: [a, b] or number (relative to grid steps)
  // - tickLen: [a, b] or number (in pixels)
  // - labelStep: [a, b] or number (relative to tick steps)
  // - yLabelFormat: fn to format label string for y-axis
  // - xLabelFormat: fn to format label string for x-axis
  // - smartLabelPositioning: true or false to ignore minus sign

  graphie.graphInit = function (options) {
    options = options || {};
    $__default["default"].each(options, function (prop, val) {
      // allow options to be specified by a single number for shorthand if
      // the horizontal and vertical components are the same
      if (!prop.match(/.*Opacity$/) && prop !== "range" && typeof val === "number") {
        options[prop] = [val, val];
      } // allow symmetric ranges to be specified by the absolute values


      if (prop === "range" || prop === "gridRange") {
        if (val.constructor === Array) {
          // but don't mandate symmetric ranges
          if (val[0].constructor !== Array) {
            options[prop] = [[-val[0], val[0]], [-val[1], val[1]]];
          }
        } else if (typeof val === "number") {
          options[prop] = [[-val, val], [-val, val]];
        }
      }
    });
    const range = options.range || [[-10, 10], [-10, 10]];
    const gridRange = options.gridRange || options.range;
    const scale = options.scale || [20, 20];
    const grid = options.grid != null ? options.grid : true;
    const gridOpacity = options.gridOpacity || 0.1;
    const gridStep = options.gridStep || [1, 1];
    const axes = options.axes != null ? options.axes : true;
    const axisArrows = options.axisArrows || "";
    const axisOpacity = options.axisOpacity || 1.0;
    const axisCenter = options.axisCenter || [Math.min(Math.max(range[0][0], 0), range[0][1]), Math.min(Math.max(range[1][0], 0), range[1][1])];
    const axisLabels = options.axisLabels != null ? options.axisLabels : false;
    const ticks = options.ticks != null ? options.ticks : true;
    const tickStep = options.tickStep || [2, 2];
    const tickLen = options.tickLen || [5, 5];
    const tickOpacity = options.tickOpacity || 1.0;
    const labels = options.labels || options.labelStep || false;
    const labelStep = options.labelStep || [1, 1];
    const labelOpacity = options.labelOpacity || 1.0;
    let unityLabels = options.unityLabels || false;

    const labelFormat = options.labelFormat || function (a) {
      return a;
    };

    let xLabelFormat = options.xLabelFormat || labelFormat;
    let yLabelFormat = options.yLabelFormat || labelFormat;
    const smartLabelPositioning = options.smartLabelPositioning != null ? options.smartLabelPositioning : true;
    const realRange = [[range[0][0] - (range[0][0] > 0 ? 1 : 0), range[0][1] + (range[0][1] < 0 ? 1 : 0)], [range[1][0] - (range[1][0] > 0 ? 1 : 0), range[1][1] + (range[1][1] < 0 ? 1 : 0)]];

    if (!___default["default"].isArray(unityLabels)) {
      unityLabels = [unityLabels, unityLabels];
    }

    if (smartLabelPositioning) {
      const minusIgnorer = function (lf) {
        return function (a) {
          return (lf(a) + "").replace(/-(\d)/g, "\\llap{-}$1");
        };
      };

      xLabelFormat = minusIgnorer(xLabelFormat);
      yLabelFormat = minusIgnorer(yLabelFormat);
    }

    this.init({
      range: realRange,
      scale: scale,
      isMobile: options.isMobile
    }); // draw grid

    if (grid) {
      this.grid(gridRange[0], gridRange[1], {
        stroke: options.isMobile ? KhanColors.GRAY_C : "#000000",
        opacity: options.isMobile ? 1 : gridOpacity,
        step: gridStep,
        strokeWidth: options.isMobile ? 1 : 2
      });
    } // draw axes


    if (axes) {
      // this is a slight hack until <-> arrowheads work
      if (axisArrows === "<->" || axisArrows === true) {
        this.style({
          stroke: options.isMobile ? KhanColors.GRAY_G : "#000000",
          opacity: options.isMobile ? 1 : axisOpacity,
          strokeWidth: options.isMobile ? 1 : 2,
          arrows: "->"
        }, function () {
          if (range[1][0] < 0 && range[1][1] > 0) {
            this.path([axisCenter, [gridRange[0][0], axisCenter[1]]]);
            this.path([axisCenter, [gridRange[0][1], axisCenter[1]]]);
          }

          if (range[0][0] < 0 && range[0][1] > 0) {
            this.path([axisCenter, [axisCenter[0], gridRange[1][0]]]);
            this.path([axisCenter, [axisCenter[0], gridRange[1][1]]]);
          }
        }); // also, we don't support "<-" arrows yet, but why you
        // would want that on your graph is beyond me.
      } else if (axisArrows === "->" || axisArrows === "") {
        this.style({
          stroke: "#000000",
          opacity: axisOpacity,
          strokeWidth: 2,
          arrows: axisArrows
        }, function () {
          this.path([[gridRange[0][0], axisCenter[1]], [gridRange[0][1], axisCenter[1]]]);
          this.path([[axisCenter[0], gridRange[1][0]], [axisCenter[0], gridRange[1][1]]]);
        });
      }

      if (axisLabels && axisLabels.length === 2) {
        this.label([gridRange[0][1], axisCenter[1]], axisLabels[0], "right");
        this.label([axisCenter[0], gridRange[1][1]], axisLabels[1], "above");
      }
    } // draw tick marks


    if (ticks) {
      const halfWidthTicks = options.isMobile;
      this.style({
        stroke: options.isMobile ? KhanColors.GRAY_G : "#000000",
        opacity: options.isMobile ? 1 : tickOpacity,
        strokeWidth: 1
      }, function () {
        // horizontal axis
        let step = gridStep[0] * tickStep[0];
        let len = tickLen[0] / scale[1];
        let start = gridRange[0][0];
        let stop = gridRange[0][1];

        if (range[1][0] < 0 && range[1][1] > 0) {
          for (let x = step + axisCenter[0]; x <= stop; x += step) {
            if (x < stop || !axisArrows) {
              this.line([x, -len + axisCenter[1]], [x, halfWidthTicks ? 0 : len + axisCenter[1]]);
            }
          }

          for (let x = -step + axisCenter[0]; x >= start; x -= step) {
            if (x > start || !axisArrows) {
              this.line([x, -len + axisCenter[1]], [x, halfWidthTicks ? 0 : len + axisCenter[1]]);
            }
          }
        } // vertical axis


        step = gridStep[1] * tickStep[1];
        len = tickLen[1] / scale[0];
        start = gridRange[1][0];
        stop = gridRange[1][1];

        if (range[0][0] < 0 && range[0][1] > 0) {
          for (let y = step + axisCenter[1]; y <= stop; y += step) {
            if (y < stop || !axisArrows) {
              this.line([-len + axisCenter[0], y], [halfWidthTicks ? 0 : len + axisCenter[0], y]);
            }
          }

          for (let y = -step + axisCenter[1]; y >= start; y -= step) {
            if (y > start || !axisArrows) {
              this.line([-len + axisCenter[0], y], [halfWidthTicks ? 0 : len + axisCenter[0], y]);
            }
          }
        }
      });
    } // draw axis labels


    if (labels) {
      this.style({
        stroke: options.isMobile ? KhanColors.GRAY_G : "#000000",
        opacity: options.isMobile ? 1 : labelOpacity
      }, function () {
        // horizontal axis
        let step = gridStep[0] * tickStep[0] * labelStep[0];
        let start = gridRange[0][0];
        let stop = gridRange[0][1];
        const xAxisPosition = axisCenter[0] < 0 ? "above" : "below";
        const yAxisPosition = axisCenter[0] < 0 ? "right" : "left";
        const xShowZero = axisCenter[0] === 0 && axisCenter[1] !== 0;
        const yShowZero = axisCenter[0] !== 0 && axisCenter[1] === 0;
        const axisOffCenter = axisCenter[0] !== 0 || axisCenter[1] !== 0;
        const showUnityX = unityLabels[0] || axisOffCenter;
        const showUnityY = unityLabels[1] || axisOffCenter; // positive x-axis

        for (let x = (xShowZero ? 0 : step) + axisCenter[0]; x <= stop; x += step) {
          if (x < stop || !axisArrows) {
            this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
          }
        } // negative x-axis


        for (let x = -step * (showUnityX ? 1 : 2) + axisCenter[0]; x >= start; x -= step) {
          if (x > start || !axisArrows) {
            this.label([x, axisCenter[1]], xLabelFormat(x), xAxisPosition);
          }
        }

        step = gridStep[1] * tickStep[1] * labelStep[1];
        start = gridRange[1][0];
        stop = gridRange[1][1]; // positive y-axis

        for (let y = (yShowZero ? 0 : step) + axisCenter[1]; y <= stop; y += step) {
          if (y < stop || !axisArrows) {
            this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
          }
        } // negative y-axis


        for (let y = -step * (showUnityY ? 1 : 2) + axisCenter[1]; y >= start; y -= step) {
          if (y > start || !axisArrows) {
            this.label([axisCenter[0], y], yLabelFormat(y), yAxisPosition);
          }
        }
      });
    }
  };

  return graphie;
};

/* eslint-disable */

(function ($, window, document, undefined$1) {
  if (typeof $ === "undefined") {
    return;
  }

  var dataPropertyName = "virtualMouseBindings",
      touchTargetPropertyName = "virtualTouchID",
      virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split(" "),
      touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "),
      mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
      mouseEventProps = $.event.props.concat(mouseHookProps),
      activeDocHandlers = {},
      resetTimerID = 0,
      startX = 0,
      startY = 0,
      didScroll = false,
      clickBlockList = [],
      blockMouseTriggers = false,
      blockTouchTriggers = false,
      eventCaptureSupported = ("addEventListener" in document),
      $document = $(document),
      nextTouchID = 1,
      lastTouchID = 0;
  $.vmouse = {
    moveDistanceThreshold: 10,
    clickDistanceThreshold: 10,
    resetTimerDuration: 1500
  };

  function getNativeEvent(event) {
    while (event && typeof event.originalEvent !== "undefined") {
      event = event.originalEvent;
    }

    return event;
  }

  function createVirtualEvent(event, eventType) {
    var t = event.type,
        oe,
        props,
        ne,
        prop,
        ct,
        touch,
        i,
        j,
        len;
    event = $.Event(event);
    event.type = eventType;
    oe = event.originalEvent;
    props = $.event.props; // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
    // https://github.com/jquery/jquery-mobile/issues/3280

    if (t.search(/mouse/) > -1) {
      props = mouseEventProps;
    } // copy original event properties over to the new event
    // this would happen if we could call $.event.fix instead of $.Event
    // but we don't have a way to force an event to be fixed multiple times


    if (oe) {
      for (i = props.length, prop; i;) {
        prop = props[--i];
        event[prop] = oe[prop];
      }
    } // make sure that if the mouse and click virtual events are generated
    // without a .which one is defined


    if (t.search(/mouse(down|up)|click/) > -1 && !event.which) {
      event.which = 1;
    }

    if (t.search(/^touch/) !== -1) {
      ne = getNativeEvent(oe);
      t = ne.touches;
      ct = ne.changedTouches;
      touch = t && t.length ? t[0] : ct && ct.length ? ct[0] : undefined$1;

      if (touch) {
        for (j = 0, len = touchEventProps.length; j < len; j++) {
          prop = touchEventProps[j];
          event[prop] = touch[prop];
        }
      }
    }

    return event;
  }

  function getVirtualBindingFlags(element) {
    var flags = {},
        b,
        k;

    while (element) {
      b = $.data(element, dataPropertyName);

      for (k in b) {
        if (b[k]) {
          flags[k] = flags.hasVirtualBinding = true;
        }
      }

      element = element.parentNode;
    }

    return flags;
  }

  function getClosestElementWithVirtualBinding(element, eventType) {
    var b;

    while (element) {
      b = $.data(element, dataPropertyName);

      if (b && (!eventType || b[eventType])) {
        return element;
      }

      element = element.parentNode;
    }

    return null;
  }

  function enableTouchBindings() {
    blockTouchTriggers = false;
  }

  function disableTouchBindings() {
    blockTouchTriggers = true;
  }

  function enableMouseBindings() {
    lastTouchID = 0;
    clickBlockList.length = 0;
    blockMouseTriggers = false; // When mouse bindings are enabled, our
    // touch bindings are disabled.

    disableTouchBindings();
  }

  function disableMouseBindings() {
    // When mouse bindings are disabled, our
    // touch bindings are enabled.
    enableTouchBindings();
  }

  function startResetTimer() {
    clearResetTimer();
    resetTimerID = setTimeout(function () {
      resetTimerID = 0;
      enableMouseBindings();
    }, $.vmouse.resetTimerDuration);
  }

  function clearResetTimer() {
    if (resetTimerID) {
      clearTimeout(resetTimerID);
      resetTimerID = 0;
    }
  }

  function triggerVirtualEvent(eventType, event, flags) {
    var ve;

    if (flags && flags[eventType] || !flags && getClosestElementWithVirtualBinding(event.target, eventType)) {
      ve = createVirtualEvent(event, eventType);
      $(event.target).trigger(ve);
    }

    return ve;
  }

  function mouseEventCallback(event) {
    var touchID = $.data(event.target, touchTargetPropertyName);

    if (!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
      var ve = triggerVirtualEvent("v" + event.type, event);

      if (ve) {
        if (ve.isDefaultPrevented()) {
          event.preventDefault();
        }

        if (ve.isPropagationStopped()) {
          event.stopPropagation();
        }

        if (ve.isImmediatePropagationStopped()) {
          event.stopImmediatePropagation();
        }
      }
    }
  }

  function handleTouchStart(event) {
    var touches = getNativeEvent(event).touches,
        target,
        flags;

    if (touches && touches.length === 1) {
      target = event.target;
      flags = getVirtualBindingFlags(target);

      if (flags.hasVirtualBinding) {
        lastTouchID = nextTouchID++;
        $.data(target, touchTargetPropertyName, lastTouchID);
        clearResetTimer();
        disableMouseBindings();
        didScroll = false;
        var t = getNativeEvent(event).touches[0];
        startX = t.pageX;
        startY = t.pageY;
        triggerVirtualEvent("vmouseover", event, flags);
        triggerVirtualEvent("vmousedown", event, flags);
      }
    }
  }

  function handleScroll(event) {
    if (blockTouchTriggers) {
      return;
    }

    if (!didScroll) {
      triggerVirtualEvent("vmousecancel", event, getVirtualBindingFlags(event.target));
    }

    didScroll = true;
    startResetTimer();
  }

  function handleTouchMove(event) {
    if (blockTouchTriggers) {
      return;
    }

    var t = getNativeEvent(event).touches[0],
        didCancel = didScroll,
        moveThreshold = $.vmouse.moveDistanceThreshold,
        didScroll = didScroll || Math.abs(t.pageX - startX) > moveThreshold || Math.abs(t.pageY - startY) > moveThreshold,
        flags = getVirtualBindingFlags(event.target);

    if (didScroll && !didCancel) {
      triggerVirtualEvent("vmousecancel", event, flags);
    }

    triggerVirtualEvent("vmousemove", event, flags);
    startResetTimer();
  }

  function handleTouchEnd(event) {
    if (blockTouchTriggers) {
      return;
    }

    disableTouchBindings();
    var flags = getVirtualBindingFlags(event.target),
        t;
    triggerVirtualEvent("vmouseup", event, flags);

    if (!didScroll) {
      var ve = triggerVirtualEvent("vclick", event, flags);

      if (ve && ve.isDefaultPrevented()) {
        // The target of the mouse events that follow the touchend
        // event don't necessarily match the target used during the
        // touch. This means we need to rely on coordinates for blocking
        // any click that is generated.
        t = getNativeEvent(event).changedTouches[0];
        clickBlockList.push({
          touchID: lastTouchID,
          x: t.clientX,
          y: t.clientY
        }); // Prevent any mouse events that follow from triggering
        // virtual event notifications.

        blockMouseTriggers = true;
      }
    }

    triggerVirtualEvent("vmouseout", event, flags);
    didScroll = false;
    startResetTimer();
  }

  function hasVirtualBindings(ele) {
    var bindings = $.data(ele, dataPropertyName),
        k;

    if (bindings) {
      for (k in bindings) {
        if (bindings[k]) {
          return true;
        }
      }
    }

    return false;
  }

  function dummyMouseHandler() {}

  function getSpecialEventObject(eventType) {
    var realType = eventType.substr(1);
    return {
      setup: function (data, namespace) {
        // If this is the first virtual mouse binding for this element,
        // add a bindings object to its data.
        if (!hasVirtualBindings(this)) {
          $.data(this, dataPropertyName, {});
        } // If setup is called, we know it is the first binding for this
        // eventType, so initialize the count for the eventType to zero.


        var bindings = $.data(this, dataPropertyName);
        bindings[eventType] = true; // If this is the first virtual mouse event for this type,
        // register a global handler on the document.

        activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;

        if (activeDocHandlers[eventType] === 1) {
          $document.bind(realType, mouseEventCallback);
        } // Some browsers, like Opera Mini, won't dispatch mouse/click events
        // for elements unless they actually have handlers registered on them.
        // To get around this, we register dummy handlers on the elements.


        $(this).bind(realType, dummyMouseHandler); // For now, if event capture is not supported, we rely on mouse handlers.

        if (eventCaptureSupported) {
          // If this is the first virtual mouse binding for the document,
          // register our touchstart handler on the document.
          activeDocHandlers["touchstart"] = (activeDocHandlers["touchstart"] || 0) + 1;

          if (activeDocHandlers["touchstart"] === 1) {
            $document.bind("touchstart", handleTouchStart).bind("touchend", handleTouchEnd) // On touch platforms, touching the screen and then dragging your finger
            // causes the window content to scroll after some distance threshold is
            // exceeded. On these platforms, a scroll prevents a click event from being
            // dispatched, and on some platforms, even the touchend is suppressed. To
            // mimic the suppression of the click event, we need to watch for a scroll
            // event. Unfortunately, some platforms like iOS don't dispatch scroll
            // events until *AFTER* the user lifts their finger (touchend). This means
            // we need to watch both scroll and touchmove events to figure out whether
            // or not a scroll happenens before the touchend event is fired.
            .bind("touchmove", handleTouchMove).bind("scroll", handleScroll);
          }
        }
      },
      teardown: function (data, namespace) {
        // If this is the last virtual binding for this eventType,
        // remove its global handler from the document.
        --activeDocHandlers[eventType];

        if (!activeDocHandlers[eventType]) {
          $document.unbind(realType, mouseEventCallback);
        }

        if (eventCaptureSupported) {
          // If this is the last virtual mouse binding in existence,
          // remove our document touchstart listener.
          --activeDocHandlers["touchstart"];

          if (!activeDocHandlers["touchstart"]) {
            $document.unbind("touchstart", handleTouchStart).unbind("touchmove", handleTouchMove).unbind("touchend", handleTouchEnd).unbind("scroll", handleScroll);
          }
        }

        var $this = $(this),
            bindings = $.data(this, dataPropertyName); // teardown may be called when an element was
        // removed from the DOM. If this is the case,
        // jQuery core may have already stripped the element
        // of any data bindings so we need to check it before
        // using it.

        if (bindings) {
          bindings[eventType] = false;
        } // Unregister the dummy event handler.


        $this.unbind(realType, dummyMouseHandler); // If this is the last virtual mouse binding on the
        // element, remove the binding data from the element.

        if (!hasVirtualBindings(this)) {
          $this.removeData(dataPropertyName);
        }
      }
    };
  } // Expose our custom events to the jQuery bind/unbind mechanism.


  for (var i = 0; i < virtualEventNames.length; i++) {
    $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
  } // Add a capture click handler to block clicks.
  // Note that we require event capture support for this so if the device
  // doesn't support it, we punt for now and rely solely on mouse events.


  if (eventCaptureSupported) {
    document.addEventListener("click", function (e) {
      var cnt = clickBlockList.length,
          target = e.target,
          x,
          y,
          ele,
          i,
          o;

      if (cnt) {
        x = e.clientX;
        y = e.clientY;
        threshold = $.vmouse.clickDistanceThreshold; // The idea here is to run through the clickBlockList to see if
        // the current click event is in the proximity of one of our
        // vclick events that had preventDefault() called on it. If we find
        // one, then we block the click.
        //
        // Why do we have to rely on proximity?
        //
        // Because the target of the touch event that triggered the vclick
        // can be different from the target of the click event synthesized
        // by the browser. The target of a mouse/click event that is syntehsized
        // from a touch event seems to be implementation specific. For example,
        // some browsers will fire mouse/click events for a link that is near
        // a touch event, even though the target of the touchstart/touchend event
        // says the user touched outside the link. Also, it seems that with most
        // browsers, the target of the mouse/click event is not calculated until the
        // time it is dispatched, so if you replace an element that you touched
        // with another element, the target of the mouse/click will be the new
        // element underneath that point.
        //
        // Aside from proximity, we also check to see if the target and any
        // of its ancestors were the ones that blocked a click. This is necessary
        // because of the strange mouse/click target calculation done in the
        // Android 2.1 browser, where if you click on an element, and there is a
        // mouse/click handler on one of its ancestors, the target will be the
        // innermost child of the touched element, even if that child is no where
        // near the point of touch.

        ele = target;

        while (ele) {
          for (i = 0; i < cnt; i++) {
            o = clickBlockList[i];

            if (ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold || $.data(ele, touchTargetPropertyName) === o.touchID) {
              // XXX: We may want to consider removing matches from the block list
              //      instead of waiting for the reset timer to fire.
              e.preventDefault();
              e.stopPropagation();
              return;
            }
          }

          ele = ele.parentNode;
        }
      }
    }, true);
  }
})($__default["default"], window, document);

/**
 * A work-in-progress of _ methods for objects.
 * That is, they take an object as a parameter,
 * and return an object instead of an array.
 *
 * TODO(aria): Move this out of interactive2
 */
/**
 * Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */

const pluck = function (table, subKey) {
  return ___default["default"].object(___default["default"].map(table, function (value, key) {
    return [key, value[subKey]];
  }));
};
/**
 * Maps an object to an object
 *
 * > mapObject({a: '1', b: '2'}, (value, key) => {
 *       return value + 1;
 *   });
 * {a: 2, b: 3}
 */


const mapObject$3 = function (obj, lambda) {
  const result = {};

  ___default["default"].each(___default["default"].keys(obj), function (key) {
    result[key] = lambda(obj[key], key);
  });

  return result;
};
/**
 * Maps an array to an object
 *
 * > mapObjectFromArray(['a', 'b'], function(elem) {
 *       return elem + elem;
 *   });
 * {a: 'aa', b: 'bb'}
 */


const mapObjectFromArray$1 = function (arr, lambda) {
  const result = {};

  ___default["default"].each(arr, function (elem) {
    result[elem] = lambda(elem);
  });

  return result;
};

var objective_ = {
  pluck: pluck,
  mapObject: mapObject$3,
  mapObjectFromArray: mapObjectFromArray$1
};

/* eslint-disable @babel/no-invalid-this */
/*
 * These functions, when called on the wrapped object, simply pass the
 * arguments to the underlying Raphael object.
 */

const PASS_TO_RAPHAEL = ["attr", "animate"];

const WrappedDefaults = ___default["default"].extend({
  transform: function (transformation) {
    const prefixedTransform = InteractiveUtil.getPrefixedTransform();
    this.wrapper.style[prefixedTransform] = transformation;
  },
  toFront: function () {
    const parentNode = this.wrapper.parentNode; // TODO(emily): Sometimes, we call `.remove()` but then hold a
    // reference to this object, and sometimes call `.toFront` on it.
    // Notably, this happens in the reflection transformation in the
    // Transformer widget. This is a hacky fix. Make this less bad.

    if (parentNode) {
      parentNode.appendChild(this.wrapper);
    }
  },
  toBack: function () {
    const parentNode = this.wrapper.parentNode;

    if (parentNode.firstChild !== this.wrapper) {
      parentNode.insertBefore(this.wrapper, parentNode.firstChild);
    }
  },
  remove: function () {
    this.visibleShape.remove();
    $__default["default"](this.wrapper).remove();
  },
  getMouseTarget: function () {
    return this.visibleShape[0];
  },
  moveTo: function (point) {
    const delta = kmath.vector.subtract(this.graphie.scalePoint(point), this.graphie.scalePoint(this.initialPoint));
    const do3dTransform = InteractiveUtil.getCanUse3dTransform();
    const transformation = "translateX(" + delta[0] + "px) " + "translateY(" + delta[1] + "px)" + (do3dTransform ? " translateZ(0)" : "");
    this.transform(transformation);
  },
  hide: function () {
    this.visibleShape.hide();
  },
  show: function () {
    this.visibleShape.show();
  }
}, objective_.mapObjectFromArray(PASS_TO_RAPHAEL, function (attribute) {
  return function () {
    this.visibleShape[attribute](...arguments);
  };
}));

const DEFAULT_OPTIONS$2 = {
  maxScale: 1,
  mouselayer: false,
  shadow: false,
  disableMouseEventsOnWrapper: false
};

const WrappedEllipse = function (graphie, center, radii, options) {
  options = ___default["default"].extend({}, DEFAULT_OPTIONS$2, options); // Add `wrapper`, `visibleShape`, and remaining properties.

  const fixedEllipse = graphie.fixedEllipse(center, radii, options.maxScale, options.padding);

  ___default["default"].extend(this, fixedEllipse, {
    graphie: graphie,
    initialPoint: center
  });

  if (options.interactiveKindForTesting) {
    this.wrapper.setAttribute("data-interactive-kind-for-testing", options.interactiveKindForTesting);
  } // Add to appropriate graphie layer


  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    this.wrapper.style.touchAction = "none";
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  }

  if (options.shadow) {
    const filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
    const wrapper = this.wrapper;
    wrapper.style.webkitFilter = filter;
    wrapper.style.filter = filter;

    this.moveTo = function (point) {
      const delta = kmath.vector.subtract(this.graphie.scalePoint(point), this.graphie.scalePoint(this.initialPoint));
      const do3dTransform = InteractiveUtil.getCanUse3dTransform();
      const transform = "translateX(" + Math.round(delta[0]) + "px) " + "translateY(" + Math.round(delta[1]) + "px)" + (do3dTransform ? " translateZ(0)" : "");
      this.transform(transform);
    };
  }

  if (options.disableMouseEventsOnWrapper) {
    this.wrapper.style.pointerEvents = "none";
    this.visibleShape.node.style.pointerEvents = "auto";
  }
};

___default["default"].extend(WrappedEllipse.prototype, WrappedDefaults);

const DEFAULT_OPTIONS$1 = {
  thickness: 2,
  mouselayer: false
};

const WrappedLine = function (graphie, start, end, options) {
  options = ___default["default"].extend({}, DEFAULT_OPTIONS$1, options); // Always make the line as large as possible and horizontal; this
  // simplifies a lot of the transforms, e.g., we can rotate by exactly the
  // angle of the argument points in `moveTo`.

  const initialStart = [graphie.range[0][0], 0];
  const initialEnd = [graphie.range[0][1], 0]; // Add `wrapper` and `visibleShape`

  ___default["default"].extend(this, graphie.fixedLine(initialStart, initialEnd, options.thickness));

  if (options.interactiveKindForTesting) {
    this.wrapper.setAttribute("data-interactive-kind-for-testing", options.interactiveKindForTesting);
  }

  this.visibleShape.attr(options.normalStyle); // Save properties for computing transformations

  ___default["default"].extend(this, {
    graphie: graphie,
    initialPoint: graphie.scalePoint(initialStart),
    initialLength: kmath.point.distanceToPoint(graphie.scalePoint(initialStart), graphie.scalePoint(initialEnd))
  }); // Add to appropriate graphie layer


  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    this.wrapper.style.touchAction = "none";
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  } // Move to argument points


  this.moveTo(start, end);
};

___default["default"].extend(WrappedLine.prototype, WrappedDefaults, {
  getMouseTarget: function () {
    return this.wrapper;
  },
  moveTo: function (start, end) {
    const scaledStart = this.graphie.scalePoint(start);
    const scaledEnd = this.graphie.scalePoint(end); // Compute transformation parameters

    const polarDiff = kmath.vector.polarDegFromCart(kmath.vector.subtract(scaledEnd, scaledStart));
    const lineLength = polarDiff[0];
    const angle = KhanMath.bound(polarDiff[1]);
    const delta = kmath.vector.subtract(scaledStart, this.initialPoint);
    const scale = KhanMath.bound(lineLength / this.initialLength); // Construct and apply transformation string

    const do3dTransform = InteractiveUtil.getCanUse3dTransform();
    const transformation = "translateX(" + delta[0] + "px) " + "translateY(" + delta[1] + "px) " + (do3dTransform ? " translateZ(0)" : "") + "rotate(" + angle + "deg) " + "scaleX(" + scale + ") scaleY(1)";
    this.transform(transformation);
  }
});

const DEFAULT_OPTIONS = {
  center: null,
  // gets ignored in `graphie.fixedPath` if `null`
  createPath: null,
  // gets defaulted in `graphie.fixedPath` if `null`
  mouselayer: false
};

const WrappedPath = function (graphie, points, options) {
  options = ___default["default"].extend({}, DEFAULT_OPTIONS, options); // Add `wrapper` and `visibleShape`

  ___default["default"].extend(this, graphie.fixedPath(points, options.center, options.createPath)); // Add remaining properties


  ___default["default"].extend(this, {
    graphie: graphie,
    initialPoint: graphie.scalePoint(___default["default"].head(points))
  }); // Add to appropriate graphie layer


  if (options.mouselayer) {
    // Disable browser handling of all panning and zooming gestures on the
    // movable wrapper so that when moved the browser does not scroll page
    this.wrapper.style.touchAction = "none";
    this.graphie.addToMouseLayerWrapper(this.wrapper);
  } else {
    this.graphie.addToVisibleLayerWrapper(this.wrapper);
  }
};

___default["default"].extend(WrappedPath.prototype, WrappedDefaults);

/* eslint-disable @babel/no-invalid-this */
const {
  getCanUse3dTransform
} = InteractiveUtil;

function sum$1(array) {
  return ___default["default"].reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}

function clockwise$1(points) {
  const segments = ___default["default"].zip(points, points.slice(1).concat(points.slice(0, 1)));

  const areas = ___default["default"].map(segments, function (segment) {
    const p1 = segment[0];
    const p2 = segment[1];
    return (p2[0] - p1[0]) * (p2[1] + p1[1]);
  });

  return sum$1(areas) > 0;
}
/* vector-add multiple [x, y] coords/vectors */


function addPoints() {
  const zipped = ___default["default"].zip(...arguments);

  return ___default["default"].map(zipped, sum$1);
}

function reverseVector(vector) {
  return ___default["default"].map(vector, function (coord) {
    return coord * -1;
  });
}

function scaledDistanceFromAngle(angle) {
  const a = 3.51470560176242 * 20;
  const b = 0.5687298702748785 * 20;
  const c = -0.037587715462826674;
  return (a - b) * Math.exp(c * angle) + b;
}

function scaledPolarRad(radius, radians) {
  return [radius * Math.cos(radians), radius * Math.sin(radians) * -1 // SVG flips y axis
  ];
}

function scaledPolarDeg(radius, degrees) {
  const radians = degrees * Math.PI / 180;
  return scaledPolarRad(radius, radians);
} // Global dragging state


let dragging = false;
const InteractiveUtils = {
  // Useful for shapes that are only sometimes drawn. If a shape isn't
  // needed, it can be replaced with bogusShape which just has stub methods
  // that successfully do nothing.
  // The alternative would be 'if..typeof' checks all over the place.
  bogusShape: {
    animate: function () {},
    attr: function () {},
    remove: function () {}
  }
};

___default["default"].extend(GraphUtils.Graphie.prototype, {
  // graphie puts text spans on top of the SVG, which looks good, but gets
  // in the way of mouse events. This adds another SVG element on top
  // of everything else where we can add invisible shapes with mouse
  // handlers wherever we want.
  addMouseLayer: function (options) {
    const graph = this;
    options = ___default["default"].extend({
      allowScratchpad: false,
      setDrawingAreaAvailable: function () {}
    }, options);
    const mouselayerZIndex = 2;
    graph.mouselayer = raphael.exports(graph.raphael.canvas.parentNode, graph.xpixels, graph.ypixels);
    $__default["default"](graph.mouselayer.canvas).css("z-index", mouselayerZIndex);

    if (options.onClick || options.onMouseDown || options.onMouseMove || options.onMouseOver || options.onMouseOut) {
      const canvasClickTarget = graph.mouselayer.rect(0, 0, graph.xpixels, graph.ypixels).attr({
        fill: "#000",
        opacity: 0
      });
      let isClickingCanvas = false;
      $__default["default"](graph.mouselayer.canvas).on("vmousedown", function (e) {
        if (e.target === canvasClickTarget[0]) {
          if (options.onMouseDown) {
            options.onMouseDown(graph.getMouseCoord(e));
          }

          isClickingCanvas = true;

          if (options.onMouseMove) {
            $__default["default"](document).bind("vmousemove.mouseLayer", function (e) {
              if (isClickingCanvas) {
                e.preventDefault();
                options.onMouseMove(graph.getMouseCoord(e));
              }
            });
          }

          $__default["default"](document).bind("vmouseup.mouseLayer", function (e) {
            $__default["default"](document).unbind(".mouseLayer"); // Only register clicks that started on the canvas,
            // and not on another mouseLayer target

            if (isClickingCanvas && options.onClick) {
              options.onClick(graph.getMouseCoord(e));
            }

            isClickingCanvas = false;
          });
        }
      });

      if (options.onMouseOver) {
        $__default["default"](graph.mouselayer.canvas).on("vmouseover", function (e) {
          options.onMouseOver(graph.getMouseCoord(e));
        });
      }

      if (options.onMouseOut) {
        $__default["default"](graph.mouselayer.canvas).on("vmouseout", function (e) {
          options.onMouseOut(graph.getMouseCoord(e));
        });
      }
    }

    if (!options.allowScratchpad) {
      options.setDrawingAreaAvailable(false);
    } // Add mouse and visible wrapper layers for DOM-node-wrapped movables


    graph._mouselayerWrapper = document.createElement("div");
    $__default["default"](graph._mouselayerWrapper).css({
      position: "absolute",
      left: 0,
      top: 0,
      zIndex: mouselayerZIndex
    });
    graph._visiblelayerWrapper = document.createElement("div");
    $__default["default"](graph._visiblelayerWrapper).css({
      position: "absolute",
      left: 0,
      top: 0
    });
    const el = graph.raphael.canvas.parentNode;
    el.appendChild(graph._visiblelayerWrapper);
    el.appendChild(graph._mouselayerWrapper); // Add functions for adding to wrappers

    graph.addToMouseLayerWrapper = function (el) {
      this._mouselayerWrapper.appendChild(el);
    };

    graph.addToVisibleLayerWrapper = function (el) {
      this._visiblelayerWrapper.appendChild(el);
    };
  },

  /**
   * Get mouse coordinates in pixels
   */
  getMousePx: function (event) {
    const graphie = this;
    const mouseX = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
    const mouseY = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top;
    return [mouseX, mouseY];
  },

  /**
   * Get mouse coordinates in graph coordinates
   */
  getMouseCoord: function (event) {
    return this.unscalePoint(this.getMousePx(event));
  },

  /**
   * Unlike all other Graphie-related code, the following three functions use
   * a lot of scaled coordinates (so that labels appear the same size
   * regardless of current shape/figure scale). These are prefixed with 's'.
   */
  labelAngle: function (options) {
    const graphie = this;

    ___default["default"].defaults(options, {
      point1: [0, 0],
      vertex: [0, 0],
      point3: [0, 0],
      label: null,
      numArcs: 1,
      showRightAngleMarker: true,
      pushOut: 0,
      clockwise: false,
      style: {}
    });

    let text = options.text === undefined ? "" : options.text;
    const vertex = options.vertex;
    const sVertex = graphie.scalePoint(vertex);
    let p1;
    let p3;

    if (options.clockwise) {
      p1 = options.point1;
      p3 = options.point3;
    } else {
      p1 = options.point3;
      p3 = options.point1;
    }

    const startAngle = GraphUtils.findAngle(p1, vertex);
    const endAngle = GraphUtils.findAngle(p3, vertex);
    const angle = (endAngle + 360 - startAngle) % 360;
    const halfAngle = (startAngle + angle / 2) % 360;
    const sPadding = 5 * options.pushOut;
    let sRadius = sPadding + scaledDistanceFromAngle(angle);
    const temp = [];

    if (Math.abs(angle - 90) < 1e-9 && options.showRightAngleMarker) {
      const v1 = addPoints(sVertex, scaledPolarDeg(sRadius, startAngle));
      const v2 = addPoints(sVertex, scaledPolarDeg(sRadius, endAngle));
      sRadius *= Math.SQRT2;
      const v3 = addPoints(sVertex, scaledPolarDeg(sRadius, halfAngle));

      ___default["default"].each([v1, v2], function (v) {
        temp.push(graphie.scaledPath([v, v3], options.style));
      });
    } else {
      // Draw arcs
      ___default["default"].times(options.numArcs, function (i) {
        temp.push(graphie.arc(vertex, graphie.unscaleVector(sRadius), startAngle, endAngle, options.style));
        sRadius += 3;
      });
    }

    if (text) {
      const match = text.match(/\$deg(\d)?/);

      if (match) {
        const precision = match[1] || 1;
        text = text.replace(match[0], KhanMath.toFixedApprox(angle, precision) + "^{\\circ}");
      }

      const sOffset = scaledPolarDeg(sRadius + 15, halfAngle);
      const sPosition = addPoints(sVertex, sOffset);
      const position = graphie.unscalePoint(sPosition); // Reuse label if possible

      if (options.label) {
        options.label.setPosition(position);
        options.label.processMath(text,
        /* force */
        true);
      } else {
        graphie.label(position, text, "center", options.style);
      }
    }

    return temp;
  },
  labelSide: function (options) {
    const graphie = this;

    ___default["default"].defaults(options, {
      point1: [0, 0],
      point2: [0, 0],
      label: null,
      text: "",
      numTicks: 0,
      numArrows: 0,
      clockwise: false,
      style: {}
    });

    let p1;
    let p2;

    if (options.clockwise) {
      p1 = options.point1;
      p2 = options.point2;
    } else {
      p1 = options.point2;
      p2 = options.point1;
    }

    const midpoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
    const sMidpoint = graphie.scalePoint(midpoint);
    const parallelAngle = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
    const perpendicularAngle = parallelAngle + Math.PI / 2;
    const temp = [];
    let sCumulativeOffset = 0;

    if (options.numTicks) {
      const n = options.numTicks;
      const sSpacing = 5;
      const sHeight = 5;

      const style = ___default["default"].extend({}, options.style, {
        strokeWidth: 2
      });

      ___default["default"].times(n, function (i) {
        const sOffset = sSpacing * (i - (n - 1) / 2);
        const sOffsetVector = scaledPolarRad(sOffset, parallelAngle);
        const sHeightVector = scaledPolarRad(sHeight, perpendicularAngle);
        const sPath = [addPoints(sMidpoint, sOffsetVector, sHeightVector), addPoints(sMidpoint, sOffsetVector, reverseVector(sHeightVector))];
        temp.push(graphie.scaledPath(sPath, style));
      });

      sCumulativeOffset += sSpacing * (n - 1) + 15;
    }

    if (options.numArrows) {
      const n = options.numArrows;
      const start = [p1, p2].sort(function (a, b) {
        if (a[1] === b[1]) {
          return a[0] - b[0];
        }

        return a[1] - b[1];
      })[0];
      const sStart = graphie.scalePoint(start);

      const style = ___default["default"].extend({}, options.style, {
        arrows: "->",
        strokeWidth: 2
      });

      const sSpacing = 5;

      ___default["default"].times(n, function (i) {
        const sOffset = sCumulativeOffset + sSpacing * i;
        let sOffsetVector = scaledPolarRad(sOffset, parallelAngle);

        if (start !== p1) {
          sOffsetVector = reverseVector(sOffsetVector);
        }

        const sEnd = addPoints(sMidpoint, sOffsetVector);
        temp.push(graphie.scaledPath([sStart, sEnd], style));
      });
    }

    let text = options.text;

    if (text) {
      const match = text.match(/\$len(\d)?/);

      if (match) {
        const distance = GraphUtils.getDistance(p1, p2);
        const precision = match[1] || 1;
        text = text.replace(match[0], KhanMath.toFixedApprox(distance, precision));
      }

      const sOffset = 20;
      const sOffsetVector = scaledPolarRad(sOffset, perpendicularAngle);
      const sPosition = addPoints(sMidpoint, sOffsetVector);
      const position = graphie.unscalePoint(sPosition); // Reuse label if possible

      if (options.label) {
        options.label.setPosition(position);
        options.label.processMath(text,
        /* force */
        true);
      } else {
        graphie.label(position, text, "center", options.style);
      }
    }

    return temp;
  },

  /* Can also be used to label points that aren't vertices */
  labelVertex: function (options) {
    const graphie = this;

    ___default["default"].defaults(options, {
      point1: null,
      vertex: [0, 0],
      point3: null,
      label: null,
      text: "",
      clockwise: false,
      style: {}
    });

    if (!options.text) {
      return;
    }

    const vertex = options.vertex;
    const sVertex = graphie.scalePoint(vertex);
    let p1;
    let p3;

    if (options.clockwise) {
      p1 = options.point1;
      p3 = options.point3;
    } else {
      p1 = options.point3;
      p3 = options.point1;
    }

    let angle = 135;
    let halfAngle;

    if (p1 && p3) {
      const startAngle = GraphUtils.findAngle(p1, vertex);
      const endAngle = GraphUtils.findAngle(p3, vertex);
      angle = (endAngle + 360 - startAngle) % 360;
      halfAngle = (startAngle + angle / 2 + 180) % 360;
    } else if (p1) {
      const parallelAngle = GraphUtils.findAngle(vertex, p1);
      halfAngle = parallelAngle + 90;
    } else if (p3) {
      const parallelAngle = GraphUtils.findAngle(p3, vertex);
      halfAngle = parallelAngle + 90;
    } else {
      // Standalone point
      halfAngle = 135;
    }

    const sRadius = 10 + scaledDistanceFromAngle(360 - angle);
    const sOffsetVector = scaledPolarDeg(sRadius, halfAngle);
    const sPosition = addPoints(sVertex, sOffsetVector);
    const position = graphie.unscalePoint(sPosition); // Reuse label if possible

    if (options.label) {
      options.label.setPosition(position);
      options.label.processMath(options.text,
      /* force */
      true);
    } else {
      graphie.label(position, options.text, "center", options.style);
    }
  },
  // Add a point to the graph that can be dragged around.
  // It allows automatic constraints on its movement as well as automatically
  // managing line segments that terminate at the point.
  //
  // Options can be set to control how the point behaves:
  //   coord[]:
  //     The initial position of the point
  //   snapX, snapY:
  //     The minimum increment the point can be moved
  //
  // The return value is an object that can be used to manipulate the point:
  //   The coordX and coordY properties tell you the current position
  //
  //   By adding an onMove() method to the returned object, you can install an
  //   event handler that gets called every time the user moves the point.
  //
  //   The returned object also provides a moveTo(x,y) method that will move
  //   the point to a specific coordinate
  //
  // Constraints can be set on the on the returned object:
  //
  //  - Set point to be immovable:
  //        movablePoint.constraints.fixed = true
  //
  //  - Constrain point to a fixed distance from another point. The resulting
  //    point will move in a circle:
  //        movablePoint.fixedDistance = {
  //           dist: 2,
  //           point: point1
  //        }
  //
  //  - Constrain point to a line defined by a fixed angle between it and
  //    two other points:
  //        movablePoint.fixedAngle = {
  //           angle: 45,
  //           vertex: point1,
  //           ref: point2
  //        }
  //
  //  - Confined the point to traveling in a vertical or horizontal line,
  //    respectively
  //        movablePoint.constrainX = true;
  //        movablePoint.constrainY = true;
  //
  //  - Connect a movableLineSegment to a movablePoint. The point is attached
  //    to a specific end of the line segment by adding the segment either to
  //    the list of lines that start at the point or the list of lines that
  //    end at the point (movableLineSegment can do this for you):
  //        movablePoint.lineStarts.push(movableLineSegment);
  //          - or -
  //        movablePoint.lineEnds.push(movableLineSegment);
  //
  //  - Connect a movablePolygon to a movablePoint in exacty the same way:
  //        movablePoint.polygonVertices.push(movablePolygon);
  //
  addMovablePoint: function (options) {
    const movablePoint = $__default["default"].extend(true, {
      graph: this,
      coord: [0, 0],
      snapX: 0,
      snapY: 0,
      pointSize: 4,
      highlight: false,
      dragging: false,
      visible: true,
      bounded: true,
      constraints: {
        fixed: false,
        constrainX: false,
        constrainY: false,
        fixedAngle: {},
        fixedDistance: {}
      },
      lineStarts: [],
      lineEnds: [],
      polygonVertices: [],
      normalStyle: {},
      highlightStyle: {
        fill: KhanColors.INTERACTING,
        stroke: KhanColors.INTERACTING
      },
      labelStyle: {
        color: KhanColors.INTERACTIVE
      },
      vertexLabel: "",
      mouseTarget: null
    }, options);
    const normalColor = movablePoint.constraints.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    movablePoint.normalStyle = ___default["default"].extend({}, {
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle); // deprecated: don't use coordX/coordY; use coord[]

    if (options.coordX !== undefined) {
      movablePoint.coord[0] = options.coordX;
    }

    if (options.coordY !== undefined) {
      movablePoint.coord[1] = options.coordY;
    }

    const graph = movablePoint.graph;

    const applySnapAndConstraints = function (coord) {
      // coord should be the scaled coordinate
      // move point away from edge of graph unless it's invisible or fixed
      if (movablePoint.visible && movablePoint.bounded && !movablePoint.constraints.fixed) {
        // can't go beyond 10 pixels from the edge
        coord = graph.constrainToBounds(coord, 10);
      }

      let coordX = coord[0];
      let coordY = coord[1]; // snap coordinates to grid

      if (movablePoint.snapX !== 0) {
        coordX = Math.round(coordX / movablePoint.snapX) * movablePoint.snapX;
      }

      if (movablePoint.snapY !== 0) {
        coordY = Math.round(coordY / movablePoint.snapY) * movablePoint.snapY;
      } // snap to points around circle


      if (movablePoint.constraints.fixedDistance.snapPoints) {
        const mouse = graph.scalePoint(coord);
        let mouseX = mouse[0];
        let mouseY = mouse[1];
        const snapRadians = 2 * Math.PI / movablePoint.constraints.fixedDistance.snapPoints;
        const radius = movablePoint.constraints.fixedDistance.dist;
        const centerCoord = movablePoint.constraints.fixedDistance.point;
        const centerX = (centerCoord[0] - graph.range[0][0]) * graph.scale[0];
        const centerY = (-centerCoord[1] + graph.range[1][1]) * graph.scale[1];
        let mouseXrel = mouseX - centerX;
        let mouseYrel = -mouseY + centerY;
        let radians = Math.atan(mouseYrel / mouseXrel);
        const outsideArcTanRange = mouseXrel < 0; // adjust so that angles increase from 0 to 2 pi as you go
        // around the circle

        if (outsideArcTanRange) {
          radians += Math.PI;
        } // perform the snap


        radians = Math.round(radians / snapRadians) * snapRadians; // convert from radians back to pixels

        mouseXrel = radius * Math.cos(radians);
        mouseYrel = radius * Math.sin(radians); // convert back to coordinates relative to graphie canvas

        mouseX = mouseXrel + centerX;
        mouseY = -mouseYrel + centerY;
        coordX = KhanMath.roundTo(5, mouseX / graph.scale[0] + graph.range[0][0]);
        coordY = KhanMath.roundTo(5, graph.range[1][1] - mouseY / graph.scale[1]);
      }

      const result = movablePoint.applyConstraint([coordX, coordY]);
      return result;
    }; // Using the passed coordinates, apply any constraints and return
    // the closest coordinates that match the constraints.


    movablePoint.applyConstraint = function (coord, extraConstraints, override) {
      let newCoord = coord.slice();
      const constraints = {};

      if (override) {
        $__default["default"].extend(constraints, {
          fixed: false,
          constrainX: false,
          constrainY: false,
          fixedAngle: {},
          fixedDistance: {}
        }, extraConstraints);
      } else {
        $__default["default"].extend(constraints, this.constraints, extraConstraints);
      } // constrain to vertical movement


      if (constraints.constrainX) {
        newCoord = [this.coord[0], coord[1]]; // constrain to horizontal movement
      } else if (constraints.constrainY) {
        newCoord = [coord[0], this.coord[1]]; // both distance and angle are constrained
      } else if (typeof constraints.fixedAngle.angle === "number" && typeof constraints.fixedDistance.dist === "number") {
        const vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
        const ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;
        const distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;
        const constrainedAngle = (constraints.fixedAngle.angle + GraphUtils.findAngle(ref, vertex)) * Math.PI / 180;
        const length = constraints.fixedDistance.dist;
        newCoord[0] = length * Math.cos(constrainedAngle) + distPoint[0];
        newCoord[1] = length * Math.sin(constrainedAngle) + distPoint[1]; // angle is constrained
      } else if (typeof constraints.fixedAngle.angle === "number") {
        const vertex = constraints.fixedAngle.vertex.coord || constraints.fixedAngle.vertex;
        const ref = constraints.fixedAngle.ref.coord || constraints.fixedAngle.ref;
        const constrainedAngle = (constraints.fixedAngle.angle + GraphUtils.findAngle(ref, vertex)) * Math.PI / 180;
        const angle = GraphUtils.findAngle(coord, vertex) * Math.PI / 180;
        const distance = GraphUtils.getDistance(coord, vertex);
        let length = distance * Math.cos(constrainedAngle - angle);
        length = length < 1.0 ? 1.0 : length;
        newCoord[0] = length * Math.cos(constrainedAngle) + vertex[0];
        newCoord[1] = length * Math.sin(constrainedAngle) + vertex[1]; // distance is constrained
      } else if (typeof constraints.fixedDistance.dist === "number") {
        const distPoint = constraints.fixedDistance.point.coord || constraints.fixedDistance.point;
        let angle = GraphUtils.findAngle(coord, distPoint);
        const length = constraints.fixedDistance.dist;
        angle = angle * Math.PI / 180;
        newCoord[0] = length * Math.cos(angle) + distPoint[0];
        newCoord[1] = length * Math.sin(angle) + distPoint[1]; // point is fixed
      } else if (constraints.fixed) {
        newCoord = movablePoint.coord;
      }

      return newCoord;
    };

    movablePoint.coord = applySnapAndConstraints(movablePoint.coord);
    const highlightScale = 2;

    if (movablePoint.visible) {
      graph.style(movablePoint.normalStyle, function () {
        const radii = [movablePoint.pointSize / graph.scale[0], movablePoint.pointSize / graph.scale[1]];
        const options = {
          maxScale: highlightScale,
          // Add in 2px of padding to avoid clipping at the edges.
          padding: 2
        }; // $FlowFixMe[invalid-constructor]

        movablePoint.visibleShape = new WrappedEllipse(graph, movablePoint.coord, radii, options);
        movablePoint.visibleShape.attr(___default["default"].omit(movablePoint.normalStyle, "scale"));
        movablePoint.visibleShape.toFront();
      });
    }

    movablePoint.normalStyle.scale = 1;
    movablePoint.highlightStyle.scale = highlightScale;

    if (movablePoint.vertexLabel) {
      movablePoint.labeledVertex = this.label([0, 0], "", "center", movablePoint.labelStyle);
    }

    movablePoint.drawLabel = function () {
      if (movablePoint.vertexLabel) {
        movablePoint.graph.labelVertex({
          vertex: movablePoint.coord,
          label: movablePoint.labeledVertex,
          text: movablePoint.vertexLabel,
          style: movablePoint.labelStyle
        });
      }
    };

    movablePoint.drawLabel();

    movablePoint.grab = function (offset) {
      // The offset for the gesture. When provided, the movable point will
      // track the mouse's position, plus this offset. This is typically
      // used to lock the distance between a user's finger and the movable
      // point, when dragging.
      offset = offset || [0, 0];
      $__default["default"](document).bind("vmousemove.point vmouseup.point", function (event) {
        event.preventDefault();
        movablePoint.dragging = true;
        dragging = true; // Adjust the target coordinate by accounting for the gesture's
        // offset.

        let coord = kmath.vector.add(graph.getMouseCoord(event), offset);
        coord = applySnapAndConstraints(coord);
        let coordX = coord[0];
        let coordY = coord[1];
        let mouseX;
        let mouseY;

        if (event.type === "vmousemove") {
          let doMove = true; // The caller has the option of adding an onMove() method
          // to the movablePoint object we return as a sort of event
          // handler. By returning false from onMove(), the move
          // can be vetoed, providing custom constraints on where
          // the point can be moved. By returning array [x, y], the
          // move can be overridden

          if (___default["default"].isFunction(movablePoint.onMove)) {
            const result = movablePoint.onMove(coordX, coordY);

            if (result === false) {
              doMove = false;
            }

            if (___default["default"].isArray(result)) {
              coordX = result[0];
              coordY = result[1];
            }
          } // coord{X|Y} may have been modified by constraints or
          // onMove handler; adjust mouse{X|Y} to match


          mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
          mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];

          if (doMove) {
            const point = graph.unscalePoint([mouseX, mouseY]);
            movablePoint.visibleShape.moveTo(point);
            movablePoint.mouseTarget.moveTo(point);
            movablePoint.coord = [coordX, coordY];
            movablePoint.updateLineEnds();
            $__default["default"](movablePoint).trigger("move");
          }

          movablePoint.drawLabel();
        } else if (event.type === "vmouseup") {
          $__default["default"](document).unbind(".point");
          movablePoint.dragging = false;
          dragging = false;

          if (___default["default"].isFunction(movablePoint.onMoveEnd)) {
            const result = movablePoint.onMoveEnd(coordX, coordY);

            if (___default["default"].isArray(result)) {
              coordX = result[0];
              coordY = result[1];
              mouseX = (coordX - graph.range[0][0]) * graph.scale[0];
              mouseY = (-coordY + graph.range[1][1]) * graph.scale[1];
              const point = graph.unscalePoint([mouseX, mouseY]);
              movablePoint.visibleShape.moveTo(point);
              movablePoint.mouseTarget.moveTo(point);
              movablePoint.coord = [coordX, coordY];
            }
          }

          if (!movablePoint.highlight) {
            movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);

            if (movablePoint.onUnhighlight) {
              movablePoint.onUnhighlight();
            }
          }
        }
      });
    };

    if (movablePoint.visible && !movablePoint.constraints.fixed) {
      // the invisible shape in front of the point that gets mouse events
      if (!movablePoint.mouseTarget) {
        const radii = graph.unscaleVector(16);
        const options = {
          mouselayer: true,
          padding: 0,
          disableMouseEventsOnWrapper: true,
          interactiveKindForTesting: "movable-point"
        }; // $FlowFixMe[invalid-constructor]

        movablePoint.mouseTarget = new WrappedEllipse(graph, movablePoint.coord, radii, options);
        movablePoint.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }

      const $mouseTarget = $__default["default"](movablePoint.mouseTarget.getMouseTarget());
      $mouseTarget.css("cursor", "move");
      $mouseTarget.bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          movablePoint.highlight = true;

          if (!dragging) {
            movablePoint.visibleShape.animate(movablePoint.highlightStyle, 50);

            if (movablePoint.onHighlight) {
              movablePoint.onHighlight();
            }
          }
        } else if (event.type === "vmouseout") {
          movablePoint.highlight = false;

          if (!movablePoint.dragging && !dragging) {
            movablePoint.visibleShape.animate(movablePoint.normalStyle, 50);

            if (movablePoint.onUnhighlight) {
              movablePoint.onUnhighlight();
            }
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault(); // The offset between the cursor or finger and the initial
          // coordinates of the point. This is tracked so as to avoid
          // locking the moving point to the user's finger on touch
          // devices, which would obscure it, no matter how large we
          // made the touch target. Instead, we respect the offset at
          // which the point was grabbed for the entirety of the
          // gesture, if it's a touch-based interaction.

          const startCoord = movablePoint.coord;
          const startMouseCoord = graph.getMouseCoord(event);
          const isMouse = !("ontouchstart" in window);
          const touchOffset = isMouse ? [0, 0] : kmath.vector.subtract(startCoord, startMouseCoord);
          movablePoint.grab(touchOffset);
        }
      });
    } // Method to let the caller animate the point to a new position.
    // Useful as part of a hint to show the user the correct place
    // to put the point.


    movablePoint.moveTo = function (coordX, coordY, updateLines) {
      const distance = GraphUtils.getDistance(this.graph.scalePoint([coordX, coordY]), this.graph.scalePoint(this.coord));
      const time = distance * 5;

      const cb = updateLines && function (coord) {
        movablePoint.coord = coord;
        movablePoint.updateLineEnds();
      };

      this.visibleShape.animateTo([coordX, coordY], time, cb);
      this.mouseTarget.animateTo([coordX, coordY], time, cb);
      this.coord = [coordX, coordY];

      if (___default["default"].isFunction(this.onMove)) {
        this.onMove(coordX, coordY);
      }
    }; // After moving the point, call this to update all line segments
    // terminating at the point


    movablePoint.updateLineEnds = function () {
      $__default["default"](this.lineStarts).each(function () {
        this.coordA = movablePoint.coord;
        this.transform();
      });
      $__default["default"](this.lineEnds).each(function () {
        this.coordZ = movablePoint.coord;
        this.transform();
      });
      $__default["default"](this.polygonVertices).each(function () {
        this.transform();
      });
    }; // Put the point at a new position without any checks, animation,
    // or callbacks


    movablePoint.setCoord = function (coord) {
      if (this.visible) {
        this.visibleShape.moveTo(coord);

        if (this.mouseTarget != null) {
          this.mouseTarget.moveTo(coord);
        }
      }

      this.coord = coord.slice();
    }; // Put the point at the new position, checking that it is
    // within the graph's bounds


    movablePoint.setCoordConstrained = function (coord) {
      this.setCoord(applySnapAndConstraints(coord));
    }; // Change z-order to back


    movablePoint.toBack = function () {
      if (this.visible) {
        if (this.mouseTarget != null) {
          this.mouseTarget.toBack();
        }

        this.visibleShape.toBack();
      }
    }; // Change z-order to front


    movablePoint.toFront = function () {
      if (this.visible) {
        if (this.mouseTarget != null) {
          this.mouseTarget.toFront();
        }

        this.visibleShape.toFront();
      }
    };

    movablePoint.remove = function () {
      if (this.visibleShape) {
        this.visibleShape.remove();
      }

      if (this.mouseTarget) {
        this.mouseTarget.remove();
      }

      if (this.labeledVertex) {
        this.labeledVertex.remove();
      }
    };

    return movablePoint;
  },
  // MovableLineSegment is a line segment that can be dragged around the
  // screen. By attaching a smartPoint to each (or one) end, the ends can be
  // manipulated individually.
  //
  // To use with smartPoints, add the smartPoints first, then:
  //   addMovableLineSegment({ pointA: smartPoint1, pointZ: smartPoint2 });
  // Or just one end:
  //   addMovableLineSegment({ pointA: smartPoint, coordZ: [0, 0] });
  //
  // Include "fixed: true" in the options if you don't want the entire line
  // to be draggable (you can still use points to make the endpoints
  // draggable)
  //
  // The returned object includes the following properties/methods:
  //
  //   - lineSegment.coordA / lineSegment.coordZ
  //         The coordinates of each end of the line segment
  //
  //   - lineSegment.transform(syncToPoints)
  //         Repositions the line segment. Call after changing coordA
  //         and/or coordZ, or pass syncToPoints = true to use the current
  //         position of the corresponding smartPoints, if the segment was
  //         defined using smartPoints
  //
  addMovableLineSegment: function (options) {
    const lineSegment = $__default["default"].extend({
      graph: this,
      coordA: [0, 0],
      coordZ: [1, 1],
      snapX: 0,
      snapY: 0,
      fixed: false,
      ticks: 0,
      normalStyle: {},
      highlightStyle: {
        stroke: KhanColors.INTERACTING,
        "stroke-width": 6
      },
      labelStyle: {
        stroke: KhanColors.INTERACTIVE,
        color: KhanColors.INTERACTIVE
      },
      highlight: false,
      dragging: false,
      tick: [],
      extendLine: false,
      extendRay: false,
      constraints: {
        fixed: false,
        constrainX: false,
        constrainY: false
      },
      sideLabel: "",
      vertexLabels: [],
      numArrows: 0,
      numTicks: 0,
      movePointsWithLine: false
    }, options);
    const normalColor = lineSegment.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    lineSegment.normalStyle = ___default["default"].extend({}, {
      "stroke-width": 2,
      stroke: normalColor
    }, options.normalStyle); // arrowStyle should be kept in sync with styling of the line

    lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.normalStyle, {
      color: lineSegment.normalStyle.stroke
    }); // If the line segment is defined by movablePoints, coordA/coordZ are
    // owned by the points, otherwise they're owned by us

    if (options.pointA !== undefined) {
      lineSegment.coordA = options.pointA.coord;
      lineSegment.pointA.lineStarts.push(lineSegment);
    } else if (options.coordA !== undefined) {
      lineSegment.coordA = options.coordA.slice();
    }

    if (options.pointZ !== undefined) {
      lineSegment.coordZ = options.pointZ.coord;
      lineSegment.pointZ.lineEnds.push(lineSegment);
    } else if (options.coordA !== undefined) {
      lineSegment.coordA = lineSegment.coordA.slice();
    }

    const graph = lineSegment.graph;
    graph.style(lineSegment.normalStyle);

    for (let i = 0; i < lineSegment.ticks; ++i) {
      lineSegment.tick[i] = InteractiveUtils.bogusShape;
    }

    let path = GraphUtils.unscaledSvgPath([[0, 0], [1, 0]]);

    for (let i = 0; i < lineSegment.ticks; ++i) {
      const tickoffset = 0.5 - (lineSegment.ticks - 1 + i * 2) / graph.scale[0]; // TODO(kevinb) figure out why path isn't being used
      // eslint-disable-next-line no-unused-vars

      path += GraphUtils.unscaledSvgPath([[tickoffset, -7], [tickoffset, 7]]);
    }

    options = {
      thickness: Math.max(lineSegment.normalStyle["stroke-width"], lineSegment.highlightStyle["stroke-width"])
    }; // $FlowFixMe[invalid-constructor]

    lineSegment.visibleLine = new WrappedLine(graph, [0, 0], [1, 0], options);
    lineSegment.visibleLine.attr(lineSegment.normalStyle); // Add mouse target

    if (!lineSegment.fixed) {
      const options = {
        thickness: 30,
        mouselayer: true,
        interactiveKindForTesting: "movable-line"
      }; // $FlowFixMe[invalid-constructor]

      lineSegment.mouseTarget = new WrappedLine(graph, [0, 0], [1, 0], options);
      lineSegment.mouseTarget.attr({
        fill: "#000",
        opacity: 0.0
      });
    } // Reposition the line segment. Call after changing coordA and/or
    // coordZ, or pass syncToPoints = true to use the current position of
    // the corresponding movablePoints, if the segment was defined using
    // movablePoints


    lineSegment.transform = function (syncToPoints) {
      if (syncToPoints) {
        if (typeof this.pointA === "object") {
          this.coordA = this.pointA.coord;
        }

        if (typeof this.pointZ === "object") {
          this.coordZ = this.pointZ.coord;
        }
      }

      const getScaledAngle = function (line) {
        const scaledA = line.graph.scalePoint(line.coordA);
        const scaledZ = line.graph.scalePoint(line.coordZ);
        return kmath.vector.polarDegFromCart(kmath.vector.subtract(scaledZ, scaledA))[1];
      };

      const getClipPoint = function (graph, coord, angle) {
        graph = lineSegment.graph;
        const xExtent = graph.range[0][1] - graph.range[0][0];
        const yExtent = graph.range[1][1] - graph.range[1][0];
        const distance = xExtent + yExtent;
        const angleVec = graph.unscaleVector(kmath.vector.cartFromPolarDeg(1, angle));
        const distVec = kmath.vector.scale(kmath.vector.normalize(angleVec), distance);
        const farCoord = kmath.vector.add(coord, distVec);
        const scaledAngle = kmath.vector.polarDegFromCart(angleVec)[1];
        const clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4, scaledAngle * Math.PI / 180);
        return clipPoint;
      };

      const angle = getScaledAngle(this);
      let start = this.coordA;
      let end = this.coordZ; // Extend start, end if necessary (i.e., if not a line segment)

      if (this.extendLine) {
        start = getClipPoint(graph, start, 360 - angle);
        end = getClipPoint(graph, end, (540 - angle) % 360);
      } else if (this.extendRay) {
        end = getClipPoint(graph, start, 360 - angle);
      }

      const elements = [this.visibleLine];

      if (!this.fixed) {
        elements.push(this.mouseTarget);
      }

      ___default["default"].each(elements, function (element) {
        element.moveTo(start, end);
      });

      const createArrow = function (graph, style) {
        const center = [0.75, 0];
        let points = [[-3, 4], [-2.75, 2.5], [0, 0.25], center, [0, -0.25], [-2.75, -2.5], [-3, -4]];
        const scale = 1.4;
        points = ___default["default"].map(points, function (point) {
          const pv = kmath.vector.subtract(point, center);
          const pvScaled = kmath.vector.scale(pv, scale);
          return kmath.vector.add(center, pvScaled);
        });

        const createCubicPath = function (points) {
          let path = "M" + points[0][0] + " " + points[0][1];

          for (let i = 1; i < points.length; i += 3) {
            path += "C" + points[i][0] + " " + points[i][1] + " " + points[i + 1][0] + " " + points[i + 1][1] + " " + points[i + 2][0] + " " + points[i + 2][1];
          }

          return path;
        };

        const unscaledPoints = ___default["default"].map(points, graph.unscalePoint);

        const options = {
          center: graph.unscalePoint(center),
          createPath: createCubicPath
        }; // $FlowFixMe[invalid-constructor]

        const arrowHead = new WrappedPath(graph, unscaledPoints, options);
        arrowHead.attr(___default["default"].extend({
          "stroke-linejoin": "round",
          "stroke-linecap": "round",
          "stroke-dasharray": ""
        }, style)); // Add custom function for transforming arrowheads that
        // accounts for center, scaling, etc.
        // $FlowFixMe[prop-missing]

        arrowHead.toCoordAtAngle = function (coord, angle) {
          const clipPoint = graph.scalePoint(getClipPoint(graph, coord, angle));
          const do3dTransform = getCanUse3dTransform();
          arrowHead.transform("translateX(" + (clipPoint[0] + scale * center[0]) + "px) " + "translateY(" + (clipPoint[1] + scale * center[1]) + "px) " + (do3dTransform ? "translateZ(0) " : "") + "rotate(" + (360 - KhanMath.bound(angle)) + "deg)");
        };

        return arrowHead;
      }; // Add arrows


      if (this._arrows == null) {
        this._arrows = [];

        if (this.extendLine) {
          this._arrows.push(createArrow(graph, this.normalStyle));

          this._arrows.push(createArrow(graph, this.normalStyle));
        } else if (this.extendRay) {
          this._arrows.push(createArrow(graph, this.normalStyle));
        }
      }

      const coordForArrow = [this.coordA, this.coordZ];
      const angleForArrow = [360 - angle, (540 - angle) % 360];

      ___default["default"].each(this._arrows, function (arrow, i) {
        arrow.toCoordAtAngle(coordForArrow[i], angleForArrow[i]);
      }); // Temporary objects: array of SVG nodes that get recreated on drag


      ___default["default"].invoke(this.temp, "remove");

      this.temp = [];
      const isClockwise = this.coordA[0] < this.coordZ[0] || this.coordA[0] === this.coordZ[0] && this.coordA[1] > this.coordZ[1]; // Update side label

      if (this.sideLabel) {
        this.temp.push(this.graph.labelSide({
          point1: this.coordA,
          point2: this.coordZ,
          label: this.labeledSide,
          text: this.sideLabel,
          numArrows: this.numArrows,
          numTicks: this.numTicks,
          clockwise: isClockwise,
          style: this.labelStyle
        }));
      } // Update vertex labels


      if (this.vertexLabels.length) {
        this.graph.labelVertex({
          vertex: this.coordA,
          point3: this.coordZ,
          label: this.labeledVertices[0],
          text: this.vertexLabels[0],
          clockwise: isClockwise,
          style: this.labelStyle
        });
        this.graph.labelVertex({
          point1: this.coordA,
          vertex: this.coordZ,
          label: this.labeledVertices[1],
          text: this.vertexLabels[1],
          clockwise: isClockwise,
          style: this.labelStyle
        });
      }

      this.temp = ___default["default"].flatten(this.temp);
    }; // Change z-order to back;


    lineSegment.toBack = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.toBack();
      }

      lineSegment.visibleLine.toBack();
    }; // Change z-order to front


    lineSegment.toFront = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.toFront();
      }

      lineSegment.visibleLine.toFront();
    };

    lineSegment.remove = function () {
      if (!lineSegment.fixed) {
        lineSegment.mouseTarget.remove();
      }

      lineSegment.visibleLine.remove();

      if (lineSegment.labeledSide) {
        lineSegment.labeledSide.remove();
      }

      if (lineSegment.labeledVertices) {
        ___default["default"].invoke(lineSegment.labeledVertices, "remove");
      }

      if (lineSegment._arrows) {
        ___default["default"].invoke(lineSegment._arrows, "remove");
      }

      if (lineSegment.temp.length) {
        ___default["default"].invoke(lineSegment.temp, "remove");
      }
    };

    lineSegment.hide = function () {
      lineSegment.visibleLine.hide();

      if (lineSegment.temp.length) {
        ___default["default"].invoke(lineSegment.temp, "hide");
      }

      if (lineSegment._arrows) {
        ___default["default"].invoke(lineSegment._arrows, "hide");
      }
    };

    lineSegment.show = function () {
      lineSegment.visibleLine.show();

      if (lineSegment.temp.length) {
        ___default["default"].invoke(lineSegment.temp, "show");
      }

      if (lineSegment._arrows) {
        ___default["default"].invoke(lineSegment._arrows, "show");
      }
    };

    if (lineSegment.sideLabel) {
      lineSegment.labeledSide = this.label([0, 0], "", "center", lineSegment.labelStyle);
    }

    if (lineSegment.vertexLabels.length) {
      lineSegment.labeledVertices = ___default["default"].map(lineSegment.vertexLabels, function (label) {
        return this.label([0, 0], "", "center", lineSegment.labelStyle);
      }, this);
    }

    if (!lineSegment.fixed && !lineSegment.constraints.fixed) {
      const $mouseTarget = $__default["default"](lineSegment.mouseTarget.getMouseTarget());
      $mouseTarget.css("cursor", "move");
      $mouseTarget.bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          if (!dragging) {
            lineSegment.highlight = true;
            lineSegment.visibleLine.animate(lineSegment.highlightStyle, 50);
            lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.arrowStyle, {
              color: lineSegment.highlightStyle.stroke,
              stroke: lineSegment.highlightStyle.stroke
            });
            lineSegment.transform();
          }
        } else if (event.type === "vmouseout") {
          lineSegment.highlight = false;

          if (!lineSegment.dragging) {
            lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
            lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.arrowStyle, {
              color: lineSegment.normalStyle.stroke,
              stroke: lineSegment.normalStyle.stroke
            });
            lineSegment.transform();
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault();
          let coordX = (event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left) / graph.scale[0] + graph.range[0][0];
          let coordY = graph.range[1][1] - (event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top) / graph.scale[1];

          if (lineSegment.snapX > 0) {
            coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
          }

          if (lineSegment.snapY > 0) {
            coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
          }

          const mouseOffsetA = [lineSegment.coordA[0] - coordX, lineSegment.coordA[1] - coordY];
          const mouseOffsetZ = [lineSegment.coordZ[0] - coordX, lineSegment.coordZ[1] - coordY];
          const offsetLeft = -Math.min(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
          const offsetRight = Math.max(graph.scaleVector(mouseOffsetA)[0], graph.scaleVector(mouseOffsetZ)[0]);
          const offsetTop = Math.max(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
          const offsetBottom = -Math.min(graph.scaleVector(mouseOffsetA)[1], graph.scaleVector(mouseOffsetZ)[1]);
          $__default["default"](document).bind("vmousemove.lineSegment vmouseup.lineSegment", function (event) {
            event.preventDefault();
            lineSegment.dragging = true;
            dragging = true;
            let mouseX = event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left;
            let mouseY = event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top; // no part of the line segment can go beyond 10
            // pixels from the edge

            mouseX = Math.max(offsetLeft + 10, Math.min(graph.xpixels - 10 - offsetRight, mouseX));
            mouseY = Math.max(offsetTop + 10, Math.min(graph.ypixels - 10 - offsetBottom, mouseY));
            let coordX = mouseX / graph.scale[0] + graph.range[0][0];
            let coordY = graph.range[1][1] - mouseY / graph.scale[1];

            if (lineSegment.snapX > 0) {
              coordX = Math.round(coordX / lineSegment.snapX) * lineSegment.snapX;
            }

            if (lineSegment.snapY > 0) {
              coordY = Math.round(coordY / lineSegment.snapY) * lineSegment.snapY;
            }

            if (event.type === "vmousemove") {
              if (lineSegment.constraints.constrainX) {
                coordX = lineSegment.coordA[0] - mouseOffsetA[0];
              }

              if (lineSegment.constraints.constrainY) {
                coordY = lineSegment.coordA[1] - mouseOffsetA[1];
              }

              const dX = coordX + mouseOffsetA[0] - lineSegment.coordA[0];
              const dY = coordY + mouseOffsetA[1] - lineSegment.coordA[1];
              lineSegment.coordA = [coordX + mouseOffsetA[0], coordY + mouseOffsetA[1]];
              lineSegment.coordZ = [coordX + mouseOffsetZ[0], coordY + mouseOffsetZ[1]];
              lineSegment.transform();

              if (lineSegment.movePointsWithLine) {
                // If the points are movablePoints, adjust
                // their coordinates when the line itself is
                // dragged
                if (typeof lineSegment.pointA === "object") {
                  lineSegment.pointA.setCoord([lineSegment.pointA.coord[0] + dX, lineSegment.pointA.coord[1] + dY]);
                }

                if (typeof lineSegment.pointZ === "object") {
                  lineSegment.pointZ.setCoord([lineSegment.pointZ.coord[0] + dX, lineSegment.pointZ.coord[1] + dY]);
                }
              }

              if (___default["default"].isFunction(lineSegment.onMove)) {
                lineSegment.onMove(dX, dY);
              }
            } else if (event.type === "vmouseup") {
              $__default["default"](document).unbind(".lineSegment");
              lineSegment.dragging = false;
              dragging = false;

              if (!lineSegment.highlight) {
                lineSegment.visibleLine.animate(lineSegment.normalStyle, 50);
                lineSegment.arrowStyle = ___default["default"].extend({}, lineSegment.arrowStyle, {
                  color: lineSegment.normalStyle.stroke,
                  stroke: lineSegment.normalStyle.stroke
                });
                lineSegment.transform();
              }

              if (___default["default"].isFunction(lineSegment.onMoveEnd)) {
                lineSegment.onMoveEnd();
              }
            }

            $__default["default"](lineSegment).trigger("move");
          });
        }
      });
    }

    if (lineSegment.pointA !== undefined) {
      lineSegment.pointA.toFront();
    }

    if (lineSegment.pointZ !== undefined) {
      lineSegment.pointZ.toFront();
    }

    lineSegment.transform();
    return lineSegment;
  },
  // MovablePolygon is a polygon that can be dragged around the screen.
  // By attaching a smartPoint to each vertex, the points can be
  // manipulated individually.
  //
  // To use with smartPoints, add the smartPoints first, then:
  //   addMovablePolygon({points: [...]});
  //
  // Include "fixed: true" in the options if you don't want the entire
  // polygon to be draggable (you can still use points to make the
  // vertices draggable)
  //
  // The returned object includes the following properties/methods:
  //
  //   - polygon.points
  //         The polygon's dynamic smartPoints and static coordinates, mixed.
  //
  //   - polygon.coords
  //         The polygon's current coordinates (generated, don't edit).
  //
  //   - polygon.transform()
  //         Repositions the polygon. Call after changing any points.
  //
  addMovablePolygon: function (options) {
    const graphie = this;
    const polygon = $__default["default"].extend({
      snapX: 0,
      snapY: 0,
      fixed: false,
      constrainToGraph: true,
      normalStyle: {},
      highlightStyle: {
        stroke: KhanColors.INTERACTING,
        "stroke-width": 2,
        fill: KhanColors.INTERACTING,
        "fill-opacity": 0.05
      },
      pointHighlightStyle: {
        fill: KhanColors.INTERACTING,
        stroke: KhanColors.INTERACTING
      },
      labelStyle: {
        stroke: KhanColors.DYNAMIC,
        "stroke-width": 1,
        color: KhanColors.DYNAMIC
      },
      angleLabels: [],
      showRightAngleMarkers: [],
      sideLabels: [],
      vertexLabels: [],
      numArcs: [],
      numArrows: [],
      numTicks: [],
      updateOnPointMove: true,
      closed: true
    }, ___default["default"].omit(options, "points"));
    const normalColor = polygon.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    polygon.normalStyle = ___default["default"].extend({
      "stroke-width": 2,
      "fill-opacity": 0,
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle); // don't deep copy the points array with $.extend;
    // we may want to append to it later for click-to-add-points

    polygon.points = options.points;

    const isPoint = function (coordOrPoint) {
      return !___default["default"].isArray(coordOrPoint);
    };

    polygon.update = function () {
      const n = polygon.points.length; // Update coords

      polygon.coords = ___default["default"].map(polygon.points, function (coordOrPoint, i) {
        if (isPoint(coordOrPoint)) {
          return coordOrPoint.coord;
        }

        return coordOrPoint;
      }); // Calculate bounding box

      polygon.left = ___default["default"].min(___default["default"].pluck(polygon.coords, 0));
      polygon.right = ___default["default"].max(___default["default"].pluck(polygon.coords, 0));
      polygon.top = ___default["default"].max(___default["default"].pluck(polygon.coords, 1));
      polygon.bottom = ___default["default"].min(___default["default"].pluck(polygon.coords, 1));

      let scaledCoords = ___default["default"].map(polygon.coords, function (coord) {
        return graphie.scalePoint(coord);
      }); // Create path


      if (polygon.closed) {
        scaledCoords.push(true);
      } else {
        // For open polygons, concatenate a reverse of the path,
        // to remove the inside area of the path, which would
        // otherwise be clickable (even if the closing line segment
        // wasn't drawn
        scaledCoords = scaledCoords.concat(___default["default"].clone(scaledCoords).reverse());
      }

      polygon.path = GraphUtils.unscaledSvgPath(scaledCoords); // Temporary objects

      ___default["default"].invoke(polygon.temp, "remove");

      polygon.temp = [];
      const isClockwise = clockwise$1(polygon.coords); // Update angle labels

      if (polygon.angleLabels.length || polygon.showRightAngleMarkers.length) {
        ___default["default"].each(polygon.labeledAngles, function (label, i) {
          polygon.temp.push(graphie.labelAngle({
            point1: polygon.coords[(i - 1 + n) % n],
            vertex: polygon.coords[i],
            point3: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.angleLabels[i],
            showRightAngleMarker: polygon.showRightAngleMarkers[i],
            numArcs: polygon.numArcs[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          }));
        });
      } // Update side labels


      if (polygon.sideLabels.length) {
        ___default["default"].each(polygon.labeledSides, function (label, i) {
          polygon.temp.push(graphie.labelSide({
            point1: polygon.coords[i],
            point2: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.sideLabels[i],
            numArrows: polygon.numArrows[i],
            numTicks: polygon.numTicks[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          }));
        });
      } // Update vertex labels


      if (polygon.vertexLabels.length) {
        ___default["default"].each(polygon.labeledVertices, function (label, i) {
          graphie.labelVertex({
            point1: polygon.coords[(i - 1 + n) % n],
            vertex: polygon.coords[i],
            point3: polygon.coords[(i + 1) % n],
            label: label,
            text: polygon.vertexLabels[i],
            clockwise: isClockwise,
            style: polygon.labelStyle
          });
        });
      }

      polygon.temp = ___default["default"].flatten(polygon.temp);
    };

    polygon.transform = function () {
      polygon.update();
      polygon.visibleShape.attr({
        path: polygon.path
      });

      if (!polygon.fixed) {
        polygon.mouseTarget.attr({
          path: polygon.path
        });
      }
    };

    polygon.remove = function () {
      polygon.visibleShape.remove();

      if (!polygon.fixed) {
        polygon.mouseTarget.remove();
      }

      if (polygon.labeledAngles) {
        ___default["default"].invoke(polygon.labeledAngles, "remove");
      }

      if (polygon.labeledSides) {
        ___default["default"].invoke(polygon.labeledSides, "remove");
      }

      if (polygon.labeledVertices) {
        ___default["default"].invoke(polygon.labeledVertices, "remove");
      }

      if (polygon.temp.length) {
        ___default["default"].invoke(polygon.temp, "remove");
      }
    };

    polygon.toBack = function () {
      if (!polygon.fixed) {
        polygon.mouseTarget.toBack();
      }

      polygon.visibleShape.toBack();
    };

    polygon.toFront = function () {
      if (!polygon.fixed) {
        polygon.mouseTarget.toFront();
      }

      polygon.visibleShape.toFront();
    }; // Setup


    if (polygon.updateOnPointMove) {
      ___default["default"].each(___default["default"].filter(polygon.points, isPoint), function (coordOrPoint) {
        coordOrPoint.polygonVertices.push(polygon);
      });
    }

    polygon.coords = new Array(polygon.points.length);

    if (polygon.angleLabels.length) {
      const numLabels = Math.max(polygon.angleLabels.length, polygon.showRightAngleMarkers.length);
      polygon.labeledAngles = ___default["default"].times(numLabels, function () {
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }

    if (polygon.sideLabels.length) {
      polygon.labeledSides = ___default["default"].map(polygon.sideLabels, function (label) {
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }

    if (polygon.vertexLabels.length) {
      polygon.labeledVertices = ___default["default"].map(polygon.vertexLabels, function (label) {
        return this.label([0, 0], "", "center", polygon.labelStyle);
      }, this);
    }

    polygon.update();
    polygon.visibleShape = graphie.raphael.path(polygon.path);
    polygon.visibleShape.attr(polygon.normalStyle);

    if (!polygon.fixed) {
      polygon.mouseTarget = graphie.mouselayer.path(polygon.path);
      polygon.mouseTarget.attr({
        fill: "#000",
        opacity: 0,
        cursor: "move"
      });
      $__default["default"](polygon.mouseTarget[0]).bind("vmousedown vmouseover vmouseout", function (event) {
        if (event.type === "vmouseover") {
          if (!dragging || polygon.dragging) {
            polygon.highlight = true;
            polygon.visibleShape.animate(polygon.highlightStyle, 50);

            ___default["default"].each(___default["default"].filter(polygon.points, isPoint), function (point) {
              point.visibleShape.animate(polygon.pointHighlightStyle, 50);
            });
          }
        } else if (event.type === "vmouseout") {
          polygon.highlight = false;

          if (!polygon.dragging) {
            polygon.visibleShape.animate(polygon.normalStyle, 50);

            const points = ___default["default"].filter(polygon.points, isPoint);

            if (!___default["default"].any(___default["default"].pluck(points, "dragging"))) {
              ___default["default"].each(points, function (point) {
                point.visibleShape.animate(point.normalStyle, 50);
              });
            }
          }
        } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
          event.preventDefault();

          ___default["default"].each(___default["default"].filter(polygon.points, isPoint), function (point) {
            point.dragging = true;
          });

          let startX = (event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left) / graphie.scale[0] + graphie.range[0][0];
          let startY = graphie.range[1][1] - (event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top) / graphie.scale[1];

          if (polygon.snapX > 0) {
            startX = Math.round(startX / polygon.snapX) * polygon.snapX;
          }

          if (polygon.snapY > 0) {
            startY = Math.round(startY / polygon.snapY) * polygon.snapY;
          }

          let lastX = startX;
          let lastY = startY;
          const polygonCoords = polygon.coords.slice();
          const offsetLeft = (startX - polygon.left) * graphie.scale[0];
          const offsetRight = (polygon.right - startX) * graphie.scale[0];
          const offsetTop = (polygon.top - startY) * graphie.scale[1];
          const offsetBottom = (startY - polygon.bottom) * graphie.scale[1];
          $__default["default"](document).bind("vmousemove.polygon vmouseup.polygon", function (event) {
            event.preventDefault();
            polygon.dragging = true;
            dragging = true;
            let mouseX = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
            let mouseY = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top; // no part of the polygon can go beyond 10 pixels from
            // the edge

            if (polygon.constrainToGraph) {
              mouseX = Math.max(offsetLeft + 10, Math.min(graphie.xpixels - 10 - offsetRight, mouseX));
              mouseY = Math.max(offsetTop + 10, Math.min(graphie.ypixels - 10 - offsetBottom, mouseY));
            }

            let currentX = mouseX / graphie.scale[0] + graphie.range[0][0];
            let currentY = graphie.range[1][1] - mouseY / graphie.scale[1];

            if (polygon.snapX > 0) {
              currentX = Math.round(currentX / polygon.snapX) * polygon.snapX;
            }

            if (polygon.snapY > 0) {
              currentY = Math.round(currentY / polygon.snapY) * polygon.snapY;
            }

            if (event.type === "vmousemove") {
              let dX = currentX - startX;
              let dY = currentY - startY;
              let doMove = true;

              if (___default["default"].isFunction(polygon.onMove)) {
                const onMoveResult = polygon.onMove(dX, dY);

                if (onMoveResult === false) {
                  doMove = false;
                } else if (___default["default"].isArray(onMoveResult)) {
                  dX = onMoveResult[0];
                  dY = onMoveResult[1];
                  currentX = startX + dX;
                  currentY = startY + dY;
                }
              }

              const increment = function (i) {
                return [polygonCoords[i][0] + dX, polygonCoords[i][1] + dY];
              };

              if (doMove) {
                ___default["default"].each(polygon.points, function (coordOrPoint, i) {
                  if (isPoint(coordOrPoint)) {
                    coordOrPoint.setCoord(increment(i));
                  } else {
                    polygon.points[i] = increment(i);
                  }
                });

                polygon.transform();
                $__default["default"](polygon).trigger("move");
                lastX = currentX;
                lastY = currentY;
              }
            } else if (event.type === "vmouseup") {
              $__default["default"](document).unbind(".polygon");

              const points = ___default["default"].filter(polygon.points, isPoint);

              ___default["default"].each(points, function (point) {
                point.dragging = false;
              });

              polygon.dragging = false;
              dragging = false;

              if (!polygon.highlight) {
                polygon.visibleShape.animate(polygon.normalStyle, 50);

                ___default["default"].each(points, function (point) {
                  point.visibleShape.animate(point.normalStyle, 50);
                });
              }

              if (___default["default"].isFunction(polygon.onMoveEnd)) {
                polygon.onMoveEnd(lastX - startX, lastY - startY);
              }
            }
          });
        }
      });
    } // Bring any movable points to the front


    ___default["default"].invoke(___default["default"].filter(polygon.points, isPoint), "toFront");

    return polygon;
  },

  /**
   * Constrain a point to be within the graph (including padding).
   * If outside graph, point's x and y coordinates are clamped within
   * the graph.
   */
  constrainToBounds: function (point, padding) {
    const lower = this.unscalePoint([padding, this.ypixels - padding]);
    const upper = this.unscalePoint([this.xpixels - padding, padding]);
    const coordX = Math.max(lower[0], Math.min(upper[0], point[0]));
    const coordY = Math.max(lower[1], Math.min(upper[1], point[1]));
    return [coordX, coordY];
  },

  /**
   * Constrain a point to be within the graph (including padding).
   * If outside graph, point is moved along the ray specified by angle
   * until inside graph.
   */
  constrainToBoundsOnAngle: function (point, padding, angle) {
    const lower = this.unscalePoint([padding, this.ypixels - padding]);
    const upper = this.unscalePoint([this.xpixels - padding, padding]);
    let result = point.slice();

    if (result[0] < lower[0]) {
      result = [lower[0], result[1] + (lower[0] - result[0]) * Math.tan(angle)];
    } else if (result[0] > upper[0]) {
      result = [upper[0], result[1] - (result[0] - upper[0]) * Math.tan(angle)];
    }

    if (result[1] < lower[1]) {
      result = [result[0] + (lower[1] - result[1]) / Math.tan(angle), lower[1]];
    } else if (result[1] > upper[1]) {
      result = [result[0] - (result[1] - upper[1]) / Math.tan(angle), upper[1]];
    }

    return result;
  },
  // MovableAngle is an angle that can be dragged around the screen.
  // By attaching a smartPoint to the vertex and ray control points, the
  // rays can be manipulated individually.
  //
  // Use only with smartPoints; add the smartPoints first, then:
  //   addMovableAngle({points: [...]});
  //
  // The rays can be controlled to snap on degrees (more useful than snapping
  // on coordinates) by setting snapDegrees to a positive integer.
  //
  // The returned object includes the following properties/methods:
  //
  //   - movableAngle.points
  //         The movableAngle's dynamic smartPoints.
  //
  //   - movableAngle.coords
  //         The movableAngle's current coordinates (generated, don't edit).
  //
  addMovableAngle: function (options) {
    // $FlowFixMe[invalid-constructor]
    return new MovableAngle(this, options);
  },
  // center: movable point
  // radius: int
  // circ: graphie circle
  // perim: invisible mouse target for dragging/changing radius
  addCircleGraph: function (options) {
    const graphie = this;
    const circle = $__default["default"].extend({
      center: [0, 0],
      radius: 2,
      snapX: 0.5,
      snapY: 0.5,
      snapRadius: 0.5,
      minRadius: 1,
      centerConstraints: {},
      centerNormalStyle: {},
      centerHighlightStyle: {
        stroke: KhanColors.INTERACTING,
        fill: KhanColors.INTERACTING
      },
      circleNormalStyle: {
        stroke: KhanColors.INTERACTIVE,
        "fill-opacity": 0
      },
      circleHighlightStyle: {
        stroke: KhanColors.INTERACTING,
        fill: KhanColors.INTERACTING,
        "fill-opacity": 0.05
      }
    }, options);
    const normalColor = circle.centerConstraints.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    const centerNormalStyle = options ? options.centerNormalStyle : null;
    circle.centerNormalStyle = ___default["default"].extend({}, {
      fill: normalColor,
      stroke: normalColor
    }, centerNormalStyle);
    circle.centerPoint = graphie.addMovablePoint({
      graph: graphie,
      coord: circle.center,
      normalStyle: circle.centerNormalStyle,
      snapX: circle.snapX,
      snapY: circle.snapY,
      constraints: circle.centerConstraints
    });
    circle.circ = graphie.circle(circle.center, circle.radius, circle.circleNormalStyle);
    circle.perim = graphie.mouselayer.circle(graphie.scalePoint(circle.center)[0], graphie.scalePoint(circle.center)[1], graphie.scaleVector(circle.radius)[0]).attr({
      "stroke-width": 20,
      opacity: 0.002 // This is as close to 0 as MSIE will allow

    }); // Highlight circle circumference on center point hover

    if (!circle.centerConstraints.fixed) {
      $__default["default"](circle.centerPoint.mouseTarget.getMouseTarget()).on("vmouseover vmouseout", function (event) {
        if (circle.centerPoint.highlight || circle.centerPoint.dragging) {
          circle.circ.animate(circle.circleHighlightStyle, 50);
        } else {
          circle.circ.animate(circle.circleNormalStyle, 50);
        }
      });
    }

    circle.toFront = function () {
      circle.circ.toFront();
      circle.perim.toFront();
      circle.centerPoint.visibleShape.toFront();

      if (!circle.centerConstraints.fixed) {
        circle.centerPoint.mouseTarget.toFront();
      }
    };

    circle.centerPoint.onMove = function (x, y) {
      circle.toFront();
      circle.circ.attr({
        cx: graphie.scalePoint(x)[0],
        cy: graphie.scalePoint(y)[1]
      });
      circle.perim.attr({
        cx: graphie.scalePoint(x)[0],
        cy: graphie.scalePoint(y)[1]
      });

      if (circle.onMove) {
        circle.onMove(x, y);
      }
    };

    $__default["default"](circle.centerPoint).on("move", function () {
      circle.center = this.coord;
      $__default["default"](circle).trigger("move");
    }); // circle.setCenter(x, y) moves the circle to the specified
    // x, y coordinate as if the user had dragged it there.

    circle.setCenter = function (x, y) {
      circle.centerPoint.setCoord([x, y]);
      circle.centerPoint.onMove(x, y);
      circle.center = [x, y];
    }; // circle.setRadius(r) sets the circle's radius to the specified
    // value as if the user had dragged it there.


    circle.setRadius = function (r) {
      circle.radius = r;
      circle.perim.attr({
        r: graphie.scaleVector(r)[0]
      });
      circle.circ.attr({
        rx: graphie.scaleVector(r)[0],
        ry: graphie.scaleVector(r)[1]
      });
    };

    circle.remove = function () {
      circle.centerPoint.remove();
      circle.circ.remove();
      circle.perim.remove();
    }; // Define a set of axes using polar coordinates to specify
    // which resizing cursor we want to show based on where the
    // mouse position lies in relation to the circle's center.
    // The first two columns in cursorAxes refer to the minimum
    // and maximum angle values bounding a circle sector, and
    // the third column refers to the cursor name that will be
    // applied if the mouse position falls inside the given sector.


    const cursorAxes = [[Math.PI * -1.0, Math.PI * -0.875, "ew-resize"], [Math.PI * -0.875, Math.PI * -0.625, "nesw-resize"], [Math.PI * -0.625, Math.PI * -0.375, "ns-resize"], [Math.PI * -0.375, Math.PI * -0.125, "nwse-resize"], [Math.PI * -0.125, Math.PI * 0.125, "ew-resize"], [Math.PI * 0.125, Math.PI * 0.375, "nesw-resize"], [Math.PI * 0.375, Math.PI * 0.625, "ns-resize"], [Math.PI * 0.625, Math.PI * 0.875, "nwse-resize"], [Math.PI * 0.875, Math.PI * 1.0, "ew-resize"]]; // When the mouse moves along the circle's perimeter, we
    // dynamically set a CSS rule to show the correct
    // bidirectional cursor so a student knows they can resize
    // our circle. To do this, we convert the x and y coordinates
    // of the mouse position into polar coordinates and use the
    // defined cursorAxes above to set our rule.

    $__default["default"](circle.perim.node).on("vmousemove", event => {
      let [x, y] = this.getMouseCoord(event);
      x -= circle.center[0];
      y -= circle.center[1];
      const theta = Math.atan2(y, x);
      cursorAxes.forEach(function (axes) {
        const [min, max, cursorName] = axes;

        if (theta >= min && theta < max) {
          $__default["default"](circle.perim.node).css("cursor", cursorName);
        }
      });
    }); // Set a default resizing-friendly cursor to be safe.

    $__default["default"](circle.perim.node).css("cursor", "nesw-resize"); // Prevent the page from scrolling when we grab and drag the circle on
    // a mobile device.

    circle.perim.node.addEventListener("touchstart", function (event) {
      event.preventDefault();
    }, {
      passive: false
    });
    $__default["default"](circle.perim.node).on("vmouseover vmouseout vmousedown", function (event) {
      if (event.type === "vmouseover") {
        circle.highlight = true;

        if (!dragging) {
          // TODO(jack): Figure out why this doesn't work
          // for circleHighlightStyle's that change
          // stroke-dasharray
          circle.circ.animate(circle.circleHighlightStyle, 50);
          circle.centerPoint.visibleShape.animate(circle.centerHighlightStyle, 50);
        }
      } else if (event.type === "vmouseout") {
        circle.highlight = false;

        if (!circle.dragging && !circle.centerPoint.dragging) {
          circle.circ.animate(circle.circleNormalStyle, 50);
          circle.centerPoint.visibleShape.animate(circle.centerNormalStyle, 50);
        }
      } else if (event.type === "vmousedown" && (event.which === 1 || event.which === 0)) {
        event.preventDefault();
        circle.toFront();
        const startRadius = circle.radius;
        $__default["default"](document).on("vmousemove vmouseup", function (event) {
          event.preventDefault();
          circle.dragging = true;
          dragging = true;

          if (event.type === "vmousemove") {
            const coord = graphie.constrainToBounds(graphie.getMouseCoord(event), 10);
            let radius = GraphUtils.getDistance(circle.centerPoint.coord, coord);
            radius = Math.max(circle.minRadius, Math.round(radius / circle.snapRadius) * circle.snapRadius);
            const oldRadius = circle.radius;
            let doResize = true;

            if (circle.onResize) {
              const onResizeResult = circle.onResize(radius, oldRadius);

              if (___default["default"].isNumber(onResizeResult)) {
                radius = onResizeResult;
              } else if (onResizeResult === false) {
                doResize = false;
              }
            }

            if (doResize) {
              circle.setRadius(radius);
              $__default["default"](circle).trigger("move");
            }
          } else if (event.type === "vmouseup") {
            $__default["default"](document).off("vmousemove vmouseup");
            circle.dragging = false;
            dragging = false;

            if (circle.onResizeEnd) {
              circle.onResizeEnd(circle.radius, startRadius);
            }
          }
        });
      }
    });
    return circle;
  },
  addRotateHandle: function () {
    const drawRotateHandle = function (graphie, center, radius, halfWidth, lengthAngle, angle, interacting) {
      const getRotateHandlePoint = function (offset, distanceFromArrowMidline) {
        const distFromRotationCenter = radius + distanceFromArrowMidline;
        const vec = kmath.vector.cartFromPolarDeg(distFromRotationCenter, angle + offset);
        const absolute = kmath.vector.add(center, vec);
        const pixels = graphie.scalePoint(absolute);
        return pixels[0] + "," + pixels[1];
      };

      const innerR = graphie.scaleVector(radius - halfWidth);
      const outerR = graphie.scaleVector(radius + halfWidth); // Draw the double-headed arrow thing that shows users where to
      // click and drag to rotate

      return graphie.raphael.path( // upper arrowhead
      " M" + getRotateHandlePoint(lengthAngle, -halfWidth) + " L" + getRotateHandlePoint(lengthAngle, -3 * halfWidth) + " L" + getRotateHandlePoint(2 * lengthAngle, 0) + " L" + getRotateHandlePoint(lengthAngle, 3 * halfWidth) + " L" + getRotateHandlePoint(lengthAngle, halfWidth) + // outer arc
      " A" + outerR[0] + "," + outerR[1] + ",0,0,1," + getRotateHandlePoint(-lengthAngle, halfWidth) + // lower arrowhead
      " L" + getRotateHandlePoint(-lengthAngle, 3 * halfWidth) + " L" + getRotateHandlePoint(-2 * lengthAngle, 0) + " L" + getRotateHandlePoint(-lengthAngle, -3 * halfWidth) + " L" + getRotateHandlePoint(-lengthAngle, -halfWidth) + // inner arc
      " A" + innerR[0] + "," + innerR[1] + ",0,0,0," + getRotateHandlePoint(lengthAngle, -halfWidth) + " Z").attr({
        stroke: null,
        fill: interacting ? KhanColors.INTERACTING : KhanColors.INTERACTIVE
      });
    };

    return function (options) {
      const graph = this;
      let rotatePoint = options.center;
      const radius = options.radius;
      const lengthAngle = options.lengthAngle || 30;
      const hideArrow = options.hideArrow || false;
      const mouseTarget = options.mouseTarget;

      const id = ___default["default"].uniqueId("rotateHandle"); // Normalize rotatePoint into something that always looks
      // like a movablePoint


      if (___default["default"].isArray(rotatePoint)) {
        rotatePoint = {
          coord: rotatePoint
        };
      }

      const rotateHandle = graph.addMovablePoint({
        coord: kmath.point.addVector(rotatePoint.coord, kmath.vector.cartFromPolarDeg(radius, options.angleDeg || 0)),
        constraints: {
          fixedDistance: {
            dist: radius,
            point: rotatePoint
          }
        },
        mouseTarget: mouseTarget
      }); // move the rotatePoint in front of the rotateHandle to avoid
      // confusing clicking/scaling of the rotateHandle when the user
      // intends to click on the rotatePoint
      // $FlowFixMe[prop-missing]

      rotatePoint.toFront();
      let rotatePointPrevCoord = rotatePoint.coord;
      let rotateHandlePrevCoord = rotateHandle.coord;
      let rotateHandleStartCoord = rotateHandlePrevCoord;
      let isRotating = false;
      let isHovering = false;
      let drawnRotateHandle;

      const redrawRotateHandle = function (handleCoord) {
        if (hideArrow) {
          return; // Don't draw anything!
        }

        const handleVec = kmath.vector.subtract(handleCoord, rotatePoint.coord);
        const handlePolar = kmath.vector.polarDegFromCart(handleVec);
        const angle = handlePolar[1];

        if (drawnRotateHandle) {
          drawnRotateHandle.remove();
        }

        drawnRotateHandle = drawRotateHandle(graph, rotatePoint.coord, options.radius, isRotating || isHovering ? options.hoverWidth / 2 : options.width / 2, lengthAngle, angle, isRotating || isHovering);
      }; // when the rotation center moves, we need to move
      // the rotationHandle as well, or it will end up out
      // of sync


      $__default["default"](rotatePoint).on("move." + id, function () {
        const delta = kmath.vector.subtract(rotatePoint.coord, rotatePointPrevCoord);
        rotateHandle.setCoord(kmath.vector.add(rotateHandle.coord, delta));
        redrawRotateHandle(rotateHandle.coord);
        rotatePointPrevCoord = rotatePoint.coord;
        rotateHandle.constraints.fixedDistance.point = rotatePoint;
        rotateHandlePrevCoord = rotateHandle.coord;
      }); // Rotate polygon with rotateHandle

      rotateHandle.onMove = function (x, y) {
        if (!isRotating) {
          rotateHandleStartCoord = rotateHandlePrevCoord;
          isRotating = true;
        }

        let coord = [x, y];

        if (options.onMove) {
          const oldPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(rotateHandlePrevCoord, rotatePoint.coord));
          const newPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(coord, rotatePoint.coord));
          const oldAngle = oldPolar[1];
          const newAngle = newPolar[1];
          let result = options.onMove(newAngle, oldAngle); // $FlowFixMe[incompatible-type] add proper onMove param type

          if (result != null && result !== true) {
            // $FlowFixMe[incompatible-type] add proper onMove param type
            if (result === false) {
              result = oldAngle;
            }

            coord = kmath.vector.add(rotatePoint.coord, kmath.vector.cartFromPolarDeg(oldPolar[0], result));
          }
        }

        redrawRotateHandle(coord);
        rotateHandlePrevCoord = coord;
        return coord;
      };

      rotateHandle.onMoveEnd = function () {
        isRotating = false;
        redrawRotateHandle(rotateHandle.coord);

        if (options.onMoveEnd) {
          const oldPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(rotateHandleStartCoord, rotatePoint.coord));
          const newPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(rotateHandle.coord, rotatePoint.coord));
          options.onMoveEnd(newPolar[1], oldPolar[1]);
        }
      }; // Remove the default dot added by the movablePoint since we have
      // our double-arrow thing


      rotateHandle.visibleShape.remove();

      if (!mouseTarget) {
        // Make the default mouse target bigger to encompass the whole
        // area around the double-arrow thing
        rotateHandle.mouseTarget.attr({
          scale: 2
        });
      }

      const $mouseTarget = $__default["default"](rotateHandle.mouseTarget.getMouseTarget());
      $mouseTarget.bind("vmouseover", function (e) {
        isHovering = true;
        redrawRotateHandle(rotateHandle.coord);
      });
      $mouseTarget.bind("vmouseout", function (e) {
        isHovering = false;
        redrawRotateHandle(rotateHandle.coord);
      });
      redrawRotateHandle(rotateHandle.coord);
      const oldRemove = rotateHandle.remove;

      rotateHandle.remove = function () {
        oldRemove.call(rotateHandle);

        if (drawnRotateHandle) {
          drawnRotateHandle.remove();
        }

        $__default["default"](rotatePoint).off("move." + id);
      };

      rotateHandle.update = function () {
        redrawRotateHandle(rotateHandle.coord);
      };

      return rotateHandle;
    };
  }(),
  addReflectButton: function () {
    const drawButton = function (graphie, buttonCoord, lineCoords, size, distanceFromCenter, leftStyle, rightStyle) {
      // Avoid invalid lines
      if (kmath.point.equal(lineCoords[0], lineCoords[1])) {
        lineCoords = [lineCoords[0], kmath.point.addVector(lineCoords[0], [1, 1])];
      }

      const lineDirection = kmath.vector.normalize(kmath.vector.subtract(lineCoords[1], lineCoords[0]));
      const lineVec = kmath.vector.scale(lineDirection, size / 2);
      const centerVec = kmath.vector.scale(lineDirection, distanceFromCenter);
      const leftCenterVec = kmath.vector.rotateDeg(centerVec, 90);
      const rightCenterVec = kmath.vector.rotateDeg(centerVec, -90);
      const negLineVec = kmath.vector.negate(lineVec);
      const leftVec = kmath.vector.rotateDeg(lineVec, 90);
      const rightVec = kmath.vector.rotateDeg(lineVec, -90);
      const leftCenter = kmath.point.addVectors(buttonCoord, leftCenterVec);
      const rightCenter = kmath.point.addVectors(buttonCoord, rightCenterVec);
      const leftCoord1 = kmath.point.addVectors(buttonCoord, leftCenterVec, lineVec, leftVec);
      const leftCoord2 = kmath.point.addVectors(buttonCoord, leftCenterVec, negLineVec, leftVec);
      const rightCoord1 = kmath.point.addVectors(buttonCoord, rightCenterVec, lineVec, rightVec);
      const rightCoord2 = kmath.point.addVectors(buttonCoord, rightCenterVec, negLineVec, rightVec);
      const leftButton = graphie.path([leftCenter, leftCoord1, leftCoord2, true], leftStyle);
      const rightButton = graphie.path([rightCenter, rightCoord1, rightCoord2, true], rightStyle);
      return {
        remove: function () {
          leftButton.remove();
          rightButton.remove();
        }
      };
    };

    return function (options) {
      const graphie = this;
      const line = options.line;
      const button = graphie.addMovablePoint({
        constraints: options.constraints,
        coord: kmath.line.midpoint([line.pointA.coord, line.pointZ.coord]),
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        onMove: function (x, y) {
          // Don't allow the button to actually move. This is a hack
          // around the inability to both set a point as fixed AND
          // allow it to be clicked.
          return false;
        },
        onMoveEnd: function (x, y) {
          if (options.onMoveEnd) {
            options.onMoveEnd.call(this, x, y);
          }
        }
      });
      let isHovering = false;
      let isFlipped = false;
      let currentlyDrawnButton;

      const isHighlight = function () {
        return isHovering;
      };

      const styles = ___default["default"].map([0, 1], function (isHighlight) {
        const baseStyle = isHighlight ? options.highlightStyle : options.normalStyle;
        return ___default["default"].map([0, 1], function (opacity) {
          return ___default["default"].defaults({
            "fill-opacity": opacity
          }, baseStyle);
        });
      });

      const getStyle = function (isRight) {
        if (isFlipped) {
          isRight = !isRight;
        }

        return styles[+isHighlight()][+isRight];
      };

      const redraw = function (coord, lineCoords) {
        if (currentlyDrawnButton) {
          currentlyDrawnButton.remove();
        }

        currentlyDrawnButton = drawButton(graphie, coord, lineCoords, isHighlight() ? options.size * 1.5 : options.size, isHighlight() ? options.size * 0.125 : 0.25, getStyle(0), getStyle(1));
      };

      const update = function (coordA, coordZ) {
        coordA = coordA || line.pointA.coord;
        coordZ = coordZ || line.pointZ.coord;
        const buttonCoord = kmath.line.midpoint([coordA, coordZ]);
        button.setCoord(buttonCoord);
        redraw(buttonCoord, [coordA, coordZ]);
      };

      $__default["default"](line).on("move", ___default["default"].bind(update, button, null, null));
      const $mouseTarget = $__default["default"](button.mouseTarget.getMouseTarget());
      $mouseTarget.on("vclick", function () {
        const result = options.onClick();

        if (result !== false) {
          isFlipped = !isFlipped;
          redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
        }
      }); // Bring the reflection line handles in front of the button, so
      // that if we drag the reflectPoints really close together, we can
      // still move the handles away from each other, rather than only
      // being able to apply the reflection.

      line.pointA.toFront();
      line.pointZ.toFront(); // Replace the visual point with the double triangle thing

      button.visibleShape.remove();
      const pointScale = graphie.scaleVector(options.size)[0] / 20;
      button.mouseTarget.attr({
        scale: 1.5 * pointScale
      });
      $mouseTarget.css("cursor", "pointer"); // Make the arrow-thing grow and shrink with mouseover/out

      $mouseTarget.bind("vmouseover", function (e) {
        isHovering = true;
        redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
      });
      $mouseTarget.bind("vmouseout", function (e) {
        isHovering = false;
        redraw(button.coord, [line.pointA.coord, line.pointZ.coord]);
      });
      const oldButtonRemove = button.remove;

      button.remove = function () {
        currentlyDrawnButton.remove();
        oldButtonRemove.call(button);
      };

      button.update = update;

      button.isFlipped = function () {
        return isFlipped;
      };

      update();
      return button;
    };
  }(),
  protractor: function (center) {
    // $FlowFixMe[invalid-constructor]
    return new Protractor(this, center);
  },
  ruler: function (options) {
    // $FlowFixMe[invalid-constructor]
    return new Ruler(this, options || {});
  },
  addPoints: addPoints
});

function Protractor(graph, center) {
  this.set = graph.raphael.set();
  this.cx = center[0];
  this.cy = center[1];
  const pro = this;
  const r = graph.unscaleVector(180.5)[0];
  const imgPos = graph.scalePoint([this.cx - r, this.cy + r - graph.unscaleVector(10.5)[1]]);
  const image = graph.mouselayer.image("https://ka-perseus-graphie.s3.amazonaws.com/e9d032f2ab8b95979f674fbfa67056442ba1ff6a.png", imgPos[0], imgPos[1], 360, 180);
  this.set.push(image); // Prevent the page from scrolling when we grab and drag the image on a
  // mobile device.

  image.node.addEventListener("touchstart", function (event) {
    event.preventDefault();
  }, {
    passive: false
  });

  const arrowHelper = function (angle, pixelsFromEdge) {
    const scaledRadius = graph.scaleVector(r);
    scaledRadius[0] -= 16;
    scaledRadius[1] -= 16;
    const scaledCenter = graph.scalePoint(center);
    const x = Math.sin((angle + 90) * Math.PI / 180) * (scaledRadius[0] + pixelsFromEdge) + scaledCenter[0];
    const y = Math.cos((angle + 90) * Math.PI / 180) * (scaledRadius[1] + pixelsFromEdge) + scaledCenter[1];
    return x + "," + y;
  };

  const arrow = graph.raphael.path(" M" + arrowHelper(180, 6) + " L" + arrowHelper(180, 2) + " L" + arrowHelper(183, 10) + " L" + arrowHelper(180, 18) + " L" + arrowHelper(180, 14) + " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,1," + arrowHelper(170, 14) + " L" + arrowHelper(170, 18) + " L" + arrowHelper(167, 10) + " L" + arrowHelper(170, 2) + " L" + arrowHelper(170, 6) + " A" + (graph.scaleVector(r)[0] + 10) + "," + (graph.scaleVector(r)[1] + 10) + ",0,0,0," + arrowHelper(180, 6) + " Z").attr({
    stroke: null,
    fill: KhanColors.INTERACTIVE
  }); // add it to the set so it translates with everything else

  this.set.push(arrow);
  this.centerPoint = graph.addMovablePoint({
    coord: center,
    visible: false
  }); // Use a movablePoint for rotation

  this.rotateHandle = graph.addMovablePoint({
    bounded: false,
    coord: [Math.sin(275 * Math.PI / 180) * r + this.cx, Math.cos(275 * Math.PI / 180) * r + this.cy],
    onMove: function (x, y) {
      const angle = Math.atan2(pro.centerPoint.coord[1] - y, pro.centerPoint.coord[0] - x) * 180 / Math.PI;
      pro.rotate(-angle - 5, true);
    }
  }); // Add a constraint so the point moves in a circle

  this.rotateHandle.constraints.fixedDistance.dist = r;
  this.rotateHandle.constraints.fixedDistance.point = this.centerPoint; // Remove the default dot added by the movablePoint since we have our
  // double-arrow thing

  this.rotateHandle.visibleShape.remove(); // Make the mouse target bigger to encompass the whole area around the
  // double-arrow thing

  this.rotateHandle.mouseTarget.attr({
    scale: 2.0
  });
  let isDragging = false;
  let isHovering = false;

  const isHighlight = function () {
    return isHovering || isDragging;
  };

  const self = this;
  const $mouseTarget = $__default["default"](self.rotateHandle.mouseTarget.getMouseTarget());
  $mouseTarget.bind("vmousedown", function (event) {
    isDragging = true;
    $mouseTarget.css("cursor", "-webkit-grabbing");
    $mouseTarget.css("cursor", "grabbing");
    arrow.animate({
      scale: 1.5,
      fill: KhanColors.INTERACTING
    }, 50);
    $__default["default"](document).bind("vmouseup.rotateHandle", function (event) {
      isDragging = false;
      $mouseTarget.css("cursor", "-webkit-grab");
      $mouseTarget.css("cursor", "grab");

      if (!isHighlight()) {
        arrow.animate({
          scale: 1.0,
          fill: KhanColors.INTERACTIVE
        }, 50);
      }

      $__default["default"](document).unbind("vmouseup.rotateHandle");
    });
  });
  $mouseTarget.bind("vmouseover", function (event) {
    isHovering = true;
    arrow.animate({
      scale: 1.5,
      fill: KhanColors.INTERACTING
    }, 50);
  });
  $mouseTarget.bind("vmouseout", function (event) {
    isHovering = false;

    if (!isHighlight()) {
      arrow.animate({
        scale: 1.0,
        fill: KhanColors.INTERACTIVE
      }, 50);
    }
  });
  const setNodes = $__default["default"].map(this.set, function (el) {
    return el.node;
  });

  this.makeTranslatable = function makeTranslatable() {
    $__default["default"](setNodes).css("cursor", "move");
    $mouseTarget.css("cursor", "-webkit-grab");
    $mouseTarget.css("cursor", "grab");
    $__default["default"](setNodes).bind("vmousedown", function (event) {
      event.preventDefault();
      let startx = event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left;
      let starty = event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top;
      $__default["default"](document).bind("vmousemove.protractor", function (event) {
        let mouseX = event.pageX - $__default["default"](graph.raphael.canvas.parentNode).offset().left;
        let mouseY = event.pageY - $__default["default"](graph.raphael.canvas.parentNode).offset().top; // can't go beyond 10 pixels from the edge

        mouseX = Math.max(10, Math.min(graph.xpixels - 10, mouseX));
        mouseY = Math.max(10, Math.min(graph.ypixels - 10, mouseY));
        const dx = mouseX - startx;
        const dy = mouseY - starty;
        $__default["default"].each(pro.set.items, function () {
          this.translate(dx, dy);
        });
        pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
        pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
        startx = mouseX;
        starty = mouseY;
      });
      $__default["default"](document).one("vmouseup", function (event) {
        $__default["default"](document).unbind("vmousemove.protractor");
      });
    });
  };

  this.rotation = 0;

  this.rotate = function (offset, absolute) {
    const center = graph.scalePoint(this.centerPoint.coord);

    if (absolute) {
      this.rotation = 0;
    }

    this.set.rotate(this.rotation + offset, center[0], center[1]);
    this.rotation = this.rotation + offset;
    return this;
  };

  this.moveTo = function moveTo(x, y) {
    const start = graph.scalePoint(pro.centerPoint.coord);
    const end = graph.scalePoint([x, y]);
    const time = GraphUtils.getDistance(start, end) * 2;
    $__default["default"]({
      x: start[0],
      y: start[1]
    }).animate({
      x: end[0],
      y: end[1]
    }, {
      duration: time,
      step: function (now, fx) {
        let dx = 0;
        let dy = 0;

        if (fx.prop === "x") {
          dx = now - graph.scalePoint(pro.centerPoint.coord)[0];
        } else if (fx.prop === "y") {
          dy = now - graph.scalePoint(pro.centerPoint.coord)[1];
        }

        $__default["default"].each(pro.set.items, function () {
          this.translate(dx, dy);
        });
        pro.centerPoint.setCoord([pro.centerPoint.coord[0] + dx / graph.scale[0], pro.centerPoint.coord[1] - dy / graph.scale[1]]);
        pro.rotateHandle.setCoord([pro.rotateHandle.coord[0] + dx / graph.scale[0], pro.rotateHandle.coord[1] - dy / graph.scale[1]]);
      }
    });
  };

  this.rotateTo = function rotateTo(angle) {
    if (Math.abs(this.rotation - angle) > 180) {
      this.rotation += 360;
    }

    const time = Math.abs(this.rotation - angle) * 5; // $FlowFixMe[unsupported-syntax]

    $__default["default"]({
      0: this.rotation
    }).animate( // $FlowFixMe[unsupported-syntax]
    {
      0: angle
    }, {
      duration: time,
      step: function (now, fx) {
        pro.rotate(now, true);
        pro.rotateHandle.setCoord([Math.sin((now + 275) * Math.PI / 180) * r + pro.centerPoint.coord[0], Math.cos((now + 275) * Math.PI / 180) * r + pro.centerPoint.coord[1]]);
      }
    });
  };

  this.remove = function () {
    this.set.remove();
  };

  this.makeTranslatable();
  return this;
}

function Ruler(graphie, options) {
  ___default["default"].defaults(options, {
    center: [0, 0],
    pixelsPerUnit: 40,
    ticksPerUnit: 10,
    // 10 or power of 2
    units: 10,
    // the length the ruler can measure
    label: "",
    // e.g "cm" (the shorter, the better)
    style: {
      fill: null,
      stroke: KhanColors.GRAY
    }
  });

  const light = ___default["default"].extend({}, options.style, {
    strokeWidth: 1
  });

  const bold = ___default["default"].extend({}, options.style, {
    strokeWidth: 2
  });

  const width = options.units * options.pixelsPerUnit;
  const height = 50;
  const leftBottom = graphie.unscalePoint(kmath.vector.subtract(graphie.scalePoint(options.center), kmath.vector.scale([width, -height], 0.5)));
  const graphieUnitsPerUnit = options.pixelsPerUnit / graphie.scale[0];
  const graphieUnitsHeight = height / graphie.scale[0];
  const rightTop = kmath.vector.add(leftBottom, [options.units * graphieUnitsPerUnit, graphieUnitsHeight]);
  const tickHeight = 1.0;
  let tickHeightMap;

  if (options.ticksPerUnit === 10) {
    // decimal, as on a centimeter ruler
    tickHeightMap = {
      // $FlowFixMe[unsupported-syntax]
      10: tickHeight,
      // $FlowFixMe[unsupported-syntax]
      5: tickHeight * 0.55,
      // $FlowFixMe[unsupported-syntax]
      1: tickHeight * 0.35
    };
  } else {
    const sizes = [1, 0.6, 0.45, 0.3];
    tickHeightMap = {};

    for (let i = options.ticksPerUnit; i >= 1; i /= 2) {
      tickHeightMap[i] = tickHeight * (sizes.shift() || 0.2);
    }
  }

  const tickFrequencies = ___default["default"].keys(tickHeightMap).sort(function (a, b) {
    return b - a;
  });

  function getTickHeight(i) {
    for (let k = 0; k < tickFrequencies.length; k++) {
      const key = tickFrequencies[k];

      if (i % key === 0) {
        return tickHeightMap[key];
      }
    }

    return 0;
  }

  const left = leftBottom[0];
  const bottom = leftBottom[1];
  const right = rightTop[0];
  const top = rightTop[1];
  const numTicks = options.units * options.ticksPerUnit + 1;
  const set = graphie.raphael.set();
  const px = 1 / graphie.scale[0];
  set.push(graphie.line([left - px, bottom], [right + px, bottom], bold));
  set.push(graphie.line([left - px, top], [right + px, top], bold));

  ___default["default"].times(numTicks, function (i) {
    const n = i / options.ticksPerUnit;
    const x = left + n * graphieUnitsPerUnit;
    const height = getTickHeight(i) * graphieUnitsHeight;
    const style = i === 0 || i === numTicks - 1 ? bold : light;
    set.push(graphie.line([x, bottom], [x, bottom + height], style));

    if (n % 1 === 0) {
      const coord = graphie.scalePoint([x, top]);
      let text;
      let offset;

      if (n === 0) {
        // Unit label
        text = options.label;
        offset = {
          mm: 13,
          cm: 11,
          m: 8,
          km: 11,
          in: 8,
          ft: 8,
          yd: 10,
          mi: 10
        }[text] || 3 * text.toString().length;
      } else {
        // Tick label
        text = n;
        offset = -3 * (n.toString().length + 1);
      }

      const label = graphie.raphael.text(coord[0] + offset, coord[1] + 10, text);
      label.attr({
        "font-family": "KaTeX_Main",
        "font-size": "12px",
        color: "#444"
      });
      set.push(label);
    }
  });

  const mouseTarget = graphie.mouselayer.path(GraphUtils.svgPath([leftBottom, [left, top], rightTop, [right, bottom],
  /* closed */
  true]));
  mouseTarget.attr({
    fill: "#000",
    opacity: 0,
    stroke: "#000",
    "stroke-width": 2
  });
  set.push(mouseTarget); // Prevent the page from scrolling when we grab and drag the ruler on a
  // mobile device.

  mouseTarget.node.addEventListener("touchstart", function (event) {
    event.preventDefault();
  }, {
    passive: false
  });
  const setNodes = $__default["default"].map(set, function (el) {
    return el.node;
  });
  $__default["default"](setNodes).css("cursor", "move");
  $__default["default"](setNodes).bind("vmousedown", function (event) {
    event.preventDefault();
    let startx = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
    let starty = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top;
    $__default["default"](document).bind("vmousemove.ruler", function (event) {
      let mouseX = event.pageX - $__default["default"](graphie.raphael.canvas.parentNode).offset().left;
      let mouseY = event.pageY - $__default["default"](graphie.raphael.canvas.parentNode).offset().top; // can't go beyond 10 pixels from the edge

      mouseX = Math.max(10, Math.min(graphie.xpixels - 10, mouseX));
      mouseY = Math.max(10, Math.min(graphie.ypixels - 10, mouseY));
      const dx = mouseX - startx;
      const dy = mouseY - starty;
      set.translate(dx, dy);
      leftBottomHandle.setCoord([leftBottomHandle.coord[0] + dx / graphie.scale[0], leftBottomHandle.coord[1] - dy / graphie.scale[1]]);
      rightBottomHandle.setCoord([rightBottomHandle.coord[0] + dx / graphie.scale[0], rightBottomHandle.coord[1] - dy / graphie.scale[1]]);
      startx = mouseX;
      starty = mouseY;
    });
    $__default["default"](document).one("vmouseup", function (event) {
      $__default["default"](document).unbind("vmousemove.ruler");
    });
  });
  const leftBottomHandle = graphie.addMovablePoint({
    coord: leftBottom,
    normalStyle: {
      fill: KhanColors.INTERACTIVE,
      "fill-opacity": 0,
      stroke: KhanColors.INTERACTIVE
    },
    highlightStyle: {
      fill: KhanColors.INTERACTING,
      "fill-opacity": 0.1,
      stroke: KhanColors.INTERACTING
    },
    pointSize: 6,
    // or 8 maybe?
    onMove: function (x, y) {
      const dy = rightBottomHandle.coord[1] - y;
      const dx = rightBottomHandle.coord[0] - x;
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      const center = kmath.vector.scale(kmath.vector.add([x, y], rightBottomHandle.coord), 0.5);
      const scaledCenter = graphie.scalePoint(center);
      const oldCenter = kmath.vector.scale(kmath.vector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
      const scaledOldCenter = graphie.scalePoint(oldCenter);
      const diff = kmath.vector.subtract(scaledCenter, scaledOldCenter);
      set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
      set.translate(diff[0], diff[1]);
    }
  });
  const rightBottomHandle = graphie.addMovablePoint({
    coord: [right, bottom],
    normalStyle: {
      fill: KhanColors.INTERACTIVE,
      "fill-opacity": 0,
      stroke: KhanColors.INTERACTIVE
    },
    highlightStyle: {
      fill: KhanColors.INTERACTING,
      "fill-opacity": 0.1,
      stroke: KhanColors.INTERACTING
    },
    pointSize: 6,
    // or 8 maybe?
    onMove: function (x, y) {
      const dy = y - leftBottomHandle.coord[1];
      const dx = x - leftBottomHandle.coord[0];
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      const center = kmath.vector.scale(kmath.vector.add([x, y], leftBottomHandle.coord), 0.5);
      const scaledCenter = graphie.scalePoint(center);
      const oldCenter = kmath.vector.scale(kmath.vector.add(leftBottomHandle.coord, rightBottomHandle.coord), 0.5);
      const scaledOldCenter = graphie.scalePoint(oldCenter);
      const diff = kmath.vector.subtract(scaledCenter, scaledOldCenter);
      set.rotate(-angle, scaledOldCenter[0], scaledOldCenter[1]);
      set.translate(diff[0], diff[1]);
    }
  }); // Make each handle rotate the ruler about the other one

  leftBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
  leftBottomHandle.constraints.fixedDistance.point = rightBottomHandle;
  rightBottomHandle.constraints.fixedDistance.dist = width / graphie.scale[0];
  rightBottomHandle.constraints.fixedDistance.point = leftBottomHandle;

  this.remove = function () {
    set.remove();
    leftBottomHandle.remove();
    rightBottomHandle.remove();
  };

  return this;
}

function MovableAngle(graphie, options) {
  this.graphie = graphie; // TODO(alex): Move standard colors from math.js to somewhere else
  // so that they are available when this file is first parsed

  ___default["default"].extend(this, options);

  ___default["default"].defaults(this, {
    normalStyle: {
      stroke: KhanColors.INTERACTIVE,
      "stroke-width": 2,
      fill: KhanColors.INTERACTIVE
    },
    highlightStyle: {
      stroke: KhanColors.INTERACTING,
      "stroke-width": 2,
      fill: KhanColors.INTERACTING
    },
    labelStyle: {
      stroke: KhanColors.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors.DYNAMIC
    },
    angleStyle: {
      stroke: KhanColors.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors.DYNAMIC
    },
    allowReflex: true // not on MovableAngle.prototype so that
    // it is not overridden by undefined

  });

  if (!this.points || this.points.length !== 3) {
    throw new PerseusError("MovableAngle requires 3 points", Errors.InvalidInput);
  } // Handle coordinates that are not MovablePoints (i.e. [2, 4])


  this.points = ___default["default"].map(options.points, function (point) {
    if (___default["default"].isArray(point)) {
      return graphie.addMovablePoint({
        coord: point,
        visible: false,
        constraints: {
          fixed: true
        },
        normalStyle: this.normalStyle
      });
    }

    return point;
  }, this);
  this.coords = ___default["default"].pluck(this.points, "coord");

  if (this.reflex == null) {
    if (this.allowReflex) {
      this.reflex = this._getClockwiseAngle(this.coords) > 180;
    } else {
      this.reflex = false;
    }
  }

  this.rays = ___default["default"].map([0, 2], function (i) {
    return graphie.addMovableLineSegment({
      pointA: this.points[1],
      pointZ: this.points[i],
      fixed: true,
      extendRay: true
    });
  }, this);
  this.temp = [];
  this.labeledAngle = graphie.label([0, 0], "", "center", this.labelStyle);

  if (!this.fixed) {
    this.addMoveHandlers();
    this.addHighlightHandlers();
  }

  this.update();
}

___default["default"].extend(MovableAngle.prototype, {
  points: [],
  snapDegrees: 0,
  snapOffsetDeg: 0,
  angleLabel: "",
  numArcs: 1,
  pushOut: 0,
  fixed: false,
  addMoveHandlers: function () {
    const graphie = this.graphie;

    function tooClose(point1, point2) {
      const safeDistance = 30;
      const distance = GraphUtils.getDistance(graphie.scalePoint(point1), graphie.scalePoint(point2));
      return distance < safeDistance;
    }

    const points = this.points; // Drag the vertex to move the entire angle

    points[1].onMove = function (x, y) {
      const oldVertex = points[1].coord;
      const newVertex = [x, y];
      const delta = addPoints(newVertex, reverseVector(oldVertex));
      let valid = true;
      const newPoints = {};

      ___default["default"].each([0, 2], function (i) {
        const oldPoint = points[i].coord;
        let newPoint = addPoints(oldPoint, delta);
        let angle = GraphUtils.findAngle(newVertex, newPoint);
        angle *= Math.PI / 180;
        newPoint = graphie.constrainToBoundsOnAngle(newPoint, 10, angle);
        newPoints[i] = newPoint;

        if (tooClose(newVertex, newPoint)) {
          valid = false;
        }
      }); // Only move points if all new positions are valid


      if (valid) {
        ___default["default"].each(newPoints, function (newPoint, i) {
          points[i].setCoord(newPoint);
        });
      }

      return valid;
    };

    const snap = this.snapDegrees;
    const snapOffset = this.snapOffsetDeg; // Drag ray control points to move each ray individually

    ___default["default"].each([0, 2], function (i) {
      points[i].onMove = function (x, y) {
        const newPoint = [x, y];
        const vertex = points[1].coord;

        if (tooClose(vertex, newPoint)) {
          return false;
        }

        if (snap) {
          let angle = GraphUtils.findAngle(newPoint, vertex);
          angle = Math.round((angle - snapOffset) / snap) * snap + snapOffset;
          const distance = GraphUtils.getDistance(newPoint, vertex);
          return addPoints(vertex, graphie.polar(distance, angle));
        }

        return true;
      };
    }); // Expose only a single move event


    $__default["default"](points).on("move", function () {
      this.update();
      $__default["default"](this).trigger("move");
    }.bind(this));
  },
  addHighlightHandlers: function () {
    const vertex = this.points[1];

    vertex.onHighlight = function () {
      ___default["default"].each(this.points, function (point) {
        point.visibleShape.animate(this.highlightStyle, 50);
      }, this);

      ___default["default"].each(this.rays, function (ray) {
        ray.visibleLine.animate(this.highlightStyle, 50);
        ray.arrowStyle = ___default["default"].extend({}, ray.arrowStyle, {
          color: this.highlightStyle.stroke,
          stroke: this.highlightStyle.stroke
        });
      }, this);

      this.angleStyle = ___default["default"].extend({}, this.angleStyle, {
        color: this.highlightStyle.stroke,
        stroke: this.highlightStyle.stroke
      });
      this.update();
    }.bind(this);

    vertex.onUnhighlight = function () {
      ___default["default"].each(this.points, function (point) {
        point.visibleShape.animate(this.normalStyle, 50);
      }, this);

      ___default["default"].each(this.rays, function (ray) {
        ray.visibleLine.animate(ray.normalStyle, 50);
        ray.arrowStyle = ___default["default"].extend({}, ray.arrowStyle, {
          color: ray.normalStyle.stroke,
          stroke: ray.normalStyle.stroke
        });
      }, this);

      this.angleStyle = ___default["default"].extend({}, this.angleStyle, {
        color: KhanColors.DYNAMIC,
        stroke: KhanColors.DYNAMIC
      });
      this.update();
    }.bind(this);
  },

  /**
   * Returns the angle in [0, 360) degrees created by the
   * coords when interpreted in a clockwise direction.
   */
  _getClockwiseAngle: function (coords) {
    const rawAngle = GraphUtils.findAngle( // The order of these is "weird" to match what a clockwise
    // order is in graphie.labelAngle
    coords[2], // from the second point
    coords[0], // clockwise to the first point
    coords[1] // the vertex parameter is last
    );
    const clockwiseAngle = rawAngle + 360 % 360;
    return clockwiseAngle;
  },
  isReflex: function () {
    return this.reflex;
  },
  isClockwise: function () {
    const clockwiseReflexive = this._getClockwiseAngle(this.coords) > 180;
    return clockwiseReflexive === this.reflex;
  },
  getClockwiseCoords: function () {
    if (this.isClockwise()) {
      return ___default["default"].clone(this.coords);
    }

    return ___default["default"].clone(this.coords).reverse();
  },
  update: function (shouldChangeReflexivity) {
    const prevCoords = this.coords;
    this.coords = ___default["default"].pluck(this.points, "coord"); // Update lines

    ___default["default"].invoke(this.points, "updateLineEnds");

    const prevAngle = this._getClockwiseAngle(prevCoords);

    const angle = this._getClockwiseAngle(this.coords);

    const prevClockwiseReflexive = prevAngle > 180;
    const clockwiseReflexive = angle > 180;

    if (this.allowReflex) {
      if (shouldChangeReflexivity == null) {
        shouldChangeReflexivity = prevClockwiseReflexive !== clockwiseReflexive && Math.abs(angle - prevAngle) < 180;
      }

      if (shouldChangeReflexivity) {
        this.reflex = !this.reflex;
      }
    }

    ___default["default"].invoke(this.temp, "remove");

    this.temp = this.graphie.labelAngle({
      point1: this.coords[0],
      vertex: this.coords[1],
      point3: this.coords[2],
      label: this.labeledAngle,
      text: this.angleLabel,
      numArcs: this.numArcs,
      pushOut: this.pushOut,
      clockwise: this.reflex === clockwiseReflexive,
      style: this.angleStyle
    });
  },
  remove: function () {
    ___default["default"].invoke(this.rays, "remove");

    ___default["default"].invoke(this.temp, "remove");

    this.labeledAngle.remove();
  }
});

/* eslint-disable @babel/no-invalid-this */
const nestedMap$1 = Util.nestedMap;
const deepEq$4 = Util.deepEq;
/**
 * A base class for all Graphie Movables
 *
 * Used for checking that all Graphie children are, in fact,
 * GraphieMovables
 */

function GraphieMovable$1(descriptor) {
  ___default["default"].extend(this, descriptor);
}

const abstractMethod = function () {
  throw new PerseusError("Abstract method! Must be implemented by Graphie Movable" + this.constructor.displayName, Errors.NotAllowed);
};

___default["default"].extend(GraphieMovable$1.prototype, {
  movableProps: [],
  add: abstractMethod,
  modify: abstractMethod,
  remove: abstractMethod,
  toFront: function () {
    /* no op */
  },
  componentDidMount: function () {
    /* no op */
    // Note: this method is here to trick react-hot-loader into thinking
    // components built from extending GraphieMovable are recognized as
    // class base React components so that they get wrapped correctly.
    // See https://github.com/gaearon/react-hot-loader/blob/master/src/internal/reactUtils.js#L14-L26
    // for details of how react-hot-loader determines whether something is
    // a React class (component).
  }
});
/**
 * returns cloned props modified with `children: childrenArray`
 */


const rewriteProps = function (props, childrenArray) {
  // Clone the props and add `children:`
  // childrenArray is always an array here because this is only called
  // from createClass, which initializes childrenArray as _.rest(arguments)
  return ___default["default"].extend({}, props, {
    children: ___default["default"].filter(___default["default"].flatten(childrenArray), ___default["default"].identity)
  });
};
/**
 * Create a custom GraphieMovable class
 */


const createClass = function (spec) {
  const GraphieClass = function (props) {
    if (!(this instanceof GraphieClass)) {
      throw new PerseusError("Use createElement or JSX with graphie movables", Errors.NotAllowed);
    }

    this.props = rewriteProps(props, props.children || []);
    return this;
  };

  spec.displayName = spec.displayName || ___default["default"].uniqueId("GraphieClass"); // Add the displayName to the constructor for compatibility with
  // React's myDescriptor.constructor.displayName

  GraphieClass.displayName = spec.displayName; // $FlowFixMe[invalid-constructor]

  GraphieClass.prototype = new GraphieMovable$1(spec);
  GraphieClass.prototype.constructor = GraphieClass;
  return GraphieClass;
};
/**
 * Create a GraphieMovable class from a function that describes
 * how to add said class to a graphie, and returns an array of
 * `.remove()`able elements to be used when a remove() or
 * modify() is called.
 *
 * This convenience method creates an inefficient class, although
 * it does check for a difference in this.props and prevProps before
 * removing and re-adding itself.
 *
 * The primary benefit of this is being able to very easily create
 * a wrapper for old graphie code to make it interface with <Graphie>
 *
 * Commonly used elements should use the fully-fledged createClass
 * and implement an efficient modify() operation.
 */


const createSimpleClass = function (addFunction) {
  return createClass({
    displayName: addFunction.name || ___default["default"].uniqueId("GraphieSimpleClass"),
    movableProps: ["children"],
    add: function (graphie) {
      this._elements = addFunction(graphie, this.props);
      this._prevProps = this.props;
    },
    modify: function (graphie) {
      if (!deepEq$4(this.props, this._prevProps)) {
        this.remove();
        this.add(graphie);
        this._prevProps = this.props;
        return "reordered";
      }
    },
    remove: function () {
      nestedMap$1(this._elements, elem => {
        if (elem) {
          elem.remove();
        }
      });
      this._elements = null;
      this._prevProps = null;
    },
    toFront: function () {
      nestedMap$1(this._elements, elem => {
        if (___default["default"].isFunction(elem.toFront)) {
          elem.toFront();
        }
      });
    }
  });
};

var GraphieClasses = {
  GraphieMovable: GraphieMovable$1,
  createClass: createClass,
  createSimpleClass: createSimpleClass
};

/* eslint-disable @babel/no-invalid-this */

/**
 * Helper functions
 */
const getScaledAngle = function (line) {
  const scaledA = line.graphie.scalePoint(line.coord(0));
  const scaledZ = line.graphie.scalePoint(line.coord(1));
  return kmath.vector.polarDegFromCart(kmath.vector.subtract(scaledZ, scaledA))[1];
}; // Given `coord` and `angle`, find the point where a line extended
// from `coord` in the direction of `angle` would be clipped by the
// edge of the graphie canvas. Then draw an arrowhead at that point
// pointing in the direction of `angle`.


const getClipPoint = function (graph, coord, angle) {
  // Actually put the arrowheads 4px from the edge so they have
  // a bit of room
  const xExtent = graph.range[0][1] - graph.range[0][0];
  const yExtent = graph.range[1][1] - graph.range[1][0]; // shoot a point off into the distance ...

  const distance = xExtent + yExtent; // we need to scale the point according to the scale of the axes

  const angleVec = graph.unscaleVector(kmath.vector.cartFromPolarDeg(1, angle));
  const distVec = kmath.vector.scale(kmath.vector.normalize(angleVec), distance);
  const farCoord = kmath.vector.add(coord, distVec);
  const scaledAngle = kmath.vector.polarDegFromCart(angleVec)[1]; // ... and then bring it back

  const clipPoint = graph.constrainToBoundsOnAngle(farCoord, 4, scaledAngle * Math.PI / 180);
  return clipPoint;
}; // Given `coord` and `angle`, find the point where a line extended
// from `coord` in the direction of `angle` would be clipped by the
// edge of the graphie canvas. Then draw an arrowhead at that point
// pointing in the direction of `angle`.


const createArrow = function (graph, style) {
  // Points that define the arrowhead
  const center = [0.75, 0];
  let points = [[-3, 4], [-2.75, 2.5], [0, 0.25], center, [0, -0.25], [-2.75, -2.5], [-3, -4]]; // Scale points by 1.4 around (0.75, 0)

  const scale = 1.4;
  points = ___default["default"].map(points, function (point) {
    const pv = kmath.vector.subtract(point, center);
    const pvScaled = kmath.vector.scale(pv, scale);
    return kmath.vector.add(center, pvScaled);
  }); // We can't just pass in a path to `graph.fixedPath` as we need to modify
  // the points in some way, so instead we provide a function for creating
  // the path once the points have been transformed

  const createCubicPath = function (points) {
    let path = "M" + points[0][0] + " " + points[0][1];

    for (let i = 1; i < points.length; i += 3) {
      path += "C" + points[i][0] + " " + points[i][1] + " " + points[i + 1][0] + " " + points[i + 1][1] + " " + points[i + 2][0] + " " + points[i + 2][1];
    }

    return path;
  }; // Create arrowhead


  const unscaledPoints = ___default["default"].map(points, graph.unscalePoint);

  const options = {
    center: graph.unscalePoint(center),
    createPath: createCubicPath
  }; // $FlowFixMe[invalid-constructor]

  const arrowHead = new WrappedPath(graph, unscaledPoints, options);
  arrowHead.attr(___default["default"].extend({
    "stroke-linejoin": "round",
    "stroke-linecap": "round",
    "stroke-dasharray": ""
  }, style)); // Add custom function for transforming arrowheads that accounts for
  // center, scaling, etc.
  // $FlowFixMe[prop-missing]

  arrowHead.toCoordAtAngle = function (coord, angle) {
    const clipPoint = graph.scalePoint(getClipPoint(graph, coord, angle));
    arrowHead.transform("translateX(" + (clipPoint[0] + scale * center[0]) + "px) " + "translateY(" + (clipPoint[1] + scale * center[1]) + "px) " + "translateZ(0) " + "rotate(" + (360 - KhanMath.bound(angle)) + "deg)");
  };

  return arrowHead;
};
/**
 * MovableLine option functions
 */


const add$2 = {
  // We do this in add as well as in standard so that we can call
  // pointsToFront after the first draw (which adds `this.visibleShape`)
  draw: function () {
    this.draw();
  },
  pointsToFront: function (state) {
    ___default["default"].invoke(state.points, "toFront");
  }
}; // $FlowFixMe[prop-missing]

add$2.standard = [add$2.draw, add$2.pointsToFront];
const modify$2 = {
  draw: function () {
    this.draw();
  }
}; // $FlowFixMe[prop-missing]

modify$2.standard = [modify$2.draw];
const draw$3 = {
  basic: function (state) {
    const graphie = this.graphie;
    let start = this.coord(0);
    let end = this.coord(1);

    if (!this.state.visibleShape) {
      const options = {
        thickness: 10
      }; // $FlowFixMe[invalid-constructor]

      this.state.visibleShape = new WrappedLine(graphie, start, end, options);
      this.state.visibleShape.attr(this.normalStyle());
      this.state.visibleShape.toFront();

      if (this.mouseTarget()) {
        this.mouseTarget().toFront();
      }
    } // Compute angle


    const angle = getScaledAngle(this); // Extend start, end if necessary (i.e., if not a line segment)

    if (state.extendLine) {
      start = getClipPoint(graphie, start, 360 - angle);
      end = getClipPoint(graphie, end, (540 - angle) % 360);
    } else if (state.extendRay) {
      end = getClipPoint(graphie, end, 360 - angle);
    } // Move elements


    const elements = [this.state.visibleShape];

    if (this.mouseTarget()) {
      elements.push(this.mouseTarget());
    }

    ___default["default"].each(elements, function (element) {
      element.moveTo(start, end);
    });
  },
  arrows: function (state) {
    // Create arrows, if not yet created
    if (this._arrows == null) {
      this._arrows = [];

      if (state.extendLine) {
        this._arrows.push(createArrow(this.graphie, this.normalStyle()));

        this._arrows.push(createArrow(this.graphie, this.normalStyle()));
      } else if (state.extendRay) {
        this._arrows.push(createArrow(this.graphie, this.normalStyle()));
      }
    } // Transform arrows


    const angle = getScaledAngle(this);
    const angleForArrow = [360 - angle, (540 - angle) % 360];

    ___default["default"].each(this._arrows, function (arrow, i) {
      arrow.toCoordAtAngle(this.coord(i), angleForArrow[i]);
    }, this);
  },
  highlight: function (state, prevState) {
    // TODO(jack): Figure out a way to highlight the points attached to
    // the line. Maybe this means an additional isHovering: []
    // function to state of movable/movablepoint to define [additional?]
    // times it should be highlighted
    if (state.isHovering && !prevState.isHovering) {
      state.visibleShape.animate(state.highlightStyle, 50);
    } else if (!state.isHovering && prevState.isHovering) {
      state.visibleShape.animate(state.normalStyle, 50);
    }
  }
}; // $FlowFixMe[prop-missing]

draw$3.standard = [draw$3.basic, draw$3.arrows, draw$3.highlight];
const remove$2 = {
  basic: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.remove();
    }
  },
  arrows: function () {
    if (this._arrows != null) {
      ___default["default"].invoke(this._arrows, "remove");
    }

    this._arrows = null;
  }
}; // $FlowFixMe[prop-missing]

remove$2.standard = [remove$2.basic, remove$2.arrows];
const constraints$2 = {
  fixed: function () {
    return function () {
      return false;
    };
  },
  snap: function (snap) {
    return function (coord, prevCoord) {
      if (snap === null) {
        return true;
      }

      let delta = kmath.vector.subtract(coord, prevCoord);
      snap = snap || this.graphie.snap;
      delta = kmath.point.roundTo(delta, snap);
      return kmath.vector.add(prevCoord, delta);
    };
  },
  bound: function (range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }

    return function (coord, prevCoord) {
      const graphie = this.graphie;
      const delta = kmath.vector.subtract(coord, prevCoord);
      range = range || graphie.range; // A null snap means no snap; an undefined snap means
      // default to graphie's

      if (snap === undefined) {
        snap = graphie.snap;
      } // Calculate the bounds for both points


      let absoluteLower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      let absoluteUpper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);

      if (snap) {
        absoluteLower = kmath.point.ceilTo(absoluteLower, snap);
        absoluteUpper = kmath.point.floorTo(absoluteUpper, snap);
      } // Calculate the bounds for the delta.


      const deltaBounds = ___default["default"].map(this.coords(), function (coord, i) {
        const max = kmath.vector.subtract(absoluteUpper, coord);
        const min = kmath.vector.subtract(absoluteLower, coord);
        return [min, max];
      }); // bound the delta by the calculated bounds


      const boundedDelta = ___default["default"].reduce(deltaBounds, function (delta, bound) {
        const lower = bound[0];
        const upper = bound[1];
        const deltaX = Math.max(lower[0], Math.min(upper[0], delta[0]));
        const deltaY = Math.max(lower[1], Math.min(upper[1], delta[1]));
        return [deltaX, deltaY];
      }, delta);

      return kmath.vector.add(prevCoord, boundedDelta);
    };
  }
}; // $FlowFixMe[prop-missing]

constraints$2.standard = null;
const onMove$1 = {
  updatePoints: function (coord, prevCoord) {
    const actualDelta = kmath.vector.subtract(coord, prevCoord);

    ___default["default"].each(this.state.points, function (point) {
      point.setCoord(kmath.vector.add(point.coord(), actualDelta));
    });
  }
}; // $FlowFixMe[prop-missing]

onMove$1.standard = null;
var MovableLineOptions = {
  add: add$2,
  modify: modify$2,
  draw: draw$3,
  remove: remove$2,
  onMoveStart: {
    standard: null
  },
  constraints: constraints$2,
  onMove: onMove$1,
  onMoveEnd: {
    standard: null
  }
};

/**
 * MovableLine
 */
const assert$9 = InteractiveUtil.assert;
const normalizeOptions$3 = InteractiveUtil.normalizeOptions;
const FUNCTION_ARRAY_OPTIONS$3 = ["add", "draw", "remove", "onMoveStart", "constraints", "onMove", "onMoveEnd"]; // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.cursor() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".

const DEFAULT_PROPS$3 = {
  points: null,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  extendLine: false,
  extendRay: false
};
const DEFAULT_STATE$3 = {
  visibleShape: null,
  mouseTarget: null
};

const MovableLine$4 = function (graphie, movable, options) {
  assert$9(graphie != null);
  assert$9(options != null);

  ___default["default"].extend(this, {
    graphie: graphie,
    movable: movable,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movableLine")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(___default["default"].extend({}, DEFAULT_STATE$3, options));
};

___default["default"].extend(MovableLine$4, MovableLineOptions);

InteractiveUtil.createGettersFor(MovableLine$4, ___default["default"].extend({}, DEFAULT_PROPS$3, DEFAULT_STATE$3));
InteractiveUtil.addMovableHelperMethodsTo(MovableLine$4);

___default["default"].extend(MovableLine$4.prototype, {
  cloneState: function () {
    return ___default["default"].extend(this.movable.cloneState(), {
      coords: this.coords()
    }, this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id
    }, normalizeOptions$3(FUNCTION_ARRAY_OPTIONS$3, // Defaults are copied from MovableLineOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_.pluck(MovableLineOptions, "standard")), DEFAULT_PROPS$3);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend(this._createDefaultState(), options));
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = this.graphie;

    const state = self.state = ___default["default"].extend(self.state, normalizeOptions$3(FUNCTION_ARRAY_OPTIONS$3, options)); // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPERTIES!)


    const normalColor = state.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    state.normalStyle = ___default["default"].extend({
      stroke: normalColor,
      "stroke-width": 2
    }, state.normalStyle);
    state.highlightStyle = ___default["default"].extend({
      stroke: KhanColors.INTERACTING,
      "stroke-width": 3
    }, state.highlightStyle);

    if (!state.static) {
      // the invisible shape in front of the line that gets mouse events
      if (!state.mouseTarget) {
        const options = {
          thickness: 30,
          mouselayer: true,
          interactiveKindForTesting: "movable-line"
        }; // $FlowFixMe[invalid-constructor]

        state.mouseTarget = new WrappedLine(graphie, this.coord(0), this.coord(1), options);
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }
    }

    if (state.static && state.mouseTarget) {
      // state.static was specified, remove any previously
      // existing mousetarget (from a previous modify)
      state.mouseTarget.remove();
      state.mouseTarget = null;
    } // The movable that handles mouse events for us


    self.movable.modify(___default["default"].extend({}, state, {
      mouseTarget: state.mouseTarget,
      // We null out the add/modify/remove to avoid propagating our
      // state.add... to the movable, so that we can fire those
      // events ourselves, rather than letting the movable handle
      // them
      add: null,
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: function () {
        self._initialRefCoord = self.coord(0);
        self._prevRefCoord = self._initialRefCoord;
        self._totalDelta = [0, 0];

        self._fireEvent(self.state.onMoveStart, self.coord(0), self.coord(0));
      },
      onMove: function (mouseCoord, prevMouseCoord) {
        const delta = kmath.vector.subtract(mouseCoord, prevMouseCoord);
        self._totalDelta = kmath.vector.add(self._totalDelta, delta);
        let refCoord = kmath.vector.add(self._initialRefCoord, self._totalDelta);
        refCoord = self._applyConstraints(refCoord, self._prevRefCoord);

        if (refCoord === false) {
          return;
        }

        self._fireEvent(self.state.onMove, refCoord, self._prevRefCoord);

        self._prevRefCoord = refCoord;
      },
      onMoveEnd: function () {
        self._fireEvent(self.state.onMoveEnd, self._prevRefCoord, self._initialRefCoord);
      }
    })); // Trigger an add event if this hasn't been added before

    if (!state.added) {
      self.prevState = {};

      self._fireEvent(state.add, self.cloneState(), self.prevState);

      state.added = true; // Update the line with the points' movement

      ___default["default"].invoke(state.points, "listen", "onMove", state.id, self.draw.bind(self)); // Update the state for `added` and in case the add event
      // changed it


      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  coords: function () {
    return ___default["default"].invoke(this.state.points, "coord");
  },
  point: function (index) {
    return this.state.points[index];
  },
  coord: function (index) {
    return this.point(index).coord();
  },
  remove: function () {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.points) {
      ___default["default"].invoke(this.points, "unlisten", "onMove", this.state.id);
    }

    if (this.movable) {
      // We need this to be guarded because it is called on the initial
      // constructor/modify call, before this.movable is created
      this.movable.remove();
    }
  },
  // Change z-order to back
  toBack: function () {
    this.movable.toBack();

    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }

    this.movable.toFront();
  },

  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function () {
    return this.movable.isHovering();
  },
  isDragging: function () {
    return this.movable.isDragging();
  },
  mouseTarget: function () {
    return this.movable.mouseTarget();
  }
});

/**
 * Icon paths to be used with `inline-icon.jsx`.
 *
 * These paths are taken directly from webapp's `icon-paths.js`. Unlike the
 * webapp equivalent, these can be directly required within Perseus files since
 * this is all bundled together anyway.
 */
const iconCheck = {
  path: "M8.70710678,12.2928932 C8.31658249,11.9023689 7.68341751,11.9023689 7.29289322,12.2928932 C6.90236893,12.6834175 6.90236893,13.3165825 7.29289322,13.7071068 L9.82842712,16.2426407 C10.2207367,16.6349502 10.8574274,16.6328935 11.2471942,16.2380576 L16.7116603,10.7025237 C17.0996535,10.3094846 17.0955629,9.67633279 16.7025237,9.28833966 C16.3094846,8.90034653 15.6763328,8.90443714 15.2883397,9.29747629 L10.5309507,14.1167372 L8.70710678,12.2928932 Z",
  width: 24,
  height: 24
};
const iconCheckMedium = {
  path: "M6.072 10.4l6.175-7.058a1 1 0 1 1 1.506 1.317L6.769 12.64a1 1 0 0 1-1.55-.054L2.203 8.604a1 1 0 1 1 1.594-1.208L6.072 10.4z",
  width: 16,
  height: 16
};
const iconChevronDown = {
  path: "M99.669 13.048q0 3.36-2.352 5.712l-41.664 41.664q-2.408 2.408-5.88 2.408t-5.712-2.408l-41.664-41.664q-2.408-2.24-2.408-5.712t2.408-5.88l4.76-4.816q2.52-2.352 5.88-2.352t5.656 2.352l31.136 31.136 31.08-31.136q2.352-2.352 5.712-2.352t5.88 2.352l4.816 4.816q2.352 2.52 2.352 5.88z",
  width: 100,
  height: 63.034
};
const iconChevronRight = {
  path: "M62.808 49.728q0 3.36-2.352 5.88l-41.72 41.664q-2.352 2.408-5.768 2.408t-5.768-2.408l-4.872-4.76q-2.352-2.52-2.352-5.88t2.352-5.712l31.08-31.136-31.08-31.024q-2.352-2.52-2.352-5.88t2.352-5.712l4.872-4.76q2.296-2.408 5.768-2.408t5.768 2.408l41.72 41.664q2.352 2.296 2.352 5.656z",
  width: 63.034,
  height: 100
};
const iconCircle = {
  path: "M100.035 50.046q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
const iconCircleArrowDown = {
  path: "M50.046 83.676q1.767 0 2.907-1.14l29.526-29.526q1.197-1.197 1.197-2.907t-1.197-2.964l-5.928-5.928q-1.197-1.14-2.964-1.14t-2.907 1.14l-12.312 12.312l0-32.661q0-1.71-1.254-2.964t-2.907-1.254l-8.322 0q-1.71 0-2.964 1.254t-1.254 2.964l0 32.661l-12.312-12.312q-1.197-1.254-2.907-1.254t-2.907 1.254l-5.928 5.928q-1.197 1.197-1.197 2.964t1.197 2.907l29.469 29.526q1.197 1.14 2.964 1.14zm49.989-33.63q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
const iconCircleArrowUp = {
  path: "M54.207 83.391q1.653 0 2.907-1.254t1.254-2.907l0-32.718l12.312 12.312q1.254 1.254 2.964 1.254t2.907-1.254l5.928-5.928q1.197-1.197 1.14-2.964 0-1.767-1.14-2.907l-29.526-29.526q-1.197-1.14-2.907-1.14t-2.964 1.14l-29.469 29.526q-1.197 1.254-1.197 2.964t1.197 2.907l5.928 5.928q1.197 1.197 2.907 1.197t2.907-1.197l12.312-12.312l0 32.718q0 1.653 1.254 2.907t2.964 1.254l8.322 0zm45.828-33.345q.057 13.623-6.669 25.137t-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.669 25.137z",
  width: 100,
  height: 100
};
const iconCircleThin = {
  path: "M50.046 8.322q-8.493 0-16.188 3.306-15.561 6.669-22.173 22.23-3.363 7.695-3.363 16.188t3.306 16.188 8.949 13.281q5.586 5.586 13.281 8.892t16.188 3.306 16.188-3.306 13.281-8.892 8.892-13.281 3.306-16.188-3.306-16.188-8.892-13.281-13.281-8.949q-7.695-3.306-16.188-3.306zm0 91.713q-13.623 0-25.137-6.726t-18.183-18.183q-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.726 25.137-6.726 25.137-18.24 18.126q-11.514 6.726-25.08 6.726z",
  width: 100,
  height: 99.944
};
const iconDesktop = {
  path: "M94.208 52.119l0-43.746q0-.69-.506-1.15t-1.196-.506l-84.088 0q-.69 0-1.196.506t-.506 1.15l0 43.746q0 .69.506 1.196t1.196.506l84.088 0q.69 0 1.196-.506t.506-1.196zm6.716-43.746l0 57.224q0 3.45-2.484 5.934t-5.934 2.484l-28.566 0q0 3.128 2.53 7.774.828 1.61.828 2.622t-1.012 2.07q-1.012 1.012-2.346.966l-26.91 0q-1.38 0-2.392-1.012t-1.012-2.024q0-1.058 1.656-4.14t1.748-6.256l-28.612 0q-3.45 0-5.934-2.484t-2.484-5.934l0-57.224q0-3.45 2.484-5.934t5.934-2.438l84.088 0q3.45 0 5.98 2.438 2.438 2.484 2.438 5.934z",
  width: 100,
  height: 86.648
};
const iconDropdownArrow = {
  path: "M9 9.8c0 .5.7 1.7 1.5 2.8 1.5 1.9 1.5 1.9 3 0C15.7 9.7 15.4 9 12 9c-1.6 0-3 .4-3 .8z",
  width: 24,
  height: 24
};
const iconExclamationSign = {
  path: "M58.368 81.225l0-12.369q0-.912-.57-1.539t-1.425-.627l-12.54 0q-.855-.057-1.482.627t-.684 1.539l0 12.369q-.057.855.627 1.482t1.539.684l12.54 0q.855 0 1.425-.627t.57-1.539zm1.026-62.871q0-1.596-2.223-1.71l-14.307 0q-2.109 0-2.223 1.71l1.14 40.47q0 .627.627 1.14t1.539.456l12.084 0q.912-.057 1.539-.513t.684-1.083zm-9.348-18.354q13.566 0 25.08 6.726 11.514 6.669 18.24 18.183t6.726 25.137-6.726 25.137-18.24 18.183-25.08 6.669-25.137-6.726q-11.514-6.726-18.183-18.183-6.726-11.571-6.726-25.137t6.726-25.08 18.24-18.24 25.08-6.669z",
  width: 100,
  height: 99.944
}; // Grabbed from https://github.com/encharm/Font-Awesome-SVG-PNG

const iconGear = {
  path: "M1152 896q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm512-109v222q0 12-8 23t-20 13l-185 28q-19 54-39 91 35 50 107 138 10 12 10 25t-9 23q-27 37-99 108t-94 71q-12 0-26-9l-138-108q-44 23-91 38-16 136-29 186-7 28-36 28h-222q-14 0-24.5-8.5t-11.5-21.5l-28-184q-49-16-90-37l-141 107q-10 9-25 9-14 0-25-11-126-114-165-168-7-10-7-23 0-12 8-23 15-21 51-66.5t54-70.5q-27-50-41-99l-183-27q-13-2-21-12.5t-8-23.5v-222q0-12 8-23t19-13l186-28q14-46 39-92-40-57-107-138-10-12-10-24 0-10 9-23 26-36 98.5-107.5t94.5-71.5q13 0 26 10l138 107q44-23 91-38 16-136 29-186 7-28 36-28h222q14 0 24.5 8.5t11.5 21.5l28 184q49 16 90 37l142-107q9-9 24-9 13 0 25 10 129 119 165 170 7 8 7 22 0 12-8 23-15 21-51 66.5t-54 70.5q26 50 41 98l183 28q13 2 21 12.5t8 23.5z",
  width: 1792,
  height: 1792
};
const iconMobilePhone = {
  path: "M36.04 89.557q0-2.584-1.836-4.42t-4.42-1.836-4.352 1.836q-1.836 1.836-1.836 4.42t1.836 4.352 4.42 1.836q2.652-.068 4.42-1.836t1.768-4.352zm16.184-12.444l0-54.74q0-1.088-.748-1.768t-1.768-.68l-39.78 0q-1.088 0-1.768.748t-.68 1.7l0 54.74q0 1.02.748 1.768t1.7.68l39.78 0q1.02-.068 1.768-.748t.748-1.7zm-14.892-65.892q0-1.224-1.292-1.292l-12.444 0q-1.224.068-1.224 1.292t1.224 1.224l12.444 0q1.292 0 1.292-1.224zm22.372-1.292l0 79.628q0 3.944-2.992 6.936t-7.004 2.992l-39.78 0q-4.012 0-7.004-2.924-2.924-2.924-2.924-7.004l0-79.628q0-4.012 2.924-6.936t7.004-2.992l39.78 0q4.012-.068 7.004 2.924t2.992 7.004z",
  width: 60.013,
  height: 100
};
const iconOk = {
  path: "M37.964 76.048q-2.576 0-4.368-1.792l-31.864-31.864q-1.792-1.792-1.792-4.368t1.792-4.368l8.736-8.68q1.792-1.792 4.368-1.792t4.312 1.792l18.816 18.872 42-42.056q1.792-1.792 4.368-1.792t4.312 1.792l8.736 8.736q1.792 1.792 1.792 4.368t-1.792 4.312l-55.048 55.048q-1.792 1.792-4.368 1.792z",
  width: 100,
  height: 76.637
};
const iconPlus = {
  path: "M99.758 43.09l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-29.45 0l0 29.45q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-29.45l-29.45 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l29.45 0l0-29.45q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836l0 29.45l29.45 0q2.852 0 4.836 1.984t1.984 4.836z",
  width: 100,
  height: 100
};
const iconRemove = {
  path: "M100.464 80.808q0 3.404-2.368 5.772l-11.47 11.544q-2.368 2.368-5.772 2.368t-5.698-2.368l-24.864-24.864-24.864 24.864q-2.368 2.368-5.772 2.368t-5.772-2.368l-11.47-11.544q-2.368-2.368-2.368-5.772t2.368-5.698l24.864-24.864-24.864-24.864q-2.368-2.368-2.368-5.772t2.368-5.772l11.47-11.47q2.368-2.368 5.772-2.368t5.772 2.368l24.864 24.864 24.864-24.864q2.294-2.368 5.698-2.368t5.772 2.368l11.47 11.47q2.368 2.368 2.368 5.772t-2.368 5.772l-24.864 24.864 24.864 24.864q2.368 2.294 2.368 5.698z",
  width: 100,
  height: 100
};
const iconStar = {
  path: "M15.1052249,9.55978547 L22.0028147,9.55978545 C23.6568673,9.55978545 23.9349557,10.3753626 22.6181351,11.3858845 L16.9943688,15.7015366 L19.2518801,22.8294455 C19.7526645,24.4106317 19.0984455,24.8825885 17.769353,23.8673293 L12.0490577,19.4977438 L6.5116497,23.8422153 C5.20921411,24.8640642 4.53299569,24.4067544 5.00266927,22.8160582 L7.10332364,15.7015366 L1.42794544,11.3634306 C0.110226041,10.3562014 0.383967283,9.54239221 2.0409646,9.54574013 L8.9924676,9.55978547 L11.1485117,2.72669438 C11.6458693,1.15043244 12.4548928,1.15900049 12.9494787,2.72669438 L15.1052249,9.55978547 Z",
  width: 24,
  height: 24
};
const iconTryAgain = {
  path: "M3.74890556,17.9799506 C2.19251241,16.1970909 1.10103636,13.4971457 1.13090903,11.1491783 C1.17160478,7.95052637 4.01704076,0.865059407 11.7028044,0.865059407 C19.388568,0.865059407 22.3026521,7.35203035 22.3026521,11.5879453 C22.3026521,15.8238603 19.386629,20.5574509 13.6832464,21.7131548 L13.6757539,17.3722171 C17.0812986,16.2190517 18.331158,14.1944123 18.3311578,11.5879451 C18.3311574,8.16554692 15.6664205,5.03476549 11.7028048,5.20494205 C7.73918903,5.37511861 5.59244567,8.66930079 5.59244567,11.1491783 C5.59244567,12.9090077 6.11128139,14.1753512 6.93640437,15.3053215 L8.14052356,14.2949456 C8.98559348,13.5858477 9.6994861,13.9070448 9.73489556,15.0076413 L9.91284941,20.5388014 C9.94832683,21.6415103 9.09967118,22.3514475 8.02194403,22.1254594 L2.60571602,20.9897332 C1.5259204,20.7633114 1.34338662,19.9984207 2.18070755,19.295825 L3.74890556,17.9799506 Z",
  width: 23,
  height: 23
};
const iconTablet = {
  path: "M45.322 90.706q0-1.86-1.302-3.224-1.364-1.364-3.224-1.364t-3.224 1.364-1.302 3.224q0 1.86 1.364 3.224 1.302 1.364 3.162 1.302 1.86.062 3.224-1.302t1.302-3.224zm27.218-11.346l0-68.014q0-.93-.682-1.612t-1.55-.682l-58.962 0q-.93 0-1.612.682t-.682 1.612l0 68.014q0 .93.682 1.612t1.612.62l58.962 0q.992-.062 1.612-.682t.62-1.55zm9.114-68.014l0 77.066q0 4.65-3.348 7.998t-7.998 3.348l-58.962 0q-4.65 0-7.998-3.348t-3.348-7.998l0-77.066q0-4.65 3.348-7.998t7.998-3.348l58.962 0q4.65 0 7.998 3.348t3.348 7.998z",
  width: 81.852,
  height: 100
};
const iconTrash = {
  path: "M31.293 37.506q2.052 0 2.052 2.109l0 37.506q0 1.995-2.052 2.109l-4.218 0q-.912-.057-1.482-.627t-.57-1.482l0-37.506q0-2.109 2.052-2.109l4.218 0zm18.753 2.109l0 37.506q0 .912-.57 1.482t-1.539.627l-4.161 0q-1.995 0-2.109-2.109l0-37.506q.057-.912.627-1.482t1.482-.627l4.161 0q.969.057 1.539.627t.57 1.482zm14.592-2.109q2.052 0 2.052 2.109l0 37.506q0 1.995-2.052 2.109l-4.161 0q-.969-.057-1.539-.627t-.57-1.482l0-37.506q0-2.109 2.109-2.109l4.161 0zm10.431 49.248l0-61.731l-58.368 0l0 61.731q.057 2.679.969 3.819t1.083 1.14l54.207 0q.171 0 1.14-1.083t.969-3.876zm-43.776-70.11l29.184 0l-3.135-7.581q-.456-.57-1.14-.741l-20.634 0q-.627.114-1.083.741zm-31.293 2.109q0-1.995 2.109-2.109l20.121 0l4.56-10.83q.969-2.394 3.477-4.104 2.565-1.71 5.187-1.71l20.805 0q2.622 0 5.187 1.71t3.477 4.104l4.56 10.83l20.178 0q.912.057 1.482.627t.57 1.482l0 4.161q0 1.995-2.052 2.109l-6.27 0l0 61.731q0 5.415-3.078 9.348t-7.353 3.933l-54.207 0q-4.275 0-7.353-3.819t-3.078-9.177l0-62.016l-6.213 0q-.969 0-1.539-.57t-.57-1.539l0-4.161z",
  width: 91.681,
  height: 100
};
const iconUndo = {
  path: "M10,6.6C10,7.2,9.8,8,9.3,9.1c0,0,0,0.1-0.1,0.1S9.2,9.3,9.2,9.4c0,0,0,0.1-0.1,0.1C9,9.6,9,9.6,8.9,9.6 c-0.1,0-0.1,0-0.1-0.1c0,0,0-0.1,0-0.1c0,0,0-0.1,0-0.1s0-0.1,0-0.1c0-0.3,0-0.5,0-0.7c0-0.4,0-0.7-0.1-1C8.6,7.1,8.5,6.9,8.4,6.7S8.2,6.3,8,6.1C7.8,5.9,7.6,5.8,7.4,5.7S6.9,5.5,6.7,5.5S6.1,5.4,5.8,5.4c-0.3,0-0.6,0-1,0H3.6v1.4c0,0.1,0,0.2-0.1,0.3C3.4,7.1,3.3,7.1,3.2,7.1C3.1,7.1,3,7.1,3,7L0.1,4.1C0,4.1,0,4,0,3.9s0-0.2,0.1-0.3L3,0.8C3,0.7,3.1,0.7,3.2,0.7c0.1,0,0.2,0,0.3,0.1C3.5,0.9,3.6,0.9,3.6,1v1.4h1.2c2.6,0,4.3,0.7,4.9,2.2C9.9,5.2,10,5.8,10,6.6z",
  width: 10,
  height: 10
};
const iconMinus = {
  path: "M8,13 L16,13 C16.5522847,13 17,12.5522847 17,12 C17,11.4477153 16.5522847,11 16,11 L8,11 C7.44771525,11 7,11.4477153 7,12 C7,12.5522847 7.44771525,13 8,13 Z",
  width: 24,
  height: 24
};

var iconPaths = /*#__PURE__*/Object.freeze({
    __proto__: null,
    iconCheck: iconCheck,
    iconCheckMedium: iconCheckMedium,
    iconChevronDown: iconChevronDown,
    iconChevronRight: iconChevronRight,
    iconCircle: iconCircle,
    iconCircleArrowDown: iconCircleArrowDown,
    iconCircleArrowUp: iconCircleArrowUp,
    iconCircleThin: iconCircleThin,
    iconDesktop: iconDesktop,
    iconDropdownArrow: iconDropdownArrow,
    iconExclamationSign: iconExclamationSign,
    iconGear: iconGear,
    iconMobilePhone: iconMobilePhone,
    iconOk: iconOk,
    iconPlus: iconPlus,
    iconRemove: iconRemove,
    iconStar: iconStar,
    iconTryAgain: iconTryAgain,
    iconTablet: iconTablet,
    iconTrash: iconTrash,
    iconUndo: iconUndo,
    iconMinus: iconMinus
});

/* eslint-disable @babel/no-invalid-this */
const add$1 = {
  constrain: function () {
    this.constrain();
  }
}; // $FlowFixMe[prop-missing]

add$1.standard = [add$1.constrain];
const modify$1 = {
  draw: function () {
    this.draw();
  }
}; // $FlowFixMe[prop-missing]

modify$1.standard = [modify$1.draw];
const draw$2 = {
  basic: function (state, prevState) {
    const graphie = this.graphie;

    if (!this.state.visibleShape) {
      const radii = [this.pointSize() / graphie.scale[0], this.pointSize() / graphie.scale[1]];
      const options = {
        maxScale: Math.max(this.highlightStyle().scale, this.normalStyle().scale),
        // Add in 10px of padding to avoid clipping at the edges.
        padding: 10,
        shadow: state.shadow
      }; // $FlowFixMe[invalid-constructor]

      this.state.visibleShape = new WrappedEllipse(graphie, this.coord(), radii, options);
      this.state.visibleShape.attr(___default["default"].omit(this.normalStyle(), "scale"));
      this.state.visibleShape.toFront(); // Keep mouseTarget in front of visible shape

      if (this.mouseTarget()) {
        this.mouseTarget().toFront();
      }
    }

    if (state.normalStyle !== prevState.normalStyle && !___default["default"].isEqual(state.normalStyle, prevState.normalStyle)) {
      this.state.visibleShape.attr(this.normalStyle());
    }

    this.state.visibleShape.moveTo(this.coord());

    if (this.mouseTarget()) {
      this.mouseTarget().moveTo(this.coord());
    }
  },
  highlight: function (state, prevState) {
    if (state.isHovering && !prevState.isHovering) {
      state.visibleShape.animate(this.highlightStyle(), 50);
    } else if (!state.isHovering && prevState.isHovering) {
      state.visibleShape.animate(this.normalStyle(), 50);
    }
  }
}; // $FlowFixMe[prop-missing]

draw$2.standard = [draw$2.basic, draw$2.highlight];
const remove$1 = {
  basic: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.remove();
      this.state.visibleShape = null;
    }
  }
}; // $FlowFixMe[prop-missing]

remove$1.standard = remove$1.basic;
const constraints$1 = {
  fixed: function () {
    return function () {
      return false;
    };
  },
  snap: function (snap) {
    return function (coord) {
      if (snap === null) {
        // NOTE(kevinb): this should probably return the original point
        return true;
      }

      snap = snap || this.graphie.snap;
      return kmath.point.roundTo(coord, snap);
    };
  },
  bound: function (range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }

    return function (coord, prev, options) {
      const graphie = this.graphie;
      range = range || graphie.range;

      if (snap === undefined) {
        snap = graphie.snap;
      }

      let lower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      let upper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);

      if (snap) {
        lower = kmath.point.ceilTo(lower, snap);
        upper = kmath.point.floorTo(upper, snap);
      }

      if (!!options && !!options.onOutOfBounds) {
        if (coord[0] > upper[0] || coord[0] < lower[0] || coord[1] > upper[1] || coord[1] < lower[1]) {
          options.onSkipRemaining();
          options.onOutOfBounds();
        }

        return coord;
      }

      const coordX = Math.max(lower[0], Math.min(upper[0], coord[0]));
      const coordY = Math.max(lower[1], Math.min(upper[1], coord[1]));
      return [coordX, coordY];
    };
  }
}; // $FlowFixMe[prop-missing]

constraints$1.standard = null;
var MovablePointOptions = {
  add: add$1,
  modify: modify$1,
  draw: draw$2,
  remove: remove$1,
  onMoveStart: {
    standard: null
  },
  constraints: constraints$1,
  onMove: {
    standard: null
  },
  onMoveEnd: {
    standard: null
  },
  onClick: {
    standard: null
  }
};

const assert$8 = InteractiveUtil.assert;
const normalizeOptions$2 = InteractiveUtil.normalizeOptions;
const {
  processMath
} = Tex$1; // State parameters that should be converted into an array of
// functions

const FUNCTION_ARRAY_OPTIONS$2 = ___default["default"].keys(MovablePointOptions); // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.coord() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".


const DEFAULT_PROPS$2 = {
  coord: [0, 0],
  pointSize: 4,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  shadow: false,
  tooltip: false
};
const DEFAULT_STATE$2 = {
  added: false,
  hasMoved: false,
  visibleShape: null,
  outOfBounds: false,
  mouseTarget: null,
  touchOffset: null
};
const tooltipResetFunctions = [];

const MovablePoint$5 = function (graphie, movable, options) {
  ___default["default"].extend(this, {
    graphie,
    movable,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movablePoint")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(___default["default"].extend({}, DEFAULT_STATE$2, options));
};

___default["default"].extend(MovablePoint$5, MovablePointOptions);

InteractiveUtil.createGettersFor(MovablePoint$5, ___default["default"].extend({}, DEFAULT_PROPS$2, DEFAULT_STATE$2));
InteractiveUtil.addMovableHelperMethodsTo(MovablePoint$5);

___default["default"].extend(MovablePoint$5.prototype, {
  cloneState: function () {
    return ___default["default"].extend(this.movable.cloneState(), this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id
    }, normalizeOptions$2(FUNCTION_ARRAY_OPTIONS$2, // Defaults are copied from MovablePointOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_.pluck(MovablePointOptions, "standard") // We only update props here, because we want things on state to
    // be persistent, and updated appropriately in modify()
    ), DEFAULT_PROPS$2);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend(this._createDefaultState(), options));
  },

  /**
   * Displays a tooltip above the point, replacing any previous contents. If
   * there is no tooltip initialized, adds the tooltip.
   *
   * If the type of contents is string, the contents will be rendered with
   * KaTeX. Otherwise, the content will be assumed to be a DOM node and will
   * be appended inside the tooltip.
   */
  _showTooltip: function (contents) {
    if (!this._tooltip) {
      this._tooltip = document.createElement("div");
      this._tooltip.className = "tooltip-content";
      this.state.visibleShape.wrapper.className = "tooltip";
      this.state.visibleShape.wrapper.appendChild(this._tooltip); // Only one tooltip should be displayed at a time, so store a list
      // of all the tooltips initialized.

      tooltipResetFunctions.push(() => {
        if (this.state.added) {
          this._hideTooltip();
        }
      });
    }

    if (this._tooltip.firstChild) {
      this._tooltip.removeChild(this._tooltip.firstChild);
    }

    this.state.visibleShape.wrapper.className = "tooltip visible";

    this._tooltip.appendChild(document.createElement("span"));

    if (typeof contents === "string") {
      processMath(this._tooltip.firstChild, contents, false);
    } else if (typeof contents === "function") {
      contents(this._tooltip.firstChild);
    } else {
      this._tooltip.firstChild.appendChild(contents);
    }
  },
  _hideTooltip: function () {
    if (this._tooltip) {
      // Without the visible class, tooltips have display: none set
      this.state.visibleShape.wrapper.className = "tooltip";
    }
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = self.graphie;

    const state = ___default["default"].extend(self.state, normalizeOptions$2(FUNCTION_ARRAY_OPTIONS$2, options));

    assert$8(kmath.point.is(state.coord)); // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPS/STATE!)

    const normalColor = state.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    state.normalStyle = ___default["default"].extend({
      fill: normalColor,
      stroke: normalColor,
      scale: 1
    }, state.normalStyle);
    state.highlightStyle = ___default["default"].extend({
      fill: KhanColors.INTERACTING,
      stroke: KhanColors.INTERACTING,
      scale: 2
    }, state.highlightStyle);

    if (!state.static) {
      // the invisible shape in front of the point that gets mouse events
      if (!state.mouseTarget) {
        const center = self.state.coord;
        const radii = graphie.unscaleVector(24);
        const options = {
          mouselayer: true,
          padding: 0,
          interactiveKindForTesting: "movable-point"
        }; // $FlowFixMe[invalid-constructor]

        state.mouseTarget = new WrappedEllipse(graphie, center, radii, options);
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0.0
        });
      }
    }

    const showTrashTooltip = () => {
      this._showTooltip(container => {
        // TODO(LP-11406): Replace with React Portal
        // eslint-disable-next-line no-restricted-syntax
        ReactDOM__namespace.render( /*#__PURE__*/React__namespace.createElement("span", {
          style: {
            fontSize: "2em"
          }
        }, /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends$1({}, iconTrash, {
          style: {
            position: "static",
            color: KhanColors.INTERACTIVE,
            marginLeft: 9,
            marginRight: 9
          }
        }))), container);
      });
    }; // The starting coord of any move, sent to onMoveEnd as the previous
    // value


    let startCoord = state.coord; // The Movable representing this movablePoint's representation
    // This handles mouse events for us, which we propagate in
    // onMove

    self.movable.modify(___default["default"].extend({}, state, {
      add: null,
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: startMouseCoord => {
        state.hasMoved = false;
        startCoord = state.coord; // Save the offset between the cursor and the initial coordinate
        // of the point. This is tracked so as to avoid locking the
        // moving point to the user's finger on touch devices, which
        // would obscure it, no matter how large we made the touch
        // target. Instead, we respect the offset at which the point was
        // grabbed for the entirety of the gesture, if it's a
        // touch-based interaction.

        if (state.touchOffset == null) {
          const isMouse = !("ontouchstart" in window);
          state.touchOffset = isMouse ? [0, 0] : kmath.vector.subtract(startCoord, startMouseCoord);
        }

        const svgElem = state.visibleShape.wrapper;

        if (state.shadow) {
          const filter = "none";
          svgElem.style.webkitFilter = filter;
          svgElem.style.filter = filter;
        }

        if (state.showHairlines) {
          state.showHairlines(state.coord);
        }

        tooltipResetFunctions.forEach(f => f());

        if (state.tooltip) {
          if (state.xOnlyTooltip) {
            this._showTooltip("".concat(state.coord[0]));
          } else {
            this._showTooltip("(".concat(state.coord[0], ", ").concat(state.coord[1], ")"));
          }

          if (state.shadow) {
            const content = svgElem.getElementsByClassName("tooltip-content")[0];
            const filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
            content.style.webkitFilter = filter;
            content.style.filter = filter;
          }
        }

        self._fireEvent(state.onMoveStart, startCoord, startCoord);

        self.draw();
      },
      onMove: (mouseCoord, prevMouseCoord) => {
        const transformedCoord = kmath.vector.add(mouseCoord, state.touchOffset);
        self.moveTo(transformedCoord);

        if (state.showHairlines) {
          if (!this.state.outOfBounds) {
            state.showHairlines(state.coord);
          } else {
            state.hideHairlines();
          }
        }

        if (state.tooltip) {
          if (!this.state.outOfBounds) {
            if (state.xOnlyTooltip) {
              this._showTooltip("".concat(state.coord[0]));
            } else {
              this._showTooltip("(".concat(state.coord[0], ", ").concat(state.coord[1], ")"));
            }
          }
        }

        if (state.onRemove && this.state.outOfBounds) {
          showTrashTooltip();
        }
      },
      onMoveEnd: () => {
        if (self.isHovering() && !state.hasMoved) {
          self._fireEvent(state.onClick, state.coord, startCoord);
        }

        const svgElem = state.visibleShape.wrapper;

        if (state.shadow) {
          const filter = "drop-shadow(0px 0px 5px rgba(0, 0, 0, 0.5))";
          svgElem.style.webkitFilter = filter;
          svgElem.style.filter = filter;
        }

        if (state.hideHairlines) {
          state.hideHairlines();
        }

        if (state.hasMoved) {
          this._hideTooltip();
        } else if (state.onRemove) {
          // If we haven't moved and we should be displaying trash
          // tooltips.
          showTrashTooltip();
          const content = svgElem.getElementsByClassName("tooltip-content")[0];
          content.style.webkitFilter = "none";
          content.style.filter = "none";

          this._tooltip.firstChild.addEventListener("touchstart", e => {
            // Prevent creation of a new point when the event is
            // propagated up the DOM.
            e.stopPropagation();
          }, true);

          this._tooltip.firstChild.addEventListener("touchend", e => {
            // Remove the point and prevent creation of a
            // new point.
            state.onRemove();
            e.stopPropagation();
          }, true);
        } else if (state.tooltip) {
          this._hideTooltip();
        }

        if (state.outOfBounds) {
          state.onRemove();
        }

        self._fireEvent(state.onMoveEnd, state.coord, startCoord);

        state.hasMoved = false;
        state.touchOffset = null;
        self.draw();
      }
    })); // Trigger an add event if this hasn't been added before

    if (!state.added) {
      self.prevState = {};

      self._fireEvent(state.add, self.cloneState(), self.prevState);

      state.added = true; // Update the state for `added` and in case the add event
      // changed it

      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  remove: function () {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.movable) {
      this.movable.remove();
    } // TODO(jack): This should really be moved off of
    // movablePoint.state and only kept on movable.state


    this.state.mouseTarget = null;
  },
  constrain: function () {
    const result = this._applyConstraints(this.coord(), this.coord());

    if (kmath.point.is(result)) {
      this.setCoord(result);
    }

    return result !== false;
  },
  setCoord: function (coord) {
    assert$8(kmath.point.is(coord, 2));
    this.state.coord = ___default["default"].clone(coord);
    this.draw();
  },
  setCoordConstrained: function (coord) {
    assert$8(kmath.point.is(coord, 2));

    const result = this._applyConstraints(coord, this.coord());

    if (result !== false) {
      this.state.coord = ___default["default"].clone(result);
      this.draw();
    }
  },
  moveTo: function (coord) {
    // The caller has the option of adding an onMove() method to the
    // movablePoint object we return as a sort of event handler
    // By returning false from onMove(), the move can be vetoed,
    // providing custom constraints on where the point can be moved.
    // By returning array [x, y], the move can be overridden
    const state = this.state;
    this.state.outOfBounds = false;

    const result = this._applyConstraints(coord, state.coord, state.onRemove ? {
      onOutOfBounds: () => {
        this.state.outOfBounds = true;
      }
    } : {});

    if (result === false) {
      return;
    }

    if (kmath.point.is(result)) {
      coord = result;
    }

    if (!kmath.point.equal(coord, state.coord)) {
      const prevCoord = state.coord;
      state.coord = coord;
      state.hasMoved = true;

      this._fireEvent(state.onMove, state.coord, prevCoord);

      this.draw();
    }
  },
  // Clone these for use with raphael, which modifies the input
  // style parameters
  normalStyle: function () {
    return ___default["default"].clone(this.state.normalStyle);
  },
  highlightStyle: function () {
    return ___default["default"].clone(this.state.highlightStyle);
  },
  // Change z-order to back
  toBack: function () {
    this.movable.toBack();

    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }

    this.movable.toFront();
  },

  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function () {
    return this.movable.isHovering();
  },
  isDragging: function () {
    return this.movable.isDragging();
  },
  mouseTarget: function () {
    return this.movable.mouseTarget();
  },
  grab: function (coord) {
    // Provide an explicit touchOffset override, so that we track the user's
    // finger when a point has been grabbed.
    this.state.touchOffset = [0, 0];
    this.movable.grab(coord);
    this.moveTo(coord);
  }
});

/* eslint-disable @babel/no-invalid-this */

function sum(array) {
  return ___default["default"].reduce(array, function (memo, arg) {
    return memo + arg;
  }, 0);
}

function clockwise(points) {
  const segments = ___default["default"].zip(points, points.slice(1).concat(points.slice(0, 1)));

  const areas = ___default["default"].map(segments, function (segment) {
    const p1 = segment[0];
    const p2 = segment[1];
    return (p2[0] - p1[0]) * (p2[1] + p1[1]);
  });

  return sum(areas) > 0;
}

const add = {
  constrain: function () {
    this.constrain();
  },
  pointsToFront: function (state) {
    ___default["default"].invoke(state.points, "toFront");
  }
}; // $FlowFixMe[prop-missing]

add.standard = [add.constrain, add.pointsToFront];
const modify = {
  draw: function () {
    this.draw();
  }
}; // $FlowFixMe[prop-missing]

modify.standard = [modify.draw];
const draw$1 = {
  basic: function (state, prevState) {
    const graphie = this.graphie;
    const path = this.path(state);

    if (!this.state.visibleShape) {
      this.state.visibleShape = graphie.raphael.path(path);
      this.state.visibleShape.attr(this.normalStyle());
    }

    if (state.normalStyle !== prevState.normalStyle && !___default["default"].isEqual(state.normalStyle, prevState.normalStyle)) {
      this.state.visibleShape.attr(this.normalStyle());
    }

    this.state.visibleShape.attr({
      path: path
    });

    if (this.mouseTarget()) {
      this.mouseTarget().attr({
        path: path
      });
    }
  },

  /* Labels are handled primarily by label objects, but sometimes require
   * extra movables, e.g., for the arcs drawn at labeled angles. These extra
   * movables are stored in the label cache. */
  labels: function (state, prevState) {
    const graphie = this.graphie;
    const self = this;

    const coords = ___default["default"].invoke(state.points, "coord");

    const isClockwise = clockwise(coords);
    const n = coords.length; // graphie.labelAngle and similar methods attempt to re-use the label
    // provided, which will have been stored on state._labeledAngles.
    // If they cannot re-use the label, they make a new one, which will
    // get stored on state._labelCache. These will all be cleared out when
    // we remove the polygon.
    // (This logic is borrowed from graphie:addMovablePolygon.)

    if (self.state._labelCache != null) {
      ___default["default"].invoke(self.state._labelCache, "remove");
    }

    self.state._labelCache = []; // Update angle labels

    if (state.angleLabels.length || state.showRightAngleMarkers.length) {
      // Generate labels
      if (self.state._labeledAngles == null) {
        self.state._labeledAngles = ___default["default"].times(Math.max(state.angleLabels.length, state.showRightAngleMarkers.length), function () {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      ___default["default"].each(self.state._labeledAngles, function (label, i) {
        self.state._labelCache.push(graphie.labelAngle({
          point1: coords[(i - 1 + n) % n],
          vertex: coords[i],
          point3: coords[(i + 1) % n],
          label: label,
          text: state.angleLabels[i],
          showRightAngleMarker: state.showRightAngleMarkers[i],
          numArcs: state.numArcs[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    } // Update side labels


    if (state.sideLabels.length) {
      // Generate labels
      if (self.state._labeledSides == null) {
        self.state._labeledSides = ___default["default"].map(state.sideLabels, function (label) {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      ___default["default"].each(self.state._labeledSides, function (label, i) {
        self.state._labelCache.push(graphie.labelSide({
          point1: coords[i],
          point2: coords[(i + 1) % n],
          label: label,
          text: state.sideLabels[i],
          numArrows: state.numArrows[i],
          numTicks: state.numTicks[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    } // Update vertex labels


    if (state.vertexLabels.length) {
      // Generate labels
      if (self.state._labeledVertices == null) {
        self.state._labeledVertices = ___default["default"].map(state.vertexLabels, function (label) {
          return graphie.label([0, 0], "", "center", state.labelStyle);
        });
      }

      ___default["default"].each(self.state._labeledVertices, function (label, i) {
        self.state._labelCache.push(graphie.labelVertex({
          point1: coords[(i - 1 + n) % n],
          vertex: coords[i],
          point3: coords[(i + 1) % n],
          label: label,
          text: state.vertexLabels[i],
          clockwise: isClockwise,
          style: state.labelStyle
        }));
      });
    } // graphie.labelVertex and its peer methods return an array of movables


    self.state._labelCache = ___default["default"].flatten(self.state._labelCache);
  },
  highlight: function (state, prevState) {
    if (state.isHovering && !prevState.isHovering) {
      state.visibleShape.animate(this.highlightStyle(), 50);
    } else if (!state.isHovering && prevState.isHovering) {
      state.visibleShape.animate(this.normalStyle(), 50);
    }
  }
}; // $FlowFixMe[prop-missing]

draw$1.standard = [draw$1.basic, draw$1.labels, draw$1.highlight];
const remove = {
  basic: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.remove();
    }
  },
  labels: function () {
    const labels = [this.state._labeledSides, this.state._labeledVertices, this.state._labeledAngles, this.state._labelCache];

    ___default["default"].each(labels, function (labelType) {
      if (labelType != null && labelType.length) {
        ___default["default"].invoke(labelType, "remove");
      }
    });
  }
}; // $FlowFixMe[prop-missing]

remove.standard = [remove.basic, remove.labels];
const constraints = {
  fixed: function () {
    return function () {
      return false;
    };
  },
  snap: function (snap) {
    return function (coord) {
      if (snap === null) {
        // NOTE(kevin): this should probably return the original point
        return true;
      }

      snap = snap || this.graphie.snap;
      return kmath.point.roundTo(coord, snap);
    };
  },
  bound: function (range, snap, paddingPx) {
    if (paddingPx === undefined) {
      if (range === undefined) {
        paddingPx = 10;
      } else {
        paddingPx = 0;
      }
    }

    return function (coord, prevCoord) {
      const graphie = this.graphie;
      const delta = kmath.vector.subtract(coord, prevCoord);
      range = range || graphie.range; // A null snap means no snap; an undefined snap means
      // default to graphie's

      if (snap === undefined) {
        snap = graphie.snap;
      } // Calculate the bounds for both points


      let absoluteLower = graphie.unscalePoint([paddingPx, graphie.ypixels - paddingPx]);
      let absoluteUpper = graphie.unscalePoint([graphie.xpixels - paddingPx, paddingPx]);

      if (snap) {
        absoluteLower = kmath.point.ceilTo(absoluteLower, snap);
        absoluteUpper = kmath.point.floorTo(absoluteUpper, snap);
      } // Calculate the bounds for the delta.


      const deltaBounds = ___default["default"].map(this.coords(), function (coord, i) {
        const max = kmath.vector.subtract(absoluteUpper, coord);
        const min = kmath.vector.subtract(absoluteLower, coord);
        return [min, max];
      }); // bound the delta by the calculated bounds


      const boundedDelta = ___default["default"].reduce(deltaBounds, function (delta, bound) {
        const lower = bound[0];
        const upper = bound[1];
        const deltaX = Math.max(lower[0], Math.min(upper[0], delta[0]));
        const deltaY = Math.max(lower[1], Math.min(upper[1], delta[1]));
        return [deltaX, deltaY];
      }, delta);

      return kmath.vector.add(prevCoord, boundedDelta);
    };
  }
}; // $FlowFixMe[prop-missing]

constraints.standard = null;
const onMove = {
  updatePoints: function (coord, prevCoord) {
    const actualDelta = kmath.vector.subtract(coord, prevCoord);

    ___default["default"].each(this.state.points, function (point) {
      point.setCoord(kmath.vector.add(point.coord(), actualDelta));
    });
  }
}; // $FlowFixMe[prop-missing]

onMove.standard = null;
var MovablePolygonOptions = {
  add: add,
  modify: modify,
  draw: draw$1,
  remove: remove,
  onMoveStart: {
    standard: null
  },
  constraints: constraints,
  onMove: onMove,
  onMoveEnd: {
    standard: null
  },
  onClick: {
    standard: null
  }
};

/**
 * Creates and adds a polygon to the graph that can be dragged around.
 * It allows constraints on its movement and draws when moves happen.
 */
const assert$7 = InteractiveUtil.assert;
const normalizeOptions$1 = InteractiveUtil.normalizeOptions; // State parameters that should be converted into an array of
// functions

const FUNCTION_ARRAY_OPTIONS$1 = ___default["default"].keys(MovablePolygonOptions); // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.points() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the point should be on "state".


const DEFAULT_PROPS$1 = {
  points: null,
  angleLabels: [],
  showRightAngleMarkers: [],
  sideLabels: [],
  vertexLabels: [],
  numArcs: [],
  numArrows: [],
  numTicks: [],
  closed: true,
  static: false,
  cursor: "move",
  normalStyle: null,
  // turned into an object in this.modify
  highlightStyle: null,
  // likewise
  labelStyle: null // likewise

};
const DEFAULT_STATE$1 = {
  added: false,
  hasMoved: false,
  visibleShape: null,
  mouseTarget: null
};

const MovablePolygon = function (graphie, movable, options) {
  assert$7(graphie != null);
  assert$7(options != null);

  ___default["default"].extend(this, {
    graphie: graphie,
    movable: movable,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movablePolygon")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(___default["default"].extend({}, DEFAULT_STATE$1, options));
};

___default["default"].extend(MovablePolygon, MovablePolygonOptions);

InteractiveUtil.createGettersFor(MovablePolygon, ___default["default"].extend({}, DEFAULT_PROPS$1, DEFAULT_STATE$1));
InteractiveUtil.addMovableHelperMethodsTo(MovablePolygon);

___default["default"].extend(MovablePolygon.prototype, {
  cloneState: function () {
    return ___default["default"].extend(this.movable.cloneState(), this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id
    }, normalizeOptions$1(FUNCTION_ARRAY_OPTIONS$1, // Defaults are copied from MovablePolygonOptions.*.standard
    // These defaults are set here instead of DEFAULT_PROPS/STATE
    // because they:
    //    - are objects, not primitives (and need a deeper copy)
    //    - they don't need getters created for them
    // TODO(jack): Consider "default" once we es3ify perseus
    objective_.pluck(MovablePolygonOptions, "standard") // We only update props here, because we want things on state to
    // be persistent, and updated appropriately in modify()
    ), DEFAULT_PROPS$1);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. state not on DEFAULT_PROPS is maintained.
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend(this._createDefaultState(), options));
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = self.graphie;

    const state = ___default["default"].extend(self.state, normalizeOptions$1(FUNCTION_ARRAY_OPTIONS$1, options)); // Default things inside the state.normalStyle object, because
    // _.extend is not deep.
    // We use _.extend instead of _.defaults because we don't want
    // to modify the passed-in copy (especially if it's from
    // DEFAULT_PROPS/STATE!)


    const normalColor = state.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
    state.normalStyle = ___default["default"].extend({}, state.normalStyle, {
      "stroke-width": 2,
      "fill-opacity": 0,
      fill: normalColor,
      stroke: normalColor
    }, options.normalStyle);
    state.highlightStyle = ___default["default"].extend({}, {
      stroke: KhanColors.INTERACTING,
      "stroke-width": 2,
      fill: KhanColors.INTERACTING,
      "fill-opacity": 0.05
    }, state.highlightStyle);
    state.labelStyle = ___default["default"].extend({}, {
      stroke: KhanColors.DYNAMIC,
      "stroke-width": 1,
      color: KhanColors.DYNAMIC
    }, state.labelStyle);

    if (!state.static) {
      // the invisible shape in front of the point that gets mouse events
      if (!state.mouseTarget) {
        state.mouseTarget = graphie.mouselayer.path(this.path());
        state.mouseTarget.attr({
          fill: "#000",
          opacity: 0,
          cursor: "move"
        });
      }
    } // The Movable representing this MovablePolygon's representation
    // This handles mouse events for us, which we propagate in
    // onMove. The onMoveStart-onMove-onMoveEnd logic is borrowed from
    // movable-line.js.


    self.movable.modify(___default["default"].extend({}, state, {
      modify: null,
      draw: self.draw.bind(self),
      remove: null,
      onMoveStart: function () {
        self._initialRefCoord = self.coord(0);
        self._prevRefCoord = self._initialRefCoord;
        self._totalDelta = [0, 0];

        self._fireEvent(self.state.onMoveStart, self.coord(0), self.coord(0));
      },
      onMove: function (mouseCoord, prevMouseCoord) {
        const delta = kmath.vector.subtract(mouseCoord, prevMouseCoord);
        self._totalDelta = kmath.vector.add(self._totalDelta, delta);
        let refCoord = kmath.vector.add(self._initialRefCoord, self._totalDelta);
        refCoord = self._applyConstraints(refCoord, self._prevRefCoord); // $FlowFixMe[incompatible-type] _applyConstraints can return false

        if (refCoord === false) {
          return;
        }

        self._fireEvent(self.state.onMove, refCoord, self._prevRefCoord);

        self._prevRefCoord = refCoord;
      },
      onMoveEnd: function () {
        self._fireEvent(self.state.onMoveEnd, self._prevRefCoord, self._initialRefCoord);
      }
    })); // Update the polygon with the points' movement

    ___default["default"].invoke(state.points, "listen", "onMove", state.id, self.draw.bind(self)); // Trigger an add event if this hasn't been added before


    if (!state.added) {
      self.prevState = {};

      self._fireEvent(state.add, self.cloneState(), self.prevState);

      state.added = true; // Update the state for `added` and in case the add event
      // changed it

      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  path: function (state) {
    const graphie = this.graphie;
    state = state || this.state;

    let coords = ___default["default"].map(state.points, function (point) {
      return graphie.scalePoint(point.coord());
    }); // Create path


    if (state.closed) {
      coords.push(true);
    } else {
      // For open polygons, concatenate a reverse of the path,
      // to remove the inside area of the path, which would
      // otherwise be clickable (even if the closing line segment
      // wasn't drawn
      coords = coords.concat(___default["default"].clone(coords).reverse());
    }

    return GraphUtils.unscaledSvgPath(coords);
  },
  coords: function () {
    return ___default["default"].invoke(this.state.points, "coord");
  },
  point: function (index) {
    return this.state.points[index];
  },
  coord: function (index) {
    return this.point(index).coord();
  },
  remove: function () {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.state.points) {
      ___default["default"].invoke(this.state.points, "unlisten", "onMove", this.state.id);
    }

    if (this.movable) {
      // We need this to be guarded because it is called on the initial
      // constructor/modify call, before this.movable is created
      this.movable.remove();
    } // TODO(jack): This should really be moved off of
    // movablePolygon.state and only kept on movable.state


    this.state.mouseTarget = null;
  },
  constrain: function () {
    if (this.points == null || this.points.length === 0) {
      return;
    }

    const prevRefCoord = this.coord(0);

    const refCoord = this._applyConstraints(prevRefCoord, prevRefCoord);

    if (refCoord !== false) {
      this._fireEvent(this.state.onMove, refCoord, prevRefCoord);
    }
  },
  // Clone these for use with raphael, which modifies the input
  // style parameters
  normalStyle: function () {
    return ___default["default"].clone(this.state.normalStyle);
  },
  highlightStyle: function () {
    return ___default["default"].clone(this.state.highlightStyle);
  },
  // Change z-order to back
  toBack: function () {
    this.movable.toBack();

    if (this.state.visibleShape) {
      this.state.visibleShape.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.visibleShape) {
      this.state.visibleShape.toFront();
    }

    this.movable.toFront();
  },

  /**
   * Forwarding methods to this.movable:
   */
  isHovering: function () {
    return this.movable.isHovering();
  },
  isDragging: function () {
    return this.movable.isDragging();
  },
  mouseTarget: function () {
    return this.movable.mouseTarget();
  }
});

/**
 * Movable
 *
 * A Movable Something, that sends onMove events based on the
 * mouse coordinate (graphie unscaled, non-pixel-value) of the
 * move.
 *
 * Other MovableThings should generally have a Movable field, and
 * let this class handle all of the virtual mouse events, and then
 * take appropriate action in onMoveStart, onMove, onMoveEnd
 */
const normalizeOptions = InteractiveUtil.normalizeOptions;
const assert$6 = InteractiveUtil.assert; // state parameters that should be converted into an array of
// functions

const FUNCTION_ARRAY_OPTIONS = ["add", "modify", "draw", "remove", "onMoveStart", "onMove", "onMoveEnd", "onClick"]; // Default "props" and "state". Both are added to this.state and
// receive magic getter methods (this.isHovering() etc).
// However, properties in DEFAULT_PROPS are updated on `modify()`,
// while those in DEFAULT_STATE persist and are not updated.
// Things that the user might want to change should be on "props",
// while things used to render the movable should be on "state".

const DEFAULT_PROPS = {
  cursor: null
};
const DEFAULT_STATE = {
  added: false,
  isHovering: false,
  isMouseOver: false,
  isDragging: false,
  mouseTarget: null
};

const Movable = function (graphie, options) {
  ___default["default"].extend(this, {
    graphie: graphie,
    state: {
      // Set here because this must be unique for each instance
      id: ___default["default"].uniqueId("movable")
    }
  }); // We only set DEFAULT_STATE once, here


  this.modify(___default["default"].extend({}, DEFAULT_STATE, options));
};

InteractiveUtil.createGettersFor(Movable, ___default["default"].extend({}, DEFAULT_PROPS, DEFAULT_STATE));
InteractiveUtil.addMovableHelperMethodsTo(Movable);

___default["default"].extend(Movable.prototype, {
  cloneState: function () {
    return ___default["default"].clone(this.state);
  },
  _createDefaultState: function () {
    return ___default["default"].extend({
      id: this.state.id,
      add: [],
      modify: [],
      draw: [],
      remove: [],
      onMoveStart: [],
      onMove: [],
      onMoveEnd: [],
      onClick: [] // We only update props here, because we want things on state to
      // be persistent, and updated appropriately in modify()

    }, DEFAULT_PROPS);
  },

  /**
   * Resets the object to its state as if it were constructed with
   * `options` originally. The only state maintained is `state.id`
   *
   * Analogous to React.js's replaceProps
   */
  modify: function (options) {
    this.update(___default["default"].extend({}, this._createDefaultState(), options));
  },

  /**
   * Simulates a mouse grab event on the movable object.
   */
  grab: function (coord) {
    assert$6(kmath.point.is(coord));
    const self = this;
    const graphie = self.graphie;
    const state = self.state;
    state.isHovering = true;
    state.isDragging = true;
    graphie.isDragging = true;
    const startMouseCoord = coord;
    let prevMouseCoord = startMouseCoord;

    self._fireEvent(state.onMoveStart, startMouseCoord, startMouseCoord);

    const moveHandler = function (e) {
      e.preventDefault();
      const mouseCoord = graphie.getMouseCoord(e);

      self._fireEvent(state.onMove, mouseCoord, prevMouseCoord);

      self.draw();
      prevMouseCoord = mouseCoord;
    };

    const upHandler = function (e) {
      $__default["default"](document).unbind("vmousemove", moveHandler);
      $__default["default"](document).unbind("vmouseup", upHandler);

      if (state.isHovering) {
        self._fireEvent(state.onClick, prevMouseCoord, startMouseCoord);
      }

      state.isHovering = self.state.isMouseOver;
      state.isDragging = false;
      graphie.isDragging = false;

      self._fireEvent(state.onMoveEnd, prevMouseCoord, startMouseCoord);

      self.draw();
    };

    $__default["default"](document).bind("vmousemove", moveHandler);
    $__default["default"](document).bind("vmouseup", upHandler);
  },

  /**
   * Adjusts constructor parameters without changing previous settings
   * for any option not specified
   *
   * Analogous to React.js's setProps
   */
  update: function (options) {
    const self = this;
    const graphie = self.graphie;
    const prevState = self.cloneState();

    const state = ___default["default"].extend(self.state, normalizeOptions(FUNCTION_ARRAY_OPTIONS, options)); // the invisible shape in front of the point that gets mouse events


    if (state.mouseTarget && !prevState.mouseTarget) {
      let $mouseTarget;

      if (state.mouseTarget.getMouseTarget) {
        $mouseTarget = $__default["default"](state.mouseTarget.getMouseTarget());
      } else {
        $mouseTarget = $__default["default"](state.mouseTarget[0]);
      }

      const isMouse = !("ontouchstart" in window);

      if (isMouse) {
        $mouseTarget.on("vmouseover", function () {
          state.isMouseOver = true;

          if (!graphie.isDragging) {
            state.isHovering = true;
          }

          if (self.state.added) {
            // Avoid drawing if the point has been removed
            self.draw();
          }
        });
        $mouseTarget.on("vmouseout", function () {
          state.isMouseOver = false;

          if (!state.isDragging) {
            state.isHovering = false;
          }

          if (self.state.added) {
            // Avoid drawing if the point has been removed
            self.draw();
          }
        });
      } // Prevent the page from scrolling when we grab and drag the
      // movable object on a mobile device.


      $mouseTarget[0].addEventListener("touchstart", function (event) {
        event.preventDefault();
      }, {
        passive: false
      });
      $mouseTarget.on("vmousedown", function (e) {
        if (e.which !== 0 && e.which !== 1) {
          return;
        }

        e.preventDefault();
        const mouseCoord = graphie.getMouseCoord(e);
        self.grab(mouseCoord);
      });
    }

    if (state.mouseTarget && state.cursor !== undefined) {
      let $mouseTarget;

      if (state.mouseTarget.getMouseTarget) {
        $mouseTarget = $__default["default"](state.mouseTarget.getMouseTarget());
      } else {
        $mouseTarget = $__default["default"](state.mouseTarget[0]);
      } // "" removes the css cursor if state.cursor is null


      $mouseTarget.css("cursor", state.cursor || "");
    } // Trigger an add event if this hasn't been added before


    if (!state.added) {
      self._fireEvent(state.modify, self.cloneState(), {});

      state.added = true; // Update the state for `added` and in case the add event
      // changed it

      self.prevState = self.cloneState();
    } // Trigger a modify event


    self._fireEvent(state.modify, self.cloneState(), self.prevState);
  },
  remove: function () {
    this.state.added = false;

    this._fireEvent(this.state.remove);

    if (this.state.mouseTarget) {
      $__default["default"](this.state.mouseTarget).off();
      this.state.mouseTarget.remove();
      this.state.mouseTarget = null;
    }
  },
  // Change z-order to back
  toBack: function () {
    if (this.state.mouseTarget) {
      this.state.mouseTarget.toBack();
    }
  },
  // Change z-order to front
  toFront: function () {
    if (this.state.mouseTarget) {
      this.state.mouseTarget.toFront();
    }
  }
});

const Interactive2 = {
  MovablePoint: MovablePoint$5,
  addMovablePoint: function (graphie, options) {
    // $FlowFixMe[invalid-constructor]
    const movable = new Movable(graphie, {}); // $FlowFixMe[invalid-constructor]

    return new MovablePoint$5(graphie, movable, options);
  },
  MovableLine: MovableLine$4,
  addMovableLine: function (graphie, options) {
    // $FlowFixMe[invalid-constructor]
    const movable = new Movable(graphie, {}); // $FlowFixMe[invalid-constructor]

    return new MovableLine$4(graphie, movable, options);
  },
  MovablePolygon: MovablePolygon,
  addMovablePolygon: function (graphie, options) {
    // $FlowFixMe[invalid-constructor]
    const movable = new Movable(graphie, {}); // $FlowFixMe[invalid-constructor]

    return new MovablePolygon(graphie, movable, options);
  },
  addMaybeMobileMovablePoint: function (widget, extraProps) {
    const isMobile = widget.props.apiOptions.isMobile;
    const commonStyle = isMobile ? {
      stroke: "#ffffff",
      "stroke-width": 3,
      fill: KhanColors.INTERACTIVE
    } : {
      stroke: KhanColors.INTERACTIVE,
      fill: KhanColors.INTERACTIVE
    };
    const normalStyle = Object.assign(commonStyle, extraProps.normalStyle);
    const highlightStyle = Object.assign(isMobile ? { ...commonStyle,
      "stroke-width": 0,
      scale: 0.75
    } : {}, extraProps.highlightStyle); // $FlowFixMe[prop-missing]

    const props = Object.assign({
      normalStyle: normalStyle,
      highlightStyle: highlightStyle,
      shadow: isMobile,
      tooltip: isMobile && widget.props.showTooltips,
      showHairlines: widget.showHairlines,
      hideHairlines: widget.hideHairlines
    }, isMobile ? {
      pointSize: 7
    } : {});
    return Interactive2.addMovablePoint(widget.graphie, Object.assign(extraProps, props));
  }
};

const MovablePoint$4 = GraphieClasses.createClass({
  displayName: "MovablePoint",
  movableProps: ["children"],
  _getProps: function () {
    if (this.props.isMobile) {
      const isMobile = this.props.isMobile; // TODO(kevinb) precompute commonStyle and commonMobileStyle

      const commonStyle = isMobile ? {
        stroke: "#ffffff",
        "stroke-width": 3,
        fill: KhanColors.INTERACTIVE
      } : {
        stroke: KhanColors.INTERACTIVE,
        fill: KhanColors.INTERACTIVE
      }; // TODO(kevinb) precompute normalStyle and normalMobileStyle

      const normalStyle = isMobile ? Object.assign(commonStyle, this.props.mobileStyleOverride || {}) : Object.assign(commonStyle, this.props.normalStyle); // TODO(kevinb) precompute highlightStyle and highlightMobileStyle

      const highlightStyle = isMobile ? { ...commonStyle,
        "stroke-width": 0,
        scale: 0.75
      } : this.props.highlightStyle;
      /* eslint-enable indent */
      // $FlowFixMe[prop-missing]

      const addedProps = Object.assign({
        normalStyle: normalStyle,
        highlightStyle: highlightStyle,
        shadow: isMobile,
        tooltip: isMobile && this.props.showTooltips
      }, isMobile ? {
        pointSize: 7
      } : {});
      return Object.assign(this.props, addedProps);
    }

    return this.props;
  },
  add: function (graphie) {
    this.point = Interactive2.addMovablePoint(graphie, this._getProps());
  },
  modify: function () {
    this.point.modify(this._getProps());
  },
  remove: function () {
    this.point.remove();
  },
  toFront: function () {
    this.point.toFront();
  },
  grab: function (coord) {
    this.point.grab(coord);
  }
}); // Include helper methods, such as MovablePoint.constrain.snap()

___default["default"].extend(MovablePoint$4, Interactive2.MovablePoint);

const MovableLine$3 = GraphieClasses.createClass({
  displayName: "MovableLine",
  movableProps: ["children"],
  add: function (graphie) {
    // Add MovablePoint children
    const points = ___default["default"].pluck(this.props.children, "point");

    const props = ___default["default"].extend({}, this.props, {
      points: points
    });

    this.line = Interactive2.addMovableLine(graphie, props);
  },
  modify: function () {
    // Add MovablePoint children
    const points = ___default["default"].pluck(this.props.children, "point");

    const props = ___default["default"].extend({}, this.props, {
      points: points
    });

    this.line.modify(props);
  },
  remove: function () {
    this.line.remove();
  },
  toFront: function () {
    this.line.toFront();
  }
}); // Include helper methods, such as MovableLine.constrain.snap()

___default["default"].extend(MovableLine$3, Interactive2.MovableLine);

const Label$2 = GraphieClasses.createSimpleClass((graphie, props) => {
  let coord = props.coord;

  if (props.unscaled) {
    coord = graphie.unscalePoint(coord);
  }

  let elem = null; // If the label is rendered for a locale other than "en", push the label
  // element to an array. This array is used to lookup the label element
  // and processed with jipt('just in place translation', crowdin specific
  // program) to replace the passed in crowdin string with the translated
  // string. For "en" locale, the jipt processing is skipped.

  if (getDependencies().JIPT.useJIPT) {
    elem = graphie.label(coord, props.text, props.direction, false, props.style);
    getDependencies().graphieMovablesJiptLabels.addLabel(elem, props.tex);
  } else {
    elem = graphie.label(coord, props.text, props.direction, props.tex, props.style);
  }

  return elem;
});
const Line$3 = GraphieClasses.createClass({
  displayName: "Line",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.line = this.graphie.line(props.start, props.end, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgPath([props.start, props.end]);
    this.line.attr(___default["default"].extend({}, props.style, {
      path: path
    }));
  },
  remove: function () {
    this.line.remove();
  },
  toFront: function () {
    this.line.toFront();
  }
});
const Parabola = GraphieClasses.createClass({
  displayName: "Parabola",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.parabola = this.graphie.parabola(props.a, props.b, props.c, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgParabolaPath(props.a, props.b, props.c);
    this.parabola.attr(___default["default"].extend({}, props.style, {
      path: path
    }));
  },
  remove: function () {
    this.parabola.remove();
  },
  toFront: function () {
    this.parabola.toFront();
  }
});
const Sinusoid$1 = GraphieClasses.createClass({
  displayName: "Sinusoid",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.sinusoid = this.graphie.sinusoid(props.a, props.b, props.c, props.d, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgSinusoidPath(props.a, props.b, props.c, props.d);
    this.sinusoid.attr(___default["default"].extend({}, props.style, {
      path: path
    }));
  },
  remove: function () {
    this.sinusoid.remove();
  },
  toFront: function () {
    this.sinusoid.toFront();
  }
});
const Plot$2 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.plot(props.fn, props.range, props.style);
});
const PlotParametric$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.plotParametric(props.fn, props.range, props.style);
});
const Point$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.ellipse(props.coord, graphie.unscaleVector([4, 4]), {
    fill: props.color || KhanColors.BLACK,
    stroke: props.color || KhanColors.BLACK
  });
});
const Path$1 = GraphieClasses.createClass({
  displayName: "Path",
  movableProps: ["children"],
  add: function (graphie) {
    const props = this.props;
    this.graphie = graphie;
    this.path = this.graphie.path(props.coords, props.style);
  },
  modify: function () {
    const props = this.props;
    const path = this.graphie.svgPath(props.coords);
    this.path.attr({
      path: path
    });
  },
  remove: function () {
    this.path.remove();
  },
  toFront: function () {
    this.path.toFront();
  }
});
const Arc$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  let center = props.center;
  let radius = props.radius;

  if (props.unscaled) {
    center = graphie.unscalePoint(center);
    radius = graphie.unscaleVector(radius);
  }

  return graphie.arc(center, radius, props.startAngle, props.endAngle, props.sector, props.style);
});
const Circle$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.circle(props.center, props.radius, props.style);
});
const Rect$1 = GraphieClasses.createSimpleClass((graphie, props) => {
  return graphie.rect(props.x, props.y, props.width, props.height, props.style);
});
var Movables = {
  Arc: Arc$1,
  Circle: Circle$1,
  Label: Label$2,
  Line: Line$3,
  MovableLine: MovableLine$3,
  MovablePoint: MovablePoint$4,
  Parabola: Parabola,
  Path: Path$1,
  Plot: Plot$2,
  PlotParametric: PlotParametric$1,
  Point: Point$1,
  Sinusoid: Sinusoid$1,
  Rect: Rect$1
};

const GraphieMovable = GraphieClasses.GraphieMovable;
const createGraphie = GraphUtils.createGraphie;
const {
  deepEq: deepEq$3,
  nestedMap
} = Util;
const {
  assert: assert$5
} = InteractiveUtil;

class Graphie extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "getGraphie", () => {
      // $FlowFixMe[prop-missing]
      return this._graphie;
    });

    _defineProperty(this, "_range", () => {
      return ___default["default"].map(this.props.range, dimRange => {
        if (dimRange[0] >= dimRange[1]) {
          return [-10, 10];
        }

        return dimRange;
      });
    });

    _defineProperty(this, "_box", () => {
      return ___default["default"].map(this.props.box, pixelDim => {
        // 340 = default size in the editor. exact value
        // is arbitrary; this is just a safety check.
        return pixelDim > 0 ? pixelDim : 340;
      });
    });

    _defineProperty(this, "_scale", () => {
      const box = this._box();

      const range = this._range();

      return ___default["default"].map(box, (pixelDim, i) => {
        const unitDim = range[i][1] - range[i][0];
        return pixelDim / unitDim;
      });
    });

    _defineProperty(this, "_setupGraphie", () => {
      this._removeMovables(); // eslint-disable-next-line react/no-string-refs


      const graphieDiv = ReactDOM__default["default"].findDOMNode(this.refs.graphieDiv);
      $__default["default"](graphieDiv).empty(); // $FlowFixMe[prop-missing]

      const graphie = this._graphie = createGraphie(graphieDiv); // This has to be called before addMouseLayer. You can re-init
      // with graphInit later if you prefer

      graphie.init({
        range: this._range(),
        scale: this._scale(),
        isMobile: this.props.isMobile
      }); // Only add the mouselayer if we actually want one.

      if (this.props.addMouseLayer) {
        graphie.addMouseLayer({
          onClick: this.props.onClick,
          onMouseDown: this.props.onMouseDown,
          onMouseUp: this.props.onMouseUp,
          onMouseMove: this.props.onMouseMove,
          setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
        });
      }

      graphie.snap = this.props.options.snapStep || [1, 1];

      if (this.props.responsive) {
        // Overwrite fixed styles set in init()
        // TODO(alex): Either make this component always responsive by
        // itself, or always wrap it in other components so that it is.
        $__default["default"](graphieDiv).css({
          width: "100%",
          height: "100%"
        });
        graphie.raphael.setSize("100%", "100%");
      }

      this.props.setup(graphie, ___default["default"].extend({
        range: this._range(),
        scale: this._scale()
      }, this.props.options));
    });

    _defineProperty(this, "_removeMovables", () => {
      // _.invoke works even when this._movables is undefined
      // $FlowFixMe[prop-missing]
      ___default["default"].invoke(this._movables, "remove"); // $FlowFixMe[prop-missing]


      this._movables = {};
    });

    _defineProperty(this, "_renderMovables", (children, options) => {
      // Each leaf of `children` is a movable descriptor created by a call to
      // some `GraphieMovable`, such as `MovablePoint`.
      //
      // This function takes these descriptors and renders them into
      // on-screen movables, or updates on-screen movables for
      // descriptors when possible.
      //
      // If there is no movable with that key already, this descriptor is
      // stored in this._movables and promoted to an on-screen movable by
      // calling `child.add(graphie)`.
      //
      // If a movable of the same type with the same key exists already,
      // we take `child.props` and give them to the already-existing
      // on-screen movable, and call `movable.modify()`
      const graphie = options.graphie;
      const oldMovables = options.oldMovables;
      const newMovables = options.newMovables;
      /* output parameter */

      const renderChildren = elem => {
        ___default["default"].each(elem.movableProps, prop => {
          // Render the children, and save the results of that
          // render to the appropriate props
          elem.props[prop] = this._renderMovables(elem.props[prop], options);
        });
      }; // Add/modify movables
      // We want to keep track of whether we have added a new svg element,
      // because if we have, then we need to call .toFront() on any svg
      // elements occurring afterwards. If this happens, we set
      // `areMovablesOutOfOrder` to true:


      let areMovablesOutOfOrder = false;
      return nestedMap(children, childDescriptor => {
        if (!childDescriptor) {
          // Still increment the key to avoid cascading key changes
          // on hiding/unhiding children, i.e. by using
          // {someBoolean && <MovablePoint />}
          options.nextKey++; // preserve the null/undefined in the resulting array

          return childDescriptor;
        } // Instantiate the descriptor to turn it into a real Movable


        const child = new childDescriptor.type(childDescriptor.props);
        assert$5(child instanceof GraphieMovable, "All children of a Graphie component must be Graphie " + "movables"); // Give each child a key

        const keyProp = childDescriptor.key;
        const key = keyProp == null ? "_no_id_" + options.nextKey : keyProp;
        options.nextKey++;
        const ref = childDescriptor.ref; // We render our children first. This allows us to replace any
        // `movableProps` on our child with the on-screen movables
        // corresponding with those descriptors.

        renderChildren(child);
        const prevMovable = oldMovables[key];

        if (!prevMovable) {
          // We're creating a new child
          child.add(graphie);
          areMovablesOutOfOrder = true;
          newMovables[key] = child;
        } else if (child.constructor === prevMovable.constructor) {
          // We're updating an old child
          prevMovable.props = child.props;
          const modifyResult = prevMovable.modify(graphie);

          if (modifyResult === "reordered") {
            areMovablesOutOfOrder = true;
          }

          newMovables[key] = prevMovable;
        } else {
          // We're destroying an old child and replacing it
          // with a new child of a different type
          // This generally is a bad idea, so warn about it if this
          // is being caused by implicit keys
          if (keyProp == null) {
            Log.error("Replacing a <Graphie> child with a " + "child of a different type. Please add keys " + "to your <Graphie> children", Errors.Internal);
          }

          prevMovable.remove();
          child.add(graphie);
          areMovablesOutOfOrder = true;
          newMovables[key] = child;
        }

        if (areMovablesOutOfOrder) {
          newMovables[key].toFront();
        }

        if (ref) {
          // $FlowFixMe[prop-missing]
          this.movables[ref] = newMovables[key];
        }

        return newMovables[key];
      });
    });

    _defineProperty(this, "_updateMovables", () => {
      // $FlowFixMe[prop-missing]
      const graphie = this._graphie; // $FlowFixMe[prop-missing]

      const oldMovables = this._movables;
      const newMovables = {}; // $FlowFixMe[prop-missing]

      this._movables = newMovables; // $FlowFixMe[prop-missing]

      this.movables = {};

      this._renderMovables(this.props.children, {
        nextKey: 1,
        graphie: graphie,
        oldMovables: oldMovables,
        newMovables: newMovables
      }); // Remove any movables that no longer exist in the child array


      ___default["default"].each(oldMovables, (oldMovable, key) => {
        if (!newMovables[key]) {
          oldMovable.remove();
        }
      });
    });
  }

  componentDidMount() {
    this._setupGraphie();

    this._updateMovables();
  }

  shouldComponentUpdate(nextProps) {
    // NOTE(jeresig): Prior to the React 16 upgrade this was using deepEq
    // However it started to throw errors. I switched to use Underscore's
    // isEqual method instead, hopefully having a similar effect.
    return !___default["default"].isEqual(this.props, nextProps);
  }

  componentDidUpdate(prevProps) {
    // If someone changes the setup function passed in, we should
    // technically setup graphie again. But that's definitely an
    // anti-pattern, since it is most-likely caused by passing in an
    // anonymous function rather than a "real" change, and re-rendering
    // in that case would cause us to constantly re-setup graphie, which
    // would have horrible performance implications. In order to avoid
    // those, we just warn here.
    if (this.props.setup !== prevProps.setup) {
      Log.error("<Graphie> was given a new setup function. " + "This is a bad idea; please refactor your code to give " + "the same setup function reference to <Graphie> on " + "every render.", Errors.Internal);
    }

    if (!deepEq$3(this.props.options, prevProps.options) || !deepEq$3(this.props.box, prevProps.box) || !deepEq$3(this.props.range, prevProps.range)) {
      this._setupGraphie();
    }

    this._updateMovables();
  }
  /**
   * Allow parents of the <Graphie> component to grab a reference to the
   * underlying graphie object using
   * `this.refs.graphieComponent.getGraphie()`
   *
   * This shouldn't be necessary for 90% of cases, but the power is there.
   * Use it for good and not evil.
   */


  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie-container"
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  }

} // Attach Graphie.createClass and Graphie.createSimpleClass


_defineProperty(Graphie, "propTypes", {
  addMouseLayer: PropTypes__default["default"].bool,
  box: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number).isRequired,
  children: PropTypes__default["default"].node,
  isMobile: PropTypes__default["default"].bool,
  onClick: PropTypes__default["default"].func,
  onMouseDown: PropTypes__default["default"].func,
  onMouseMove: PropTypes__default["default"].func,
  onMouseUp: PropTypes__default["default"].func,
  options: PropTypes__default["default"].shape({
    snapStep: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number)
  }),
  range: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].number)),
  responsive: PropTypes__default["default"].bool,
  setDrawingAreaAvailable: PropTypes__default["default"].func,
  setup: PropTypes__default["default"].func.isRequired
});

_defineProperty(Graphie, "defaultProps", {
  range: [[-10, 10], [-10, 10]],
  options: {},
  responsive: false,
  addMouseLayer: true
});

___default["default"].extend(Graphie, GraphieClasses); // Attach the Movable react components for easy reference


___default["default"].extend(Graphie, Movables);

const Status = {
  PENDING: "pending",
  LOADING: "loading",
  LOADED: "loaded",
  FAILED: "failed"
};

class ImageLoader extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "img", void 0);

    _defineProperty(this, "createLoader", () => {
      this.destroyLoader(); // We can only have one loader at a time.

      this.img = new Image();
      this.img.onload = this.handleLoad;
      this.img.onerror = this.handleError;
      this.img.src = this.props.src;
    });

    _defineProperty(this, "destroyLoader", () => {
      if (this.img) {
        this.img.onload = null;
        this.img.onerror = null;
        this.img = null;
      }
    });

    _defineProperty(this, "handleLoad", event => {
      this.destroyLoader();
      this.setState({
        status: Status.LOADED
      });

      if (this.props.onLoad) {
        this.props.onLoad(event);
      }
    });

    _defineProperty(this, "handleError", error => {
      this.destroyLoader();
      this.setState({
        status: Status.FAILED
      });

      if (this.props.onError) {
        this.props.onError(error);
      }
    });

    _defineProperty(this, "renderImg", () => {
      const {
        src,
        imgProps
      } = this.props;
      let onKeyUp = null;
      let onKeyDown = null;

      if (imgProps.onClick != null) {
        onKeyUp = e => {
          // 13 is enter key, 32 is space key
          if (e.keyCode === 13 || e.keyCode === 32) {
            imgProps.onClick && imgProps.onClick(e);
          }
        };

        onKeyDown = e => {
          // 32 is space key
          if (e.keyCode === 32) {
            // don't scroll on space when the image is focused
            e.preventDefault();
          }
        };
      }

      const staticUrl = getDependencies().staticUrl;
      return /*#__PURE__*/React__namespace.createElement("img", _extends$1({
        src: staticUrl(src),
        onKeyUp: onKeyUp,
        onKeyDown: onKeyDown
      }, imgProps));
    });

    this.state = {
      status: props.src ? Status.LOADING : Status.PENDING
    };
  }

  componentDidMount() {
    if (this.state.status === Status.LOADING) {
      this.createLoader();
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.src !== nextProps.src) {
      this.setState({
        status: nextProps.src ? Status.LOADING : Status.PENDING
      });
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.state.status === Status.LOADING && !this.img) {
      this.createLoader();
    }

    if (prevState.status !== this.state.status) {
      this.props.onUpdate(this.state.status);
    }
  }

  componentWillUnmount() {
    this.destroyLoader();
  }

  render() {
    switch (this.state.status) {
      case Status.LOADED:
        return this.renderImg();

      case Status.FAILED:
        if (this.props.children) {
          return this.props.children;
        }

        break;

      default:
        if (this.props.preloader) {
          return this.props.preloader();
        }

    }

    return null;
  }

}

// Minimum image width to make an image appear as zoomable.
const ZOOMABLE_THRESHOLD = 700; // The global cache of label data. Its format is:
// {
//   hash (e.g. "c21435944d2cf0c8f39d9059cb35836aa701d04a"): {
//     loaded: a boolean of whether the data has been loaded or not
//     dataCallbacks: a list of callbacks to call with the data when the data
//                    is loaded
//     data: the other data for this hash
//   },
//   ...
// }

const labelDataCache = {}; // Write our own JSONP handler because all the other ones don't do things we
// need.

const doJSONP = function (url, options) {
  options = {
    callbackName: "callback",
    success: $__default["default"].noop,
    error: $__default["default"].noop,
    ...options
  }; // Create the script

  const script = document.createElement("script");
  script.setAttribute("async", "");
  script.setAttribute("src", url); // A cleanup function to run when we're done.

  function cleanup() {
    document.head && document.head.removeChild(script);
    delete window[options.callbackName];
  } // Add the global callback.


  window[options.callbackName] = function () {
    cleanup();
    options.success.apply(null, arguments);
  }; // Add the error handler.


  script.addEventListener("error", function () {
    cleanup();
    options.error.apply(null, arguments);
  }); // Insert the script to start the download.

  document.head && document.head.appendChild(script);
}; // For offline exercises in the mobile app, we download the graphie data
// (svgs and localized data files) and serve them from the local file
// system (with file://). We replace urls that start with `web+graphie`
// in the perseus json with this `file+graphie` prefix to indicate that
// they should have the `file://` protocol instead of `https://`.


const svgLocalLabelsRegex = /^file\+graphie\:/;
const hashRegex = /\/([^/]+)$/;

function isImageProbablyPhotograph(imageUrl) {
  // TODO(david): Do an inventory to refine this heuristic. For example, what
  //     % of .png images are illustrations?
  return /\.(jpg|jpeg)$/i.test(imageUrl);
}

function getLocale() {
  const {
    JIPT,
    kaLocale
  } = getDependencies();
  return JIPT.useJIPT ? "en-pt" : kaLocale;
}

function shouldUseLocalizedData() {
  return getLocale() !== "en";
} // A regex to split at the last / of a URL, separating the base part from the
// hash. This is used to create the localized label data URLs.


const splitHashRegex = /\/(?=[^/]+$)/;

function getLocalizedDataUrl(url){ return Util.getDataUrl(url);}


function getUrlHash(url) {
  const match = url.match(hashRegex);

  if (match == null) {
    throw new PerseusError("not a valid URL", Errors.InvalidInput);
  }

  return match && match[1];
}

function defaultPreloader(dimensions) {
  return /*#__PURE__*/React__namespace.createElement("span", {
    style: {
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      position: "absolute",
      minWidth: "20px",
      display: "flex",
      justifyContent: "center",
      alignContent: "center"
    }
  }, /*#__PURE__*/React__namespace.createElement(wonderBlocksProgressSpinner.CircularSpinner, {
    size: "medium"
  }));
}

class SvgImage extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "_isMounted", void 0);

    _defineProperty(this, "onDataLoaded", (data, localized) => {
      if (this._isMounted && data.labels && data.range) {
        const labelsRendered = data.labels.reduce((dict, label) => ({ ...dict,
          [label.content]: false
        }), {});
        this.setState({
          dataLoaded: true,
          labelDataIsLocalized: localized,
          labelsRendered,
          labels: data.labels,
          range: data.range
        });
      }
    });

    _defineProperty(this, "onImageLoad", () => {
      // Only need to do this if rendering a Graphie
      if (this.sizeProvided()) {
        // If width and height are provided, we don't need to calculate the
        // size ourselves
        this.setState({
          imageLoaded: true
        });
      } else {
        Util.getImageSize(this.props.src, (width, height) => {
          if (this._isMounted) {
            this.setState({
              imageLoaded: true,
              imageDimensions: [width, height]
            });
          }
        });
      }
    });

    _defineProperty(this, "setupGraphie", (graphie, options) => {
      ___default["default"].map(options.labels, labelData => {
        const {
          JIPT
        } = getDependencies();

        if (JIPT.useJIPT && this.state.labelDataIsLocalized) {
          // If we're using JIPT translation and we got proper JIPT tags,
          // render the labels as plain text (so JIPT can find them) and
          // add some extra properties to the element so we can properly
          // re-render the label once it is replaced with translated
          // text.
          const elem = graphie.label(labelData.coordinates, labelData.content, labelData.alignment, false);
          getDependencies().svgImageJiptLabels.addLabel(elem, labelData.typesetAsMath);
        } else if (labelData.coordinates) {
          // Create labels from the data
          // TODO(charlie): Some erroneous labels are being sent down
          // without coordinates. They don't seem to have any content, so
          // it seems fine to just ignore them (rather than error), but
          // we should figure out why this is happening.
          const label = graphie.label(labelData.coordinates, labelData.content, labelData.alignment, labelData.typesetAsMath, {
            "font-size": 100 * this.props.scale + "%"
          }); // Convert absolute positioning css from pixels to percentages
          // TODO(alex): Dynamically resize font-size as well. This
          // almost certainly means listening to throttled window resize
          // events.

          const labelStyle = label[0].style;

          let labelTop = this._tryGetPixels(labelStyle.top);

          let labelLeft = this._tryGetPixels(labelStyle.left);

          if (labelTop === null || labelLeft === null) {
            // Graphie labels are supposed to have an explicit position,
            // but to be on the safe side, let's fall back to using
            // jQuery's position(). The reason we're not always using
            // this is that in the presence of CSS transforms, it will
            // give the rendered position, which may be scaled and
            // not equal to the explicitly specified one.
            const labelPosition = label.position();
            labelTop = labelPosition.top;
            labelLeft = labelPosition.left;
          }

          const svgHeight = (this.props.height || 0) * this.props.scale;
          const svgWidth = (this.props.width || 0) * this.props.scale;
          label.css({
            top: labelTop / svgHeight * 100 + "%",
            left: labelLeft / svgWidth * 100 + "%"
          }); // Add back the styles to each of the labels

          ___default["default"].each(labelData.style, (styleValue, styleName) => {
            label.css(styleName, styleValue);
          });
        }

        this.setState({
          labelsRendered: { ...this.state.labelsRendered,
            [labelData.content]: true
          }
        });
      });
    });

    _defineProperty(this, "_handleZoomClick", e => {
      const $image = $__default["default"](e.target); // It's possible that the image is already displayed at its
      // full size, but we don't really know that until we get a chance
      // to measure it (just now, after the user clicks). We only zoom
      // if there's more image to be shown.
      //
      // TODO(kevindangoor) If the window is narrow and the image is
      // already displayed as wide as possible, we may want to do
      // nothing in that case as well. Figuring this out correctly
      // likely required accounting for the image alignment and margins.

      if ($image.width() < this.props.width || this.props.zoomToFullSizeOnMobile) {
        ZoomService.handleZoomClick(e, this.props.zoomToFullSizeOnMobile);
      }

      this.props.trackInteraction && this.props.trackInteraction();
    });

    _defineProperty(this, "handleUpdate", status => {
      this.props.onUpdate(); // NOTE: Labeled SVG images use this.onImageLoad to set imageLoaded
      // to true and we only use the imageLoaded state when isLabeledSVG
      // is true setting imageLoaded true here shouldn't cause issues.

      if (!Util.isLabeledSVG(this.props.src) && status === "loaded") {
        this.setState({
          imageLoaded: true
        });
      }
    });

    props.setAssetStatus(props.src, false);
    this._isMounted = false;
    this.state = {
      imageLoaded: false,
      imageDimensions: null,
      dataLoaded: false,
      labelDataIsLocalized: false,
      labels: [],
      labelsRendered: {},
      range: [[0, 0], [0, 0]]
    };
  }

  componentDidMount() {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true;

    if (Util.isLabeledSVG(this.props.src)) {
      this.loadResources();
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.src !== nextProps.src) {
      this.setState({
        imageLoaded: false,
        dataLoaded: false
      });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    // If the props changed, we definitely need to update
    if (!___default["default"].isEqual(this.props, nextProps)) {
      return true;
    }

    const wasLoaded = this.isLoadedInState(this.state);
    const nextLoaded = this.isLoadedInState(nextState);
    return wasLoaded !== nextLoaded;
  }

  componentDidUpdate(prevProps, prevState) {
    const wasLoaded = this.isLoadedInState(prevState);
    const isLoaded = this.isLoadedInState(this.state);

    if (Util.isLabeledSVG(this.props.src) && !isLoaded) {
      this.loadResources();
    }

    if (!wasLoaded && isLoaded) {
      this.props.setAssetStatus(this.props.src, true);
    }
  }

  componentWillUnmount() {
    this._isMounted = false;
  } // Check if all of the resources are loaded in a given state


  isLoadedInState(state) {
    return Util.isLabeledSVG(this.props.src) ? state.imageLoaded && state.dataLoaded : state.imageLoaded;
  }

  loadResources() {
    const hash = getUrlHash(this.props.src); // We can't make multiple jsonp calls to the same file because their
    // callbacks will collide with each other. Instead, we cache the data
    // and only make the jsonp calls once.

    if (labelDataCache[hash]) {
      if (labelDataCache[hash].loaded) {
        const {
          data,
          localized
        } = labelDataCache[hash];
        this.onDataLoaded(data, localized);
      } else {
        labelDataCache[hash].dataCallbacks.push(this.onDataLoaded);
      }
    } else {
      const cacheData = {
        loaded: false,
        dataCallbacks: [this.onDataLoaded],
        data: null,
        localized: shouldUseLocalizedData()
      };
      labelDataCache[hash] = cacheData;

      const retrieveData = (url, errorCallback) => {
        doJSONP(url, {
          callbackName: "svgData" + hash,
          success: data => {
            cacheData.data = data;
            cacheData.loaded = true;

            ___default["default"].each(cacheData.dataCallbacks, callback => {
              callback(cacheData.data, cacheData.localized);
            });
          },
          error: errorCallback
        });
      };

      if (shouldUseLocalizedData()) {
        retrieveData(getLocalizedDataUrl(this.props.src), (x, status, error) => {
          cacheData.localized = false; // If there is isn't any localized data, fall back to
          // the original, unlocalized data

          retrieveData(Util.getDataUrl(this.props.src), (x, status, error) => {
            Log.error("Data load failed for svg-image", Errors.Service, {
              cause: error,
              loggedMetadata: {
                dataUrl: Util.getDataUrl(this.props.src),
                status
              }
            });
          });
        });
      } else {
        retrieveData(Util.getDataUrl(this.props.src), (x, status, error) => {
          Log.error("Data load failed for svg-image", Errors.Service, {
            cause: error,
            loggedMetadata: {
              dataUrl: Util.getDataUrl(this.props.src),
              status
            }
          });
        });
      }
    }
  }

  sizeProvided() {
    return this.props.width != null && this.props.height != null;
  }

  // Try to parse a CSS value as pixels. Returns null if the parameter string
  // does not contain a number followed by "px".
  _tryGetPixels(value) {
    value = value || ""; // While this doesn't check that there are no other alphabetical
    // characters prior to "px", that should be taken care of by the DOM,
    // which won't accept invalid units.

    if (!value.endsWith("px")) {
      return null;
    } // parseFloat() ignores trailing non-numerical characters.


    return parseFloat(value) || null;
  }

  render() {
    const imageSrc = this.props.src; // Props to send to all images

    const imageProps = {
      alt: this.props.alt,
      title: this.props.title,
      tabIndex: "0"
    }; // If alt text is present, AND overrideAriaHidden is true,
    // include aria-hidden to avoid screen reader from crawling texts
    // both from the div meant for screen readers (see svg-image.jsx)
    // and alt attribute.

    if (this.props.alt && this.props.overrideAriaHidden) {
      imageProps["aria-hidden"] = true;
    }

    const width = this.props.width && this.props.width * this.props.scale;
    const height = this.props.height && this.props.height * this.props.scale;
    const dimensions = {
      width,
      height
    }; // To make an image responsive, we need to know what its width and
    // height are in advance (before inserting it into the DOM) so that we
    // can ensure it doesn't grow past those limits. We don't always have
    // this information, especially in places where <Renderer /> is used
    // to render inline Markdown images within a widget. See Radio, Sorter,
    // Matcher, etc.
    // TODO(alex): Make all of those image rendering locations aware of
    // width+height so that they too can render responsively.

    const responsive = this.props.responsive && !!(width && height); // An additional <Graphie /> may be inserted after the image/graphie
    // pair. Only used by the image widget, for its legacy labels support.
    // Note that since the image widget always provides width and height
    // data, extraGraphie can be ignored for unresponsive images.
    // TODO(alex): Convert all existing uses of that to web+graphie. This
    // is tricky because web+graphie doesn't support labels on non-graphie
    // images.

    let extraGraphie;

    if (this.props.extraGraphie && this.props.extraGraphie.labels.length) {
      extraGraphie = /*#__PURE__*/React__namespace.createElement(Graphie, {
        box: this.props.extraGraphie.box,
        range: this.props.extraGraphie.range,
        options: {
          labels: this.props.extraGraphie.labels
        },
        responsive: true,
        addMouseLayer: false,
        setup: this.setupGraphie
      });
    } // If preloader is undefined, we use the default. If it's
    // null, there will be no preloader in use.


    const preloaderBaseFunc = this.props.preloader === undefined ? defaultPreloader : this.props.preloader;
    const preloader = preloaderBaseFunc ? () => preloaderBaseFunc(dimensions) : null; // Just use a normal image if a normal image is provided

    if (!Util.isLabeledSVG(imageSrc)) {
      if (responsive) {
        const wrapperClasses = classNames__default["default"]({
          zoomable: (width || 0) > ZOOMABLE_THRESHOLD,
          "svg-image": true
        });
        imageProps.onClick = this._handleZoomClick;
        return /*#__PURE__*/React__namespace.createElement(FixedToResponsive, {
          className: wrapperClasses,
          width: width,
          height: height,
          constrainHeight: this.props.constrainHeight,
          allowFullBleed: this.props.allowFullBleed && isImageProbablyPhotograph(imageSrc)
        }, /*#__PURE__*/React__namespace.createElement(ImageLoader, {
          src: imageSrc,
          imgProps: imageProps,
          preloader: preloader,
          onUpdate: this.handleUpdate
        }), extraGraphie);
      }

      imageProps.style = dimensions;
      return /*#__PURE__*/React__namespace.createElement(ImageLoader, {
        src: imageSrc,
        preloader: preloader,
        imgProps: imageProps,
        onUpdate: this.handleUpdate
      });
    }

    const imageUrl = Util.getSvgUrl(imageSrc);
    let graphie; // Since we only want to do the graphie setup once, we only render the
    // graphie once everything is loaded

    if (this.isLoadedInState(this.state)) {
      // Use the provided width and height to size the graphie if
      // possible, otherwise use our own calculated size
      let box;

      if (this.sizeProvided()) {
        box = [width, height];
      } else if (this.state.imageDimensions) {
        box = [this.state.imageDimensions[0] * this.props.scale, this.state.imageDimensions[1] * this.props.scale];
      } else {
        throw new PerseusError("svg-image has no dimensions", Errors.InvalidInput, {
          metadata: {
            src: this.props.src
          }
        });
      }

      const scale = [40 * this.props.scale, 40 * this.props.scale];
      graphie = /*#__PURE__*/React__namespace.createElement(Graphie // eslint-disable-next-line react/no-string-refs
      , {
        ref: "graphie",
        box: box,
        scale: scale,
        range: this.state.range,
        options: ___default["default"].pick(this.state, "labels"),
        responsive: responsive,
        addMouseLayer: false,
        setup: this.setupGraphie
      });
    }

    if (responsive) {
      return /*#__PURE__*/React__namespace.createElement(FixedToResponsive, {
        className: "svg-image",
        width: width,
        height: height,
        constrainHeight: this.props.constrainHeight
      }, /*#__PURE__*/React__namespace.createElement(ImageLoader, {
        src: imageUrl,
        onLoad: this.onImageLoad,
        onUpdate: this.handleUpdate,
        preloader: preloader,
        imgProps: imageProps
      }), graphie, extraGraphie);
    }

    imageProps.style = dimensions;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "unresponsive-svg-image",
      style: dimensions
    }, /*#__PURE__*/React__namespace.createElement(ImageLoader, {
      src: imageUrl,
      onLoad: this.onImageLoad,
      onUpdate: this.handleUpdate,
      preloader: preloader,
      imgProps: imageProps
    }), graphie);
  }

}

_defineProperty(SvgImage, "defaultProps", {
  constrainHeight: false,
  onUpdate: () => {},
  responsive: true,
  src: "",
  scale: 1,
  zoomToFullSizeOnMobile: false,
  setAssetStatus: (src, status) => {}
});

class Tex extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "_hasRendered", void 0);

    _defineProperty(this, "handleRender", () => {
      this.props.onRender();
      this.setState({
        rendered: true
      });
      this.props.onRender(); // We can't use BaseTeX's onRender callback directly b/c it
      // can fire from BaseTeX's componentDidMount() method and we
      // need to wait for all of the constructors in the perseus
      // render tree to first first.

      if (!this._hasRendered) {
        this._hasRendered = true;
        this.props.setAssetStatus(this.props.children, true);
      }
    });

    this.props.setAssetStatus(this.props.children, false);
    this.state = {
      rendered: false
    };
    this._hasRendered = false;
  }

  render() {
    const {
      TeX: BaseTeX
    } = getDependencies();
    return /*#__PURE__*/React__namespace.createElement(BaseTeX, {
      onRender: this.handleRender
    }, this.props.children);
  }

}

_defineProperty(Tex, "defaultProps", {
  onRender: () => {},
  setAssetStatus: (src, status) => {}
});

class Zoomable extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_isMounted", void 0);

    _defineProperty(this, "_observer", void 0);

    _defineProperty(this, "_measuringInitialized", void 0);

    _defineProperty(this, "_originalWidth", void 0);

    _defineProperty(this, "_node", void 0);

    _defineProperty(this, "state", {
      visible: false,
      marginBottomPx: 0,
      zoomed: true
    });

    _defineProperty(this, "reset", () => {
      if (!this._isMounted) {
        return;
      }

      if (!this.state.visible) {
        return;
      }

      this._originalWidth = null;
      this.setState({
        visible: false,
        compactHeight: null,
        expandedHeight: null,
        zoomed: true
      }, () => {
        this.measureAndScaleChildToFit(false);
      });
    });

    _defineProperty(this, "stopPropagationIfZoomed", e => {
      if (!this.state.zoomed) {
        // We only allow touch events (which trigger interactive elements)
        // to be propagated to children if we are already zoomed.
        e.stopPropagation();
      }
    });

    _defineProperty(this, "handleClickIfZoomed", e => {
      if (!this.state.zoomed) {
        e.stopPropagation();
        this.handleClick();
      }
    });

    _defineProperty(this, "handleClick", () => {
      this.setState({
        zoomed: !this.state.zoomed
      });
    });
  }

  componentDidMount() {
    this._isMounted = true;
    this.maybeInitializeMeasuring();
  }

  componentDidUpdate() {
    this.maybeInitializeMeasuring();
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this.reset);

    if (this._observer) {
      this._observer.disconnect();
    }

    this._isMounted = false;
  }

  /**
   * Calls measureAndScaleChildToFit and sets up a MutationObserver
   * to call measureAndScaleChildToFit if Zoomable's children change.
   *
   * If the readyToMeasure prop isn't true or if measuring has already
   * been initialized this method does nothing.
   */
  maybeInitializeMeasuring() {
    const shouldInitialize = this.props.readyToMeasure && !this._measuringInitialized;

    if (this._isMounted && shouldInitialize) {
      this._measuringInitialized = true; // $FlowFixMe[incompatible-type] - this is our root node, it won't be text

      this._node = ReactDOM__default["default"].findDOMNode(this); // We call measureAndScaleChildToFit asynchronously so that the browser
      // can apply CSS styles so that we get an accurate measurement.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax

      setTimeout(() => this.measureAndScaleChildToFit(false), 0);

      if (window.MutationObserver) {
        this._observer = new MutationObserver(mutations => {
          if (this._isMounted) {
            for (const mutation of mutations) {
              if (mutation.target !== this._node) {
                // Only act on mutations of children
                this.measureAndScaleChildToFit(this.state.zoomed);
                break;
              }
            }
          }
        });

        this._observer.observe(this._node, {
          childList: true,
          subtree: true,
          attributes: true
        });
      }

      window.addEventListener("resize", this.reset);
    }
  }

  // TODO(benkomalo): call this on viewport width changes?
  // https://github.com/Khan/math-input/blob/master/src/components/math-keypad.js#L43
  measureAndScaleChildToFit(zoomed) {
    if (!this._isMounted) {
      return;
    }

    const parentBounds = {
      width: this._node.offsetWidth,
      height: this._node.offsetHeight
    };
    const childBounds = this.props.computeChildBounds(this._node, parentBounds); // The +1 is a fudge factor to make sure any border on the
    // content isn't clipped by the the container it's in.

    const childWidth = childBounds.width + 1;
    const childHeight = childBounds.height + 1;

    if (childWidth > parentBounds.width) {
      const scale = parentBounds.width / childWidth;
      this.setState({
        scale,
        zoomed,
        compactHeight: Math.ceil(scale * childHeight),
        expandedHeight: childHeight
      }); // TODO(charlie): Do this as a callback to `setState`. Something is
      // going wrong with that approach in initial testing.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax

      setTimeout(() => {
        // Only show it after the next paint, to allow for CSS
        // transitions to fade it in.
        if (this._isMounted) {
          this.setState({
            visible: true
          });
        }
      });
    } else {
      this.setState({
        visible: true
      });
    }
  }

  render() {
    const {
      visible,
      scale,
      compactHeight,
      expandedHeight,
      zoomed
    } = this.state;
    const {
      animateHeight
    } = this.props;
    const property = animateHeight ? "opacity transform height" : "opacity transform"; // Since we're not using aphrodite, we have to prefix ourselves.

    const transitionStyle = visible ? {
      transitionProperty: property,
      WebkitTransitionProperty: property,
      msTransitionProperty: property,
      transitionDuration: "0.3s",
      WebkitTransitionDuration: "0.3s",
      msTransitionDuration: "0.3s",
      transitionTimingFunction: "ease-out",
      WebkitTransitionTimingfunction: "ease-out",
      msTransitionTmingFunction: "ease-out"
    } : {}; // Do a fancy little slide as we fade the contents in the first time.

    const translateOffset = visible ? "" : " translate(0, 8px)";
    const scaleString = (scale !== null && scale !== void 0 ? scale : 1).toString();
    const transform = zoomed ? "scale(1, 1) ".concat(translateOffset) : "scale(".concat(scaleString, ", ").concat(scaleString, ") ").concat(translateOffset);
    const style = {
      display: "block",
      width: "100%",
      height: zoomed ? expandedHeight : compactHeight,
      transform: transform,
      WebkitTransform: transform,
      msTransform: transform,
      transformOrigin: "0 0",
      WebkitTransformOrigin: "0 0",
      msTransformOrigin: "0 0",
      opacity: visible ? 1 : 0,
      WebkitTapHighlightColor: "transparent",
      ...transitionStyle
    };
    return /*#__PURE__*/React__namespace.createElement("span", {
      onClick: this.handleClick,
      onClickCapture: this.handleClickIfZoomed,
      onTouchCancelCapture: this.stopPropagationIfZoomed,
      onTouchEndCapture: this.stopPropagationIfZoomed,
      onTouchStartCapture: this.stopPropagationIfZoomed,
      style: style
    }, this.props.children);
  }

}

_defineProperty(Zoomable, "defaultProps", {
  animateHeight: false,
  readyToMeasure: true,
  computeChildBounds: parentNode => {
    const firstChild = parentNode.firstElementChild;
    return {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      width: firstChild.offsetWidth,
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      height: firstChild.offsetHeight
    };
  }
});

const computeMathBounds = (parentNode, parentBounds) => {
  const textElement = parentNode.querySelector(".katex-html") || parentNode.querySelector(".MathJax");
  const textBounds = {
    // $FlowFixMe[incompatible-use]
    width: textElement.offsetWidth,
    // $FlowFixMe[incompatible-use]
    height: textElement.offsetHeight
  }; // HACK(benkomalo): when measuring math content, note that
  // sometimes it actually peeks outside of the
  // container in some cases. Just be conservative and use
  // the maximum value of the text and the parent. :(

  return {
    width: Math.max(parentBounds.width, textBounds.width),
    height: Math.max(parentBounds.height, textBounds.height)
  };
};

class ZoomableTeX extends React__namespace.Component {
  constructor() {
    super();

    _defineProperty(this, "handleRender", () => {
      this.setState({
        isRendered: true
      });
    });

    this.state = {
      isRendered: false
    };
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement(Zoomable, {
      readyToMeasure: this.state.isRendered,
      computeChildBounds: computeMathBounds
    }, /*#__PURE__*/React__namespace.createElement(context$3.Consumer, null, _ref => {
      let {
        setAssetStatus
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement(Tex, {
        onRender: this.handleRender,
        setAssetStatus: setAssetStatus
      }, this.props.children);
    }));
  }

}

const defaultContext$1 = {
  activeDefinitionId: null,
  setActiveDefinitionId: () => {}
};
const DefinitionContext = /*#__PURE__*/React__namespace.createContext(defaultContext$1);
class DefinitionProvider extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      activeDefinitionId: null
    });

    _defineProperty(this, "setActiveDefinitionId", activeDefinitionId => {
      this.setState(prevState => ({
        activeDefinitionId
      }));
    });
  }

  render() {
    const {
      children
    } = this.props;
    const {
      activeDefinitionId
    } = this.state;
    const {
      setActiveDefinitionId
    } = this;
    return /*#__PURE__*/React__namespace.createElement(DefinitionContext.Provider, {
      value: {
        activeDefinitionId,
        setActiveDefinitionId
      }
    }, children);
  }

}
const DefinitionConsumer = DefinitionContext.Consumer;

class ErrorBoundary extends React__namespace.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: ""
    };
  }

  componentDidCatch(error, info) {
    this.setState({
      error: error.toString()
    });
    Log.error("Perseus error boundary caught error", Errors.Internal, {
      cause: error,
      loggedMetadata: {
        info: info.toString()
      }
    });
  }

  render() {
    if (this.state.error) {
      // TODO(djf): perhaps we should have one error boundary for
      // inline elements and one for block elements. This one uses
      // a <span> and effectively converts block elements with
      // errors into inline elements.
      // TODO(michaelpolyak): Link error icon to "Report a problem".
      return /*#__PURE__*/React__namespace.createElement("svg", {
        height: "16",
        width: "16",
        viewBox: "0 0 16 16"
      }, /*#__PURE__*/React__namespace.createElement("path", {
        d: "m8 16c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-3c0.55 0 1-0.45 1-1s-0.45-1-1-1-1 0.45-1 1 0.45 1 1 1zm0-9c-0.55 0-1 0.45-1 1v4c0 0.55.45 1 1 1s1-0.45 1-1v-4c0-0.55-0.45-1-1-1z",
        fill: "#d92916",
        fillRule: "evenodd"
      }));
    }

    return this.props.children;
  }

}

/**
 * This alternate version of `.track` does nothing as an optimization.
 */
function _noop() {}
/**
 * Wrapper for the trackInteraction apiOption.
 */


class InteractionTracker {
  // eslint-disable-next-line ft-flow/no-weak-types
  constructor( // eslint-disable-next-line ft-flow/no-weak-types
  trackApi, // original apiOptions.trackInteraction
  widgetType, widgetID, setting // "" means track once
  ) {
    _defineProperty(this, "_tracked", void 0);

    _defineProperty(this, "setting", void 0);

    _defineProperty(this, "track", void 0);

    _defineProperty(this, "trackApi", void 0);

    _defineProperty(this, "widgetID", void 0);

    _defineProperty(this, "widgetType", void 0);

    _defineProperty(this, "_track", extraData => {
      if (this._tracked && !this.setting) {
        return;
      }

      this._tracked = true;
      this.trackApi({
        type: this.widgetType,
        id: this.widgetID,
        ...extraData
      });
    });

    if (!trackApi) {
      this.track = _noop;
    } else {
      this._tracked = false;
      this.trackApi = trackApi;
      this.widgetType = widgetType;
      this.widgetID = widgetID;
      this.setting = setting;
      this.track = this._track;
    }
  }
  /**
   * Function that actually calls the API to mark the interaction. This is
   * private. The public version is just `.track` and is bound to this object
   * for easy use in other context.
   *
   * @param extraData Any extra data to track about the event.
   * @private
   */


}

/**
 * Paragraph parsing/splitting for article jipt i18n
 */
const arrayRules = {
  fence: {
    match: SimpleMarkdown__default["default"].defaultRules.fence.match,
    order: 1,
    parse: (capture, state, parse) => ({
      type: "codeBlock",
      lang: capture[2] || undefined,
      content: capture[3]
    })
  },
  paragraph: {
    match: SimpleMarkdown__default["default"].defaultRules.paragraph.match,
    order: 2,
    parse: (capture, state, parse) => ({
      content: capture[1]
    })
  }
};
const builtArrayParser = SimpleMarkdown__default["default"].parserFor(arrayRules); // This should just return an array of strings! magick!

const parseToArray = source => {
  // Remove any leading newlines to avoid splitting weirdness
  // (simple-markdown has the `newline` rule for this, and i have
  // no idea how this will handle leading newlines without that rule),
  // and add \n\n to let it parse at a block/paragraph level
  const paragraphedSource = source.replace(/^\n\s*\n/, "") + "\n\n";
  return builtArrayParser(paragraphedSource, {
    inline: false
  }).map(c => {
    return c["content"];
  });
};

const joinFromArray = paragraphs => paragraphs.join("\n\n");

var JiptParagraphs = {
  parseToArray: parseToArray,
  joinFromArray: joinFromArray
};

const exclamationIcon = {
  path: "M6 11a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm0-9a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1z",
  height: 12,
  width: 12
};

class Lint extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_positionTimeout", void 0);

    _defineProperty(this, "state", {
      tooltipAbove: true
    });

    _defineProperty(this, "getPosition", () => {
      // $FlowFixMe[prop-missing]
      // $FlowFixMe[incompatible-use]
      const rect = ReactDOM__default["default"].findDOMNode(this).getBoundingClientRect(); // TODO(scottgrant): This is a magic number! We don't know the size
      // of the tooltip at this point, so we're arbitrarily choosing a
      // point at which to flip the tooltip's position.

      this.setState({
        tooltipAbove: rect.top > 100
      });
    });

    _defineProperty(this, "renderLink", style => {
      const tooltipAbove = this.state.tooltipAbove;
      let severityStyle;
      let warningText;
      let warningTextStyle;

      if (this.props.severity === 1) {
        severityStyle = styles$C.indicatorError;
        warningText = "Error";
        warningTextStyle = styles$C.publishBlockingError;
      } else if (this.props.severity === 2) {
        severityStyle = styles$C.indicatorWarning;
        warningText = "Warning";
        warningTextStyle = styles$C.warning;
      } else {
        severityStyle = styles$C.indicatorGuideline;
        warningText = "Recommendation";
        warningTextStyle = styles$C.warning;
      }

      return /*#__PURE__*/React__namespace.createElement("a", {
        href: "https://khanacademy.org/r/linter-rules#".concat(this.props.ruleName),
        target: "lint-help-window",
        className: aphrodite.css(style)
      }, /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(styles$C.indicator, severityStyle)
      }, this.props.severity === 1 && /*#__PURE__*/React__namespace.createElement(InlineIcon, exclamationIcon)), /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$C.tooltip, tooltipAbove && styles$C.tooltipAbove)
      }, this.props.message.split("\n\n").map((m, i) => /*#__PURE__*/React__namespace.createElement("p", {
        key: i,
        className: aphrodite.css(styles$C.tooltipParagraph)
      }, /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(warningTextStyle)
      }, warningText, ":", " "), m)), /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$C.tail, tooltipAbove && styles$C.tailAbove)
      })));
    });
  }

  componentDidMount() {
    // TODO(somewhatabstract): Use WB timing
    // eslint-disable-next-line no-restricted-syntax
    this._positionTimeout = window.setTimeout(this.getPosition);
  }

  componentWillUnmount() {
    // TODO(somewhatabstract): Use WB timing
    // eslint-disable-next-line no-restricted-syntax
    window.clearTimeout(this._positionTimeout);
  } // We can't call setState in componentDidMount without risking a render
  // thrash, and we can't call getBoundingClientRect in render, so we
  // borrow a timeout approach from learnstorm-dashboard.jsx and set our
  // state once the component has mounted and we can get what we need.


  // The main render method surrounds linty content with a block or
  // inline container and the link element that displays the indicator
  // and holds the tooltip.
  render() {
    const {
      children,
      inline,
      blockHighlight,
      insideTable
    } = this.props;

    if (insideTable) {
      // If we're inside a table, then linty nodes just get
      // a simple wrapper that allows them to be highlighted
      if (inline) {
        return /*#__PURE__*/React__namespace.createElement("span", {
          "data-lint-inside-table": "true"
        }, children);
      }

      return /*#__PURE__*/React__namespace.createElement("div", {
        "data-lint-inside-table": "true"
      }, children);
    }

    if (blockHighlight) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(styles$C.lintContainer, styles$C.lintContainerBlock)
      }, this.renderLink(styles$C.radioWidgetHoverTarget), /*#__PURE__*/React__namespace.createElement("span", null, children));
    }

    if (inline) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        className: aphrodite.css(styles$C.lintContainer)
      }, this.renderLink(styles$C.inlineHoverTarget), /*#__PURE__*/React__namespace.createElement("span", null, children));
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$C.lintContainer)
    }, this.renderLink(styles$C.hoverTarget), /*#__PURE__*/React__namespace.createElement("div", null, children));
  }

} // $FlowFixMe[prop-missing]


_defineProperty(Lint, "propTypes", {
  // The children are the linty content we're highlighting
  children: PropTypes__default["default"].node,
  // Inline lint is highlighted differently than block lint.
  inline: PropTypes__default["default"].bool,
  // This is the text that appears in the tooltip
  message: PropTypes__default["default"].string.isRequired,
  // This is used as the fragment id (hash) in the URL of the link
  ruleName: PropTypes__default["default"].string.isRequired,
  // Lint warnings inside tables are handled specially
  insideTable: PropTypes__default["default"].bool.isRequired,
  // Should lint highlighting be rendered as a block to the left of
  // the lint instead of on the right gutter?
  blockHighlight: PropTypes__default["default"].bool,
  // How important this lint message is for the editor. Severity goes
  // from 1 (indicating an error) to 4 (offline reporting only)
  severity: PropTypes__default["default"].number
});

const styles$C = aphrodite.StyleSheet.create({
  // This is the class of the outermost element.
  // We use relative positioning so that the lint indicator can be
  // positioned absolutely relative to the position of the linty container.
  lintContainer: {
    position: "relative"
  },
  // Some elements that might be inline with bad parent styling are treated
  // as block elements so they render and are visible.
  lintContainerBlock: {
    display: "block"
  },
  // This is the main class for block lint. It is applied to the link element
  // that is also the hover target.
  hoverTarget: {
    // Absolute positioning relative to the lintContainer element
    position: "absolute",
    // Top of the hover target is aligned with the top of the linty block
    top: 0,
    // We want the hover target in the right margin. It is 24px wide, but
    // we have to offset it another 16px because of margins in the
    // Perseus content. I'm not sure where the 16px margin is set
    // so if that changes, this number will also have to be changed.
    // This is the part of the CSS that doesn't work right when
    // applied to things like blockquotes that have different right
    // margins.
    right: -40,
    // The hover target is a 24x24 block element.
    display: "block",
    width: 24,
    height: 24,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover
    ":hover div": {
      display: "block"
    },
    // The linty content is in a <div> sibling that follows the
    // hover target. This style highlights it on hover. We do an outline
    // rather than a border so we don't affect the layout. We could also
    // set the background color, but we don't because we can't reliably
    // set the text color of this block element. We could use
    // filter: invert(100%) if we want more visual change on hover here.
    ":hover ~ div": {
      outline: "1px solid " + warningColor
    },
    // If the div sibling is a table, then we may be displaying
    // lint warnings about errors inside that table. In that case
    // we want to highlight any linty descendants of the table
    ":hover ~ div div[data-lint-inside-table]": {
      outline: "1px solid " + warningColor
    },
    ":hover ~ div span[data-lint-inside-table]": {
      backgroundColor: warningColor,
      color: white$1
    }
  },
  // This is how we position the hover target for inline lint.
  inlineHoverTarget: {
    // For inline lint we position the hover target with a float:right
    // We can't use absolute positioning as we do in the block case
    // because the horizontal position is not predictable in the
    // inline case.
    float: "right",
    // We still have to make the hover target relative so that the
    // tooltip can be positioned relative to it.
    position: "relative",
    // See the comment above about the extra 16px of offset needed here.
    marginRight: -40,
    // The hover target is a 24x24 block. Same as the block case
    display: "block",
    width: 24,
    height: 24,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover.
    // This is the same as the block case.
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover. This is the same as the block case.
    ":hover div": {
      display: "block"
    },
    // The linty content is in a <span> sibling that follows the
    // hover target. This style highlights it on hover. In this case
    // we can just set the foreground and background color to really
    // draw attention to the linty content.
    ":hover ~ span": {
      backgroundColor: warningColor,
      color: white$1
    }
  },
  radioWidgetHoverTarget: {
    // These lint targets appear in radio checkboxes, and are not able to
    // position a lint icon in the right-most gutter thanks to a parent
    // overflow rule. We position these icons to the left of the block
    // where there is some room.
    position: "absolute",
    left: -40,
    // The hover target is a 24x24 block. Same as the block case
    display: "block",
    width: 24,
    height: 24,
    // By specifying a fixed minimum width, the tooltip will hover in a
    // readable position above and to the right.
    minWidth: 264,
    // The indicator is in a span inside the hover target.
    // This style changes its color on hover.
    // This is the same as the block case.
    ":hover > span": {
      backgroundColor: warningColorHover
    },
    // The tooltip is in a div element inside the hover target.
    // This style displays it on hover. This is the same as the block case.
    // We specify a fixed-width because of some parent styling.
    ":hover > div": {
      display: "block",
      padding: 8,
      width: 280
    },
    // Move the tooltip tail to an appropriate position relative to the
    // tooltip.
    ":hover > div > div": {
      left: 8
    },
    // The linty content is in a <span> sibling that follows the
    // hover target. This style highlights it on hover. In this case
    // we can just set the foreground and background color to really
    // draw attention to the linty content.
    ":hover ~ span": {
      backgroundColor: warningColor,
      color: white$1
    }
  },
  // This is the class for the lint indicator in the margin.
  indicator: {
    alignItems: "center",
    borderRadius: 4,
    color: "white",
    display: "flex",
    fontSize: 12,
    height: 8,
    justifyContent: "center",
    margin: 8,
    width: 8
  },
  indicatorError: {
    backgroundColor: "#be2612",
    borderRadius: 8,
    height: 16,
    width: 16
  },
  indicatorWarning: {
    backgroundColor: "#f86700"
  },
  indicatorGuideline: {
    backgroundColor: "#ffbe26"
  },
  // These are the styles for the tooltip
  tooltip: {
    // Absolute positioning relative to the lint indicator circle.
    position: "absolute",
    right: -12,
    // The tooltip is hidden by default; only displayed on hover
    display: "none",
    // When it is displayed, it goes on top!
    zIndex: 1000,
    // These styles control what the tooltip looks like
    color: white$1,
    backgroundColor: gray17,
    opacity: 0.9,
    fontFamily: baseFontFamily$1,
    fontSize: "12px",
    lineHeight: "15px",
    width: "320px",
    borderRadius: "4px"
  },
  // If we're going to render the tooltip above the warning circle, we use
  // the previous rules in tooltip, but change the position slightly.
  tooltipAbove: {
    bottom: 32
  },
  // We give the tooltip a little triangular "tail" that points down at
  // the lint indicator circle. This is inside the tooltip and positioned
  // relative to it. It also shares the opacity of the tooltip. We're using
  // the standard CSS trick for drawing triangles with a thick border.
  tail: {
    position: "absolute",
    top: -12,
    right: 16,
    width: 0,
    height: 0,
    // This is the CSS triangle trick
    borderLeft: "8px solid transparent",
    borderRight: "8px solid transparent",
    borderBottom: "12px solid " + gray17
  },
  tailAbove: {
    bottom: -12,
    borderBottom: "none",
    borderTop: "12px solid " + gray17,
    top: "auto"
  },
  // Each warning in the tooltip is its own <p>. They are 12 pixels from
  // the edges of the tooltip and 12 pixels from each other.
  tooltipParagraph: {
    margin: 12
  },
  // The text "Warning" inside the tooltip is highlighted like this
  warning: {
    color: warningColor,
    fontFamily: boldFontFamily
  },
  // The text "Publish-blocking error" instide the tooltip is highlighted
  // like this
  publishBlockingError: {
    color: publishBlockingErrorColor
  }
});

/* eslint-disable no-useless-escape, no-prototype-builtins */
const rules$1 = { ...pureMarkdown.pureMarkdownRules,
  // NOTE: basically ignored by JIPT. wraps everything at the outer layer
  columns: { ...pureMarkdown.pureMarkdownRules.columns,
    react: (node, output, state) => {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-two-columns",
        key: state.key
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column"
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column-content"
      }, output(node.col1, state))), /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column"
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: "sat-header-grafting-area"
      }), /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-column-content"
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: "sat-skill-subscore-grafting-area"
      }), output(node.col2, state), /*#__PURE__*/React__namespace.createElement("div", {
        className: "sat-grafting-area"
      }))));
    }
  },
  // Match paragraphs consisting solely of crowdin IDs
  // (they look roughly like crwdns9238932:0), which means that
  // crowdin is going to take the DOM node that ID is rendered into
  // and count it as the top-level translation node. They mutate this
  // node, so we need to make sure it is an outer node, not an inner
  // span. So here we parse this separately and just output the
  // raw string, which becomes the body of the <QuestionParagraph>
  // created by the Renderer.
  // This currently (2015-09-01) affects only articles, since
  // for exercises the renderer just renders the crowdin id to the
  // renderer div.
  crowdinId: { ...pureMarkdown.pureMarkdownRules.crowdinId,
    react: (node, output, state) => node.id
  },
  // Ensure that the table is focusable in sequential keyboard navigation
  // when rendered on mobile in a modal. Specifically this is needed for
  // Android Talkback, to enable reading/navigating tables with the swipe
  // left/right gesture. Note, setting `tabindex` doesn't appear required for
  // iOS 14.4, in order for VoiceOver to work.
  table: { ...pureMarkdown.pureMarkdownRules.table,
    react: function (node, output, state) {
      // $FlowFixMe[prop-missing]
      // $FlowFixMe[incompatible-use]
      const table = SimpleMarkdown__default["default"].defaultRules.table.react(node, output, state);

      if (!state.isMobile) {
        return table;
      }

      return /*#__PURE__*/React__namespace.cloneElement(table, {
        tabIndex: 0
      });
    }
  },
  // This is pretty much horrible, but we have a regex here to capture an
  // entire table + a title. capture[1] is the title. capture[2] of the
  // regex is a copy of the simple-markdown nptable regex. Then we turn
  // our capture[2] into tableCapture[0], and any further captures in
  // our table regex into tableCapture[1..], and we pass tableCapture to
  // our nptable regex
  titledTable: { ...pureMarkdown.pureMarkdownRules.titledTable,
    react: (node, output, state) => {
      let contents;

      if (!node.table) {
        contents = "//invalid table//";
      } else if (node.table.type === "lint") {
        var _node$table$content;

        // The `table` in this node is actually a `lint` node,
        // not the expected `table` node. This is due to the linter
        // implementation "reparenting" the `table` node, see
        // perseus-linter/src/index.js
        if (((_node$table$content = node.table.content) === null || _node$table$content === void 0 ? void 0 : _node$table$content.type) === "table") {
          // And the `content` of this lint node is the `table` node
          // which we actually want to render. Thus, we perform
          // surgery on the node to form the desired shape, so that
          // we can render a `lint` node which will then recursively
          // render the correctly shaped `titledTable` node.
          contents = rules$1.lint.react({ ...node.table,
            content: { ...node,
              table: node.table.content
            }
          }, output, { ...state,
            // Recursively render the `titledTable` node without
            // the wrapper div, as we'll be wrapping `contents`
            // ourselves below.
            unwrapTitledTableContents: true
          });
        } else {
          // We know `node.table` is actually a `lint` node, but we
          // don't know how to handle its `content`. Let the lint
          // node renderer figure it out.
          contents = rules$1.lint.react(node.table, output, state);
        }
      } else {
        // $FlowFixMe[prop-missing]
        // $FlowFixMe[incompatible-use]
        const tableOutput = SimpleMarkdown__default["default"].defaultRules.table.react(node.table, output, state);
        const caption = /*#__PURE__*/React__namespace.createElement("caption", {
          key: "caption",
          className: "perseus-table-title"
        }, output(node.title, state)); // Splice the caption into the table's children with the
        // caption as the first child.

        contents = /*#__PURE__*/React__namespace.cloneElement(tableOutput, null, [caption, ...tableOutput.props.children]);
      }

      if (state.unwrapTitledTableContents) {
        return contents;
      } // Note: if the DOM structure changes, edit the Zoomable wrapper
      // in src/renderer.jsx.


      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-titled-table",
        key: state.key
      }, contents);
    }
  },
  widget: { ...pureMarkdown.pureMarkdownRules.widget,
    react: (node, output, state) => {
      // The actual output is handled in the renderer, where
      // we know the current widget props/state. This is
      // just a stub for testing.
      return /*#__PURE__*/React__namespace.createElement("em", {
        key: state.key
      }, i18n__namespace.doNotTranslate("[Widget: ", node.id, "]"));
    }
  },
  blockMath: { ...pureMarkdown.pureMarkdownRules.blockMath,
    react: (node, output, state) => {
      const {
        TeX
      } = getDependencies(); // The actual output is handled in the renderer, because
      // it needs to pass in an `onRender` callback prop. This
      // is just a stub for testing.

      return /*#__PURE__*/React__namespace.createElement(TeX, {
        key: state.key
      }, node.content);
    }
  },
  math: { ...pureMarkdown.pureMarkdownRules.math,
    react: (node, output, state) => {
      const {
        TeX
      } = getDependencies(); // The actual output is handled in the renderer, because
      // it needs to pass in an `onRender` callback prop. This
      // is just a stub for testing.

      return /*#__PURE__*/React__namespace.createElement(TeX, {
        key: state.key
      }, node.content);
    }
  },
  unescapedDollar: { ...pureMarkdown.pureMarkdownRules.unescapedDollar,
    react: (node, output, state) => {
      // Unescaped dollar signs render correctly, but result in
      // untranslatable text after the i18n python linter flags it
      return "$";
    }
  },
  // Extend the SimpleMarkdown link parser to make the link open in a new
  // window and handle reverse tabnapping phishing attacks
  link: { ...pureMarkdown.pureMarkdownRules.link,
    react: function (node, output, state) {
      // $FlowFixMe[prop-missing]
      // $FlowFixMe[incompatible-use]
      const link = SimpleMarkdown__default["default"].defaultRules.link.react(node, output, state);
      const href = link.props.href;
      let rel = null; // The href prop should always be here, but just in case somehow the article's
      // link was not put together properly, let's make sure it's there so we
      // don't break the entire page.

      const isKAUrl = href ? href.match(/https?:\/\/[^\/]*khanacademy.org|^\//) : false;

      if (!isKAUrl) {
        // Prevents "reverse tabnabbing" phishing attacks
        rel = "noopener noreferrer";
      }

      const newProps = { ...link.props,
        target: "_blank",
        href,
        rel
      };

      if (state.baseElements && state.baseElements.Link) {
        return state.baseElements.Link(newProps);
      }

      return /*#__PURE__*/React__namespace.cloneElement(link, newProps);
    }
  },
  codeBlock: { ...pureMarkdown.pureMarkdownRules.codeBlock,
    react: (node, output, state) => {
      // ideally this should be a different rule, with only an
      // output function, but right now that breaks the parser.
      if (node.lang === "alt") {
        return /*#__PURE__*/React__namespace.createElement("div", {
          key: state.key,
          className: "perseus-markdown-alt perseus-sr-only"
        }, output(node.content, state));
      } // $FlowFixMe[prop-missing]
      // $FlowFixMe[incompatible-use]


      return SimpleMarkdown__default["default"].defaultRules.codeBlock.react(node, output, state);
    }
  },
  // The lint rule never actually matches anything.
  // We check for lint after parsing, and, if we find any, we
  // transform the tree to add lint nodes. This rule is here
  // just for the react() function
  lint: { ...pureMarkdown.pureMarkdownRules.lint,
    react: (node, output, state) => {
      return /*#__PURE__*/React__namespace.createElement(Lint, {
        message: node.message,
        ruleName: node.ruleName,
        inline: isInline(node.content),
        blockHighlight: node.blockHighlight,
        insideTable: node.insideTable,
        severity: node.severity
      }, output(node.content, state));
    }
  }
}; // Return true if the specified parse tree node represents inline content
// and false otherwise. We need this so that lint nodes can figure out whether
// they should behave as an inline wrapper or a block wrapper

function isInline(node) {
  // eslint-disable-next-line no-prototype-builtins
  return !!(node && node.type && inlineNodeTypes.hasOwnProperty(node.type));
}

const inlineNodeTypes = {
  text: true,
  math: true,
  unescapedDollar: true,
  link: true,
  img: true,
  strong: true,
  u: true,
  em: true,
  del: true,
  code: true
}; // $FlowFixMe[prop-missing]
// $FlowFixMe[incompatible-call]

const builtParser$1 = SimpleMarkdown__default["default"].parserFor(rules$1);

const parse$4 = (source, state) => {
  const paragraphedSource = source + "\n\n";
  return builtParser$1(paragraphedSource, { ...state,
    inline: false
  });
};

const inlineParser = (source, state) => {
  return builtParser$1(source, { ...state,
    inline: true
  });
};
/**
 * Traverse all of the nodes in the Perseus Markdown AST. The callback is
 * called for each node in the AST.
 */


const traverseContent = (ast, cb) => {
  if (___default["default"].isArray(ast)) {
    ___default["default"].each(ast, node => traverseContent(node, cb));
  } else if (___default["default"].isObject(ast)) {
    cb(ast);

    if (ast.type === "table") {
      traverseContent(ast.header, cb);
      traverseContent(ast.cells, cb);
    } else if (ast.type === "list") {
      traverseContent(ast.items, cb);
    } else if (ast.type === "titledTable") {
      traverseContent(ast.table, cb);
    } else if (ast.type === "columns") {
      traverseContent(ast.col1, cb);
      traverseContent(ast.col2, cb);
    } else if (___default["default"].isArray(ast.content)) {
      traverseContent(ast.content, cb);
    }
  }
};
/**
 * Pull out text content from a Perseus Markdown AST.
 * Returns an array of strings.
 */


const getContent = ast => {
  // Simplify logic by dealing with a single AST node at a time
  if (___default["default"].isArray(ast)) {
    return ___default["default"].flatten(___default["default"].map(ast, getContent));
  } // Base case: This is where we actually extract text content


  if (ast.content && ___default["default"].isString(ast.content)) {
    // Collapse whitespace within content unless it is code
    if (ast.type.toLowerCase().indexOf("code") !== -1) {
      // In case this is the sole child of a paragraph,
      // prevent whitespace from being trimmed later
      return ["", ast.content, ""];
    }

    return [ast.content.replace(/\s+/g, " ")];
  } // Recurse through child AST nodes
  // Assumptions made:
  // 1) Child AST nodes are either direct properties or inside
  //    arbitrarily nested lists that are direct properties.
  // 2) Only AST nodes have a 'type' property.


  const children = ___default["default"].chain(ast).values().flatten().filter(object => object != null && ___default["default"].has(object, "type")).value();

  if (!children.length) {
    return [];
  }

  const nestedContent = getContent(children);

  if (ast.type === "paragraph" && nestedContent.length) {
    // Trim whitespace before or after a paragraph
    nestedContent[0] = nestedContent[0].replace(/^\s+/, "");
    const last = nestedContent.length - 1;
    nestedContent[last] = nestedContent[last].replace(/\s+$/, "");
  }

  return nestedContent;
};
/**
 * Count the number of characters in Perseus Markdown source.
 * Markdown markup and widget references are ignored.
 */


const characterCount = source => {
  const ast = parse$4(source);
  const content = getContent(ast).join("");
  return content.length;
};

var PerseusMarkdown = {
  characterCount: characterCount,
  traverseContent: traverseContent,
  parse: parse$4,
  parseInline: inlineParser,
  reactFor: SimpleMarkdown__default["default"].reactFor,
  // $FlowFixMe[incompatible-use]
  ruleOutput: SimpleMarkdown__default["default"].ruleOutput(rules$1, "react"),
  basicOutput: SimpleMarkdown__default["default"].reactFor( // $FlowFixMe[incompatible-use]
  SimpleMarkdown__default["default"].ruleOutput(rules$1, "react")),
  sanitizeUrl: SimpleMarkdown__default["default"].sanitizeUrl
};

class QuestionParagraph extends React__namespace.Component {
  render() {
    const className = this.props.className ? "paragraph " + this.props.className : "paragraph"; // For perseus-article just-in-place-translation (jipt), we need
    // to attach some metadata to top-level QuestionParagraphs:

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className,
      "data-perseus-component-index": this.props.translationIndex,
      "data-perseus-paragraph-index": this.props.paragraphIndex
    }, this.props.children);
  }

}

/**
 * TranslationLinter asynchronously calls Khan Academy's poentry linter.
 *
 * The poentry linter checks for issues that prevent content from being
 * translated. This linter is KA-specific and so TranslationLinter does not do
 * anything in non-KA environments.
 */
// A LintCB is called once the linter has been run.

// msec to wait before we actually call the linter after receiving the
// last call. The timer is reset if the lint is called during the wait.
const DEBOUNCE_TIMEOUT = 1000;
class TranslationLinter {
  constructor() {
    _defineProperty(this, "previousContent", null);

    _defineProperty(this, "runLinter", _.debounce((perseusStr, onLintErrorsGenerated) => {
      // $FlowFixMe[cannot-resolve-name] -- TODO(joshuan): use an api flag instead?
      if (typeof KA === "undefined") {
        return;
      }

      if (perseusStr === this.previousContent) {
        return;
      }

      this.previousContent = perseusStr;

      if (perseusStr === "") {
        onLintErrorsGenerated([]);
        return;
      }

      fetch("/api/internal/translations/lint_poentry?preview=1&lang=en", {
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          // The poentry linter verifies that the translation from
          // the original text to the translated text is sane. We
          // want to ensure that the translation from English to
          // English is sane, so msgid === mstr.
          msgid: perseusStr,
          // msgid is the original text
          msgstr: perseusStr,
          // msgstr is the translated text
          format: "perseus_text",
          filename: ""
        }),
        method: "POST"
      }).then(response => {
        if (response.status >= 400) {
          return {
            status: "error",
            message: "Could not run i18n linter."
          };
        }

        return response.json();
      }, rejection => {
        return {
          status: "error",
          message: "Could not run i18n linter."
        };
      }).then(json => {
        if (json.status === "error") {
          onLintErrorsGenerated(["Some part of this text makes it untranslatable. " + "The specific message from the i18n linter was: " + json.message.replace(/\n/g, " ")]);
        } else {
          onLintErrorsGenerated([]);
        }
      });
    }, DEBOUNCE_TIMEOUT));
  }

  /**
   * Applies an array of errors generated by linters without position
   * information (TranslationLinter and the legacy getSaveWarnings()) to the
   * top of a Perseus tree.
   */
  applyLintErrors(parsedMarkdown, translationLintErrors) {
    // These lint errors do not have position data associated with
    // them, so we just plop them at the top.
    if (translationLintErrors.length) {
      const errorText = translationLintErrors.join("\n\n");
      parsedMarkdown.unshift({
        content: {
          type: "text",
          content: ""
        },
        insideTable: false,
        message: errorText,
        ruleName: "legacy-error",
        severity: PerseusLinter.Rule.Severity.ERROR,
        type: "lint"
      });
    }
  }

}

/**
 * Preprocess TeX code to convert things that KaTeX doesn't know how to handle
 * to things is does.
 */
var preprocessTex = (texCode => texCode // Replace uses of \begin{align}...\end{align} which KaTeX doesn't
// support (yet) with \begin{aligned}...\end{aligned} which renders
// the same is supported by KaTeX.  It does the same for align*.
// TODO(kevinb) update content to use aligned instead of align.
.replace(/\{align[*]?\}/g, "{aligned}") // Replace non-breaking spaces with regular spaces.
.replace(/[\u00a0]/g, " "));

const {
  interactiveSizes
} = constants$1; // Note: these size cutoffs represent content-width cutoffs as specified in
// http://zpl.io/1mVmvU (broken link - we no longer use Zeplin)
// TODO(benkomalo): these values aren't used in JS outside of this file, but
// are coupled to the values in styles/articles.less - DRY it up at some point

const smMax = articleMaxWidthTableInPx;
const mdMax = articleMaxWidthInPx;
const containerSizeClass = {
  SMALL: "small",
  MEDIUM: "medium",
  LARGE: "large",
  XLARGE: "xlarge"
};
const getClassFromWidth = width => {
  if (!width) {
    return containerSizeClass.MEDIUM;
  }

  if (width <= smMax) {
    return containerSizeClass.SMALL;
  }

  if (width <= mdMax) {
    return containerSizeClass.MEDIUM;
  }

  return containerSizeClass.LARGE;
};
const getInteractiveBoxFromSizeClass = sizeClass => {
  if (sizeClass === containerSizeClass.SMALL) {
    return [interactiveSizes.defaultBoxSizeSmall, interactiveSizes.defaultBoxSizeSmall];
  }

  return [interactiveSizes.defaultBoxSize, interactiveSizes.defaultBoxSize];
};

var sizingUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    containerSizeClass: containerSizeClass,
    getClassFromWidth: getClassFromWidth,
    getInteractiveBoxFromSizeClass: getInteractiveBoxFromSizeClass
});

const DEFAULT_ALIGNMENT$1 = "block"; // NOTE(kevinb): "default" is not one in `validAlignments`.

const DEFAULT_SUPPORTED_ALIGNMENTS = ["default"];
const DEFAULT_STATIC = false;
const DEFAULT_TRACKING = "";
const DEFAULT_LINTABLE = false;
const widgets = {};
const editors = {}; // Widgets must be registered to avoid circular dependencies with the
// core Editor and Renderer components.
// TODO(jeremy): The widget name is already embedded in the WidgetExports type
// so could we drop the `name` parameter here?

const registerWidget = (name, widget) => {
  widgets[name] = widget;
};
const registerWidgets = widgets => {
  widgets.forEach(widget => {
    registerWidget(widget.name, widget);
  });
  validateAlignments();
};
const registerEditors = editorsToRegister => {
  editorsToRegister.forEach(editor => {
    if (!editor.widgetName) {
      throw new PerseusError("Editor ".concat(editor.displayName, " doesn't have a widgetName property"), Errors.Internal);
    }

    editors[editor.widgetName] = editor;
  });
};
const getWidget = name => {
  // TODO(alex): Consider referring to these as renderers to avoid
  // overloading "widget"
  if (!___default["default"].has(widgets, name)) {
    return null;
  } // Allow widgets to specify a widget directly or via a function


  if (widgets[name].getWidget) {
    return widgets[name].getWidget();
  }

  return widgets[name].widget;
};
const getEditor = name => {
  return ___default["default"].has(editors, name) ? editors[name] : null;
};
const getTransform = name => {
  return ___default["default"].has(widgets, name) ? widgets[name].transform || ___default["default"].identity : null;
};
const getVersion = name => {
  const widgetInfo = widgets[name];

  if (widgetInfo) {
    return widgets[name].version || {
      major: 0,
      minor: 0
    };
  }

  return null;
};
const getVersionVector = () => {
  const version = {};

  ___default["default"].each(___default["default"].keys(widgets), function (name) {
    version[name] = getVersion(name);
  });

  return version;
};
const getPublicWidgets = () => {
  // TODO(alex): Update underscore.js so that _.pick can take a function.
  return ___default["default"].pick(widgets, ___default["default"].reject(___default["default"].keys(widgets), function (name) {
    return widgets[name].hidden;
  }));
};
const isAccessible = widgetInfo => {
  const accessible = widgets[widgetInfo.type].accessible;

  if (typeof accessible === "function") {
    return accessible(widgetInfo.options);
  }

  return !!accessible;
};
const getAllWidgetTypes = () => {
  return ___default["default"].keys(widgets);
};
const upgradeWidgetInfoToLatestVersion = oldWidgetInfo => {
  const type = oldWidgetInfo.type; // TODO(LP-10707): Remove unnecessary type checking (`type` is a string)

  if (!___default["default"].isString(type)) {
    throw new PerseusError("widget type must be a string, but was: " + type, Errors.Internal);
  }

  const widgetExports = widgets[type];

  if (widgetExports == null) {
    // If we have a widget that isn't registered, we can't upgrade it
    // TODO(aria): Figure out what the best thing to do here would be
    return oldWidgetInfo;
  } // Unversioned widgets (pre-July 2014) are all implicitly 0.0


  const initialVersion = oldWidgetInfo.version || {
    major: 0,
    minor: 0
  };
  const latestVersion = widgetExports.version || {
    major: 0,
    minor: 0
  }; // If the widget version is later than what we understand (major
  // version is higher than latest, or major versions are equal and minor
  // version is higher than latest), don't perform any upgrades.

  if (initialVersion.major > latestVersion.major || initialVersion.major === latestVersion.major && initialVersion.minor > latestVersion.minor) {
    return oldWidgetInfo;
  } // We do a clone here so that it's safe to mutate the input parameter
  // in propUpgrades functions (which I will probably accidentally do at
  // some point, and we would like to not break when that happens).


  let newEditorProps = ___default["default"].clone(oldWidgetInfo.options) || {};
  const upgradePropsMap = widgetExports.propUpgrades || {}; // Empty props usually mean a newly created widget by the editor,
  // and are always considerered up-to-date.
  // Mostly, we'd rather not run upgrade functions on props that are
  // not complete.

  if (___default["default"].keys(newEditorProps).length !== 0) {
    // We loop through all the versions after the current version of
    // the loaded widget, up to and including the latest version of the
    // loaded widget, and run the upgrade function to bring our loaded
    // widget's props up to that version.
    // There is a little subtlety here in that we call
    // upgradePropsMap[1] to upgrade *to* version 1,
    // (not from version 1).
    for (let nextVersion = initialVersion.major + 1; nextVersion <= latestVersion.major; nextVersion++) {
      if (upgradePropsMap[String(nextVersion)]) {
        newEditorProps = upgradePropsMap[String(nextVersion)](newEditorProps);
      } else {
        // This is a Log.error because it is unlikely to be hit in
        // local testing, and a Log.error is slightly less scary in
        // prod than a `throw new Error`
        Log.error("No upgrade found for widget. Cannot render.", Errors.Internal, {
          loggedMetadata: {
            type,
            fromMajorVersion: nextVersion - 1,
            toMajorVersion: nextVersion
          }
        }); // But try to keep going anyways (yolo!)
        // (Throwing an error here would just break the page
        // silently anyways, so that doesn't seem much better
        // than a halfhearted attempt to continue, however
        // shallow...)
      }
    }
  } // Minor version upgrades (eg. new optional props) don't have
  // transform functions. Instead, we fill in the new props with their
  // defaults.


  const defaultProps = type in editors ? editors[type].defaultProps : {};
  newEditorProps = { ...defaultProps,
    ...newEditorProps
  };
  let alignment = oldWidgetInfo.alignment; // Widgets that support multiple alignments will "lock in" the
  // alignment to the alignment that would be listed first in the
  // select box. If the widget only supports one alignment, the
  // alignment value will likely just end up as "default".

  if (alignment == null || alignment === "default") {
    alignment = getSupportedAlignments(type)[0];
  }

  let widgetStatic = oldWidgetInfo.static;

  if (widgetStatic == null) {
    widgetStatic = DEFAULT_STATIC;
  }

  return ___default["default"].extend({}, oldWidgetInfo, {
    // maintain other info, like type
    // After upgrading we guarantee that the version is up-to-date
    version: latestVersion,
    // Default graded to true (so null/undefined becomes true):
    graded: oldWidgetInfo.graded != null ? oldWidgetInfo.graded : true,
    alignment: alignment,
    static: widgetStatic,
    options: newEditorProps
  });
};
const getRendererPropsForWidgetInfo = (widgetInfo, problemNum) => {
  const type = widgetInfo.type;
  const widgetExports = widgets[type];

  if (widgetExports == null) {
    // The widget is not a registered widget
    // It shouldn't matter what we return here, but for consistency
    // we return the untransformed options, as if the widget did
    // not have a transform defined.
    return widgetInfo.options;
  }

  let transform;

  if (widgetInfo.static) {
    // There aren't a lot of real places where we'll have to default to
    // _.identity, but it's theoretically possible if someone changes
    // the JSON manually / we have to back out static support for a
    // widget.
    transform = getStaticTransform(type) || ___default["default"].identity;
  } else {
    transform = widgetExports.transform || ___default["default"].identity;
  } // widgetInfo.options are the widgetEditor's props:


  return transform(widgetInfo.options, problemNum);
};
const traverseChildWidgets$4 = (widgetInfo, traverseRenderer) => {
  if (!traverseRenderer) {
    throw new PerseusError("traverseRenderer must be provided, but was not", Errors.Internal);
  }

  if (!widgetInfo || !widgetInfo.type || !widgets[widgetInfo.type]) {
    return widgetInfo;
  }

  const widgetExports = widgets[widgetInfo.type];
  const props = widgetInfo.options;

  if (widgetExports.traverseChildWidgets && props) {
    const newProps = widgetExports.traverseChildWidgets(props, traverseRenderer);
    return ___default["default"].extend({}, widgetInfo, {
      options: newProps
    });
  }

  return widgetInfo;
};
/**
 * Handling for the optional alignments for widgets
 * See widget-container.jsx for details on how alignments are implemented.
 */

/**
 * Returns the list of supported alignments for the given (string) widget
 * type. This is used primarily at editing time to display the choices
 * for the user.
 *
 * Supported alignments are given as an array of strings in the exports of
 * a widget's module.
 */

const getSupportedAlignments = type => {
  const widgetExport = widgets[type];
  return widgetExport && widgetExport.supportedAlignments || DEFAULT_SUPPORTED_ALIGNMENTS;
};
/**
 * For the given (string) widget type, determine the default alignment for
 * the widget. This is used at rendering time to go from "default" alignment
 * to the actual alignment displayed on the screen.
 *
 * The default alignment is given either as a string (called
 * `defaultAlignment`) or a function (called `getDefaultAlignment`) on
 * the exports of a widget's module.
 */

const getDefaultAlignment = type => {
  const widgetExports = widgets[type];
  let alignment;

  if (!widgetExports) {
    return DEFAULT_ALIGNMENT$1;
  }

  if (widgetExports.getDefaultAlignment) {
    alignment = widgetExports.getDefaultAlignment();
  } else {
    alignment = widgetExports.defaultAlignment;
  }

  return alignment || DEFAULT_ALIGNMENT$1;
};
const validAlignments = ["block", "inline-block", "inline", "float-left", "float-right", "full-width"];
/**
 * Used at startup to fail fast if an alignment given by a widget is
 * invalid.
 */
// TODO(alex): Change this to run as a testcase (vs. being run at runtime)
// TODO(LP-10707): I think this can be completely removed because our Flow types
// enforce this!

const validateAlignments = () => {
  ___default["default"].each(widgets, function (widgetInfo) {
    if (widgetInfo.defaultAlignment && !___default["default"].contains(validAlignments, widgetInfo.defaultAlignment)) {
      throw new PerseusError("Widget '" + widgetInfo.displayName + "' has an invalid defaultAlignment value: " + widgetInfo.defaultAlignment, Errors.InvalidInput);
    }

    if (widgetInfo.supportedAlignments) {
      const unknownAlignments = ___default["default"].difference(widgetInfo.supportedAlignments, validAlignments);

      if (unknownAlignments.length) {
        throw new PerseusError("Widget '" + widgetInfo.displayName + "' has an invalid value for supportedAlignments: " + unknownAlignments.join(" "), Errors.InvalidInput);
      }
    }
  });
};
/**
 * Handling for static mode for widgets that support it.
 */

/**
 * Returns true iff the widget supports static mode.
 * A widget implicitly supports static mode if it exports a
 * staticTransform function.
 */

const supportsStaticMode = type => {
  const widgetInfo = widgets[type];
  return widgetInfo && widgetInfo.staticTransform != null;
};
/**
 * Return the staticTransform function used to convert the editorProps to
 * the rendered widget state.
 */

const getStaticTransform = type => {
  const widgetInfo = widgets[type];
  return widgetInfo && widgetInfo.staticTransform;
};
/**
 * Returns the tracking option for the widget. The default is "",
 * which means simply to track interactions once. The other available
 * option is "all" which means to track all interactions.
 */

const getTracking = type => {
  const widgetExport = widgets[type];
  return widgetExport && widgetExport.tracking || DEFAULT_TRACKING;
};
/**
 * Returns true if this widget can include lintable markdown text
 * and supports a highlightLint prop, or false otherwise.
 */

const isLintable = type => {
  const widgetExports = widgets[type];
  return widgetExports && widgetExports.isLintable || DEFAULT_LINTABLE;
};

var widgets$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    registerWidget: registerWidget,
    registerWidgets: registerWidgets,
    registerEditors: registerEditors,
    getWidget: getWidget,
    getEditor: getEditor,
    getTransform: getTransform,
    getVersion: getVersion,
    getVersionVector: getVersionVector,
    getPublicWidgets: getPublicWidgets,
    isAccessible: isAccessible,
    getAllWidgetTypes: getAllWidgetTypes,
    upgradeWidgetInfoToLatestVersion: upgradeWidgetInfoToLatestVersion,
    getRendererPropsForWidgetInfo: getRendererPropsForWidgetInfo,
    traverseChildWidgets: traverseChildWidgets$4,
    getSupportedAlignments: getSupportedAlignments,
    getDefaultAlignment: getDefaultAlignment,
    validateAlignments: validateAlignments,
    supportsStaticMode: supportsStaticMode,
    getStaticTransform: getStaticTransform,
    getTracking: getTracking,
    isLintable: isLintable
});

class WidgetContainer extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      // TODO(benkomalo): before we're mounted, we don't know how big
      // we're going to be, so just default to MEDIUM for now. :/ In the
      // future we can sniff with user-agents or something to get a
      // better approximation, to avoid flickers
      sizeClass: containerSizeClass.MEDIUM,
      widgetProps: this.props.initialProps
    });

    _defineProperty(this, "getWidget", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.widget;
    });

    _defineProperty(this, "replaceWidgetProps", newWidgetProps => {
      this.setState({
        widgetProps: newWidgetProps
      });
    });
  }

  componentDidMount() {
    // Only relay size class changes for mobile right now.  We may want to
    // this for desktop as well at some point in the future.
    if (this.state.widgetProps.apiOptions.isMobile) {
      // $FlowFixMe[prop-missing]
      // $FlowFixMe[incompatible-use]
      const containerWidth = ReactDOM__default["default"].findDOMNode(this).offsetWidth; // NOTE(benkomalo): in the common case, this won't change anything.
      // Unfortunately, it will cause a flash and re-layout on mobile,
      // but until we have better SSR or a more drastic way change to our
      // APIs that hints at the available size, we do have to measure DOM
      // unfortunately.

      /* eslint-disable react/no-did-mount-set-state */

      this.setState({
        sizeClass: getClassFromWidth(containerWidth)
      });
      /* eslint-enable react/no-did-mount-set-state */
    }
  }

  render() {
    let className = classNames__default["default"]({
      "perseus-widget-container": true,
      "widget-highlight": this.props.shouldHighlight,
      "widget-nohighlight": !this.props.shouldHighlight
    });
    const type = this.props.type;
    const WidgetType = getWidget(type);

    if (WidgetType == null) {
      // This is for the good of all people!!
      // eslint-disable-next-line no-console
      console.warn("Widget type '".concat(type, "' not found!")); // Just give up on invalid widget types

      return /*#__PURE__*/React__namespace.createElement("div", {
        className: className
      });
    }

    let alignment = this.state.widgetProps.alignment;

    if (alignment === "default") {
      alignment = getDefaultAlignment(type);
    }

    className += " widget-" + alignment;
    const apiOptions = this.state.widgetProps.apiOptions; // Hack to prevent interaction with static widgets: we overlay a big
    // div on top of the widget and overflow: hidden the container.
    // Ideally widgets themselves should know how to prevent interaction.

    const isStatic = this.state.widgetProps.static || apiOptions.readOnly;
    const staticContainerStyles = {
      position: "relative",
      overflow: "visible"
    };
    const staticOverlayStyles = {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: 0,
      left: 0,
      zIndex: zIndexInteractiveComponent$1
    }; // Some widgets may include strings of markdown that we may
    // want to run the linter on. So if the widget is lintable,
    // and we've been asked to highlight lint, pass that property
    // on to the widget, and if the content is not lintable, make sure
    // to default to false.
    // The linter context might be a constant object (and it isn't owned
    // by us anyway), so we copy it if we have to modify it.

    const linterContext = isLintable(type) ? this.props.linterContext : { ...this.props.linterContext,
      highlightLint: false
    }; // Note: if you add more props here, please consider whether or not
    // it should be auto-serialized (e.g. used in scoreInput()). See
    // widget-jsonify-deprecated.jsx and widget-prop-blacklist.jsx
    // We default to an empty object for style instead of null
    // because of a strange bug where the static styles aren't applied
    // after toggling static mode.

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className,
      style: isStatic ? staticContainerStyles : {}
    }, /*#__PURE__*/React__namespace.createElement(WidgetType, _extends$1({}, this.state.widgetProps, {
      linterContext: linterContext,
      containerSizeClass: this.state.sizeClass // eslint-disable-next-line react/no-string-refs
      ,
      ref: "widget"
    })), isStatic && /*#__PURE__*/React__namespace.createElement("div", {
      style: staticOverlayStyles
    }));
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.type !== nextProps.type) {
      throw new Error("WidgetContainer can't change widget type; set a different " + "key instead to recreate the container.");
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return this.props.shouldHighlight !== nextProps.shouldHighlight || this.props.type !== nextProps.type || this.state.widgetProps !== nextState.widgetProps || this.state.sizeClass !== nextState.sizeClass;
  }

}

_defineProperty(WidgetContainer, "defaultProps", {
  linterContext: PerseusLinter.linterContextDefault
});

const {
  mapObject: mapObject$2,
  mapObjectFromArray
} = objective_;
const rContainsNonWhitespace = /\S/;
const rImageURL = /(web\+graphie|https):\/\/[^\s]*/;

const noopOnRender = () => {};

const SHOULD_CLEAR_WIDGETS_PROP_LIST = ["content", "problemNum", "widgets"]; // Check if one focus path / id path is a prefix of another
// The focus path null will never be a prefix of any non-null
// path, since it represents no focus.
// Otherwise, prefix is calculated by whether every array
// element in the prefix is present in the same position in the
// wholeArray path.

const isIdPathPrefix = function (prefixArray, wholeArray) {
  if (prefixArray === null || wholeArray === null) {
    return prefixArray === wholeArray;
  }

  return ___default["default"].every(prefixArray, (elem, i) => {
    if (wholeArray != null) {
      return ___default["default"].isEqual(elem, wholeArray[i]);
    }
  });
};

class Renderer extends React__namespace.Component {
  // The i18n linter.
  // eslint-disable-next-line ft-flow/no-mutable-array
  constructor(_props, context) {
    var _this;

    super(_props, context);
    _this = this;

    _defineProperty(this, "_currentFocus", void 0);

    _defineProperty(this, "_foundTextNodes", void 0);

    _defineProperty(this, "_interactionTrackers", void 0);

    _defineProperty(this, "_isMounted", void 0);

    _defineProperty(this, "_isTwoColumn", void 0);

    _defineProperty(this, "_translationLinter", void 0);

    _defineProperty(this, "lastRenderedMarkdown", void 0);

    _defineProperty(this, "reuseMarkdown", void 0);

    _defineProperty(this, "translationIndex", void 0);

    _defineProperty(this, "widgetIds", void 0);

    _defineProperty(this, "getApiOptions", () => {
      return { ...ApiOptions.defaults,
        ...this.props.apiOptions
      };
    });

    _defineProperty(this, "_getInitialWidgetState", props => {
      const allWidgetInfo = this._getAllWidgetsInfo(props);

      return {
        widgetInfo: allWidgetInfo,
        widgetProps: this._getAllWidgetsStartProps(allWidgetInfo, props)
      };
    });

    _defineProperty(this, "_getAllWidgetsInfo", props => {
      return mapObject$2(props.widgets, (widgetInfo, widgetId) => {
        if (!widgetInfo.type || !widgetInfo.alignment) {
          const newValues = {};

          if (!widgetInfo.type) {
            newValues.type = widgetId.split(" ")[0];
          }

          if (!widgetInfo.alignment) {
            newValues.alignment = "default";
          }

          widgetInfo = ___default["default"].extend({}, widgetInfo, newValues);
        }

        return upgradeWidgetInfoToLatestVersion(widgetInfo);
      });
    });

    _defineProperty(this, "_getAllWidgetsStartProps", (allWidgetInfo, props) => {
      return mapObject$2(allWidgetInfo, widgetInfo => {
        return getRendererPropsForWidgetInfo(widgetInfo, props.problemNum);
      });
    });

    _defineProperty(this, "_getDefaultWidgetInfo", widgetId => {
      const widgetIdParts = Util.rTypeFromWidgetId.exec(widgetId);

      if (widgetIdParts == null) {
        // We should probably return null here since there's no
        // widget with the given id.
        // NOTE(jeremy): Further, the widgetId we were given does not even
        // look like a widget ID (ie. `widget-type \d+`). I can't figure
        // out how to trigger this line of code though.

        /* istanbul ignore next line */
        return {};
      }

      return {
        type: widgetIdParts[1],
        graded: true,
        options: {}
      };
    });

    _defineProperty(this, "_getWidgetInfo", widgetId => {
      return this.state.widgetInfo[widgetId] || this._getDefaultWidgetInfo(widgetId);
    });

    _defineProperty(this, "renderWidget", (impliedType, id, state) => {
      const widgetInfo = this.state.widgetInfo[id];

      if (widgetInfo && widgetInfo.alignment === "full-width") {
        state.foundFullWidth = true;
      }

      if (widgetInfo) {
        const type = widgetInfo && widgetInfo.type || impliedType;

        const shouldHighlight = ___default["default"].contains(this.props.highlightedWidgets, id); // By this point we should have no duplicates, which are
        // filtered out in this.render(), so we shouldn't have to
        // worry about using this widget key and ref:


        return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
          key: "container:" + id
        }, /*#__PURE__*/React__namespace.createElement(WidgetContainer, {
          ref: "container:" + id,
          type: type,
          initialProps: this.getWidgetProps(id),
          shouldHighlight: shouldHighlight,
          linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "widget")
        }));
      }

      return null;
    });

    _defineProperty(this, "getWidgetProps", id => {
      const apiOptions = this.getApiOptions();
      const widgetProps = this.state.widgetProps[id] || {}; // The widget needs access to its "rubric" at all times when in review
      // mode (which is really just part of its widget info).

      let reviewModeRubric = null;
      const widgetInfo = this.state.widgetInfo[id];

      if (this.props.reviewMode && widgetInfo) {
        reviewModeRubric = widgetInfo.options;
      }

      if (!this._interactionTrackers) {
        this._interactionTrackers = {};
      }

      let interactionTracker = this._interactionTrackers[id];

      if (!interactionTracker) {
        interactionTracker = this._interactionTrackers[id] = new InteractionTracker(apiOptions.trackInteraction, // $FlowFixMe[incompatible-call]
        widgetInfo && widgetInfo.type, id, // $FlowFixMe[incompatible-call]
        getTracking(widgetInfo && widgetInfo.type));
      }

      return { ...widgetProps,
        ref: id,
        widgetId: id,
        alignment: widgetInfo && widgetInfo.alignment,
        // When determining if a widget is static, we verify that the widget is not an
        // exercise question by verifying that it has no problem number.
        static: widgetInfo && widgetInfo.static && !this.props.problemNum,
        problemNum: this.props.problemNum,
        apiOptions: this.getApiOptions(),
        keypadElement: this.props.keypadElement,
        questionCompleted: this.props.questionCompleted,
        onFocus: ___default["default"].partial(this._onWidgetFocus, id),
        onBlur: ___default["default"].partial(this._onWidgetBlur, id),
        findWidgets: this.findWidgets,
        reviewModeRubric: reviewModeRubric,
        onChange: function (newProps, cb) {
          let silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          _this._setWidgetProps(id, newProps, cb, silent);
        },
        trackInteraction: interactionTracker.track,
        isLastUsedWidget: id === this.state.lastUsedWidgetId
      };
    });

    _defineProperty(this, "getSerializedState", widgetProps => {
      return mapObject$2(widgetProps || this.state.widgetProps, (props, widgetId) => {
        const widget = this.getWidgetInstance(widgetId);

        if (widget && widget.getSerializedState) {
          return widget.getSerializedState();
        }

        return props;
      });
    });

    _defineProperty(this, "restoreSerializedState", (serializedState, callback) => {
      // Do some basic validation on the serialized state (just make sure the
      // widget IDs are what we expect).
      const serializedWidgetIds = ___default["default"].keys(serializedState);

      const widgetPropIds = ___default["default"].keys(this.state.widgetProps); // If the two lists of IDs match (ignoring order)


      if (serializedWidgetIds.length !== widgetPropIds.length || ___default["default"].intersection(serializedWidgetIds, widgetPropIds).length !== serializedWidgetIds.length) {
        Log.error("Refusing to restore bad serialized state:", Errors.Internal, {
          loggedMetadata: {
            serializedState: JSON.stringify(serializedState),
            currentProps: JSON.stringify(this.state.widgetProps)
          }
        });
        return;
      } // We want to wait until any children widgets who have a
      // restoreSerializedState function also call their own callbacks before
      // we declare that the operation is finished.


      let numCallbacks = 1;

      const fireCallback = () => {
        --numCallbacks;

        if (callback && numCallbacks === 0) {
          callback();
        }
      };

      this.setState({
        widgetProps: mapObject$2(serializedState, (props, widgetId) => {
          const widget = this.getWidgetInstance(widgetId);

          if (widget && widget.restoreSerializedState) {
            // Note that we probably can't call
            // `this.change()/this.props.onChange()` in this
            // function, so we take the return value and use
            // that as props if necessary so that
            // `restoreSerializedState` in a widget can
            // change the props as well as state.
            // If a widget has no props to change, it can
            // safely return null.
            ++numCallbacks;
            const restoreResult = widget.restoreSerializedState(props, fireCallback);
            return ___default["default"].extend({}, this.state.widgetProps[widgetId], restoreResult);
          }

          return props;
        })
      }, () => {
        // Wait until all components have rendered. In React 16 setState
        // callback fires immediately after this componentDidUpdate, and
        // there is no guarantee that parent/siblings components have
        // finished rendering.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(fireCallback, 0);
      });
    });

    _defineProperty(this, "showRationalesForCurrentlySelectedChoices", () => {
      Object.keys(this.props.widgets).forEach(widgetId => {
        const widget = this.getWidgetInstance(widgetId);

        if (widget && widget.showRationalesForCurrentlySelectedChoices) {
          // $FlowFixMe[not-a-function]: figure out why this check isn't working
          widget.showRationalesForCurrentlySelectedChoices(this._getWidgetInfo(widgetId).options);
        }
      });
    });

    _defineProperty(this, "deselectIncorrectSelectedChoices", () => {
      // TODO(emily): this has the exact same structure as
      // showRationalesForCurrentlySelectedChoices above. Maybe DRY this up.
      Object.keys(this.props.widgets).forEach(widgetId => {
        const widget = this.getWidgetInstance(widgetId);

        if (widget && widget.deselectIncorrectSelectedChoices) {
          widget.deselectIncorrectSelectedChoices();
        }
      });
    });

    _defineProperty(this, "findInternalWidgets", filterCriterion => {
      let filterFunc; // Convenience filters:
      // "interactive-graph 3" will give you [[interactive-graph 3]]
      // "interactive-graph" will give you all interactive-graphs

      if (typeof filterCriterion === "string") {
        if (filterCriterion.indexOf(" ") !== -1) {
          const widgetId = filterCriterion;

          filterFunc = (id, widgetInfo, widget) => id === widgetId;
        } else {
          const widgetType = filterCriterion;

          filterFunc = (id, widgetInfo, widget) => {
            return widgetInfo.type === widgetType;
          };
        }
      } else {
        filterFunc = filterCriterion;
      }

      const results = this.widgetIds.filter(id => {
        const widgetInfo = this._getWidgetInfo(id);

        const widget = this.getWidgetInstance(id);
        return filterFunc(id, widgetInfo, widget);
      }).map(this.getWidgetInstance);
      return results;
    });

    _defineProperty(this, "findWidgets", filterCriterion => {
      return [...this.findInternalWidgets(filterCriterion), ...this.props.findExternalWidgets(filterCriterion)];
    });

    _defineProperty(this, "getWidgetInstance", id => {
      // eslint-disable-next-line react/no-string-refs
      const ref = this.refs["container:" + id];

      if (!ref) {
        return null;
      }

      return ref.getWidget();
    });

    _defineProperty(this, "_onWidgetFocus", function (id) {
      let focusPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (!___default["default"].isArray(focusPath)) {
        throw new PerseusError("widget props.onFocus focusPath must be an Array, " + "but was" + JSON.stringify(focusPath), Errors.Internal);
      }

      _this._setCurrentFocus([id].concat(focusPath));
    });

    _defineProperty(this, "_onWidgetBlur", (id, blurPath) => {
      const blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
      // before blur

      const fullPath = [id].concat(blurPath);

      if (!___default["default"].isEqual(fullPath, blurringFocusPath)) {
        return;
      } // Wait until after any new focus events fire this tick before
      // declaring that nothing is focused.
      // If a different widget was focused, we'll see an onBlur event
      // now, but then an onFocus event on a different element before
      // this callback is executed


      ___default["default"].defer(() => {
        if (___default["default"].isEqual(this._currentFocus, blurringFocusPath)) {
          this._setCurrentFocus(null);
        }
      });
    });

    _defineProperty(this, "getContent", (props, state) => {
      return state.jiptContent || props.content;
    });

    _defineProperty(this, "shouldRenderJiptPlaceholder", (props, state) => {
      // TODO(aria): Pass this in via webapp as an apiOption
      return getDependencies().JIPT.useJIPT && state.jiptContent == null && props.content.indexOf("crwdns") !== -1;
    });

    _defineProperty(this, "replaceJiptContent", (content, paragraphIndex) => {
      if (paragraphIndex == null) {
        // we're not translating paragraph-wise; replace the whole content
        // (we could also theoretically check for apiOptions.isArticle
        // here, which is what causes paragraphIndex to not be null)
        this.setState({
          jiptContent: content
        });
      } else {
        // This is the same regex we use in perseus/translate.py to find
        // code blocks. We use it to count entire code blocks as
        // paragraphs.
        const codeFenceRegex = /^\s*(`{3,}|~{3,})\s*(\S+)?\s*\n([\s\S]+?)\s*\1\s*$/;

        if (codeFenceRegex.test(content)) ; else if (/\S\n\s*\n\S/.test(content)) {
          // Our "render the exact same QuestionParagraphs each time"
          // strategy will fail if we allow translating a paragraph
          // to more than one paragraph. This hack renders as a single
          // paragraph and lets the translator know to not use \n\n,
          // hopefully. We can't wait for linting because we can't
          // safely render the node.
          // TODO(aria): Check for the max number of backticks or tildes
          // in the content, and just render a red code block of the
          // content here instead?
          content = "$\\large{\\red{\\text{Please translate each " + "paragraph to a single paragraph.}}}$";
        } else if (/^\s*$/.test(content)) {
          // We similarly can't have an all-whitespace paragraph, or
          // we will parse it as the closing of the previous paragraph
          content = "$\\large{\\red{\\text{Translated paragraph is " + "currently empty}}}$";
        } // Split the paragraphs; we have to use getContent() in case
        // nothing has been translated yet (in which case we just have
        // this.props.content)


        const allContent = this.getContent(this.props, this.state);
        const paragraphs = JiptParagraphs.parseToArray(allContent);
        paragraphs[paragraphIndex] = content;
        this.setState({
          jiptContent: JiptParagraphs.joinFromArray(paragraphs)
        });
      }
    });

    _defineProperty(this, "outputMarkdown", (ast, state) => {
      if (___default["default"].isArray(ast)) {
        // This is duplicated from simple-markdown
        // TODO(aria): Don't duplicate this logic
        const oldKey = state.key;
        const result = []; // map nestedOutput over the ast, except group any text
        // nodes together into a single string output.
        // NOTE(aria): These are never strings--always QuestionParagraphs
        // TODO(aria): We probably don't need this string logic here.

        let lastWasString = false;

        for (let i = 0; i < ast.length; i++) {
          state.key = i;
          state.paragraphIndex = i;
          const nodeOut = this.outputMarkdown(ast[i], state);
          const isString = typeof nodeOut === "string"; // NOTE(jeremy): As far as I can tell, this if is _never_
          // reached. As noted above, these are always QuestionParagraphs
          // now.

          /* istanbul ignore if */

          if (typeof nodeOut === "string" && lastWasString) {
            /**
             * $FlowIgnore[incompatible-type]
             * We know that last was string, but Flow can't see this
             * refinement.
             */
            result[result.length - 1] += nodeOut;
          } else {
            result.push(nodeOut);
          }

          lastWasString = isString;
        }

        state.key = oldKey;
        return result;
      } // !!! WARNING: Mutative hacks! mutates `this._foundTextNodes`:
      // because I wrote a bad interface to simple-markdown.js' `output`


      this._foundTextNodes = false;
      state.foundFullWidth = false;
      const output = this.outputNested(ast, state); // In Jipt-land, we need to render the exact same outer
      // QuestionParagraph nodes always. This means the number of
      // paragraphs needs to stay the same, and we can't modify
      // the classnames on the QuestionParagraphs or we'll destroy
      // the crowdin classnames. So we just only use the
      // 'paragraph' classname from the QuestionParagraph.
      // If this becomes a problem it would be easy to fix by wrapping
      // the nodes in an extra layer (hopefully only for jipt) that
      // handles the jipt classnames, and let this layer handle the
      // dynamic classnames.
      // We can't render the classes the first time and leave them
      // the same because we don't know at the time of the first
      // render whether they are full-bleed or centered, since they
      // only contain crowdin IDs like `crwdns:972384209:0...`

      let className;

      if (this.translationIndex != null) {
        className = null;
      } else {
        className = classNames__default["default"]({
          "perseus-paragraph-centered": !this._foundTextNodes,
          // There is only one node being rendered,
          // and it's a full-width widget.
          "perseus-paragraph-full-width": state.foundFullWidth && ast.content.length === 1
        });
      }

      return /*#__PURE__*/React__namespace.createElement(QuestionParagraph, {
        key: state.key,
        className: className,
        translationIndex: this.translationIndex,
        paragraphIndex: state.paragraphIndex
      }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, output));
    });

    _defineProperty(this, "outputNested", (ast, state) => {
      if (___default["default"].isArray(ast)) {
        // This is duplicated from simple-markdown
        // TODO(aria): Don't duplicate this logic
        const oldKey = state.key;
        const result = []; // map nestedOutput over the ast, except group any text
        // nodes together into a single string output.

        let lastWasString = false;

        for (let i = 0; i < ast.length; i++) {
          state.key = i;
          const nodeOut = this.outputNested(ast[i], state);
          const isString = typeof nodeOut === "string";

          if (typeof nodeOut === "string" && lastWasString) {
            /**
             * We know that last was string, but Flow can't see this
             * refinement.
             */
            // $FlowIgnore[incompatible-type]
            result[result.length - 1] += nodeOut;
          } else {
            result.push(nodeOut);
          }

          lastWasString = isString;
        }

        state.key = oldKey;
        return result;
      }

      return this.outputNode(ast, this.outputNested, state);
    });

    _defineProperty(this, "outputNode", (node, nestedOutput, state) => {
      const apiOptions = this.getApiOptions();
      const imagePlaceholder = apiOptions.imagePlaceholder;

      if (node.type === "widget") {
        const widgetPlaceholder = apiOptions.widgetPlaceholder;

        if (widgetPlaceholder) {
          return widgetPlaceholder;
        } // Widgets can contain text nodes, so we don't center them with
        // markdown magic here.
        // Instead, we center them with css magic in articles.less
        // /cry(aria)


        this._foundTextNodes = true;

        if (___default["default"].contains(this.widgetIds, node.id)) {
          // We don't want to render a duplicate widget key/ref,
          // as this causes problems with react (for obvious
          // reasons). Instead we just notify the
          // hopefully-content-creator that they need to change the
          // widget id.
          return /*#__PURE__*/React__namespace.createElement("span", {
            key: state.key,
            className: "renderer-widget-error"
          }, ["Widget [[", "", " ", node.id, "]] already exists."].join(""));
        }

        this.widgetIds.push(node.id);
        return this.renderWidget(node.widgetType, node.id, state);
      }

      if (node.type === "blockMath") {
        // We render math here instead of in perseus-markdown.jsx
        // because we need to pass it our onRender callback.
        const content = preprocessTex(node.content);
        const innerStyle = {
          // HACK(benkomalo): we only want horizontal scrolling, but
          // overflowX: 'auto' causes a vertical scrolling scrollbar
          // as well, despite the parent and child elements having
          // the exact same height. Force it to not scroll by
          // applying overflowY: 'hidden'
          overflowX: "auto",
          overflowY: "hidden",
          // HACK(kevinb): overflowY: 'hidden' inadvertently clips the
          // top and bottom of some fractions.  We add padding to the
          // top and bottom to avoid the clipping and then correct for
          // the padding by adding equal but opposite margins.
          paddingTop: 10,
          paddingBottom: 10,
          marginTop: -10,
          marginBottom: -10
        };

        if (apiOptions.isMobile) {
          // The style for the body of articles and exercises on mobile is
          // to have a 16px margin.  When a user taps to zoom math we'd
          // like the math to extend all the way to the edge of the page/
          // To achieve this affect we nest the Zoomable component in two
          // nested divs. The outer div has a negative margin to
          // counteract the margin on main perseus container.  The inner
          // div adds the margin back as padding so that when the math is
          // scaled out it's inset from the edge of the page.  When the
          // TeX component is full size it will extend to the edge of the
          // page if it's larger than the page.
          //
          // TODO(kevinb) automatically determine the margin size
          const margin = 16;
          const outerStyle = {
            marginLeft: -margin,
            marginRight: -margin
          };
          const horizontalPadding = {
            paddingLeft: margin,
            paddingRight: margin
          };
          const mobileInnerStyle = { ...innerStyle,
            ...styles$B.mobileZoomableParentFix
          };
          return /*#__PURE__*/React__namespace.createElement("div", {
            key: state.key,
            className: "perseus-block-math",
            style: outerStyle
          }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement("div", {
            className: "perseus-block-math-inner",
            style: { ...mobileInnerStyle,
              ...horizontalPadding
            }
          }, /*#__PURE__*/React__namespace.createElement(ZoomableTeX, null, content))));
        }

        return /*#__PURE__*/React__namespace.createElement("div", {
          key: state.key,
          className: "perseus-block-math"
        }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement("div", {
          className: "perseus-block-math-inner",
          style: innerStyle
        }, /*#__PURE__*/React__namespace.createElement(context$3.Consumer, null, _ref => {
          let {
            setAssetStatus
          } = _ref;
          return /*#__PURE__*/React__namespace.createElement(Tex, {
            setAssetStatus: setAssetStatus
          }, content);
        }))));
      }

      if (node.type === "math") {
        // Replace uses of \begin{align}...\end{align} which KaTeX doesn't
        // support (yet) with \begin{aligned}...\end{aligned} which renders
        // the same is supported by KaTeX.  It does the same for align*.
        // TODO(kevinb) update content to use aligned instead of align.
        const tex = node.content.replace(/\{align[*]?\}/g, "{aligned}"); // We render math here instead of in perseus-markdown.jsx
        // because we need to pass it our onRender callback.

        return /*#__PURE__*/React__namespace.createElement("span", {
          key: state.key,
          style: {
            // If math is directly next to text, don't let it
            // wrap to the next line
            whiteSpace: "nowrap"
          }
        }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement("span", null), /*#__PURE__*/React__namespace.createElement(context$3.Consumer, null, _ref2 => {
          let {
            setAssetStatus
          } = _ref2;
          return /*#__PURE__*/React__namespace.createElement(Tex, {
            onRender: this.props.onRender,
            setAssetStatus: setAssetStatus
          }, tex);
        }), /*#__PURE__*/React__namespace.createElement("span", null)));
      }

      if (node.type === "image") {
        if (imagePlaceholder) {
          return imagePlaceholder;
        } // We need to add width and height to images from our
        // props.images mapping.
        // We do a _.has check here to avoid weird things like
        // 'toString' or '__proto__' as a url.


        const extraAttrs = ___default["default"].has(this.props.images, node.target) ? this.props.images[node.target] : null; // The width of a table column is determined by the widest table
        // cell within that column, but responsive images constrain
        // themselves to the width of their parent containers. Thus,
        // responsive images don't do very well within tables. To avoid
        // haphazard sizing, simply make images within tables unresponsive.
        // TODO(alex): Make tables themselves responsive.

        const responsive = !state.inTable;
        return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
          key: state.key
        }, /*#__PURE__*/React__namespace.createElement(context$3.Consumer, null, _ref3 => {
          let {
            setAssetStatus
          } = _ref3;
          return /*#__PURE__*/React__namespace.createElement(SvgImage, _extends$1({
            setAssetStatus: setAssetStatus
            /* $FlowFixMe[incompatible-type]: sanitizeUrl() can return null */
            ,
            src: PerseusMarkdown.sanitizeUrl(node.target),
            alt: node.alt,
            title: node.title,
            responsive: responsive,
            onUpdate: this.props.onRender,
            zoomToFullSizeOnMobile: apiOptions.isMobile && apiOptions.isArticle
          }, extraAttrs));
        }));
      }

      if (node.type === "columns") {
        // Note that we have two columns. This is so we can put
        // a className on the outer renderer content for SAT.
        // TODO(aria): See if there is a better way we can do
        // things like this
        this._isTwoColumn = true; // but then render normally:

        return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
          key: state.key
        }, PerseusMarkdown.ruleOutput(node, nestedOutput, state));
      }

      if (node.type === "text") {
        if (rContainsNonWhitespace.test(node.content)) {
          this._foundTextNodes = true;
        } // Used by the translator portal to replace image URLs with
        // placeholders, see preprocessWidgets in manticore-utils.js
        // for more details.


        if (imagePlaceholder && rImageURL.test(node.content)) {
          return imagePlaceholder;
        }

        return node.content;
      }

      if (node.type === "table" || node.type === "titledTable") {
        const output = PerseusMarkdown.ruleOutput(node, nestedOutput, { ...state,
          isMobile: apiOptions.isMobile,
          inTable: true
        });

        if (!apiOptions.isMobile) {
          return output;
        }

        const margin = 16;
        const outerStyle = {
          marginLeft: -margin,
          marginRight: -margin
        };
        const innerStyle = {
          paddingLeft: 0,
          paddingRight: 0
        };
        const mobileInnerStyle = { ...innerStyle,
          ...styles$B.mobileZoomableParentFix
        };
        const wrappedOutput = /*#__PURE__*/React__namespace.createElement("div", {
          style: { ...mobileInnerStyle,
            overflowX: "auto"
          }
        }, /*#__PURE__*/React__namespace.createElement(ErrorBoundary, null, /*#__PURE__*/React__namespace.createElement(Zoomable, {
          animateHeight: true
        }, output))); // TODO(benkomalo): how should we deal with tappable items inside
        // of tables?

        return /*#__PURE__*/React__namespace.createElement("div", {
          style: outerStyle
        }, wrappedOutput);
      } // If it's a "normal" or "simple" markdown node, just
      // output it using its output rule.


      return /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {
        key: state.key
      }, PerseusMarkdown.ruleOutput(node, nestedOutput, state));
    });

    _defineProperty(this, "handleRender", prevProps => {
      const onRender = this.props.onRender;
      const oldOnRender = prevProps.onRender; // In the common case of no callback specified, avoid this work.

      if (onRender !== noopOnRender || oldOnRender !== noopOnRender) {
        const $images = $__default["default"](ReactDOM__default["default"].findDOMNode(this)).find("img"); // Fire callback on image load...

        if (oldOnRender !== noopOnRender) {
          $images.off("load", oldOnRender);
        }

        if (onRender !== noopOnRender) {
          $images.on("load", onRender);
        }
      } // ...as well as right now (non-image, non-TeX or image from cache)


      onRender();
    });

    _defineProperty(this, "_setCurrentFocus", path => {
      const apiOptions = this.getApiOptions(); // We don't do this when the new path is a prefix because
      // that prefix is already focused (we're just in a more specific
      // area of it). This makes it safe to call _setCurrentFocus
      // whenever a widget is interacted with--we won't wipe out
      // our focus state if we are already focused on a subpart
      // of that widget (i.e. a transformation NumberInput inside
      // of a transformer widget).

      if (!isIdPathPrefix(path, this._currentFocus)) {
        const prevFocus = this._currentFocus;

        if (prevFocus) {
          this.blurPath(prevFocus);
        }

        this._currentFocus = path;
        apiOptions.onFocusChange(this._currentFocus, prevFocus);
      }
    });

    _defineProperty(this, "focus", () => {
      let id;
      let focusResult;

      for (let i = 0; i < this.widgetIds.length; i++) {
        const widgetId = this.widgetIds[i];
        const widget = this.getWidgetInstance(widgetId);
        const widgetFocusResult = widget && widget.focus && widget.focus();

        if (widgetFocusResult) {
          id = widgetId;
          focusResult = widgetFocusResult;
          break;
        }
      }

      if (id) {
        // reconstruct a {path, element} focus object
        let path;

        if (typeof focusResult === "object") {
          // TODO(jeremy): I am 99% sure this path is no longer possible.
          // In D10274, focus management sometimes returned an object
          // with a `path` and `element` key. But later in D11387 and
          // D13664 things have been changed and seemingly removed the
          // object return value.
          // The result of focus was a {path, id} object itself
          path = [id].concat(focusResult.path || []);
          Log.error("Renderer received a focus result of type 'object' " + "instead of the expected type 'boolean'", Errors.Internal, {
            loggedMetadata: {
              focusResult: JSON.stringify(focusResult),
              currentProps: JSON.stringify(this.state.widgetProps)
            }
          });
        } else {
          // The result of focus was true or the like; just
          // construct a root focus object
          path = [id];
        }

        this._setCurrentFocus(path);

        return true;
      }
    });

    _defineProperty(this, "getDOMNodeForPath", path => {
      const widgetId = ___default["default"].first(path);

      const interWidgetPath = ___default["default"].rest(path); // Widget handles parsing of the interWidgetPath. If the path is empty
      // beyond the widgetID, as a special case we just return the widget's
      // DOM node.


      const widget = this.getWidgetInstance(widgetId);
      const getNode = widget && widget.getDOMNodeForPath;

      if (getNode) {
        return getNode(interWidgetPath);
      }

      if (interWidgetPath.length === 0) {
        // $FlowFixMe[incompatible-call]: make Widget a ReactInstance type
        return ReactDOM__default["default"].findDOMNode(widget);
      }
    });

    _defineProperty(this, "getGrammarTypeForPath", path => {
      const widgetId = ___default["default"].first(path);

      const interWidgetPath = ___default["default"].rest(path);

      const widget = this.getWidgetInstance(widgetId);

      if (widget && widget.getGrammarTypeForPath) {
        return widget.getGrammarTypeForPath(interWidgetPath);
      }
    });

    _defineProperty(this, "getInputPaths", () => {
      const inputPaths = [];

      ___default["default"].each(this.widgetIds, widgetId => {
        const widget = this.getWidgetInstance(widgetId);

        if (widget && widget.getInputPaths) {
          // Grab all input paths and add widgetID to the front
          const widgetInputPaths = widget.getInputPaths(); // Prefix paths with their widgetID and add to collective
          // list of paths.

          ___default["default"].each(widgetInputPaths, inputPath => {
            const relativeInputPath = [widgetId].concat(inputPath);
            inputPaths.push(relativeInputPath);
          });
        }
      });

      return inputPaths;
    });

    _defineProperty(this, "focusPath", path => {
      // No need to focus if it's already focused
      if (___default["default"].isEqual(this._currentFocus, path)) {
        return;
      }

      if (this._currentFocus) {
        // Unfocus old path, if exists
        this.blurPath(this._currentFocus);
      }

      const widgetId = ___default["default"].first(path);

      const interWidgetPath = ___default["default"].rest(path); // Widget handles parsing of the interWidgetPath


      const focusWidget = this.getWidgetInstance(widgetId);

      if (focusWidget && focusWidget.focusInputPath) {
        focusWidget.focusInputPath(interWidgetPath);
      }
    });

    _defineProperty(this, "blurPath", path => {
      // No need to blur if it's not focused
      if (!___default["default"].isEqual(this._currentFocus, path)) {
        return;
      }

      const widgetId = ___default["default"].first(path);

      const interWidgetPath = ___default["default"].rest(path);

      const widget = this.getWidgetInstance(widgetId); // We might be in the editor and blurring a widget that no
      // longer exists, so only blur if we actually found the widget

      if (widget) {
        const blurWidget = this.getWidgetInstance(widgetId);

        if (blurWidget && blurWidget.blurInputPath) {
          // Widget handles parsing of the interWidgetPath
          blurWidget.blurInputPath(interWidgetPath);
        }
      }
    });

    _defineProperty(this, "blur", () => {
      if (this._currentFocus) {
        this.blurPath(this._currentFocus);
      }
    });

    _defineProperty(this, "serialize", () => {
      const state = {};

      ___default["default"].each(this.state.widgetInfo, function (info, id) {
        // eslint-disable-next-line @babel/no-invalid-this
        const widget = this.getWidgetInstance(id);
        const s = widget.serialize();

        if (!___default["default"].isEmpty(s)) {
          state[id] = s;
        }
      }, this);

      return state;
    });

    _defineProperty(this, "emptyWidgets", () => {
      return ___default["default"].filter(this.widgetIds, id => {
        const widgetInfo = this._getWidgetInfo(id);

        if (widgetInfo.static) {
          // Static widgets shouldn't count as empty
          return false;
        }

        const widget = this.getWidgetInstance(id);

        if (widget && widget.simpleValidate) {
          const score = widget.simpleValidate(widgetInfo.options, null);
          return Util.scoreIsEmpty(score);
        }
      });
    });

    _defineProperty(this, "_setWidgetProps", (id, newProps, cb, silent) => {
      this.setState(prevState => {
        const widgetProps = { ...prevState.widgetProps,
          [id]: { ...prevState.widgetProps[id],
            ...newProps
          }
        }; // Update the `lastUsedWidgetId` to this widget - unless we're
        // in silent mode. We only want to track the last widget that
        // was actually _used_, and silent updates generally don't come
        // from _usage_.

        const lastUsedWidgetId = silent ? prevState.lastUsedWidgetId : id;

        if (!silent) {
          this.props.onSerializedStateUpdated(this.getSerializedState(widgetProps));
        }

        return {
          lastUsedWidgetId,
          widgetProps
        };
      }, () => {
        // Wait until all components have rendered. In React 16 setState
        // callback fires immediately after this componentDidUpdate, and
        // there is no guarantee that parent/siblings components have
        // finished rendering.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(() => {
          const cbResult = cb && cb();

          if (!silent) {
            this.props.onInteractWithWidget(id);
          }

          if (cbResult !== false) {
            // TODO(jack): For some reason, some widgets don't always
            // end up in refs here, which is repro-able if you make an
            // [[ orderer 1 ]] and copy-paste this, then change it to
            // be an [[ orderer 2 ]]. The resulting Renderer ends up
            // with an "orderer 2" ref but not an "orderer 1" ref.
            // @_@??
            // TODO(jack): Figure out why this is happening and fix it
            // As far as I can tell, this is only an issue in the
            // editor-page, so doing this shouldn't break clients
            // hopefully
            this._setCurrentFocus([id]);
          }
        }, 0);
      });
    });

    _defineProperty(this, "setInputValue", (path, newValue, focus) => {
      var _widget$setInputValue;

      const widgetId = ___default["default"].first(path);

      const interWidgetPath = ___default["default"].rest(path);

      const widget = this.getWidgetInstance(widgetId); // Widget handles parsing of the interWidgetPath.

      widget === null || widget === void 0 ? void 0 : (_widget$setInputValue = widget.setInputValue) === null || _widget$setInputValue === void 0 ? void 0 : _widget$setInputValue.call(widget, interWidgetPath, newValue, focus);
    });

    _defineProperty(this, "getUserInput", () => {
      return this.widgetIds.map(id => {
        const widget = this.getWidgetInstance(id);

        if (widget && widget.getUserInput) {
          // TODO(Jeremy): Add the widget ID in here so we can more
          // easily correlate it to the widget state.
          return widget.getUserInput();
        }
      });
    });

    _defineProperty(this, "getWidgetIds", () => {
      return this.widgetIds;
    });

    _defineProperty(this, "getUserInputForWidgets", () => {
      return mapObjectFromArray(this.widgetIds, id => {
        const widget = this.getWidgetInstance(id);

        if (widget && widget.getUserInput) {
          return widget.getUserInput();
        }
      });
    });

    _defineProperty(this, "scoreWidgets", () => {
      const widgetProps = this.state.widgetInfo;
      const onInputError = this.getApiOptions().onInputError;

      const gradedWidgetIds = ___default["default"].filter(this.widgetIds, id => {
        const props = widgetProps[id];
        const widgetIsGraded = (props === null || props === void 0 ? void 0 : props.graded) == null || props.graded;
        const widgetIsStatic = !!(props !== null && props !== void 0 && props.static); // Ungraded widgets or widgets set to static shouldn't be graded.

        return widgetIsGraded && !widgetIsStatic;
      });

      const widgetScores = {};

      ___default["default"].each(gradedWidgetIds, id => {
        const props = widgetProps[id];
        const widget = this.getWidgetInstance(id); // widget can be undefined if it hasn't yet been rendered

        if (widget && widget.simpleValidate) {
          widgetScores[id] = widget.simpleValidate(props === null || props === void 0 ? void 0 : props.options, onInputError);
        }
      });

      return widgetScores;
    });

    _defineProperty(this, "score", () => {
      return ___default["default"].reduce(this.scoreWidgets(), Util.combineScores, Util.noScore);
    });

    _defineProperty(this, "guessAndScore", () => {
      const totalGuess = this.getUserInput();
      const totalScore = this.score();
      return [totalGuess, totalScore];
    });

    _defineProperty(this, "examples", () => {
      const widgetIds = this.widgetIds;

      const examples = ___default["default"].compact(___default["default"].map(widgetIds, widgetId => {
        const widget = this.getWidgetInstance(widgetId);
        return widget != null && widget.examples ? widget.examples() : null;
      })); // no widgets with examples


      if (!examples.length) {
        return null;
      }

      const allEqual = ___default["default"].all(examples, function (example) {
        return ___default["default"].isEqual(examples[0], example);
      }); // some widgets have different examples
      // TODO(alex): handle this better


      if (!allEqual) {
        return null;
      }

      return examples[0];
    });

    _defineProperty(this, "handletranslationLintErrors", lintErrors => {
      if (!this._isMounted) {
        return;
      }

      this.setState({
        translationLintErrors: lintErrors
      });
    });

    this._translationLinter = new TranslationLinter();
    this.state = {
      jiptContent: null,
      // TranslationLinter is async and currently does not contain a
      // location. This is a list of error strings TranslationLinter
      // detected on its last run.
      translationLintErrors: [],
      // The ID of the last widget the user interacted with. We'll
      // use this to set the `isLastUsedWidget` flag on the
      // corresponding widget.
      lastUsedWidgetId: null,
      ...this._getInitialWidgetState(_props)
    };
  }

  componentDidMount() {
    this._isMounted = true; // figure out why we're passing an empty object
    // $FlowFixMe[incompatible-exact]: Flow considers empty objects to be inexact and handleRender is expecting an exact object.

    this.handleRender({});
    this._currentFocus = null; // TODO(emily): actually make the serializedState prop work like a
    // controlled prop, instead of manually calling .restoreSerializedState
    // at the right times.

    if (this.props.serializedState) {
      this.restoreSerializedState(this.props.serializedState);
    }

    if (this.props.linterContext.highlightLint) {
      // Get i18n lint errors asynchronously. If there are lint errors,
      // this component will be rerendered.
      this._translationLinter.runLinter(this.props.content, this.handletranslationLintErrors);
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (!___default["default"].isEqual(___default["default"].pick(this.props, SHOULD_CLEAR_WIDGETS_PROP_LIST), ___default["default"].pick(nextProps, SHOULD_CLEAR_WIDGETS_PROP_LIST))) {
      this.setState(this._getInitialWidgetState(nextProps));
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    // QUESTION(jeremy): Shouldn't we look at `nextProps` here? Otherwise
    // we're always looking "one render behind".
    if (this.props.alwaysUpdate) {
      // TOTAL hacks so that findWidgets doesn't break
      // when one widget updates without the other.
      // See passage-refs inside radios, which was why
      // this was introduced.
      // I'm sorry!
      // TODO(aria): cry
      //
      // HACK(djf): I've also set this alwaysUpdate property from
      // async-renderer.jsx in the manticore-package. I'm doing this
      // to work around an infinite loop of some sort that started
      // happening in manticore after the React 16 update. After
      // clicking around in the manticore exercise editor (for example)
      // the UI would freeze up, and the debugger would show that
      // we were always deep in a recursion on the propsChanged line
      // below. There is some kind of timing issue causing some kind
      // of infinite loop, but by avoiding the time-consuming deep
      // equal comparisons on our props (which are often huge) I can
      // no longer reproduce the bug.
      // TODO(djf): Remove this comment
      // https://khanacademy.atlassian.net/browse/CP-834 is resolved.
      return true;
    }

    const stateChanged = !___default["default"].isEqual(this.state, nextState);
    const propsChanged = !___default["default"].isEqual(this.props, nextProps);
    return propsChanged || stateChanged;
  }

  UNSAFE_componentWillUpdate(nextProps, nextState) {
    const oldJipt = this.shouldRenderJiptPlaceholder(this.props, this.state);
    const newJipt = this.shouldRenderJiptPlaceholder(nextProps, nextState);
    const oldContent = this.getContent(this.props, this.state);
    const newContent = this.getContent(nextProps, nextState);
    const oldHighlightedWidgets = this.props.highlightedWidgets;
    const newHighlightedWidgets = nextProps.highlightedWidgets; // TODO(jared): This seems to be a perfect overlap with
    // "shouldComponentUpdate" -- can we just remove this
    // componentWillUpdate and the reuseMarkdown attr?

    this.reuseMarkdown = !oldJipt && !newJipt && oldContent === newContent && ___default["default"].isEqual(this.state.translationLintErrors, nextState.translationLintErrors) && ( // If we are running the linter then we need to know when
    // widgets have changed because we need for force the linter to
    // run when that happens. Note: don't do identity comparison here:
    // it can cause frequent re-renders that break MathJax somehow
    !this.props.linterContext.highlightLint || ___default["default"].isEqual(this.props.widgets, nextProps.widgets)) && // If the linter is turned on or off, we have to rerender
    this.props.linterContext.highlightLint === nextProps.linterContext.highlightLint && // yes, this is identity array comparison, but these are passed
    // in from state in the item-renderer, so they should be
    // identity equal unless something changed, and it's expensive
    // to loop through them to look for differences.
    // Technically, we could reuse the markdown when this changes,
    // but to do that we'd have to do more expensive checking of
    // whether a widget should be highlighted in the common case
    // where this array hasn't changed, so we just redo the whole
    // render if this changed
    oldHighlightedWidgets === newHighlightedWidgets;
  }

  componentDidUpdate(prevProps, prevState) {
    this.handleRender(prevProps); // We even do this if we did reuse the markdown because
    // we might need to update the widget props on this render,
    // even though we have the same widgets.
    // WidgetContainers don't update their widgets' props when
    // they are re-rendered, so even if they've been
    // re-rendered we need to call these methods on them.

    ___default["default"].each(this.widgetIds, id => {
      // eslint-disable-next-line react/no-string-refs
      const container = this.refs["container:" + id];
      container && container.replaceWidgetProps(this.getWidgetProps(id));
    });

    if (this.props.serializedState && !___default["default"].isEqual(this.props.serializedState, this.getSerializedState())) {
      this.restoreSerializedState(this.props.serializedState);
    }

    if (this.props.linterContext.highlightLint) {
      // Get i18n lint errors asynchronously. If lint errors have changed
      // since the last run, this component will be rerendered.
      this._translationLinter.runLinter(this.props.content, this.handletranslationLintErrors);
    }
  }

  componentWillUnmount() {
    // Clean out the list of widgetIds when unmounting, as this list is
    // meant to be consistent with the refs controlled by the renderer, and
    // refs are also cleared out during unmounting.
    // (This may not be totally necessary, but mobile clients have been
    // seeing JS errors due to an inconsistency between the list of
    // widgetIds and the child refs of the renderer.
    // See: https://phabricator.khanacademy.org/D32420.)
    this.widgetIds = [];

    if (this.translationIndex != null) {
      // NOTE(jeremy): Since the translationIndex is simply the array
      // index of each renderer, we can't remove Renderers from this
      // list, rather, we simply null out the entry (which means that
      // this array's growth is unbounded until a page reload).
      getDependencies().rendererTranslationComponents.removeComponentAtIndex(this.translationIndex);
    }

    this._isMounted = false;
  }

  render() {
    const apiOptions = this.getApiOptions();
    const {
      KatexProvider
    } = getDependencies();

    if (this.reuseMarkdown) {
      return this.lastRenderedMarkdown;
    }

    const content = this.getContent(this.props, this.state); // `this.widgetIds` is appended to in `this.outputMarkdown`:

    this.widgetIds = [];

    if (this.shouldRenderJiptPlaceholder(this.props, this.state)) {
      // Crowdin's JIPT (Just in place translation) uses a fake language
      // with language tag "en-pt" where the value of the translations
      // look like: {crwdns2657085:0}{crwdne2657085:0} where it keeps the
      // {crowdinId:ngettext variant}. We detect whether the current
      // content matches this, so we can take over rendering of
      // the perseus content as the translators interact with jipt.
      // We search for only part of the tag that crowdin uses to guard
      // against them changing the format on us. The full tag it looks
      // for can be found in https://cdn.crowdin.net/jipt/jipt.js
      // globalPhrase var.
      // If we haven't already added this component to the registry do so
      // now. showHints() may cause this component to be rerendered
      // before jipt has a chance to replace its contents, so this check
      // will keep us from adding the component to the registry a second
      // time.
      if (!this.translationIndex) {
        this.translationIndex = getDependencies().rendererTranslationComponents.addComponent(this);
      } // For articles, we add jipt data to individual paragraphs. For
      // exercises, we add it to the renderer and let translators
      // translate the entire thing. For the article equivalent of
      // this if block, search this file for where we render a
      // QuestionParagraph, and see the `isJipt:` parameter sent to
      // PerseusMarkdown.parse()


      if (!apiOptions.isArticle) {
        // We now need to output this tag, as jipt looks for it to be
        // able to replace it with a translation that it runs an ajax
        // call to get.  We add a data attribute with the index to the
        // Persues.TranslationComponent registry so that when jipt
        // calls its before_dom_insert we can lookup this component by
        // this attribute and render the text with markdown.
        return /*#__PURE__*/React__namespace.createElement(KatexProvider, null, /*#__PURE__*/React__namespace.createElement(DefinitionProvider, null, /*#__PURE__*/React__namespace.createElement("div", {
          "data-perseus-component-index": this.translationIndex
        }, content)));
      }
    } // Hacks:
    // We use mutable state here to figure out whether the output
    // had two columns.
    // It is updated to true by `this.outputMarkdown` if a
    // column break is found
    // TODO(aria): We now have a state variable threaded through
    // simple-markdown output. We should mutate it instead of
    // state on this component to do this in a less hacky way.


    this._isTwoColumn = false; // Parse the string of markdown to a parse tree

    const parsedMarkdown = PerseusMarkdown.parse(content, {
      // Recognize crowdin IDs while translating articles
      // (This should never be hit by exercises, though if you
      // decide you want to add a check that this is an article,
      // go for it.)
      isJipt: this.translationIndex != null
    }); // Optionally apply the linter to the parse tree

    if (this.props.linterContext.highlightLint) {
      // If highlightLint is true and lint is detected, this call
      // will modify the parse tree by adding lint nodes that will
      // serve to highlight the lint when rendered
      // $FlowFixMe[cannot-spread-inexact]
      const context = {
        content: this.props.content,
        widgets: this.props.widgets,
        ...this.props.linterContext
      };
      PerseusLinter__namespace.runLinter(parsedMarkdown, context, true); // Apply the lint errors from the last TranslationLinter run.
      // TODO(joshuan): Support overlapping dots.

      this._translationLinter.applyLintErrors(parsedMarkdown, [...this.state.translationLintErrors, ...(this.props.legacyPerseusLint || [])]);
    } // Render the linted markdown parse tree with React components


    const markdownContents = this.outputMarkdown(parsedMarkdown, {
      baseElements: apiOptions.baseElements
    });
    const className = classNames__default["default"]({
      [ClassNames.RENDERER]: true,
      [ClassNames.RESPONSIVE_RENDERER]: true,
      [ClassNames.TWO_COLUMN_RENDERER]: this._isTwoColumn
    });
    this.lastRenderedMarkdown = /*#__PURE__*/React__namespace.createElement(KatexProvider, null, /*#__PURE__*/React__namespace.createElement(DefinitionProvider, null, /*#__PURE__*/React__namespace.createElement("div", {
      className: className
    }, markdownContents)));
    return this.lastRenderedMarkdown;
  }

}

_defineProperty(Renderer, "defaultProps", {
  content: "",
  widgets: {},
  images: {},
  highlightedWidgets: [],
  questionCompleted: false,
  // onRender may be called multiple times per render, for example
  // if there are multiple images or TeX pieces within `content`.
  // It is a good idea to debounce any functions passed here.
  onRender: noopOnRender,
  onInteractWithWidget: function () {},
  findExternalWidgets: () => [],
  alwaysUpdate: false,
  reviewMode: false,
  serializedState: null,
  onSerializedStateUpdated: () => {},
  linterContext: PerseusLinter__namespace.linterContextDefault
});

const styles$B = {
  mobileZoomableParentFix: {
    // NOTE(abdul): There is an issue where transform animations will
    // cause the Zoomable component to disappear when running on the
    // native app on iPad (iOS 13). I found some answers online that recommend
    // transforming the parent in 3D space. Doing this forces hardware
    // acceleration, which causes the process to run on the GPU. It's not
    // clear to me why this fixes the issue, but it's suggested online
    // to people dealing with similar disappearance and flickering issues.
    transform: "translate3d(0,0,0)"
  }
};

const prettyBig = {
  fontSize: "150%"
};
const slightlyBig = {
  fontSize: "120%"
};
const symbStyle = {
  fontSize: "130%"
};
// These are functions because we want to generate a new component for each use
// on the page rather than reusing an instance (which will cause an error).
// Also, it's useful for things which might look different depending on the
// props.
const basic = [() => [/*#__PURE__*/React__namespace.createElement("span", {
  key: "plus",
  style: slightlyBig
}, "+"), "+"], () => [/*#__PURE__*/React__namespace.createElement("span", {
  key: "minus",
  style: prettyBig
}, "-"), "-"], // TODO(joel) - display as \cdot when appropriate
props => {
  const {
    TeX
  } = getDependencies();

  if (props.convertDotToTimes) {
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "times",
      style: prettyBig
    }, i18n__namespace.doNotTranslate("\\times")), "\\times"];
  }

  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "times",
    style: prettyBig
  }, i18n__namespace.doNotTranslate("\\cdot")), "\\cdot"];
}, () => {
  const {
    TeX
  } = getDependencies();
  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "frac",
    style: prettyBig
  }, i18n__namespace.doNotTranslate("\\frac{x}{y}")), // If there's something in the input that can become part of a
  // fraction, typing "/" puts it in the numerator. If not, typing
  // "/" does nothing. In that case, enter a \frac.
  input => {
    const contents = input.latex();
    input.typedText("/");

    if (input.latex() === contents) {
      input.cmd("\\frac");
    }
  }];
}];
const buttonSets = {
  basic,
  "basic+div": basic.concat([() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "div"
    }, i18n__namespace.doNotTranslate("\\div")), "\\div"];
  }]),
  trig: [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "sin"
    }, i18n__namespace.doNotTranslate("\\sin")), "\\sin"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "cos"
    }, i18n__namespace.doNotTranslate("\\cos")), "\\cos"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "tan"
    }, i18n__namespace.doNotTranslate("\\tan")), "\\tan"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "theta",
      style: symbStyle
    }, i18n__namespace.doNotTranslate("\\theta")), "\\theta"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement("span", {
      key: "phi"
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: "perseus-sr-only"
    }, i18n__namespace.doNotTranslate("phi")), /*#__PURE__*/React__namespace.createElement(TeX, {
      key: "pi",
      style: symbStyle
    }, i18n__namespace.doNotTranslate("\\phi"))), "\\phi"];
  }],
  prealgebra: [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "sqrt"
    }, i18n__namespace.doNotTranslate("\\sqrt{x}")), "\\sqrt"];
  }, // TODO(joel) - how does desmos do this?
  () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "nthroot"
    }, i18n__namespace.doNotTranslate("\\sqrt[3]{x}")), input => {
      input.typedText("nthroot3");
      input.keystroke("Right");
    }];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "pow",
      style: slightlyBig
    }, i18n__namespace.doNotTranslate("a^b")), input => {
      const contents = input.latex();
      input.typedText("^"); // If the input hasn't changed (for example, if we're
      // attempting to add an exponent on an empty input or an empty
      // denominator), insert our own "a^b"

      if (input.latex() === contents) {
        input.typedText("a^b");
      }
    }];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "pi",
      style: slightlyBig
    }, i18n__namespace.doNotTranslate("\\pi")), "\\pi"];
  }],
  logarithms: [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "log"
    }, i18n__namespace.doNotTranslate("\\log")), "\\log"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "ln"
    }, i18n__namespace.doNotTranslate("\\ln")), "\\ln"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "log_b"
    }, i18n__namespace.doNotTranslate("\\log_b")), input => {
      input.typedText("log_");
      input.keystroke("Right");
      input.typedText("(");
      input.keystroke("Left");
      input.keystroke("Left");
    }];
  }],
  "basic relations": [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "eq"
    }, "="), "="];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "lt"
    }, i18n__namespace.doNotTranslate("\\lt")), "\\lt"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "gt"
    }, i18n__namespace.doNotTranslate("\\gt")), "\\gt"];
  }],
  "advanced relations": [() => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "neq"
    }, i18n__namespace.doNotTranslate("\\neq")), "\\neq"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "leq"
    }, i18n__namespace.doNotTranslate("\\leq")), "\\leq"];
  }, () => {
    const {
      TeX
    } = getDependencies();
    return [/*#__PURE__*/React__namespace.createElement(TeX, {
      key: "geq"
    }, i18n__namespace.doNotTranslate("\\geq")), "\\geq"];
  }]
};
const buttonSetsType = PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOf(___default["default"](buttonSets).keys()));

class TexButtons extends React__namespace.Component {
  render() {
    // Always show buttonSets in the same order. Note: Technically it's ok
    // for _.keys() to return the keys in an arbitrary order, but in
    // practice, they will be ordered as listed above.
    const sortedButtonSets = ___default["default"].sortBy(this.props.sets, setName => ___default["default"].keys(buttonSets).indexOf(setName));

    const buttons = ___default["default"](sortedButtonSets).map(setName => buttonSets[setName]);

    const buttonRows = ___default["default"](buttons).map(row => row.map(symbGen => {
      // create a (component, thing we should send to mathquill) pair
      const symbol = symbGen(this.props);
      return /*#__PURE__*/React__namespace.createElement("button", {
        onClick: () => this.props.onInsert(symbol[1]),
        className: "tex-button",
        key: symbol[0].key,
        type: "button"
      }, symbol[0]);
    }));

    const buttonPopup = ___default["default"](buttonRows).map((row, i) => {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "clearfix tex-button-row",
        key: this.props.sets[i]
      }, row);
    });

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "".concat(this.props.className || "", " preview-measure")
    }, buttonPopup);
  }

}

_defineProperty(TexButtons, "propTypes", {
  sets: buttonSetsType.isRequired,
  onInsert: PropTypes__default["default"].func.isRequired,
  className: PropTypes__default["default"].string
});

_defineProperty(TexButtons, "buttonSets", buttonSets);

_defineProperty(TexButtons, "buttonSetsType", buttonSetsType);

const PT = PropTypes__default["default"]; // A WYSIWYG math input that calls `onChange(LaTeX-string)`

class MathInput extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "mouseDown", void 0);

    _defineProperty(this, "state", {
      focused: false
    });

    _defineProperty(this, "handleFocus", () => {
      this.setState({
        focused: true
      }); // TODO(joel) fix properly - we should probably allow onFocus handlers
      // to this property, but we need to work correctly with them.
      // if (this.props.onFocus) {
      //     this.props.onFocus();
      // }
    });

    _defineProperty(this, "handleMouseDown", event => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[incompatible-call]
      const focused = ReactDOM__default["default"].findDOMNode(this).contains(event.target);
      this.mouseDown = focused;

      if (!focused) {
        this.setState({
          focused: false
        });
      }
    });

    _defineProperty(this, "handleMouseUp", () => {
      // this mouse click started in the buttons div so we should focus the
      // input
      if (this.mouseDown) {
        this.focus();
      }

      this.mouseDown = false;
    });

    _defineProperty(this, "handleBlur", e => {
      // TODO(michaelpolyak): Consider trapping focus within the button group.
      // Focusing back on the input when TAB out of the last button in the
      // group. This will probably require ESCAPE key handling to enable to
      // close (blur) the button group in order to focus on next page element.
      if (!this.mouseDown && // $FlowFixMe[incompatible-use]
      // $FlowFixMe[incompatible-call]
      !ReactDOM__default["default"].findDOMNode(this).contains(e.relatedTarget)) {
        this.setState({
          focused: false
        });
      }
    });

    _defineProperty(this, "_shouldShowButtons", () => {
      if (this.props.buttonsVisible === "always") {
        return true;
      }

      if (this.props.buttonsVisible === "never") {
        return false;
      }

      return this.state.focused;
    });

    _defineProperty(this, "insert", value => {
      const input = this.mathField();

      if (___default["default"](value).isFunction()) {
        value(input);
      } else if (value[0] === "\\") {
        input.cmd(value).focus();
      } else {
        input.write(value).focus();
      }

      input.focus();
    });

    _defineProperty(this, "mathField", options => {
      // The MathQuill API is now "versioned" through its own "InterVer"
      // system.
      // See: https://github.com/mathquill/mathquill/pull/459
      const MQ = MathQuill__default["default"].getInterface(2); // MathQuill.MathField takes a DOM node, MathQuill-ifies it if it's
      // seeing that node for the first time, then returns the associated
      // MathQuill object for that node. It is stable - will always return
      // the same object when called on the same DOM node.
      // eslint-disable-next-line react/no-string-refs

      return MQ.MathField(ReactDOM__default["default"].findDOMNode(this.refs.mathinput), options);
    });

    _defineProperty(this, "focus", () => {
      this.mathField().focus();
      this.setState({
        focused: true
      });
    });

    _defineProperty(this, "blur", () => {
      this.mathField().blur();
      this.setState({
        focused: false
      });
    });
  }

  render() {
    let className = classNames__default["default"]({
      "perseus-math-input": true,
      // mathquill usually adds these itself but react removes them when
      // updating the component.
      "mq-editable-field": true,
      "mq-math-mode": true
    });

    if (this.props.className) {
      className = className + " " + this.props.className;
    }

    let buttons = null;

    if (this._shouldShowButtons()) {
      buttons = /*#__PURE__*/React__namespace.createElement(TexButtons, {
        sets: this.props.buttonSets,
        className: "math-input-buttons absolute",
        convertDotToTimes: this.props.convertDotToTimes,
        onInsert: this.insert
      });
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "inline-block"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "inline-block"
      }
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: className // eslint-disable-next-line react/no-string-refs
      ,
      ref: "mathinput",
      "aria-label": this.props.labelText,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    })), /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        position: "relative"
      },
      onBlur: this.handleBlur
    }, buttons));
  } // handlers:
  // keep track of two related bits of state:
  // * this.state.focused - whether the buttons are currently shown
  // * this.mouseDown - whether a mouse click is active that started in the
  //   buttons div


  componentWillUnmount() {
    window.removeEventListener("mousedown", this.handleMouseDown);
    window.removeEventListener("mouseup", this.handleMouseUp);
  }

  componentDidMount() {
    window.addEventListener("mousedown", this.handleMouseDown);
    window.addEventListener("mouseup", this.handleMouseUp);
    let initialized = false; // Initialize MathQuill.MathField instance

    this.mathField({
      // LaTeX commands that, when typed, are immediately replaced by the
      // appropriate symbol. This does not include ln, log, or any of the
      // trig functions; those are always interpreted as commands.
      autoCommands: "pi theta phi sqrt nthroot",
      // Pop the cursor out of super/subscripts on arithmetic operators
      // or (in)equalities.
      charsThatBreakOutOfSupSub: "+-*/=<>",
      // Prevent excessive super/subscripts or fractions from being
      // created without operands, e.g. when somebody holds down a key
      supSubsRequireOperand: true,
      // The name of this option is somewhat misleading, as tabbing in
      // MathQuill breaks you out of a nested context (fraction/script)
      // if you're in one, but moves focus to the next input if you're
      // not. Spaces (with this option enabled) are just ignored in the
      // latter case.
      //
      // TODO(alex): In order to allow inputting mixed numbers, we will
      // have to accept spaces in certain cases. The desired behavior is
      // still to escape nested contexts if currently in one, but to
      // insert a space if not (we don't expect mixed numbers in nested
      // contexts). We should also limit to one consecutive space.
      spaceBehavesLikeTab: true,
      handlers: {
        edited: mathField => {
          // This handler is guaranteed to be called on change, but
          // unlike React it sometimes generates false positives.
          // One of these is on initialization (with an empty string
          // value), so we have to guard against that below.
          let value = mathField.latex(); // Provide a MathQuill-compatible way to generate the
          // not-equals sign without pasting unicode or typing TeX

          value = value.replace(/<>/g, "\\ne"); // Use the specified symbol to represent multiplication
          // TODO(alex): Add an option to disallow variables, in
          // which case 'x' should get converted to '\\times'

          if (this.props.convertDotToTimes) {
            value = value.replace(/\\cdot/g, "\\times"); // Preserve cursor position in the common case:
            // typing '*' to insert a multiplication sign.
            // We do this by modifying internal MathQuill state
            // directly, instead of waiting for `.latex()` to be
            // called in `componentDidUpdate()`.

            const left = mathField.__controller.cursor[MathQuill__default["default"].L];

            if (left && left.ctrlSeq === "\\cdot ") {
              mathField.__controller.backspace();

              mathField.cmd("\\times");
            }
          } else {
            value = value.replace(/\\times/g, "\\cdot");
          }

          if (initialized && this.props.value !== value) {
            this.props.onChange(value);
          }
        },
        enter: () => {
          // NOTE(kevinb): This isn't how answers to exercises are
          // submitted.  The actual mechanism for this can be found
          // in exercise-problem-template.jsx, see `handleSubmit`.
          // This handler is called when the user presses the enter
          // key. Since this isn't an actual <input> element, we have
          // to manually trigger the usually automatic form submit.
          // eslint-disable-next-line react/no-string-refs
          $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.mathinput)).submit();
        },
        upOutOf: mathField => {
          // This handler is called when the user presses the up
          // arrow key, but there is nowhere in the expression to go
          // up to (no numerator or exponent). For ease of use,
          // interpret this as an attempt to create an exponent.
          mathField.typedText("^");
        }
      }
    }); // Ideally, we would be able to pass an initial value directly into
    // the constructor above

    this.mathField().latex(this.props.value);
    initialized = true;
  }

}

_defineProperty(MathInput, "propTypes", {
  value: PT.string,
  onChange: PT.func.isRequired,
  convertDotToTimes: PT.bool,
  buttonsVisible: PT.oneOf(["always", "never", "focused"]),
  buttonSets: TexButtons.buttonSetsType.isRequired,
  labelText: PropTypes__default["default"].string,
  onFocus: PT.func,
  onBlur: PT.func
});

_defineProperty(MathInput, "defaultProps", {
  value: "",
  convertDotToTimes: false,
  buttonsVisible: "focused"
});

/*
 * In this file, an `expression` is some portion of valid TeX enclosed in
 * curly brackets.
 */

/*
 * Find the index at which an expression ends, i.e., has an unmatched
 * closing curly bracket. This method assumes that we start with a non-open
 * bracket character and end when we've seen more left than right brackets
 * (rather than assuming that we start with a bracket character and wait for
 * bracket equality).
 */
function findEndpoint(tex, currentIndex) {
  let bracketDepth = 0;

  for (let i = currentIndex, len = tex.length; i < len; i++) {
    const c = tex[i];

    if (c === "{") {
      bracketDepth++;
    } else if (c === "}") {
      bracketDepth--;
    }

    if (bracketDepth < 0) {
      return i;
    }
  } // If we never see unbalanced curly brackets, default to the
  // entire string


  return tex.length;
}
/*
 * Parses an individual set of curly brackets into TeX.
 */


function parseNextExpression(tex, currentIndex, handler) {
  // Find the first '{' and grab subsequent TeX
  // Ex) tex: '{3}{7}', and we want the '3'
  const openBracketIndex = tex.indexOf("{", currentIndex);
  const nextExpIndex = openBracketIndex + 1; // Truncate to only contain remaining TeX

  const endpoint = findEndpoint(tex, nextExpIndex);
  const expressionTeX = tex.substring(nextExpIndex, endpoint);
  const parsedExp = walkTex(expressionTeX, handler);
  return {
    endpoint: endpoint,
    expression: parsedExp
  };
}

function getNextFracIndex(tex, currentIndex) {
  const dfrac = "\\dfrac";
  const frac = "\\frac";
  const nextFrac = tex.indexOf(frac, currentIndex);
  const nextDFrac = tex.indexOf(dfrac, currentIndex);

  if (nextFrac > -1 && nextDFrac > -1) {
    return Math.min(nextFrac, nextDFrac);
  }

  if (nextFrac > -1) {
    return nextFrac;
  }

  if (nextDFrac > -1) {
    return nextDFrac;
  }

  return -1;
}

function walkTex(tex, handler) {
  if (!tex) {
    return "";
  } // Ex) tex: '2 \dfrac {3}{7}'


  let parsedString = "";
  let currentIndex = 0;
  let nextFrac = getNextFracIndex(tex, currentIndex); // For each \dfrac, find the two expressions (wrapped in {}) and recur

  while (nextFrac > -1) {
    // Gather first fragment, preceding \dfrac
    // Ex) parsedString: '2 '
    parsedString += tex.substring(currentIndex, nextFrac); // Remove everything preceding \dfrac, which has been parsed

    currentIndex = nextFrac; // Parse first expression and move index past it
    // Ex) firstParsedExpression.expression: '3'

    const firstParsedExpression = parseNextExpression(tex, currentIndex, handler);
    currentIndex = firstParsedExpression.endpoint + 1; // Parse second expression
    // Ex) secondParsedExpression.expression: '7'

    const secondParsedExpression = parseNextExpression(tex, currentIndex, handler);
    currentIndex = secondParsedExpression.endpoint + 1; // Add expressions to running total of parsed expressions

    if (parsedString.length) {
      parsedString += " ";
    } // Apply a custom handler based on the parsed subexpressions


    parsedString += handler(firstParsedExpression.expression, secondParsedExpression.expression); // Find next DFrac, relative to currentIndex

    nextFrac = getNextFracIndex(tex, currentIndex);
  } // Add remaining TeX, which is \dfrac-free


  parsedString += tex.slice(currentIndex);
  return parsedString;
}
/*
 * Modify a TeX expression, returning another TeX expression. The resulting
 * expression will have its innermost fractions stubbed out with \fracs
 * (as opposed to \dfracs). All other content will remain untouched.
 */


function modifyTex(tex) {
  function isNestedFraction(tex) {
    return tex.indexOf("\\frac") > -1 || tex.indexOf("\\dfrac") > -1;
  }

  const handler = function (exp1, exp2) {
    let prefix;

    if (isNestedFraction(exp1) || isNestedFraction(exp2)) {
      prefix = "\\dfrac";
    } else {
      prefix = "\\frac";
    }

    return prefix + " {" + exp1 + "}{" + exp2 + "}";
  };

  return walkTex(tex, handler);
}
/*
 * Parse a TeX expression into something interpretable by input-number.
 * The process is concerned with: (1) parsing fractions, i.e., \dfracs; and
 * (2) removing backslash-escaping from certain characters (right now, only
 * percent signs).
 *
 * The basic algorithm for handling \dfracs splits on \dfracs and then recurs
 * on the subsequent "expressions", i.e., the {} pairs that follow \dfrac. The
 * recursion is to allow for nested \dfrac elements.
 *
 * Backslash-escapes are removed with a simple search-and-replace.
 */


function parseTex(tex) {
  const handler = function (exp1, exp2) {
    return exp1 + "/" + exp2;
  };

  const texWithoutFracs = walkTex(tex, handler);
  return texWithoutFracs.replace("\\%", "%");
}

var TexWrangler = {
  parseTex,
  modifyTex
};

const ModifyTex = TexWrangler.modifyTex;

class MathOutput extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      focused: false,
      selectorNamespace: ___default["default"].uniqueId("math-output")
    });

    _defineProperty(this, "_getInputClassName", () => {
      let className = "math-output " + ClassNames.INPUT + " " + ClassNames.INTERACTIVE;

      if (this.state.focused) {
        className += " " + ClassNames.FOCUSED;
      }

      if (this.props.className) {
        className += " " + this.props.className;
      }

      return className;
    });

    _defineProperty(this, "_getDisplayValue", value => {
      // Cast from (potentially a) number to string
      let displayText;

      if (value != null) {
        displayText = "" + value;
      } else {
        displayText = "";
      }

      return ModifyTex(displayText);
    });

    _defineProperty(this, "getValue", () => {
      return this.props.value;
    });

    _defineProperty(this, "focus", () => {
      if (!this.state.focused) {
        this.props.onFocus();

        this._bindBlurHandler();

        this.setState({
          focused: true
        });
      }
    });

    _defineProperty(this, "blur", () => {
      if (this.state.focused) {
        this.props.onBlur();

        this._unbindBlurHandler();

        this.setState({
          focused: false
        });
      }
    });

    _defineProperty(this, "_bindBlurHandler", () => {
      $__default["default"](document).bind("vclick." + this.state.selectorNamespace, e => {
        // Detect whether the target has our React DOM node as a parent
        const $closestWidget = $__default["default"](e.target).closest(ReactDOM__default["default"].findDOMNode(this));

        if (!$closestWidget.length) {
          this.blur();
        }
      });
    });

    _defineProperty(this, "_unbindBlurHandler", () => {
      $__default["default"](document).unbind("." + this.state.selectorNamespace);
    });
  }

  render() {
    const divStyle = {
      textAlign: "center"
    };
    const {
      TeX
    } = getDependencies();
    return /*#__PURE__*/React__namespace.createElement("span", {
      // eslint-disable-next-line react/no-string-refs
      ref: "input",
      className: this._getInputClassName(),
      "aria-label": this.props.labelText,
      onMouseDown: this.focus,
      onTouchStart: this.focus
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: divStyle
    }, /*#__PURE__*/React__namespace.createElement(TeX, null, this._getDisplayValue(this.props.value))));
  }

  componentWillUnmount() {
    this._unbindBlurHandler();
  }

}

_defineProperty(MathOutput, "propTypes", {
  value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
  className: PropTypes__default["default"].string,
  labelText: PropTypes__default["default"].string,
  onFocus: PropTypes__default["default"].func,
  onBlur: PropTypes__default["default"].func
});

_defineProperty(MathOutput, "defaultProps", {
  value: "",
  onFocus: function () {},
  onBlur: function () {}
});

let lastId = 0;

function uniqueIdForInput() {
  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "input-";
  lastId++;
  return "".concat(prefix).concat(lastId);
}

class TextInput extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "focus", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this).focus();
    });

    _defineProperty(this, "blur", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this).blur();
    });

    _defineProperty(this, "getValue", () => {
      var _ReactDOM$findDOMNode;

      // $FlowFixMe[prop-missing]
      return (_ReactDOM$findDOMNode = ReactDOM__default["default"].findDOMNode(this)) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.value;
    });

    _defineProperty(this, "getStringValue", () => {
      var _ReactDOM$findDOMNode2;

      // $FlowFixMe[prop-missing]
      return (_ReactDOM$findDOMNode2 = ReactDOM__default["default"].findDOMNode(this)) === null || _ReactDOM$findDOMNode2 === void 0 ? void 0 : _ReactDOM$findDOMNode2.value.toString();
    });

    _defineProperty(this, "setSelectionRange", (selectionStart, selectionEnd) => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this).setSelectionRange(selectionStart, selectionEnd);
    });

    _defineProperty(this, "getSelectionStart", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      return ReactDOM__default["default"].findDOMNode(this).selectionStart;
    });

    _defineProperty(this, "getSelectionEnd", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      return ReactDOM__default["default"].findDOMNode(this).selectionEnd;
    });

    if (props.id) {
      this.id = props.id;
    } else {
      this.id = uniqueIdForInput();
    }
  }

  render() {
    const {
      labelText,
      value,
      onFocus,
      onBlur,
      disabled,
      placeholder,
      onKeyDown
    } = this.props;
    const formattedValue = value === null ? "" : value.toString();
    return (
      /*#__PURE__*/
      // $FlowIgnore
      React__namespace.createElement(wonderBlocksForm.TextField, {
        disabled: disabled,
        id: this.id,
        value: formattedValue,
        type: "text",
        "aria-label": labelText,
        onChange: value => this.props.onChange(value),
        placeholder: placeholder,
        onFocus: onFocus,
        onBlur: onBlur,
        onKeyDown: onKeyDown,
        autoCorrect: "off",
        autoCapitalize: "off",
        autoComplete: "off"
      })
    );
  }

}

_defineProperty(TextInput, "defaultProps", {
  value: "",
  disabled: false
});

/**
 * A generic tooltip library for React.js
 *
 * This should eventually end up in react-components
 *
 * Interface: ({a, b} means one of a or b)
 * import Tooltip from "./tooltip.jsx";
 * <Tooltip
 *     className="class-for-tooltip-contents"
 *     horizontalPosition="left" // one of "left", "right"
 *     horizontalAlign="left" // one of "left", "right"
 *     verticalPosition="bottom" // one of "top", "bottom"
 *     arrowSize={10} // arrow size in pixels
 *     borderColor="#ccc" // color of the border for the tooltip
 *     show={true} // whether the tooltip should currently be visible
 *     targetContainerStyle={targetContainerStyle}
 * >
 *     <TargetElementOfTheTooltip />
 *     <TooltipContents1 />
 *     <TooltipContents2 />
 * </Tooltip>
 *
 * To show/hide the tooltip, the parent component should call the
 * .show() and .hide() methods of the tooltip when appropriate.
 * (These are usually set up as handlers of events on the target element.)
 *
 * Notes:
 *     className should not specify a border; that is handled by borderColor
 *     so that the arrow and tooltip match
 */
const zIndex = 10;
const Triangle = createReactClass__default["default"]({
  displayName: "Triangle",
  propTypes: {
    color: PropTypes__default["default"].string.isRequired,
    left: PropTypes__default["default"].number.isRequired,
    top: PropTypes__default["default"].number.isRequired,
    width: PropTypes__default["default"].number.isRequired,
    height: PropTypes__default["default"].number.isRequired,
    horizontalDirection: PropTypes__default["default"].oneOf(["left", "right"]).isRequired,
    verticalDirection: PropTypes__default["default"].oneOf(["top", "bottom"]).isRequired
  },
  render: function () {
    let borderLeft;
    let borderRight;
    let borderTop;
    let borderBottom;
    const hBorder = "".concat(this.props.width, "px solid transparent");

    if (this.props.horizontalDirection === "right") {
      borderLeft = hBorder;
    } else {
      borderRight = hBorder;
    }

    const vBorder = "".concat(this.props.height, "px solid ").concat(this.props.color);

    if (this.props.verticalDirection === "top") {
      borderTop = vBorder;
    } else {
      borderBottom = vBorder;
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "block",
        height: 0,
        width: 0,
        position: "absolute",
        left: this.props.left,
        top: this.props["top"],
        borderLeft: borderLeft,
        borderRight: borderRight,
        borderTop: borderTop,
        borderBottom: borderBottom
      }
    });
  }
});
const TooltipArrow$1 = createReactClass__default["default"]({
  displayName: "TooltipArrow",
  propTypes: {
    position: PropTypes__default["default"].string,
    visibility: PropTypes__default["default"].string,
    left: PropTypes__default["default"].number,
    top: PropTypes__default["default"].number,
    color: PropTypes__default["default"].string.isRequired,
    // a css color
    border: PropTypes__default["default"].string.isRequired,
    // a css color
    width: PropTypes__default["default"].number.isRequired,
    height: PropTypes__default["default"].number.isRequired,
    horizontalDirection: PropTypes__default["default"].oneOf(["left", "right"]).isRequired,
    verticalDirection: PropTypes__default["default"].oneOf(["top", "bottom"]).isRequired
  },
  getDefaultProps: function () {
    return {
      position: "relative",
      visibility: "visible",
      left: 0,
      top: 0
    };
  },
  // TODO(aria): Think about adding a box-shadow to the triangle here
  // See http://css-tricks.com/triangle-with-shadow/
  render: function () {
    //const isRight = (this.props.horizontalDirection === "right");
    const isTop = this.props.verticalDirection === "top";
    const frontTopOffset = isTop ? 0 : 1;
    const borderTopOffset = isTop ? 0 : -1;
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "block",
        position: this.props.position,
        visibility: this.props.visibility,
        left: this.props.left,
        top: this.props["top"],
        width: this.props.width + 2,
        height: this.props.height + 1,
        marginTop: -1,
        marginBottom: -2,
        zIndex: zIndex
      }
    }, /*#__PURE__*/React__namespace.createElement(Triangle, {
      horizontalDirection: this.props.horizontalDirection,
      verticalDirection: this.props.verticalDirection,
      color: this.props.border,
      left: 0,
      top: borderTopOffset,
      width: this.props.width + 2 // one extra for the diagonal
      ,
      height: this.props.height + 2
    }), /*#__PURE__*/React__namespace.createElement(Triangle, {
      horizontalDirection: this.props.horizontalDirection,
      verticalDirection: this.props.verticalDirection,
      color: this.props.color,
      left: 1,
      top: frontTopOffset,
      width: this.props.width,
      height: this.props.height
    }));
  }
});
const VERTICAL_CORNERS = {
  top: {
    top: "-100%"
  },
  bottom: {
    top: 0
  }
};
const HORIZONTAL_CORNERS = {
  left: {
    targetLeft: 0
  },
  right: {
    targetLeft: "100%"
  }
};
const HORIZONTAL_ALIGNMNENTS = {
  left: {
    tooltipLeft: 0,
    arrowLeft: arrowSize => 0
  },
  right: {
    tooltipLeft: "-100%",
    arrowLeft: arrowSize => -arrowSize - 2
  }
}; // eslint-disable-next-line react/no-unsafe

const Tooltip = createReactClass__default["default"]({
  displayName: "Tooltip",
  propTypes: {
    show: PropTypes__default["default"].bool.isRequired,
    className: PropTypes__default["default"].string,
    arrowSize: PropTypes__default["default"].number,
    borderColor: PropTypes__default["default"].string,
    verticalPosition: PropTypes__default["default"].oneOf(Object.keys(VERTICAL_CORNERS)),
    horizontalPosition: PropTypes__default["default"].oneOf(Object.keys(HORIZONTAL_CORNERS)),
    horizontalAlign: PropTypes__default["default"].oneOf(Object.keys(HORIZONTAL_ALIGNMNENTS)),
    children: PropTypes__default["default"].arrayOf(PropTypes__default["default"].element).isRequired,
    targetContainerStyle: PropTypes__default["default"].any // style object

  },
  getDefaultProps: function () {
    return {
      className: "",
      arrowSize: 10,
      borderColor: "#ccc",
      verticalPosition: "bottom",
      horizontalPosition: "left",
      horizontalAlign: "left",
      targetContainerStyle: {}
    };
  },
  getInitialState: function () {
    return {
      height: null // used for offsetting "top" positioned tooltips

    };
  },
  componentDidMount: function () {
    this._updateHeight();
  },
  UNSAFE_componentWillReceiveProps: function () {
    // If the contents have changed, reset our measure of the height
    this.setState({
      height: null
    });
  },
  componentDidUpdate: function () {
    this._updateHeight();
  },
  _renderToolTipDiv: function (isTooltipAbove) {
    const settings = Object.assign({}, HORIZONTAL_CORNERS[this.props.horizontalPosition], HORIZONTAL_ALIGNMNENTS[this.props.horizontalAlign], VERTICAL_CORNERS[this.props.verticalPosition]);
    let arrowAbove;
    let arrowBelow;

    if (isTooltipAbove) {
      // We put an absolutely positioned arrow in the correct place
      arrowAbove = /*#__PURE__*/React__namespace.createElement(TooltipArrow$1, {
        verticalDirection: "top",
        horizontalDirection: this.props.horizontalAlign,
        position: "absolute",
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -this.props.arrowSize + 2,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      }); // And we use a visibility: hidden arrow below to shift up the
      // content by the correct amount

      arrowBelow = /*#__PURE__*/React__namespace.createElement(TooltipArrow$1, {
        verticalDirection: "top",
        horizontalDirection: this.props.horizontalAlign,
        visibility: "hidden",
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -1,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      });
    } else {
      arrowAbove = /*#__PURE__*/React__namespace.createElement(TooltipArrow$1, {
        verticalDirection: "bottom",
        horizontalDirection: this.props.horizontalAlign,
        color: "white",
        border: this.props.borderColor,
        left: settings.arrowLeft(this.props.arrowSize),
        top: -1,
        width: this.props.arrowSize,
        height: this.props.arrowSize,
        zIndex: zIndex
      });
      arrowBelow = null;
    }
    /* A positioned div below the input to be the parent for our
        tooltip */


    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        position: "relative",
        height: 0,
        display: this.props.show ? "block" : "none"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      // eslint-disable-next-line react/no-string-refs
      ref: "tooltipContainer",
      className: "tooltipContainer",
      style: {
        position: "absolute",
        // height must start out undefined, not null, so that
        // we can measure the actual height with jquery.
        // This is used to position the tooltip with top: -100%
        // when in verticalPosition: "top" mode
        height: this.state.height || undefined,
        left: settings.targetLeft
      }
    }, arrowAbove, /*#__PURE__*/React__namespace.createElement("div", {
      className: this.props.className // eslint-disable-next-line react/no-string-refs
      ,
      ref: "tooltipContent",
      style: {
        position: "relative",
        top: settings["top"],
        left: settings.tooltipLeft,
        border: "1px solid " + this.props.borderColor,
        WebkitBoxShadow: "0 1px 3px " + this.props.borderColor,
        MozBoxShadow: "0 1px 3px " + this.props.borderColor,
        boxShadow: "0 1px 3px " + this.props.borderColor,
        zIndex: zIndex - 1
      }
    }, this.props.children.slice(1)), arrowBelow));
  },
  _updateHeight: function () {
    const height = ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
    this.refs.tooltipContainer).offsetHeight;

    if (height !== this.state.height) {
      this.setState({
        height
      });
    }
  },
  render: function () {
    const isTooltipAbove = this.props.verticalPosition === "top";
    /* We wrap the entire output in a span so that it displays inline */

    return /*#__PURE__*/React__namespace.createElement("span", null, isTooltipAbove && this._renderToolTipDiv(isTooltipAbove), /*#__PURE__*/React__namespace.createElement("div", {
      style: this.props.targetContainerStyle
    }, this.props.children[0]), !isTooltipAbove && this._renderToolTipDiv());
  }
}); // Sorry.  // Apology-Oriented-Programming

const {
  captureScratchpadTouchStart: captureScratchpadTouchStart$3
} = Util;
const MATH = "math";
const TEXT = "text";
const TEX = "tex";

class InputWithExamples extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      focused: false,
      showExamples: false
    });

    _defineProperty(this, "_getUniqueId", () => {
      return "input-with-examples-".concat(btoa(this.props.id).replace(/=/g, ""));
    });

    _defineProperty(this, "_getInputClassName", () => {
      // <MathOutput> is a special component that manages its own class and
      // state, as it's a <span> that wants to act like an <input>.
      if (this.props.type === TEX) {
        return this.props.className;
      } // Otherwise, we need to add these INPUT and FOCUSED tags here.


      let className = ClassNames.INPUT + " " + ClassNames.INTERACTIVE;

      if (this.state.focused) {
        className += " " + ClassNames.FOCUSED;
      }

      if (this.props.className) {
        className += " " + this.props.className;
      }

      return className;
    });

    _defineProperty(this, "_getPropsForInputType", () => {
      // Minimal set of props, used by each input type
      const id = this._getUniqueId();

      const inputProps = {
        id: id,
        "aria-describedby": id,
        ref: "input",
        className: this._getInputClassName(),
        labelText: this.props.labelText,
        value: this.props.value,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur,
        disabled: this.props.disabled
      };

      if (this.props.type === TEX) {
        return inputProps;
      } // Add useful props required for MATH and TEXT modes


      ___default["default"].extend(inputProps, {
        onChange: this.props.onChange,
        onTouchStart: captureScratchpadTouchStart$3
      }); // And add final props that are MATH- and TEXT-specific


      if (this.props.type === MATH) {
        return ___default["default"].extend({
          buttonSet: this.props.buttonSet,
          buttonsVisible: this.props.buttonsVisible,
          convertDotToTimes: this.props.convertDotToTimes
        }, inputProps);
      }

      if (this.props.type === TEXT) {
        return ___default["default"].extend({
          autoCapitalize: "off",
          autoComplete: "off",
          autoCorrect: "off",
          spellCheck: "false"
        }, inputProps);
      }
    });

    _defineProperty(this, "_getComponentForInputType", () => {
      switch (this.props.type) {
        case TEX:
          return MathOutput;

        case MATH:
          return MathInput;

        case TEXT:
          return TextInput;

        default:
          return null;
      }
    });

    _defineProperty(this, "_renderInput", () => {
      const inputProps = this._getPropsForInputType();

      const InputComponent = this._getComponentForInputType();

      return /*#__PURE__*/React__namespace.createElement(InputComponent, inputProps);
    });

    _defineProperty(this, "_handleFocus", () => {
      this.props.onFocus();
      this.setState({
        focused: true,
        showExamples: true
      });
    });

    _defineProperty(this, "show", () => {
      this.setState({
        showExamples: true
      });
    });

    _defineProperty(this, "hide", () => {
      this.setState({
        showExamples: false
      });
    });

    _defineProperty(this, "_handleBlur", () => {
      this.props.onBlur();
      this.setState({
        focused: false,
        showExamples: false
      });
    });

    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.focus();
    });

    _defineProperty(this, "blur", () => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.blur();
    });

    _defineProperty(this, "handleChange", e => {
      this.props.onChange(e.target.value);
    });
  }

  render() {
    const input = this._renderInput(); // Static rendering, which doesn't include the 'tooltip' logic that the
    // other types require, and is hence handled separately.


    if (this.props.type === TEX) {
      return input;
    } // Else, we need to be able to show examples


    const examplesContent = ___default["default"].map(this.props.examples, example => {
      return "- " + example;
    }).join("\n");

    const showExamples = this.props.shouldShowExamples && this.state.showExamples;
    return /*#__PURE__*/React__namespace.createElement(Tooltip // eslint-disable-next-line react/no-string-refs
    , {
      ref: "tooltip",
      className: "perseus-formats-tooltip preview-measure",
      horizontalPosition: "left",
      horizontalAlign: "left",
      verticalPosition: "bottom",
      arrowSize: 10,
      borderColor: "#ccc",
      show: showExamples
    }, input, /*#__PURE__*/React__namespace.createElement("div", {
      id: this._getUniqueId()
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: examplesContent,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "input-with-examples")
    })));
  }

}

_defineProperty(InputWithExamples, "propTypes", {
  type: PropTypes__default["default"].oneOf([MATH, TEXT, TEX]),
  value: PropTypes__default["default"].string,
  onChange: PropTypes__default["default"].func.isRequired,
  className: PropTypes__default["default"].string,
  examples: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string).isRequired,
  shouldShowExamples: PropTypes__default["default"].bool,
  convertDotToTimes: PropTypes__default["default"].bool,
  buttonSet: PropTypes__default["default"].string,
  buttonsVisible: PropTypes__default["default"].oneOf(["always", "never", "focused"]),
  labelText: PropTypes__default["default"].string,
  onFocus: PropTypes__default["default"].func,
  onBlur: PropTypes__default["default"].func,
  disabled: PropTypes__default["default"].bool,
  // A unique string identifying this InputWithExamples
  id: PropTypes__default["default"].string.isRequired,
  linterContext: PerseusLinter__namespace.linterContextProps
});

_defineProperty(InputWithExamples, "defaultProps", {
  type: TEXT,
  shouldShowExamples: true,
  onFocus: function () {},
  onBlur: function () {},
  disabled: false,
  linterContext: PerseusLinter__namespace.linterContextDefault
});

/**
 * These are things that widgets should exclude when serializing themselves.
 *
 * The use of this list needs to die. Basically, there are codepaths that
 * blindly serialize the "props" of a widget so that it can pass around its
 * info. Unfortunately, props aren't guaranteed to be serializable, and
 * automatically serializing schemaless list of attributes causes issues (e.g.
 * circular JSON structures sometimes).
 *
 * This blacklists things that we know don't need to be serialized.
 */
var WIDGET_PROP_BLACKLIST = [// standard props "added" by react
// (technically the renderer still adds them)
"key", "ref", // added by src/renderer.jsx
"containerSizeClass", "widgetId", "onChange", "problemNum", "apiOptions", "questionCompleted", "findWidgets", // added by src/editor.jsx, for widgets removing themselves
// this is soooo not the right place for this, but alas.
"onRemove", // also added by src/editor.jsx
"id", // Callbacks and items for interaction handling
"onBlur", "onFocus", "trackInteraction", "keypadElement"];

/* eslint-disable @babel/no-invalid-this */
const USAGE = "Usage:\n" + "  this.change({propName: 5}, callback);\n" + '  this.change("propName", 5, callback);\n' + '  this.change("propName")';
/**
 * Primary helper function for this.change()
 *
 * Takes the parameters in a consistent style, once this.change() has
 * figured out which way it was called.
 */

const _changeMultiple = function (component, newProps, callback) {
  // Omit "default" props:
  // ref and key come from react, and don't actually represent
  //   the conceptual state of our component
  // onChange comes from our parent to allow this modification,
  //   and doesn't conceptually represent the state of our component
  const currProps = ___default["default"].omit(component.props, WIDGET_PROP_BLACKLIST);

  const nextProps = ___default["default"].extend(currProps, newProps);

  component.props.onChange(nextProps, callback);
};
/**
 * Helper function for changing a single prop
 */


const _changeSingle = function (component, propName, value, callback) {
  if (value === undefined) {
    // If called with a single prop name, return a lambda to change
    // a single prop on the current object
    return ___default["default"].partial(_changeSingle, component, propName);
  } // If called with two values, change a single prop of the
  // current object


  const newProps = {};
  newProps[propName] = value;

  _changeMultiple(component, newProps, callback);
};
/**
 * this.change()
 *
 * Can be called as follows:
 * this.change(newProps, callback);
 *
 * this.change(propName, propValue, callback);
 *
 * this.change(propName) -> returns a lambda that takes a prop value to
 * set and a callback to call after having set that value.
 */
// TODO(WEB-1727): use proper flow syntax for overloaded functions


const change = function (newPropsOrSinglePropName, propValue, callback) {
  if (___default["default"].isObject(newPropsOrSinglePropName) && callback === undefined) {
    // Called with an object of multiple props to change
    callback = propValue;
    return _changeMultiple(this, newPropsOrSinglePropName, // object newProps
    callback);
  }

  if (typeof newPropsOrSinglePropName === "string") {
    // Called with a string propName of a single prop to change
    return _changeSingle(this, newPropsOrSinglePropName, // string propName
    propValue, callback);
  }

  throw new PerseusError("Invalid types sent to this.change(): " + ___default["default"].toArray(arguments).join() + "\n" + USAGE, Errors.Internal);
};
const propTypes = {
  onChange: PropTypes__default["default"].func.isRequired
};

var changeable = /*#__PURE__*/Object.freeze({
    __proto__: null,
    change: change,
    propTypes: propTypes
});

const ERROR_MESSAGE = i18n__namespace._("Sorry, I don't understand that!");

const insertBraces = value => {
  // HACK(alex): Make sure that all LaTeX super/subscripts are wrapped
  // in curly braces to avoid the mismatch between KAS and LaTeX sup/sub
  // parsing.
  //
  // What exactly is this mismatch? Due to its heritage of parsing plain
  // text math from <OldExpression />, KAS parses "x^12" as x^(12).
  // This is both generally what the user expects to happen, and is
  // consistent with other computer algebra systems. It is NOT
  // consistent with LaTeX however, where x^12 is equivalent to x^{1}2.
  //
  // Since the only LaTeX we parse comes from MathQuill, this wouldn't
  // be a problem if MathQuill just always gave us the latter version
  // (with explicit braces). However, instead it always gives the former.
  // This behavior is baked in pretty deep; my naive attempts at changing
  // it triggered all sorts of confusing errors. So instead we just make
  // sure to add in any missing braces before grading MathQuill input.
  //
  // TODO(alex): Properly hack MathQuill to always use explicit braces.
  return value.replace(/([_^])([^{])/g, "$1{$2}");
};

// The new, MathQuill input expression widget
class Expression extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "displayName", "Expression");

    _defineProperty(this, "state", {
      showErrorTooltip: false,
      showErrorText: false
    });

    _defineProperty(this, "componentDidMount", () => {
      // TODO(scottgrant): This is a hack to remove the deprecated call to
      // this.isMounted() but is still considered an anti-pattern.
      this._isMounted = true;
    });

    _defineProperty(this, "componentDidUpdate", prevProps => {
      if (!___default["default"].isEqual(this.props.value, prevProps.value) || !___default["default"].isEqual(this.props.functions, prevProps.functions)) {
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // eslint-disable-next-line no-restricted-syntax
        clearTimeout(this.errorTimeout);

        if (this.parse(this.props.value, this.props).parsed) {
          // eslint-disable-next-line react/no-did-update-set-state
          this.setState({
            showErrorTooltip: false
          });
        } else {
          // Store timeout ID so that we can clear it above
          // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
          // eslint-disable-next-line no-restricted-syntax
          this.errorTimeout = setTimeout(() => {
            const apiResult = this.props.apiOptions.onInputError(null, // reserved for some widget identifier
            this.props.value, ERROR_MESSAGE);

            if (apiResult !== false) {
              this.setState({
                showErrorTooltip: true
              });
            }
          }, 2000);
        }
      }
    });

    _defineProperty(this, "componentWillUnmount", () => {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      clearTimeout(this.errorTimeout);
      this._isMounted = false;
    });

    _defineProperty(this, "_isMounted", false);

    _defineProperty(this, "errorTimeout", null);

    _defineProperty(this, "simpleValidate", (rubric, onInputError) => {
      onInputError = onInputError || function () {};

      return Expression.validate(this.getUserInput(), rubric, onInputError);
    });

    _defineProperty(this, "getUserInput", () => {
      return Expression.getUserInputFromProps(this.props);
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "parse", (value, props) => {
      // TODO(jack): Disable icu for content creators here, or
      // make it so that solution answers with ','s or '.'s work
      const options = ___default["default"].pick(props || this.props, "functions");

      ___default["default"].extend(options, {
        decimal_separator: i18n__namespace.getDecimalSeparator()
      });

      return KAS__namespace.parse(insertBraces(value), options);
    });

    _defineProperty(this, "changeAndTrack", (e, cb) => {
      this.change("value", e, cb);
      this.props.trackInteraction();
    });

    _defineProperty(this, "_handleFocus", () => {
      /* istanbul ignore next */
      this.props.onFocus([]);
    });

    _defineProperty(this, "_handleBlur", () => {
      /* istanbul ignore next */
      this.props.onBlur([]);
    });

    _defineProperty(this, "focus", () => {
      if (this.props.apiOptions.customKeypad) {
        // eslint-disable-next-line react/no-string-refs
        this.refs.input.focus();
      }

      return true;
    });

    _defineProperty(this, "focusInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.focus();
    });

    _defineProperty(this, "blurInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.blur();
    });

    _defineProperty(this, "insert", text => {
      if (!this.props.apiOptions.staticRender) {
        // eslint-disable-next-line react/no-string-refs
        this.refs.input.insert(text);
      }
    });

    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.

      /* istanbul ignore next */
      return [[]];
    });

    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      /* istanbul ignore next */
      return "expression";
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      this.props.onChange({
        value: newValue
      }, cb);
    });
  }

  //#region Previously a class extension

  /* Content creators input a list of answers which are matched from top to
   * bottom. The intent is that they can include spcific solutions which should
   * be graded as correct or incorrect (or ungraded!) first, then get more
   * general.
   *
   * We iterate through each answer, trying to match it with the user's input
   * using the following angorithm:
   * - Try to parse the user's input. If it doesn't parse then return "not
   *   graded".
   * - For each answer:
   *   ~ Try to validate the user's input against the answer. The answer is
   *     expected to parse.
   *   ~ If the user's input validates (the validator judges it "correct"), we've
   *     matched and can stop considering answers.
   * - If there were no matches or the matching answer is considered "ungraded",
   *   show the user an error. TODO(joel) - what error?
   * - Otherwise, pass through the resulting points and message.
   */
  static validate(userInput, rubric) {
    let onInputError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

    const options = ___default["default"].clone(rubric);

    ___default["default"].extend(options, {
      decimal_separator: i18n__namespace.getDecimalSeparator()
    });

    const createValidator = answer => {
      // We give options to KAS.parse here because it is parsing the
      // solution answer, not the student answer, and we don't want a
      // solution to work if the student is using a different language
      // (different from the content creation language, ie. English).
      const expression = KAS__namespace.parse(answer.value, rubric); // An answer may not be parsed if the expression was defined
      // incorrectly. For example if the answer is using a symbol defined
      // in the function variables list for the expression.

      if (!expression.parsed) {
        /* istanbul ignore next */
        Log.error("Unable to parse solution answer for expression", Errors.InvalidInput, {
          loggedMetadata: {
            rubric: JSON.stringify(rubric)
          }
        });
        return null;
      }

      return KhanAnswerTypes.expression.createValidatorFunctional(expression.expr, ___default["default"]({}).extend(options, {
        simplify: answer.simplify,
        form: answer.form
      }));
    }; // Find the first answer form that matches the user's input and that
    // is considered correct. Also, track whether the input is
    // considered "empty" for all answer forms, and keep the validation
    // result for the first answer form for which the user's input was
    // considered "ungraded".
    // (Terminology reminder: the answer forms are provided by the
    // assessment items; they are not the user's input. Each one might
    // represent a correct answer, an incorrect one (if the exercise
    // creator has predicted certain common wrong answers and wants to
    // provide guidance via a message), or an ungraded one (same idea,
    // but without giving the user an incorrect mark for the question).


    let matchingAnswerForm;
    let matchMessage;
    let allEmpty = true;
    let firstUngradedResult;

    for (const answerForm of rubric.answerForms || []) {
      const validate = createValidator(answerForm);

      if (!validate) {
        continue;
      }

      const result = validate(userInput); // Short-circuit as soon as the user's input matches some answer
      // (independently of whether the answer is correct)

      if (result.correct) {
        matchingAnswerForm = answerForm;
        matchMessage = result.message || "";
        break;
      }

      allEmpty = allEmpty && result.empty; // If this answer form is correct and the user's input is considered
      // "ungraded" for it, we'll want to keep the evaluation result for
      // later. If the user's input doesn't match any answer forms, we'll
      // show the message from this validation.

      if (answerForm.considered === "correct" && result.ungraded && !firstUngradedResult) {
        firstUngradedResult = result;
      }
    } // Now check to see if we matched any answer form at all, and if
    // we did, whether it's considered correct, incorrect, or ungraded


    if (!matchingAnswerForm) {
      if (firstUngradedResult) {
        // While we didn't directly match with any answer form, we
        // did at some point get an "ungraded" validation result,
        // which might indicate e.g. a mismatch in variable casing.
        // We'll return "invalid", which will let the user try again
        // with no penalty, and the hopefully helpful validation
        // message.
        return {
          type: "invalid",
          message: firstUngradedResult.message,
          suppressAlmostThere: firstUngradedResult.suppressAlmostThere
        };
      }

      if (allEmpty) {
        // If everything graded as empty, it's invalid.
        return {
          type: "invalid",
          message: null
        };
      } // We fell through all the possibilities and we're not empty,
      // so the answer is considered incorrect.


      return {
        type: "points",
        earned: 0,
        total: 1
      };
    }

    if (matchingAnswerForm.considered === "ungraded") {
      // We matched an ungraded answer form - return "invalid", which
      // will let the user try again with no penalty
      const apiResult = onInputError(null, // Reserved for some widget identifier
      userInput, matchMessage);
      return {
        type: "invalid",
        message: apiResult === false ? null : matchMessage
      };
    } // We matched a graded answer form, so we can now tell the user
    // whether their input was correct or incorrect, and hand out
    // points accordingly
    // TODO(eater): Seems silly to translate result to this
    // invalid/points thing and immediately translate it back in
    // ItemRenderer.scoreInput()


    return {
      type: "points",
      earned: matchingAnswerForm.considered === "correct" ? 1 : 0,
      total: 1,
      message: matchMessage
    };
  }

  static getUserInputFromProps(props) {
    return insertBraces(props.value);
  }

  static getOneCorrectAnswerFromRubric(rubric) {
    const correctAnswers = (rubric.answerForms || []).filter(answerForm => answerForm.considered === "correct");

    if (correctAnswers.length === 0) {
      return;
    }

    return correctAnswers[0].value;
  } //#endregion


  render() {
    if (this.props.apiOptions.customKeypad) {
      return /*#__PURE__*/React__namespace.createElement(mathInput.KeypadInput // eslint-disable-next-line react/no-string-refs
      , {
        ref: "input",
        value: this.props.value,
        keypadElement: this.props.keypadElement,
        onChange: this.changeAndTrack,
        onFocus: () => {
          var _this$props$keypadEle;

          // this.props.keypadElement should always be set
          // when apiOptions.customKeypad is set, but how
          // to convince Flow of this?
          (_this$props$keypadEle = this.props.keypadElement) === null || _this$props$keypadEle === void 0 ? void 0 : _this$props$keypadEle.configure(this.props.keypadConfiguration, () => {
            if (this._isMounted) {
              this._handleFocus();
            }
          });
        },
        onBlur: this._handleBlur
      });
    }

    if (this.props.apiOptions.staticRender) {
      // To make things slightly easier, we just use an InputWithExamples
      // component to handle the static rendering, which is the same
      // component used by InputNumber and NumericInput
      return /*#__PURE__*/React__namespace.createElement(InputWithExamples // eslint-disable-next-line react/no-string-refs
      , {
        ref: "input",
        value: this.props.value,
        type: "tex",
        examples: [],
        shouldShowExamples: false,
        onChange: this.changeAndTrack,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur,
        id: this.props.widgetId,
        linterContext: this.props.linterContext
      });
    } // TODO(alex): Style this tooltip to be more consistent with other
    // tooltips on the site; align to left middle (once possible)


    const errorTooltip = /*#__PURE__*/React__namespace.createElement("span", {
      className: "error-tooltip",
      role: "tooltip"
    }, /*#__PURE__*/React__namespace.createElement(Tooltip, {
      className: "error-text-container",
      horizontalPosition: "right",
      horizontalAlign: "left",
      verticalPosition: "top",
      arrowSize: 10,
      borderColor: "#fcc335",
      show: this.state.showErrorText
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: "error-icon",
      "data-test-id": "test-error-icon",
      onMouseEnter: () => {
        this.setState({
          showErrorText: true
        });
      },
      onMouseLeave: () => {
        this.setState({
          showErrorText: false
        });
      },
      onClick: () => {
        // TODO(alex): Better error feedback for mobile
        this.setState({
          showErrorText: !this.state.showErrorText
        });
      }
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconExclamationSign)), /*#__PURE__*/React__namespace.createElement("div", {
      className: "error-text"
    }, ERROR_MESSAGE)));
    const className = classNames__default["default"]({
      "perseus-widget-expression": true,
      "show-error-tooltip": this.state.showErrorTooltip
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className
    }, /*#__PURE__*/React__namespace.createElement(MathInput // eslint-disable-next-line react/no-string-refs
    , {
      ref: "input",
      className: ClassNames.INTERACTIVE,
      value: this.props.value,
      onChange: this.changeAndTrack,
      convertDotToTimes: this.props.times,
      buttonsVisible: this.props.buttonsVisible || "focused",
      buttonSets: this.props.buttonSets,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur
    }), this.state.showErrorTooltip && errorTooltip);
  }

}
/**
 * Determine the keypad configuration parameters for the input, based on the
 * provided properties.
 *
 * There are two configuration parameters to be passed to the keypad:
 *   (1) The keypad type. For the Expression widget, we always use the
 *       Expression keypad.
 *   (2) The extra keys; namely, any variables or constants (like Pi) that need
 *       to be included as keys on the keypad. These are scraped from the answer
 *       forms.
 */

_defineProperty(Expression, "defaultProps", {
  value: "",
  times: false,
  functions: [],
  buttonSets: ["basic", "trig", "prealgebra", "logarithms"],
  onFocus: () => {},
  onBlur: () => {},
  apiOptions: ApiOptions.defaults,
  linterContext: PerseusLinter.linterContextDefault
});

const keypadConfigurationForProps = widgetOptions => {
  // Always use the Expression keypad, regardless of the button sets that have
  // been enabled.
  const keypadType = mathInput.KeypadTypes.EXPRESSION; // Extract any and all variables and constants from the answer forms.

  const uniqueExtraVariables = {};
  const uniqueExtraConstants = {};

  for (const answerForm of widgetOptions.answerForms) {
    const maybeExpr = KAS__namespace.parse(answerForm.value, widgetOptions);

    if (maybeExpr.parsed) {
      const expr = maybeExpr.expr; // The keypad expects Greek letters to be capitalized (e.g., it
      // requires `PI` instead of `pi`). Right now, it only supports Pi
      // and Theta, so we special-case.

      const isGreek = symbol => symbol === "pi" || symbol === "theta";

      const toKey = symbol => isGreek(symbol) ? symbol.toUpperCase() : symbol;

      for (const variable of expr.getVars()) {
        uniqueExtraVariables[toKey(variable)] = true;
      }

      for (const constant of expr.getConsts()) {
        uniqueExtraConstants[toKey(constant)] = true;
      }
    }
  } // TODO(charlie): Alert the keypad as to which of these symbols should be
  // treated as functions.


  const extraVariables = Object.keys(uniqueExtraVariables);
  extraVariables.sort();
  const extraConstants = Object.keys(uniqueExtraConstants);
  extraConstants.sort();
  const extraKeys = [...extraVariables, ...extraConstants];

  if (!extraKeys.length) {
    // If there are no extra symbols available, we include Pi anyway, so
    // that the "extra symbols" button doesn't appear empty.
    extraKeys.push("PI");
  }

  return {
    keypadType,
    extraKeys
  };
};

const propUpgrades$2 = {
  /* istanbul ignore next */
  "1": v0props => ({
    times: v0props.times,
    buttonSets: v0props.buttonSets,
    functions: v0props.functions,
    buttonsVisible: v0props.buttonsVisible,
    answerForms: [{
      considered: "correct",
      form: v0props.form,
      simplify: v0props.simplify,
      value: v0props.value
    }]
  })
};
var Expression$1 = {
  name: "expression",
  displayName: "Expression / Equation",
  defaultAlignment: "inline-block",
  widget: Expression,
  transform: widgetOptions => {
    const {
      times,
      functions,
      buttonSets,
      buttonsVisible
    } = widgetOptions;
    return {
      keypadConfiguration: keypadConfigurationForProps(widgetOptions),
      times,
      functions,
      buttonSets,
      buttonsVisible
    };
  },
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades$2,
  // For use by the editor
  isLintable: true
};

class PossibleAnswers extends React__namespace.Component {
  render() {
    // It's redundant to show duplicate answers.
    // So, remove duplicates from the given list of answer strings.
    const answers = ___default["default"].uniq(this.props.answers);

    const answerComponents = ___default["default"].map(answers, answer => {
      // Plus, now that our answers are distinct, we can safely use the
      // answer string as a key.
      return /*#__PURE__*/React__namespace.createElement("dd", {
        key: answer
      }, answer);
    });

    return /*#__PURE__*/React__namespace.createElement("dl", {
      className: "perseus-possible-answers"
    }, /*#__PURE__*/React__namespace.createElement("dt", null, i18n__namespace.doNotTranslate("Correct Answer")), answerComponents);
  }

}

_defineProperty(PossibleAnswers, "propTypes", {
  answers: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)
});

const SimpleKeypadInput = createReactClass__default["default"]({
  displayName: "SimpleKeypadInput",
  propTypes: {
    keypadElement: mathInput.keypadElementPropType,
    onFocus: PropTypes__default["default"].func,
    value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number])
  },
  componentDidMount: function () {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true;
  },
  componentWillUnmount: function () {
    this._isMounted = false;
  },

  focus() {
    // $FlowFixMe[object-this-reference]
    this.refs.input.focus(); // eslint-disable-line react/no-string-refs
  },

  blur() {
    // $FlowFixMe[object-this-reference]
    this.refs.input.blur(); // eslint-disable-line react/no-string-refs
  },

  getValue: function () {
    return this.props.value;
  },

  render() {
    // $FlowFixMe[object-this-reference]
    const _this = this; // Intercept the `onFocus` prop, as we need to configure the keypad
    // before continuing with the default focus logic for Perseus inputs.
    // Intercept the `value` prop so as to map `null` to the empty string,
    // as the `KeypadInput` does not support `null` values.


    const {
      keypadElement,
      onFocus,
      value,
      ...rest
    } = _this.props;
    return /*#__PURE__*/React__namespace.createElement(mathInput.KeypadInput // eslint-disable-next-line react/no-string-refs
    , _extends$1({
      ref: "input",
      keypadElement: keypadElement,
      onFocus: () => {
        if (keypadElement) {
          keypadElement.configure({
            keypadType: mathInput.KeypadTypes.FRACTION
          }, () => {
            if (_this._isMounted) {
              onFocus && onFocus();
            }
          });
        } else {
          onFocus && onFocus();
        }
      },
      value: value == null ? "" : "" + value
    }, rest));
  }

});

const ParseTex$1 = TexWrangler.parseTex;
const answerTypes = {
  number: {
    name: "Numbers",
    forms: "integer, decimal, proper, improper, mixed"
  },
  decimal: {
    name: "Decimals",
    forms: "decimal"
  },
  integer: {
    name: "Integers",
    forms: "integer"
  },
  rational: {
    name: "Fractions and mixed numbers",
    forms: "integer, proper, improper, mixed"
  },
  improper: {
    name: "Improper numbers (no mixed)",
    forms: "integer, proper, improper"
  },
  mixed: {
    name: "Mixed numbers (no improper)",
    forms: "integer, proper, mixed"
  },
  percent: {
    name: "Numbers or percents",
    forms: "integer, decimal, proper, improper, mixed, percent"
  },
  pi: {
    name: "Numbers with pi",
    forms: "pi"
  }
};
const formExamples$1 = {
  integer: function (options) {
    return i18n__namespace._("an integer, like $6$");
  },
  proper: function (options) {
    if (options.simplify === "optional") {
      return i18n__namespace._("a *proper* fraction, like $1/2$ or $6/10$");
    }

    return i18n__namespace._("a *simplified proper* fraction, like $3/5$");
  },
  improper: function (options) {
    if (options.simplify === "optional") {
      return i18n__namespace._("an *improper* fraction, like $10/7$ or $14/8$");
    }

    return i18n__namespace._("a *simplified improper* fraction, like $7/4$");
  },
  mixed: function (options) {
    return i18n__namespace._("a mixed number, like $1\\ 3/4$");
  },
  decimal: function (options) {
    return i18n__namespace._("an *exact* decimal, like $0.75$");
  },
  percent: function (options) {
    return i18n__namespace._("a percent, like $12.34\\%$");
  },
  pi: function (options) {
    return i18n__namespace._("a multiple of pi, like $12\\ \\text{pi}$ or " + "$2/3\\ \\text{pi}$");
  }
};

class InputNumber extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "shouldShowExamples", () => {
      return this.props.answerType !== "number" && !this.props.apiOptions.staticRender;
    });

    _defineProperty(this, "handleChange", (newValue, cb) => {
      this.props.onChange({
        currentValue: newValue
      }, cb);
    });

    _defineProperty(this, "_getInputType", () => {
      if (this.props.apiOptions.staticRender) {
        return "tex";
      }

      return "text";
    });

    _defineProperty(this, "_handleFocus", () => {
      this.props.onFocus([]); // HACK(kevinb): We want to dismiss the feedback popover that webapp
      // displays as soon as a user clicks in in the input field so we call
      // interactionCallback directly.

      const {
        interactionCallback
      } = this.props.apiOptions;

      if (interactionCallback) {
        interactionCallback();
      }
    });

    _defineProperty(this, "_handleBlur", () => {
      this.props.onBlur([]);
    });

    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.focus();
      return true;
    });

    _defineProperty(this, "focusInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.focus();
    });

    _defineProperty(this, "blurInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.blur();
    });

    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.

      /* istanbul ignore next */
      return [[]];
    });

    _defineProperty(this, "getGrammarTypeForPath", path => {
      /* istanbul ignore next */
      return "number";
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      this.props.onChange({
        currentValue: newValue
      }, cb);
    });

    _defineProperty(this, "getUserInput", () => {
      return InputNumber.getUserInputFromProps(this.props);
    });

    _defineProperty(this, "simpleValidate", (rubric, onInputError) => {
      onInputError = onInputError || function () {};

      return InputNumber.validate(this.getUserInput(), rubric, onInputError);
    });

    _defineProperty(this, "examples", () => {
      const type = this.props.answerType;
      const forms = answerTypes[type].forms.split(/\s*,\s*/);

      const examples = ___default["default"].map(forms, function (form) {
        // eslint-disable-next-line @babel/no-invalid-this
        return formExamples$1[form](this.props);
      }, this);

      return [i18n__namespace._("**Your answer should be** ")].concat(examples);
    });
  }

  render() {
    if (this.props.apiOptions.customKeypad) {
      // TODO(charlie): Support "Review Mode".
      const input = /*#__PURE__*/React__namespace.createElement(SimpleKeypadInput // eslint-disable-next-line react/no-string-refs
      , {
        ref: "input",
        value: this.props.currentValue,
        keypadElement: this.props.keypadElement,
        onChange: this.handleChange,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur
      });

      if (this.props.rightAlign) {
        return /*#__PURE__*/React__namespace.createElement("div", {
          className: "perseus-input-right-align"
        }, input);
      }

      return input;
    } // HACK(johnsullivan): Create a function with shared logic between
    // this and NumericInput.


    const rubric = this.props.reviewModeRubric;
    let correct = null;
    let answerBlurb = null; // SAT is deprecated and not testable

    /* istanbul ignore if */

    if (this.props.apiOptions.satStyling && rubric) {
      const score = this.simpleValidate(rubric);
      correct = score.type === "points" && score.earned === score.total;

      if (!correct) {
        // TODO(johnsullivan): Make this a little more
        // human-friendly.
        let answerString = String(rubric.value);

        if (rubric.inexact && rubric.maxError) {
          answerString += " \u00B1 " + rubric.maxError;
        }

        const answerStrings = [answerString];
        answerBlurb = /*#__PURE__*/React__namespace.createElement(PossibleAnswers, {
          answers: answerStrings
        });
      }
    }

    const classes = {};
    classes["perseus-input-size-" + this.props.size] = true;
    classes["perseus-input-right-align"] = this.props.rightAlign;
    classes[ClassNames.CORRECT] = rubric && correct && this.props.currentValue;
    classes[ClassNames.INCORRECT] = rubric && !correct && this.props.currentValue;
    classes[ClassNames.UNANSWERED] = rubric && !this.props.currentValue;
    const input = /*#__PURE__*/React__namespace.createElement(InputWithExamples // eslint-disable-next-line react/no-string-refs
    , {
      ref: "input",
      value: this.props.currentValue,
      onChange: this.handleChange,
      className: classNames__default["default"](classes),
      type: this._getInputType(),
      examples: this.examples(),
      shouldShowExamples: this.shouldShowExamples(),
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      id: this.props.widgetId,
      disabled: this.props.apiOptions.readOnly,
      linterContext: this.props.linterContext
    }); // SAT is deprecated, answer blurb is an SAT feature

    /* istanbul ignore if */

    if (answerBlurb) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-input-with-answer-blurb"
      }, input, answerBlurb);
    }

    return input;
  }

  static validate(state, rubric) {
    let onInputError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};

    if (rubric.answerType == null) {
      rubric.answerType = "number";
    }

    const val = KhanAnswerTypes.number.createValidatorFunctional(rubric.value, {
      simplify: rubric.simplify,
      inexact: rubric.inexact || undefined,
      maxError: rubric.maxError,
      forms: answerTypes[rubric.answerType].forms
    }); // We may have received TeX; try to parse it before grading.
    // If `currentValue` is not TeX, this should be a no-op.

    const currentValue = ParseTex$1(state.currentValue);
    const result = val(currentValue); // TODO(eater): Seems silly to translate result to this invalid/points
    // thing and immediately translate it back in ItemRenderer.scoreInput()

    if (result.empty) {
      // TODO(FEI-3867): remove null-check once we have APIOptionsInternal
      const apiResult = onInputError === null || onInputError === void 0 ? void 0 : onInputError(null, // reserved for some widget identifier
      state.currentValue, result.message);
      return {
        type: "invalid",
        message: apiResult === false ? null : result.message
      };
    }

    return {
      type: "points",
      earned: result.correct ? 1 : 0,
      total: 1,
      message: result.message
    };
  }

  static getUserInputFromProps(props) {
    return {
      currentValue: props.currentValue
    };
  }

  static getOneCorrectAnswerFromRubric(rubric) {
    if (rubric.value == null) {
      return;
    }

    let answerString = String(rubric.value);

    if (rubric.inexact && rubric.maxError) {
      answerString += " \u00B1 " + rubric.maxError;
    }

    return answerString;
  }

}

_defineProperty(InputNumber, "defaultProps", {
  currentValue: "",
  size: "normal",
  answerType: "number",
  rightAlign: false,
  // NOTE(kevinb): renderer.jsx should be provide this so we probably don't
  // need to include it in defaultProps.
  apiOptions: ApiOptions.defaults,
  linterContext: PerseusLinter.linterContextDefault
});

const propTransform$4 = widgetOptions => {
  const {
    simplify,
    size,
    answerType,
    rightAlign
  } = widgetOptions;
  return {
    simplify,
    size,
    answerType,
    rightAlign
  };
};

var InputNumber$1 = {
  name: "input-number",
  displayName: "Number text box (old)",
  defaultAlignment: "inline-block",
  hidden: true,
  widget: InputNumber,
  transform: propTransform$4,
  isLintable: true
};

const ParseTex = TexWrangler.parseTex;
const answerFormButtons = [{
  title: "Integers",
  value: "integer",
  content: "6"
}, {
  title: "Decimals",
  value: "decimal",
  content: "0.75"
}, {
  title: "Proper fractions",
  value: "proper",
  content: "\u2157"
}, {
  title: "Improper fractions",
  value: "improper",
  content: "\u2077\u2044\u2084"
}, {
  title: "Mixed numbers",
  value: "mixed",
  content: "1\u00BE"
}, {
  title: "Numbers with \u03C0",
  value: "pi",
  content: "\u03C0"
}];
const formExamples = {
  integer: () => i18n__namespace._("an integer, like $6$"),
  proper: form => form.simplify === "optional" ? i18n__namespace._("a *proper* fraction, like $1/2$ or $6/10$") : i18n__namespace._("a *simplified proper* fraction, like $3/5$"),
  improper: form => form.simplify === "optional" ? i18n__namespace._("an *improper* fraction, like $10/7$ or $14/8$") : i18n__namespace._("a *simplified improper* fraction, like $7/4$"),
  mixed: () => i18n__namespace._("a mixed number, like $1\\ 3/4$"),
  decimal: () => i18n__namespace._("an *exact* decimal, like $0.75$"),
  pi: () => i18n__namespace._("a multiple of pi, like $12\\ \\text{pi}$ or " + "$2/3\\ \\text{pi}$")
};
class NumericInput extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      // keeps track of the other set of values when switching
      // between 0 and finite solutions
      previousValues: [""]
    });

    _defineProperty(this, "getAnswerBlurb", rubric => {
      let correct;
      let answerBlurb;
      /* Ignore this block because SAT is deprecated */

      /* istanbul ignore next */

      if (this.props.apiOptions.satStyling && rubric) {
        const score = this.simpleValidate(rubric);
        correct = score.type === "points" && score.earned === score.total;

        if (!correct) {
          const correctAnswers = ___default["default"].filter(rubric.answers, answer => answer.status === "correct");

          const answerStrings = ___default["default"].map(correctAnswers, answer => {
            // Figure out how this answer is supposed to be
            // displayed
            let format = "decimal";

            if (answer.answerForms && answer.answerForms[0]) {
              // NOTE(johnsullivan): This isn't exactly ideal, but
              // it does behave well for all the currently known
              // problems. See D14742 for some discussion on
              // alternate strategies.
              format = answer.answerForms[0];
            }

            let answerString = KhanMath.toNumericString(answer.value, format);

            if (answer.maxError) {
              answerString += " \u00B1 " + KhanMath.toNumericString(answer.maxError, format);
            }

            return answerString;
          });

          answerBlurb = /*#__PURE__*/React__namespace.createElement(PossibleAnswers, {
            answers: answerStrings
          });
        }
      }

      return [answerBlurb, !!correct];
    });

    _defineProperty(this, "examples", () => {
      var _this$props$answerFor;

      // if the set of specified forms are empty, allow all forms
      const forms = ((_this$props$answerFor = this.props.answerForms) === null || _this$props$answerFor === void 0 ? void 0 : _this$props$answerFor.length) !== 0 ? this.props.answerForms : ___default["default"].map(___default["default"].keys(formExamples), name => {
        return {
          name: name,
          simplify: "required"
        };
      });

      let examples = ___default["default"].map(forms, form => {
        return formExamples[form.name](form);
      }); // Ensure no duplicate tooltip text from simplified and unsimplified
      // versions of the same format


      examples = ___default["default"].uniq(examples);
      return [i18n__namespace._("**Your answer should be** ")].concat(examples);
    });

    _defineProperty(this, "shouldShowExamples", () => {
      var _this$props$answerFor2, _this$props$answerFor3;

      const noFormsAccepted = ((_this$props$answerFor2 = this.props.answerForms) === null || _this$props$answerFor2 === void 0 ? void 0 : _this$props$answerFor2.length) === 0; // To check if all answer forms are accepted, we must first
      // find the *names* of all accepted forms, and see if they are
      // all present, ignoring duplicates

      const answerFormNames = ___default["default"].uniq((_this$props$answerFor3 = this.props.answerForms) === null || _this$props$answerFor3 === void 0 ? void 0 : _this$props$answerFor3.map(form => form.name));

      const allFormsAccepted = answerFormNames.length >= ___default["default"].size(formExamples);

      return !noFormsAccepted && !allFormsAccepted;
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return NumericInput.validate(this.getUserInput(), rubric);
    });

    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.focus();
      return true;
    });

    _defineProperty(this, "focusInputPath", inputPath => {
      /* istanbul ignore next */
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.focus();
    });

    _defineProperty(this, "blurInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.input.blur();
    });

    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.

      /* istanbul ignore next */
      return [[]];
    });

    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      /* istanbul ignore next */
      return "number";
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      /* istanbul ignore next */
      this.props.onChange({
        currentValue: newValue
      }, cb);
    });

    _defineProperty(this, "getUserInput", () => {
      return NumericInput.getUserInputFromProps(this.props);
    });

    _defineProperty(this, "handleChange", (newValue, cb) => {
      this.props.onChange({
        currentValue: newValue
      }, cb);
      this.props.trackInteraction();
    });

    _defineProperty(this, "_getInputType", () => {
      if (this.props.apiOptions.staticRender) {
        return "tex";
      }

      return "text";
    });

    _defineProperty(this, "_handleFocus", () => {
      this.props.onFocus([]); // HACK(kevinb): We want to dismiss the feedback popover that webapp
      // displays as soon as a user clicks in in the input field so we call
      // interactionCallback directly.

      const {
        interactionCallback
      } = this.props.apiOptions;

      if (interactionCallback) {
        interactionCallback();
      }
    });

    _defineProperty(this, "_handleBlur", () => {
      this.props.onBlur([]);
    });
  }

  static getUserInputFromProps(props) {
    return {
      currentValue: props.currentValue
    };
  }

  static getOneCorrectAnswerFromRubric(rubric) {
    const correctAnswers = ___default["default"].filter(rubric.answers, answer => answer.status === "correct");

    const answerStrings = ___default["default"].map(correctAnswers, answer => {
      // Figure out how this answer is supposed to be
      // displayed
      let format = "decimal";

      if (answer.answerForms && answer.answerForms[0]) {
        // NOTE(johnsullivan): This isn't exactly ideal, but
        // it does behave well for all the currently known
        // problems. See D14742 for some discussion on
        // alternate strategies.
        format = answer.answerForms[0];
      }

      let answerString = KhanMath.toNumericString(answer.value, format);

      if (answer.maxError) {
        answerString += " \u00B1 " + KhanMath.toNumericString(answer.maxError, format);
      }

      return answerString;
    });

    if (answerStrings.length === 0) {
      return;
    }

    return answerStrings[0];
  }

  static validate(useInput, rubric) {
    const allAnswerForms = ___default["default"].pluck(answerFormButtons, "value");

    const createValidator = answer => KhanAnswerTypes.number.createValidatorFunctional(answer.value, {
      message: answer.message,
      simplify: answer.status === "correct" ? answer.simplify : "optional",
      inexact: true,
      // TODO(merlob) backfill / delete
      maxError: answer.maxError,
      forms: answer.strict && answer.answerForms && answer.answerForms.length !== 0 ? answer.answerForms : allAnswerForms
    }); // We may have received TeX; try to parse it before grading.
    // If `currentValue` is not TeX, this should be a no-op.


    const currentValue = ParseTex(useInput.currentValue);

    const correctAnswers = ___default["default"].where(rubric.answers, {
      status: "correct"
    });

    const normalizedAnswerExpected = correctAnswers.every(answer => Math.abs(answer.value) <= 1); // Look through all correct answers for one that matches either
    // precisely or approximately and return the appropriate message:
    // - if precise, return the message that the answer came with
    // - if it needs to be simplified, etc., show that message

    let result = ___default["default"].find(___default["default"].map(correctAnswers, answer => {
      // The coefficient is an attribute of the widget
      let localValue = currentValue;

      if (rubric.coefficient) {
        if (!localValue) {
          localValue = 1;
        } else if (localValue === "-") {
          localValue = -1;
        }
      }

      const validate = createValidator(answer);
      return validate(maybeParsePercentInput(localValue, normalizedAnswerExpected));
    }), match => match.correct || match.empty);

    if (!result) {
      // Otherwise, if the guess is not correct
      const otherAnswers = [].concat(___default["default"].where(rubric.answers, {
        status: "ungraded"
      }), ___default["default"].where(rubric.answers, {
        status: "wrong"
      })); // Look through all other answers and if one matches either
      // precisely or approximately return the answer's message

      const match = ___default["default"].find(otherAnswers, answer => {
        const validate = createValidator(answer);
        return validate(maybeParsePercentInput(currentValue, normalizedAnswerExpected)).correct;
      });

      result = {
        empty: match ? match.status === "ungraded" : false,
        correct: match ? match.status === "correct" : false,
        message: match ? match.message : null,
        guess: currentValue
      };
    } // TODO(eater): Seems silly to translate result to this
    // invalid/points thing and immediately translate it
    // back in ItemRenderer.scoreInput()


    if (result.empty) {
      return {
        type: "invalid",
        message: result.message
      };
    }

    return {
      type: "points",
      earned: result.correct ? 1 : 0,
      total: 1,
      message: result.message
    };
  }

  render() {
    const rubric = this.props.reviewModeRubric;
    const answers = this.getAnswerBlurb(rubric);
    const answerBlurb = answers[0];
    const classes = [];
    let labelText = this.props.labelText;

    if (labelText == null || labelText === "") {
      labelText = i18n__namespace._("Your answer:");
    } // To right align a custom keypad we need to wrap it.


    const maybeRightAlignKeypadInput = keypadInput => {
      return this.props.rightAlign ? /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-input-right-align"
      }, keypadInput) : keypadInput;
    };

    if (this.props.apiOptions.customKeypad) {
      // TODO(charlie): Support "Review Mode".
      return maybeRightAlignKeypadInput( /*#__PURE__*/React__namespace.createElement(SimpleKeypadInput // eslint-disable-next-line react/no-string-refs
      , {
        ref: "input",
        value: this.props.currentValue,
        keypadElement: this.props.keypadElement,
        onChange: this.handleChange,
        onFocus: this._handleFocus,
        onBlur: this._handleBlur
      }));
    }

    const input = /*#__PURE__*/React__namespace.createElement(InputWithExamples // eslint-disable-next-line react/no-string-refs
    , {
      ref: "input",
      value: this.props.currentValue,
      onChange: this.handleChange,
      className: classNames__default["default"](classes),
      labelText: labelText,
      type: this._getInputType(),
      examples: this.examples(),
      shouldShowExamples: this.shouldShowExamples(),
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      id: this.props.widgetId,
      disabled: this.props.apiOptions.readOnly // $FlowFixMe[prop-missing]
      ,
      highlightLint: this.props.highlightLint
    });
    /* This only gets used with SAT Content */

    /* istanbul ignore next if */

    if (answerBlurb) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-input-with-answer-blurb"
      }, input, answerBlurb);
    }

    if (this.props.apiOptions.satStyling) {
      // NOTE(amy): the input widgets themselves already have
      // a default aria label of "Your Answer", so we hide this
      // redundant label from screen-readers.
      return /*#__PURE__*/React__namespace.createElement("label", {
        className: "perseus-input-with-label"
      }, /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-input-label",
        "aria-hidden": "true"
      }, i18n__namespace.doNotTranslate("Answer:")), input);
    }

    return /*#__PURE__*/React__namespace.createElement("div", null, input);
  }

} // TODO(thomas): Currently we receive a list of lists of acceptable answer types
// and union them down into a single set. It's worth considering whether it
// wouldn't make more sense to have a single set of acceptable answer types for
// a given *problem* rather than for each possible [correct/wrong] *answer*.
// When should two answers to a problem take different answer types?
// See D27790 for more discussion.

_defineProperty(NumericInput, "defaultProps", {
  currentValue: "",
  size: "normal",
  rightAlign: false,
  apiOptions: ApiOptions.defaults,
  coefficient: false,
  answerForms: [],
  labelText: "",
  linterContext: PerseusLinter.linterContextDefault,
  multipleNumberInput: false
});

const unionAnswerForms = function (answerFormsList) {
  // Takes a list of lists of answer forms, and returns a list of the forms
  // in each of these lists in the same order that they're listed in the
  // `formExamples` forms from above.
  // uniqueBy takes a list of elements and a function which compares whether
  // two elements are equal, and returns a list of unique elements. This is
  // just a helper function here, but works generally.
  const uniqueBy = function (list, iteratee) {
    return ___default["default"].reduce(list, (uniqueList, element) => {
      // For each element, decide whether it's already in the list of
      // unique items.
      const inList = ___default["default"].find(uniqueList, iteratee.bind(null, element));

      if (inList) {
        return uniqueList;
      }

      return uniqueList.concat([element]);
    }, []);
  }; // Pull out all of the forms from the different lists.


  const allForms = ___default["default"].flatten(answerFormsList); // Pull out the unique forms using uniqueBy.


  const uniqueForms = uniqueBy(allForms, ___default["default"].isEqual); // Sort them by the order they appear in the `formExamples` list.

  return ___default["default"].sortBy(uniqueForms, form => {
    return ___default["default"].keys(formExamples).indexOf(form.name);
  });
};
// This function checks if the user inputted a percent value, parsing
// it as a number (and maybe scaling) so that it can be graded.
// NOTE(michaelpolyak): Unlike `KhanAnswerTypes.number.percent()` which
// can accept several input forms with or without "%", the decision
// to parse based on the presence of "%" in the input, is so that we
// don't accidently scale the user typed value before grading, CP-930.
const maybeParsePercentInput = (inputValue, normalizedAnswerExpected) => {
  // If the input value is not a string ending with "%", then there's
  // nothing more to do. The value will be graded as inputted by user.
  if (!(typeof inputValue === "string" && inputValue.endsWith("%"))) {
    return inputValue;
  }

  const value = parseFloat(inputValue.slice(0, -1)); // If the input value stripped of the "%" cannot be parsed as a
  // number (the slice is not really necessary for parseFloat to work
  // if the string starts with a number) then return the original
  // input for grading.

  if (isNaN(value)) {
    return inputValue;
  } // Next, if all correct answers are in the range of |0,1| then we
  // scale the user typed value. We assume this is the correct thing
  // to do since the input value ends with "%".


  if (normalizedAnswerExpected) {
    return value / 100;
  } // Otherwise, we return input value (number) stripped of the "%".


  return value;
};

const propsTransform = function (widgetOptions) {
  const rendererProps = ___default["default"].extend(___default["default"].omit(widgetOptions, "answers"), {
    answerForms: unionAnswerForms( // Pull out the name of each form and whether that form has
    // required simplification.
    ___default["default"].map(widgetOptions.answers, answer => {
      return ___default["default"].map(answer.answerForms, form => {
        return {
          simplify: answer.simplify,
          name: form
        };
      });
    }))
  });

  return rendererProps;
};

var NumericInput$1 = {
  name: "numeric-input",
  displayName: "Number text box",
  defaultAlignment: "inline-block",
  accessible: true,
  widget: NumericInput,
  transform: propsTransform,
  isLintable: true
};

/* Free implementation of getUserInput. This should be used sparingly, since it
 * just returns all the widget's props rather than picking out those which were
 * input by the user.
 */
const WidgetJsonifyDeprecated = {
  getUserInput: function () {
    // Omit props that get passed to all widgets
    return ___default["default"].omit(this.props, WIDGET_PROP_BLACKLIST);
  },
  // Static version of `WidgetJsonifyDeprecated.getUserInput`
  getUserInputFromProps: function (props) {
    // Omit props that get passed to all widgets
    return ___default["default"].omit(props, WIDGET_PROP_BLACKLIST);
  }
};

const EN_DASH$1 = "\u2013";

class PassageRef extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "displayName", "PassageRef");

    _defineProperty(this, "_isMounted", void 0);

    _defineProperty(this, "_throttledUpdateRange", void 0);

    _defineProperty(this, "state", {
      lineRange: null,
      content: null
    });

    _defineProperty(this, "getUserInput", () => {
      return WidgetJsonifyDeprecated.getUserInput.call(this);
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "_deferredUpdateRange", () => {
      ___default["default"].defer(this._updateRange);
    });

    _defineProperty(this, "_updateRange", () => {
      const passage = this.props.findWidgets("passage " + this.props.passageNumber)[0];
      let refInfo = null;

      if (passage) {
        refInfo = passage.getReference(this.props.referenceNumber);
      }

      if (this._isMounted) {
        if (refInfo) {
          this.setState({
            lineRange: [refInfo.startLine, refInfo.endLine],
            content: refInfo.content
          });
        } else {
          this.setState({
            lineRange: null,
            content: null
          });
        }
      }
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return PassageRef.validate(this.getUserInput(), rubric);
    });
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !___default["default"].isEqual(this.props, nextProps) || !___default["default"].isEqual(this.state, nextState);
  }

  render() {
    const lineRange = this.state.lineRange;
    let lineRangeOutput;

    if (!lineRange) {
      lineRangeOutput = i18n__namespace.$_("lines %(lineRange)s", {
        lineRange: "?".concat(EN_DASH$1, "?")
      });
    } else if (lineRange[0] === lineRange[1]) {
      lineRangeOutput = i18n__namespace.$_("line %(lineNumber)s", {
        lineNumber: lineRange[0]
      });
    } else {
      lineRangeOutput = i18n__namespace.$_("lines %(lineRange)s", {
        lineRange: lineRange[0] + EN_DASH$1 + lineRange[1]
      });
    }

    let summaryOutput;

    if (this.props.summaryText) {
      const summaryTree = PerseusMarkdown.parseInline(this.props.summaryText);
      summaryOutput = /*#__PURE__*/React__namespace.createElement("span", {
        "aria-hidden": true
      }, " ", "(\u201C", PerseusMarkdown.basicOutput(summaryTree), "\u201D)");
    } else {
      summaryOutput = null;
    }

    return /*#__PURE__*/React__namespace.createElement("span", null, lineRangeOutput, summaryOutput, lineRange && /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-sr-only"
    }, this.state.content));
  }

  componentDidMount() {
    // TODO(scottgrant): This is a hack to remove the deprecated call to
    // this.isMounted() but is still considered an anti-pattern.
    this._isMounted = true;

    this._deferredUpdateRange();

    this._throttledUpdateRange = ___default["default"].throttle(this._deferredUpdateRange, 500);
    window.addEventListener("resize", this._throttledUpdateRange);
  }

  componentDidUpdate() {
    this._deferredUpdateRange();
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this._throttledUpdateRange);
    this._isMounted = false;
  }

  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }

}

_defineProperty(PassageRef, "defaultProps", {
  passageNumber: 1,
  referenceNumber: 1,
  summaryText: ""
});

var PassageRef$1 = {
  name: "passage-ref",
  displayName: "PassageRef (SAT only)",
  defaultAlignment: "inline",
  widget: PassageRef,
  transform: widgetOptions => ({
    passageNumber: widgetOptions.passageNumber,
    referenceNumber: widgetOptions.referenceNumber,
    summaryText: widgetOptions.summaryText
  }),
  version: {
    major: 0,
    minor: 1
  }
};

/**
 * A default set of media queries to use for different screen sizes. Based on
 * the breakpoints from purecss.
 *
 * Use like:
 *   StyleSheet.create({
 *       blah: {
 *           [mediaQueries.xs]: {
 *
 *           },
 *       },
 *   });
 */
const {
  pureXsMax: pureXsMax$1,
  pureSmMin: pureSmMin$1,
  pureSmMax: pureSmMax$1,
  pureMdMin: pureMdMin$1,
  pureMdMax: pureMdMax$1,
  pureLgMin: pureLgMin$1,
  pureLgMax: pureLgMax$1,
  pureXlMin: pureXlMin$1
} = constants$1;
var mediaQueries = {
  xs: "@media screen and (max-width: ".concat(pureXsMax$1, ")"),
  sm: "@media screen and (min-width: ".concat(pureSmMin$1, ") and ") + "(max-width: ".concat(pureSmMax$1, ")"),
  md: "@media screen and (min-width: ".concat(pureMdMin$1, ") and ") + "(max-width: ".concat(pureMdMax$1, ")"),
  lg: "@media screen and (min-width: ".concat(pureLgMin$1, ") and ") + "(max-width: ".concat(pureLgMax$1, ")"),
  xl: "@media screen and (min-width: ".concat(pureXlMin$1, ")"),
  xsOrSmaller: "@media screen and (max-width: ".concat(pureXsMax$1, ")"),
  smOrSmaller: "@media screen and (max-width: ".concat(pureSmMax$1, ")"),
  mdOrSmaller: "@media screen and (max-width: ".concat(pureMdMax$1, ")"),
  lgOrSmaller: "@media screen and (max-width: ".concat(pureLgMax$1, ")"),
  smOrLarger: "@media screen and (min-width: ".concat(pureSmMin$1, ")"),
  mdOrLarger: "@media screen and (min-width: ".concat(pureMdMin$1, ")"),
  lgOrLarger: "@media screen and (min-width: ".concat(pureLgMin$1, ")"),
  xlOrLarger: "@media screen and (min-width: ".concat(pureXlMin$1, ")")
};

const {
  zIndexAboveScratchpad,
  zIndexInteractiveComponent,
  radioBorderColor: radioBorderColor$1,
  checkedColor,
  circleSize,
  radioMarginWidth
} = constants$1; // $FlowFixMe[prop-missing]

var sharedStyles = aphrodite.StyleSheet.create({
  perseusInteractive: {
    zIndex: zIndexInteractiveComponent,
    position: "relative"
  },
  aboveScratchpad: {
    position: "relative",
    zIndex: zIndexAboveScratchpad
  },
  blankBackground: {
    // TODO(emily): Use KhanUtil._BACKGROUND?
    backgroundColor: "#FDFDFD"
  },
  perseusSrOnly: {
    border: 0,
    clip: "rect(0,0,0,0)",
    height: 1,
    margin: -1,
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: 1
  },
  responsiveLabel: {
    // NOTE(charlie): The values used here should be kept in sync with the
    // caption text sizing in Perseus' articles.less.
    // TODO(charlie): Migrate the captions over to using this style.
    [mediaQueries.smOrSmaller]: {
      fontSize: 14,
      lineHeight: 1.3
    },
    [mediaQueries.md]: {
      fontSize: 17,
      lineHeight: 1.4
    },
    [mediaQueries.lgOrLarger]: {
      fontSize: 20,
      lineHeight: 1.4
    }
  },
  responsiveInput: {
    display: "inline-block",
    WebkitAppearance: "none",
    appearance: "none",
    "::-ms-check": {
      display: "none"
    },
    backgroundColor: "#fff",
    border: "2px solid #fff",
    boxShadow: "0 0px 0px 1px ".concat(radioBorderColor$1),
    outline: "none",
    boxSizing: "border-box",
    flexShrink: 0,
    marginBottom: 1,
    marginLeft: 1,
    marginRight: 1,
    marginTop: 1,
    height: circleSize - 2,
    width: circleSize - 2
  },
  responsiveRadioInput: {
    borderRadius: "50%",
    ":checked": {
      backgroundColor: checkedColor,
      border: "none",
      borderRadius: "50%",
      boxShadow: "inset 0px 0px 0px 2px white, " + "0 0px 0px 2px ".concat(checkedColor),
      marginTop: radioMarginWidth,
      marginBottom: radioMarginWidth,
      marginLeft: radioMarginWidth,
      marginRight: radioMarginWidth,
      height: circleSize - 2 * radioMarginWidth,
      width: circleSize - 2 * radioMarginWidth
    }
  },
  responsiveRadioInputActive: {
    backgroundColor: "#fff",
    border: "2px solid #fff",
    borderRadius: "50%",
    boxShadow: "0 0px 0px 2px ".concat(checkedColor),
    marginTop: radioMarginWidth,
    marginBottom: radioMarginWidth,
    marginLeft: radioMarginWidth,
    marginRight: radioMarginWidth,
    height: circleSize - 2 * radioMarginWidth,
    width: circleSize - 2 * radioMarginWidth,
    ":checked": {
      backgroundColor: "#fff"
    }
  },
  disableTextSelection: {
    userSelect: "none"
  }
});

/**
 * A small collection of useful scrolling utility functions.
 */
// Polyfill scrollTo if it doesn't exist
// $FlowIgnore[method-unbinding]
if (typeof HTMLElement !== "undefined" && !HTMLElement.prototype.scrollTo) {
  // $FlowIgnore[cannot-write]: Flow sees this as read-only, so we have to suppress it.
  HTMLElement.prototype.scrollTo = function (left, top) {
    this.scrollLeft = left;
    this.scrollTop = top;
  };
}
/**
 * Handles applying a given scroll object to either the window object,
 * or an HTML element.
 * NOTE: SIDE EFFECTS. This method touches the DOM.
 */


const applyUniversalScrollOffset = (elementOrWindow, amount) => {
  // Window objects need to be scrolled by using the `.scrollTo()` function.
  // Elements in MODERN browsers also have this method, but a safer x-browser
  // solution is to use the `.scrollTop` property setter.
  // $FlowIgnore[method-unbinding]
  if (typeof elementOrWindow.scrollTo === "function") {
    elementOrWindow.scrollTo(0, amount);
  } else if ("scrollTop" in elementOrWindow) {
    elementOrWindow.scrollTop = amount;
  }
};
/**
 * Smoothly scroll the given element to the given offset.
 *
 * This assumes that element.scrollHeight > element.clientHeight.
 */


const scrollElementToOffset = function (elementOrWindow, offset) {
  let duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let callback = arguments.length > 3 ? arguments[3] : undefined;
  const startPosition = elementOrWindow === window ? window.pageYOffset : elementOrWindow.scrollTop;
  const endPosition = offset;
  const scrollDistance = endPosition - startPosition; // Aim for ~60 FPS

  const tickLength = 17;
  const numberOfSteps = duration / tickLength;
  let step = 0; // TODO (josh): Rewrite this using window.requestAnimationFrame
  // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API
  // eslint-disable-next-line no-restricted-syntax

  const scrollInterval = setInterval(function () {
    if (step < numberOfSteps) {
      const x = step / numberOfSteps; // Domain: [0, 1]

      const y = (-Math.cos(Math.PI * x) + 1) / 2; // Range: [0, 1]

      const newPosition = startPosition + scrollDistance * y;
      applyUniversalScrollOffset(elementOrWindow, newPosition);
      step += 1;
    } else {
      // Account for non-integer numberOfSteps
      applyUniversalScrollOffset(elementOrWindow, endPosition); // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax

      clearInterval(scrollInterval);
      callback && callback();
    }
  }, tickLength);
};
/**
 * Returns the closest ancestor that is scrollable.
 *
 * If the container is document.body we return window b/c scrollTo() doesn't
 * work on document.body in some browsers.
 */


const getScrollContainer = element => {
  if (element === document.body) {
    return window;
  }

  if (element == null) {
    return window;
  }

  if (element.scrollHeight > element.clientHeight) {
    return element;
  }

  return getScrollContainer(element.parentElement);
};

const SCROLL_ANIMATION_DURATION = 750; // ms

/**
 * Scroll the given element into view.
 *
 * This works with elements inside scroll containers, but may fail in scenarios
 * involving multiple nested scroll containers.
 */

const scrollElementIntoView = (element, callback) => {
  // Often times we scroll an element into with in reaction to some change in
  // the DOM.  Since we need to measure things, we wait a tick for the DOM to
  // settle before computing the distance to scroll and beginning the scroll
  // animation.
  // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API
  // eslint-disable-next-line no-restricted-syntax
  setTimeout(() => {
    const scrollContainer = getScrollContainer(element);
    const childBounds = element.getBoundingClientRect();
    const containerBounds = scrollContainer === window ? {
      top: 0,
      bottom: window.innerHeight
    } : scrollContainer.getBoundingClientRect();
    let offset = 0;
    const currentScrollTop = scrollContainer === window ? window.scrollY : scrollContainer.scrollTop;

    if (childBounds.bottom > containerBounds.bottom) {
      let distanceToScroll = childBounds.bottom - containerBounds.bottom; // Ensure that we see the top of the component we're scrolling.

      if (childBounds.top + distanceToScroll < containerBounds.top) {
        distanceToScroll = childBounds.top - containerBounds.top;
      }

      offset = currentScrollTop + distanceToScroll;
    } else if (childBounds.top < containerBounds.top) {
      const distanceToScroll = childBounds.top - containerBounds.top;
      offset = currentScrollTop + distanceToScroll;
    }

    scrollElementToOffset(scrollContainer, offset, SCROLL_ANIMATION_DURATION, callback);
  }, 0);
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to, from) {
  if (from === undefined) from = '';

  var toParts = (to && to.split('/')) || [];
  var fromParts = (from && from.split('/')) || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');

  if (
    mustEndAbs &&
    fromParts[0] !== '' &&
    (!fromParts[0] || !isAbsolute(fromParts[0]))
  )
    fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

var isProduction$1 = process.env.NODE_ENV === 'production';
function warning(condition, message) {
  if (!isProduction$1) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

var isProduction = process.env.NODE_ENV === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    var provided = typeof message === 'function' ? message() : message;
    var value = provided ? prefix + ": " + provided : prefix;
    throw new Error(value);
}

function addLeadingSlash$1(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
}
function hasBasename(path, prefix) {
  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
}
function stripBasename$1(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';
  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
  return path;
}

function createLocation(path, state, key, currentLocation) {
  var location;

  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}

function createTransitionManager() {
  var prompt = null;

  function setPrompt(nextPrompt) {
    process.env.NODE_ENV !== "production" ? warning(prompt == null, 'A history supports only one prompt at a time') : void 0;
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  }

  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          process.env.NODE_ENV !== "production" ? warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : void 0;
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }

  var listeners = [];

  function appendListener(fn) {
    var isActive = true;

    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  }

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message)); // eslint-disable-line no-alert
}
/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
  return window.history && 'pushState' in window.history;
}
/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */

function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
}
/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
}
/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
}
/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */


function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ? process.env.NODE_ENV !== "production" ? invariant(false, 'Browser history needs a DOM') : invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props,
      _props$forceRefresh = _props.forceRefresh,
      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : '';

  function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = pathname + search + hash;
    process.env.NODE_ENV !== "production" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : void 0;
    if (basename) path = stripBasename$1(path, basename);
    return createLocation(path, state, key);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }

  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }

  var forceNextPop = false;

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key]; // Public interface

  function createHref(location) {
    return basename + createPath(location);
  }

  function push(path, state) {
    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action: action,
            location: location
          });
        }
      } else {
        process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : void 0;
        window.location.href = href;
      }
    });
  }

  function replace(path, state) {
    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action: action,
            location: location
          });
        }
      } else {
        process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : void 0;
        window.location.replace(href);
      }
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash$1
  },
  slash: {
    encodePath: addLeadingSlash$1,
    decodePath: addLeadingSlash$1
  }
};

function stripHash(url) {
  var hashIndex = url.indexOf('#');
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
}

function pushHashPath(path) {
  window.location.hash = path;
}

function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + '#' + path);
}

function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ? process.env.NODE_ENV !== "production" ? invariant(false, 'Hash history needs a DOM') : invariant(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = _props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  function getDOMLocation() {
    var path = decodePath(getHashPath());
    process.env.NODE_ENV !== "production" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : void 0;
    if (basename) path = stripBasename$1(path, basename);
    return createLocation(path);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  var forceNextPop = false;
  var ignorePath = null;

  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }

  function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  }

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  } // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  function createHref(location) {
    var baseTag = document.querySelector('base');
    var href = '';

    if (baseTag && baseTag.getAttribute('href')) {
      href = stripHash(window.location.href);
    }

    return href + '#' + encodePath(basename + createPath(location));
  }

  function push(path, state) {
    process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Hash history cannot push state; it is ignored') : void 0;
    var action = 'PUSH';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path);
        allPaths = nextPaths;
        setState({
          action: action,
          location: location
        });
      } else {
        process.env.NODE_ENV !== "production" ? warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : void 0;
        setState();
      }
    });
  }

  function replace(path, state) {
    process.env.NODE_ENV !== "production" ? warning(state === undefined, 'Hash history cannot replace state; it is ignored') : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    process.env.NODE_ENV !== "production" ? warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
/**
 * Creates a history object that stores locations in memory.
 */


function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      getUserConfirmation = _props.getUserConfirmation,
      _props$initialEntries = _props.initialEntries,
      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
      _props$initialIndex = _props.initialIndex,
      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
  }); // Public interface

  var createHref = createPath;

  function push(path, state) {
    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);

      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }

  function replace(path, state) {
    process.env.NODE_ENV !== "production" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
    var action = 'POP';
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    return transitionManager.setPrompt(prompt);
  }

  function listen(listener) {
    return transitionManager.appendListener(listener);
  }

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
  return history;
}

var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};

function getUniqueId() {
  var key = '__global_unique_id__';
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + getUniqueId() + '__';

  var Provider = /*#__PURE__*/function (_Component) {
    _inheritsLoose(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if (process.env.NODE_ENV !== 'production') {
            warning((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(React.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes__default["default"].object.isRequired, _Provider$childContex);

  var Consumer = /*#__PURE__*/function (_Component2) {
    _inheritsLoose(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(React.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes__default["default"].object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

var index = React__default["default"].createContext || createReactContext;

var pathToRegexp$1 = {exports: {}};

var isarray$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

var isarray = isarray$1;

/**
 * Expose `pathToRegexp`.
 */
pathToRegexp$1.exports = pathToRegexp;
pathToRegexp$1.exports.parse = parse$3;
pathToRegexp$1.exports.compile = compile;
pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse$3 (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse$3(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse$3(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

var reactIs$1 = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
	return reactIs_production_min;
}

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development.AsyncMode = AsyncMode;
	reactIs_development.ConcurrentMode = ConcurrentMode;
	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min();
	} else {
	  module.exports = requireReactIs_development();
	}
} (reactIs$1));

var reactIs = reactIs$1.exports;

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext = function createNamedContext(name) {
  var context = index();
  context.displayName = name;
  return context;
};

var historyContext = /*#__PURE__*/createNamedContext("Router-History");

var context$2 = /*#__PURE__*/createNamedContext("Router");

/**
 * The public API for putting history on context.
 */

var Router = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  function Router(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    }; // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.

    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        if (_this._isMounted) {
          _this.setState({
            location: location
          });
        } else {
          _this._pendingLocation = location;
        }
      });
    }

    return _this;
  }

  var _proto = Router.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;

    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };

  _proto.render = function render() {
    return /*#__PURE__*/React__default["default"].createElement(context$2.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /*#__PURE__*/React__default["default"].createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };

  return Router;
}(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  Router.propTypes = {
    children: PropTypes__default["default"].node,
    history: PropTypes__default["default"].object.isRequired,
    staticContext: PropTypes__default["default"].object
  };

  Router.prototype.componentDidUpdate = function (prevProps) {
    process.env.NODE_ENV !== "production" ? warning(prevProps.history === this.props.history, "You cannot change <Router history>") : void 0;
  };
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }

  var _proto = MemoryRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/React__default["default"].createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return MemoryRouter;
}(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  MemoryRouter.propTypes = {
    initialEntries: PropTypes__default["default"].array,
    initialIndex: PropTypes__default["default"].number,
    getUserConfirmation: PropTypes__default["default"].func,
    keyLength: PropTypes__default["default"].number,
    children: PropTypes__default["default"].node
  };

  MemoryRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.") : void 0;
  };
}

/*#__PURE__*/(function (_React$Component) {
  _inheritsLoose(Lifecycle, _React$Component);

  function Lifecycle() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
})(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  var messageType = PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].string]);
  ({
    when: PropTypes__default["default"].bool,
    message: messageType.isRequired
  });
}

if (process.env.NODE_ENV !== "production") {
  ({
    push: PropTypes__default["default"].bool,
    from: PropTypes__default["default"].string,
    to: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].object]).isRequired
  });
}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path]) return pathCache[path];
  var keys = [];
  var regexp = pathToRegexp$1.exports(path, keys, options);
  var result = {
    regexp: regexp,
    keys: keys
  };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */


function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }

  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === void 0 ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function (matched, path) {
    if (!path && path !== "") return null;
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);
    if (!match) return null;
    var url = match[0],
        values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path,
      // the path used to match
      url: path === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact: isExact,
      // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}

function isEmptyChildren(children) {
  return React__default["default"].Children.count(children) === 0;
}

function evalChildrenDev(children, props, path) {
  var value = children(props);
  process.env.NODE_ENV !== "production" ? warning(value !== undefined, "You returned `undefined` from the `children` function of " + ("<Route" + (path ? " path=\"" + path + "\"" : "") + ">, but you ") + "should have returned a React element or `null`") : void 0;
  return value || null;
}
/**
 * The public API for matching a single path and rendering.
 */


var Route = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Route, _React$Component);

  function Route() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Route.prototype;

  _proto.render = function render() {
    var _this = this;

    return /*#__PURE__*/React__default["default"].createElement(context$2.Consumer, null, function (context$1) {
      !context$1 ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Route> outside a <Router>") : invariant(false) : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;

      var props = _extends({}, context$1, {
        location: location,
        match: match
      });

      var _this$props = _this.props,
          children = _this$props.children,
          component = _this$props.component,
          render = _this$props.render; // Preact uses an empty array as children by
      // default, so use null if that's the case.

      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }

      return /*#__PURE__*/React__default["default"].createElement(context$2.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? process.env.NODE_ENV !== "production" ? evalChildrenDev(children, props, _this.props.path) : children(props) : children : component ? /*#__PURE__*/React__default["default"].createElement(component, props) : render ? render(props) : null : typeof children === "function" ? process.env.NODE_ENV !== "production" ? evalChildrenDev(children, props, _this.props.path) : children(props) : null);
    });
  };

  return Route;
}(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  Route.propTypes = {
    children: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].node]),
    component: function component(props, propName) {
      if (props[propName] && !reactIs$1.exports.isValidElementType(props[propName])) {
        return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
      }
    },
    exact: PropTypes__default["default"].bool,
    location: PropTypes__default["default"].object,
    path: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)]),
    render: PropTypes__default["default"].func,
    sensitive: PropTypes__default["default"].bool,
    strict: PropTypes__default["default"].bool
  };

  Route.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : void 0;
    process.env.NODE_ENV !== "production" ? warning(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : void 0;
    process.env.NODE_ENV !== "production" ? warning(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : void 0;
  };

  Route.prototype.componentDidUpdate = function (prevProps) {
    process.env.NODE_ENV !== "production" ? warning(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    process.env.NODE_ENV !== "production" ? warning(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}

function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;
  return _extends({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}

function stripBasename(basename, location) {
  if (!basename) return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}

function staticHandler(methodName) {
  return function () {
     process.env.NODE_ENV !== "production" ? invariant(false, "You cannot %s with <StaticRouter>") : invariant(false) ;
  };
}

function noop$1() {}
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


var StaticRouter = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(StaticRouter, _React$Component);

  function StaticRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.handlePush = function (location) {
      return _this.navigateTo(location, "PUSH");
    };

    _this.handleReplace = function (location) {
      return _this.navigateTo(location, "REPLACE");
    };

    _this.handleListen = function () {
      return noop$1;
    };

    _this.handleBlock = function () {
      return noop$1;
    };

    return _this;
  }

  var _proto = StaticRouter.prototype;

  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props,
        _this$props$basename = _this$props.basename,
        basename = _this$props$basename === void 0 ? "" : _this$props$basename,
        _this$props$context = _this$props.context,
        context = _this$props$context === void 0 ? {} : _this$props$context;
    context.action = action;
    context.location = addBasename(basename, createLocation(location));
    context.url = createURL(context.location);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        _this$props2$basename = _this$props2.basename,
        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
        _this$props2$context = _this$props2.context,
        context = _this$props2$context === void 0 ? {} : _this$props2$context,
        _this$props2$location = _this$props2.location,
        location = _this$props2$location === void 0 ? "/" : _this$props2$location,
        rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);

    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /*#__PURE__*/React__default["default"].createElement(Router, _extends({}, rest, {
      history: history,
      staticContext: context
    }));
  };

  return StaticRouter;
}(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  StaticRouter.propTypes = {
    basename: PropTypes__default["default"].string,
    context: PropTypes__default["default"].object,
    location: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].object])
  };

  StaticRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.") : void 0;
  };
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Switch, _React$Component);

  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Switch.prototype;

  _proto.render = function render() {
    var _this = this;

    return /*#__PURE__*/React__default["default"].createElement(context$2.Consumer, null, function (context) {
      !context ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Switch> outside a <Router>") : invariant(false) : void 0;
      var location = _this.props.location || context.location;
      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
      // here because toArray adds keys to all child elements and we do not want
      // to trigger an unmount/remount for two <Route>s that render the same
      // component at different URLs.

      React__default["default"].Children.forEach(_this.props.children, function (child) {
        if (match == null && /*#__PURE__*/React__default["default"].isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, _extends({}, child.props, {
            path: path
          })) : context.match;
        }
      });
      return match ? /*#__PURE__*/React__default["default"].cloneElement(element, {
        location: location,
        computedMatch: match
      }) : null;
    });
  };

  return Switch;
}(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  Switch.propTypes = {
    children: PropTypes__default["default"].node,
    location: PropTypes__default["default"].object
  };

  Switch.prototype.componentDidUpdate = function (prevProps) {
    process.env.NODE_ENV !== "production" ? warning(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
    process.env.NODE_ENV !== "production" ? warning(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
  };
}

/**
 * A public higher-order component to access the imperative API
 */

function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";

  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);

    return /*#__PURE__*/React__default["default"].createElement(context$2.Consumer, null, function (context) {
      !context ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <" + displayName + " /> outside a <Router>") : invariant(false) : void 0;
      return /*#__PURE__*/React__default["default"].createElement(Component, _extends({}, remainingProps, context, {
        ref: wrappedComponentRef
      }));
    });
  };

  C.displayName = displayName;
  C.WrappedComponent = Component;

  if (process.env.NODE_ENV !== "production") {
    C.propTypes = {
      wrappedComponentRef: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].func, PropTypes__default["default"].object])
    };
  }

  return hoistNonReactStatics_cjs(C, Component);
}

React__default["default"].useContext;

if (process.env.NODE_ENV !== "production") {
  if (typeof window !== "undefined") {
    var global$1 = window;
    var key = "__react_router_build__";
    var buildNames = {
      cjs: "CommonJS",
      esm: "ES modules",
      umd: "UMD"
    };

    if (global$1[key] && global$1[key] !== "esm") {
      var initialBuildName = buildNames[global$1[key]];
      var secondaryBuildName = buildNames["esm"]; // TODO: Add link to article that explains in detail how to avoid
      // loading 2 different builds.

      throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
    }

    global$1[key] = "esm";
  }
}

/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }

  var _proto = BrowserRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/React__default["default"].createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return BrowserRouter;
}(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  BrowserRouter.propTypes = {
    basename: PropTypes__default["default"].string,
    children: PropTypes__default["default"].node,
    forceRefresh: PropTypes__default["default"].bool,
    getUserConfirmation: PropTypes__default["default"].func,
    keyLength: PropTypes__default["default"].number
  };

  BrowserRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.") : void 0;
  };
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(HashRouter, _React$Component);

  function HashRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }

  var _proto = HashRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/React__default["default"].createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return HashRouter;
}(React__default["default"].Component);

if (process.env.NODE_ENV !== "production") {
  HashRouter.propTypes = {
    basename: PropTypes__default["default"].string,
    children: PropTypes__default["default"].node,
    getUserConfirmation: PropTypes__default["default"].func,
    hashType: PropTypes__default["default"].oneOf(["hashbang", "noslash", "slash"])
  };

  HashRouter.prototype.componentDidMount = function () {
    process.env.NODE_ENV !== "production" ? warning(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.") : void 0;
  };
}

var resolveToLocation = function resolveToLocation(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};

var forwardRefShim = function forwardRefShim(C) {
  return C;
};

var forwardRef = React__default["default"].forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

var LinkAnchor = forwardRef(function (_ref, forwardedRef) {
  var innerRef = _ref.innerRef,
      navigate = _ref.navigate,
      _onClick = _ref.onClick,
      rest = _objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);

  var target = rest.target;

  var props = _extends({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick) _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && ( // ignore everything but left clicks
      !target || target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();
          navigate();
        }
    }
  }); // React 15 compat


  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  /* eslint-disable-next-line jsx-a11y/anchor-has-content */


  return /*#__PURE__*/React__default["default"].createElement("a", props);
});

if (process.env.NODE_ENV !== "production") {
  LinkAnchor.displayName = "LinkAnchor";
}
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = forwardRef(function (_ref2, forwardedRef) {
  var _ref2$component = _ref2.component,
      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,
      replace = _ref2.replace,
      to = _ref2.to,
      innerRef = _ref2.innerRef,
      rest = _objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);

  return /*#__PURE__*/React__default["default"].createElement(context$2.Consumer, null, function (context) {
    !context ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <Link> outside a <Router>") : invariant(false) : void 0;
    var history = context.history;
    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);
    var href = location ? history.createHref(location) : "";

    var props = _extends({}, rest, {
      href: href,
      navigate: function navigate() {
        var location = resolveToLocation(to, context.location);
        var isDuplicateNavigation = createPath(context.location) === createPath(normalizeToLocation(location));
        var method = replace || isDuplicateNavigation ? history.replace : history.push;
        method(location);
      }
    }); // React 15 compat


    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return /*#__PURE__*/React__default["default"].createElement(component, props);
  });
});

if (process.env.NODE_ENV !== "production") {
  var toType = PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].object, PropTypes__default["default"].func]);
  var refType = PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].func, PropTypes__default["default"].shape({
    current: PropTypes__default["default"].any
  })]);
  Link.displayName = "Link";
  Link.propTypes = {
    innerRef: refType,
    onClick: PropTypes__default["default"].func,
    replace: PropTypes__default["default"].bool,
    target: PropTypes__default["default"].string,
    to: toType.isRequired
  };
}

var forwardRefShim$1 = function forwardRefShim(C) {
  return C;
};

var forwardRef$1 = React__default["default"].forwardRef;

if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}

function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }

  return classnames.filter(function (i) {
    return i;
  }).join(" ");
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


var NavLink = forwardRef$1(function (_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"],
      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,
      _ref$activeClassName = _ref.activeClassName,
      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,
      activeStyle = _ref.activeStyle,
      classNameProp = _ref.className,
      exact = _ref.exact,
      isActiveProp = _ref.isActive,
      locationProp = _ref.location,
      sensitive = _ref.sensitive,
      strict = _ref.strict,
      styleProp = _ref.style,
      to = _ref.to,
      innerRef = _ref.innerRef,
      rest = _objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);

  return /*#__PURE__*/React__default["default"].createElement(context$2.Consumer, null, function (context) {
    !context ? process.env.NODE_ENV !== "production" ? invariant(false, "You should not use <NavLink> outside a <Router>") : invariant(false) : void 0;
    var currentLocation = locationProp || context.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202

    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact: exact,
      sensitive: sensitive,
      strict: strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;
    var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;

    if (isActive) {
      className = joinClassnames(className, activeClassName);
      style = _extends({}, style, activeStyle);
    }

    var props = _extends({
      "aria-current": isActive && ariaCurrent || null,
      className: className,
      style: style,
      to: toLocation
    }, rest); // React 15 compat


    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return /*#__PURE__*/React__default["default"].createElement(Link, props);
  });
});

if (process.env.NODE_ENV !== "production") {
  NavLink.displayName = "NavLink";
  var ariaCurrentType = PropTypes__default["default"].oneOf(["page", "step", "location", "date", "time", "true", "false"]);
  NavLink.propTypes = _extends({}, Link.propTypes, {
    "aria-current": ariaCurrentType,
    activeClassName: PropTypes__default["default"].string,
    activeStyle: PropTypes__default["default"].object,
    className: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].func]),
    exact: PropTypes__default["default"].bool,
    isActive: PropTypes__default["default"].func,
    location: PropTypes__default["default"].object,
    sensitive: PropTypes__default["default"].bool,
    strict: PropTypes__default["default"].bool,
    style: PropTypes__default["default"].oneOfType([PropTypes__default["default"].object, PropTypes__default["default"].func])
  });
}

const getAppropriateTriggersForRole = role => {
  switch (role) {
    case "link":
      return {
        triggerOnEnter: true,
        triggerOnSpace: false
      };

    case "checkbox":
    case "radio":
    case "listbox":
    case "option":
      return {
        triggerOnEnter: false,
        triggerOnSpace: true
      };

    case "button":
    case "menuitem":
    case "menu":
    default:
      return {
        triggerOnEnter: true,
        triggerOnSpace: true
      };
  }
};

const disabledHandlers = {
  onClick: () => void 0,
  onMouseEnter: () => void 0,
  onMouseLeave: () => void 0,
  onMouseDown: () => void 0,
  onMouseUp: () => void 0,
  onDragStart: () => void 0,
  onTouchStart: () => void 0,
  onTouchEnd: () => void 0,
  onTouchCancel: () => void 0,
  onKeyDown: () => void 0,
  onKeyUp: () => void 0,
  tabIndex: 0
};
const keyCodes = {
  enter: 13,
  space: 32
};
const startState = {
  hovered: false,
  focused: false,
  pressed: false,
  waiting: false
};
class ClickableBehavior extends React__namespace.Component {
  static getDerivedStateFromProps(props, state) {
    if (props.disabled) {
      return _extends({}, startState, {
        focused: state.focused
      });
    } else {
      return null;
    }
  }

  constructor(props) {
    super(props);

    this.handleClick = e => {
      const {
        onClick = undefined,
        beforeNav = undefined,
        safeWithNav = undefined
      } = this.props;

      if (this.enterClick) {
        return;
      }

      if (onClick || beforeNav || safeWithNav) {
        this.waitingForClick = false;
      }

      this.runCallbackAndMaybeNavigate(e);
    };

    this.handleMouseEnter = e => {
      if (e.buttons === 1) {
        this.dragging = true;
        this.setState({
          pressed: true
        });
      } else if (!this.waitingForClick) {
        this.setState({
          hovered: true
        });
      }
    };

    this.handleMouseLeave = () => {
      if (!this.waitingForClick) {
        this.dragging = false;
        this.setState({
          hovered: false,
          pressed: false,
          focused: false
        });
      }
    };

    this.handleMouseDown = () => {
      this.setState({
        pressed: true
      });
    };

    this.handleMouseUp = e => {
      if (this.dragging) {
        this.dragging = false;
        this.handleClick(e);
      }

      this.setState({
        pressed: false,
        focused: false
      });
    };

    this.handleDragStart = e => {
      this.dragging = true;
      e.preventDefault();
    };

    this.handleTouchStart = () => {
      this.setState({
        pressed: true
      });
    };

    this.handleTouchEnd = () => {
      this.setState({
        pressed: false
      });
      this.waitingForClick = true;
    };

    this.handleTouchCancel = () => {
      this.setState({
        pressed: false
      });
      this.waitingForClick = true;
    };

    this.handleKeyDown = e => {
      const {
        onKeyDown,
        role
      } = this.props;

      if (onKeyDown) {
        onKeyDown(e);
      }

      const keyCode = e.which || e.keyCode;
      const {
        triggerOnEnter,
        triggerOnSpace
      } = getAppropriateTriggersForRole(role);

      if (triggerOnEnter && keyCode === keyCodes.enter || triggerOnSpace && keyCode === keyCodes.space) {
        e.preventDefault();
        this.setState({
          pressed: true
        });
      } else if (!triggerOnEnter && keyCode === keyCodes.enter) {
        this.enterClick = true;
      }
    };

    this.handleKeyUp = e => {
      const {
        onKeyUp,
        role
      } = this.props;

      if (onKeyUp) {
        onKeyUp(e);
      }

      const keyCode = e.which || e.keyCode;
      const {
        triggerOnEnter,
        triggerOnSpace
      } = getAppropriateTriggersForRole(role);

      if (triggerOnEnter && keyCode === keyCodes.enter || triggerOnSpace && keyCode === keyCodes.space) {
        this.setState({
          pressed: false,
          focused: true
        });
        this.runCallbackAndMaybeNavigate(e);
      } else if (!triggerOnEnter && keyCode === keyCodes.enter) {
        this.enterClick = false;
      }
    };

    this.handleFocus = e => {
      this.setState({
        focused: true
      });
    };

    this.handleBlur = e => {
      this.setState({
        focused: false,
        pressed: false
      });
    };

    this.state = startState;
    this.waitingForClick = false;
    this.enterClick = false;
    this.dragging = false;
  }

  navigateOrReset(shouldNavigate) {
    if (shouldNavigate) {
      const {
        history,
        href,
        skipClientNav,
        target = undefined
      } = this.props;

      if (href) {
        if (target === "_blank") {
          window.open(href, "_blank");
          this.setState({
            waiting: false
          });
        } else if (history && !skipClientNav) {
          history.push(href);
          this.setState({
            waiting: false
          });
        } else {
          window.location.assign(href);
        }
      }
    } else {
      this.setState({
        waiting: false
      });
    }
  }

  handleSafeWithNav(safeWithNav, shouldNavigate) {
    const {
      skipClientNav,
      history
    } = this.props;

    if (history && !skipClientNav || this.props.target === "_blank") {
      safeWithNav();
      this.navigateOrReset(shouldNavigate);
      return Promise.resolve();
    } else {
      if (!this.state.waiting) {
        this.setState({
          waiting: true
        });
      }

      return safeWithNav().then(() => {
        if (!this.state.waiting) {
          this.setState({
            waiting: true
          });
        }

        return;
      }).catch(error => {}).finally(() => {
        this.navigateOrReset(shouldNavigate);
      });
    }
  }

  runCallbackAndMaybeNavigate(e) {
    const {
      onClick = undefined,
      beforeNav = undefined,
      safeWithNav = undefined,
      href,
      type
    } = this.props;
    let shouldNavigate = true;
    let canSubmit = true;

    if (onClick) {
      onClick(e);
    }

    if (e.defaultPrevented) {
      shouldNavigate = false;
      canSubmit = false;
    }

    e.preventDefault();

    if (!href && type === "submit" && canSubmit) {
      let target = e.currentTarget;

      while (target) {
        if (target instanceof window.HTMLFormElement) {
          const event = new window.Event("submit", {
            cancelable: true
          });
          target.dispatchEvent(event);
          break;
        }

        target = target.parentElement;
      }
    }

    if (beforeNav) {
      this.setState({
        waiting: true
      });
      beforeNav().then(() => {
        if (safeWithNav) {
          return this.handleSafeWithNav(safeWithNav, shouldNavigate);
        } else {
          return this.navigateOrReset(shouldNavigate);
        }
      }).catch(() => {});
    } else if (safeWithNav) {
      return this.handleSafeWithNav(safeWithNav, shouldNavigate);
    } else {
      this.navigateOrReset(shouldNavigate);
    }
  }

  render() {
    const childrenProps = this.props.disabled ? _extends({}, disabledHandlers, {
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    }) : {
      onClick: this.handleClick,
      onMouseEnter: this.handleMouseEnter,
      onMouseLeave: this.handleMouseLeave,
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp,
      onDragStart: this.handleDragStart,
      onTouchStart: this.handleTouchStart,
      onTouchEnd: this.handleTouchEnd,
      onTouchCancel: this.handleTouchCancel,
      onKeyDown: this.handleKeyDown,
      onKeyUp: this.handleKeyUp,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      tabIndex: 0
    };
    childrenProps.rel = this.props.rel || (this.props.target === "_blank" ? "noopener noreferrer" : undefined);
    const {
      children
    } = this.props;
    return children && children(this.state, childrenProps);
  }

}
ClickableBehavior.defaultProps = {
  disabled: false
};

const isClientSideUrl = href => {
  if (typeof href !== "string") {
    return false;
  }

  return !/^(https?:)?\/\//i.test(href) && !/^([^#]*#[\w-]*|[\w\-.]+:)/.test(href);
};

const ClickableBehaviorWithRouter = withRouter(ClickableBehavior);
function getClickableBehavior(href, skipClientNav, router) {
  if (router && skipClientNav !== true && href && isClientSideUrl(href)) {
    return ClickableBehaviorWithRouter;
  }

  return ClickableBehavior;
}

const _excluded = ["href", "onClick", "skipClientNav", "beforeNav", "safeWithNav", "style", "target", "testId", "onKeyDown", "onKeyUp", "hideDefaultFocusRing", "light", "disabled"];
const StyledAnchor = wonderBlocksCore.addStyle("a");
const StyledButton = wonderBlocksCore.addStyle("button");
const StyledLink = wonderBlocksCore.addStyle(Link);
class Clickable extends React__namespace.Component {
  constructor(...args) {
    super(...args);

    this.getCorrectTag = (clickableState, router, commonProps) => {
      const activeHref = this.props.href && !this.props.disabled;
      const useClient = router && !this.props.skipClientNav && isClientSideUrl(this.props.href || "");

      if (activeHref && useClient && this.props.href) {
        return React__namespace.createElement(StyledLink, _extends({}, commonProps, {
          to: this.props.href,
          role: this.props.role,
          target: this.props.target || undefined,
          "aria-disabled": this.props.disabled ? "true" : undefined
        }), this.props.children(clickableState));
      } else if (activeHref && !useClient) {
        return React__namespace.createElement(StyledAnchor, _extends({}, commonProps, {
          href: this.props.href,
          role: this.props.role,
          target: this.props.target || undefined,
          "aria-disabled": this.props.disabled ? "true" : undefined
        }), this.props.children(clickableState));
      } else {
        return React__namespace.createElement(StyledButton, _extends({}, commonProps, {
          type: "button",
          "aria-disabled": this.props.disabled
        }), this.props.children(clickableState));
      }
    };
  }

  renderClickableBehavior(router) {
    const _this$props = this.props,
          {
      href,
      onClick,
      skipClientNav,
      beforeNav = undefined,
      safeWithNav = undefined,
      style,
      target = undefined,
      testId,
      onKeyDown,
      onKeyUp,
      hideDefaultFocusRing,
      light,
      disabled
    } = _this$props,
          restProps = _objectWithoutPropertiesLoose(_this$props, _excluded);

    const ClickableBehavior = getClickableBehavior(href, skipClientNav, router);

    const getStyle = state => [styles$A.reset, styles$A.link, !hideDefaultFocusRing && state.focused && (light ? styles$A.focusedLight : styles$A.focused), style];

    if (beforeNav) {
      return React__namespace.createElement(ClickableBehavior, {
        href: href,
        onClick: onClick,
        beforeNav: beforeNav,
        safeWithNav: safeWithNav,
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp,
        disabled: disabled
      }, (state, childrenProps) => this.getCorrectTag(state, router, _extends({}, restProps, {
        "data-test-id": testId,
        style: getStyle(state)
      }, childrenProps)));
    } else {
      return React__namespace.createElement(ClickableBehavior, {
        href: href,
        onClick: onClick,
        safeWithNav: safeWithNav,
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp,
        target: target,
        disabled: disabled
      }, (state, childrenProps) => this.getCorrectTag(state, router, _extends({}, restProps, {
        "data-test-id": testId,
        style: getStyle(state)
      }, childrenProps)));
    }
  }

  render() {
    return React__namespace.createElement(context$2.Consumer, null, router => this.renderClickableBehavior(router));
  }

}
Clickable.defaultProps = {
  light: false,
  disabled: false,
  "aria-label": ""
};
const styles$A = aphrodite.StyleSheet.create({
  reset: {
    border: "none",
    margin: 0,
    padding: 0,
    width: "auto",
    overflow: "visible",
    background: "transparent",
    textDecoration: "none",
    color: "inherit",
    font: "inherit",
    boxSizing: "border-box",
    touchAction: "manipulation",
    userSelect: "none",
    outline: "none",
    lineHeight: "normal",
    WebkitFontSmoothing: "inherit",
    MozOsxFontSmoothing: "inherit"
  },
  link: {
    cursor: "pointer"
  },
  focused: {
    outline: `solid 2px ${Color__default["default"].blue}`
  },
  focusedLight: {
    outline: `solid 2px ${Color__default["default"].white}`
  }
});

// WARNING: This determines the *viewport* width and height, so a change here
//          requires scaling the values of every SVG path passed in as a string
//          without corresponding `width` and `height` values.
const BASE_ICON_SIZE = 10; // If you pass in an object you need to specify an SVG path to
// render along with the width and height of the path (to ensure
// that it gets scaled correctly).

class Icon extends React__namespace.Component {
  render() {
    const {
      color,
      pathClassName,
      className,
      title,
      style,
      alt
    } = this.props;
    let {
      icon,
      size
    } = this.props;
    let units = ""; // If the raw path was passed in, wrap it in the format that we expect.

    if (typeof icon === "string") {
      icon = {
        path: icon,
        width: BASE_ICON_SIZE,
        height: BASE_ICON_SIZE
      };
    } // `size` defaults to 1em to mirror the behavior of Font Awesome.


    if (typeof size !== "number") {
      size = 1;
      units = "em";
    }

    const height = size;
    const width = height / icon.height * icon.width; // NOTE: We assume that the viewBox is cropped and aligned to (0, 0),
    //       but icons can be defined differently. At some point we might
    //       want to add these attributes to icon-paths.js, but for now
    //       this is a fairly safe assumption.

    const xMin = 0;
    const yMin = 0;
    const focusable = !!this.props.focusable;
    return /*#__PURE__*/React__namespace.createElement("svg", {
      role: "img",
      alt: alt,
      "aria-label": title,
      "aria-hidden": title ? null : true,
      className: className,
      style: style,
      focusable: focusable.toString(),
      width: width + units,
      height: height + units,
      viewBox: "".concat(xMin, " ").concat(yMin, " ").concat(icon.width, " ").concat(icon.height)
    }, !!title && /*#__PURE__*/React__namespace.createElement("title", null, title), /*#__PURE__*/React__namespace.createElement("path", {
      className: pathClassName,
      fill: color,
      d: icon.path
    }));
  }

}

_defineProperty(Icon, "defaultProps", {
  color: "currentColor"
});

class FocusRing extends React__namespace.Component {
  render() {
    const borderColor = this.props.visible ? this.props.color : "transparent";
    const style = {
      borderColor: borderColor
    };
    return /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$z.ring),
      style: style
    }, this.props.children);
  }

}

_defineProperty(FocusRing, "defaultProps", {
  visible: true,
  color: kaGreen$1
});

const styles$z = aphrodite.StyleSheet.create({
  ring: {
    margin: "auto",
    display: "inline-block",
    borderRadius: "50%",
    borderWidth: 2,
    padding: 2,
    borderStyle: "solid"
  }
});

/**
 * Given a choice's position in the radio widget, return the corresponding
 * "choice letter". (For example, in English, `getChoiceLetter(0)` is "A",
 * `getChoiceLetter(1)` is "B", etc.)
 */

function getChoiceLetter(pos) {
  /* I18N: This is a list of single-character labels that will appear in
   * front of multiple-choice options. For instance, a multiple-choice
   * question with three options would display
   *  (A) first option
   *  (B) second option
   *  (C) third option
   * There must be spaces between each of the different characters. The
   * characters will show up next to options in the order that they are
   * listed here. Most multiple choice questions have 5 or fewer options.
   */
  const lettersString = i18n__namespace._("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");

  const letters = lettersString.split(" ");

  if (pos < letters.length) {
    // If the position we need is listed in the localized string, use that.
    return letters[pos];
  } // If we're out of letters, give up and return a space.


  return " ";
}

const SAT_ICON_SIZE = 25;

class SATChoiceIcon extends React__namespace.Component {
  // TODO(amy): figure out a better scheme for specifying these
  // styles that isn't such a pain to grok. See some neat ideas
  // from MDR in https://phabricator.khanacademy.org/D35249.
  constructStyles(reviewMode, correct, checked) {
    let backgroundColor;
    let borderColor = satBlue;
    let color = satBlue;

    if (reviewMode) {
      if (correct) {
        borderColor = satCorrectColor;
        color = checked ? white$1 : satCorrectColor;
        backgroundColor = checked ? satCorrectColor : white$1;
      } else if (checked) {
        borderColor = satIncorrectColor;
        color = white$1;
        backgroundColor = satIncorrectColor;
      }
    } else if (checked) {
      color = white$1;
      backgroundColor = satBlue;
    }

    return {
      color,
      backgroundColor,
      borderColor
    };
  }

  render() {
    const {
      letter,
      a11yText,
      reviewMode,
      checked,
      correct,
      crossedOut
    } = this.props;
    const {
      color,
      backgroundColor,
      borderColor
    } = this.constructStyles(reviewMode, correct, checked);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$y.iconWrapper)
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$y.satCircle),
      style: {
        backgroundColor,
        borderColor
      }
    }), /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        color
      },
      className: aphrodite.css(styles$y.letter)
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: "perseus-sr-only"
    }, a11yText), /*#__PURE__*/React__namespace.createElement("span", {
      "aria-hidden": "true"
    }, letter)), crossedOut && /*#__PURE__*/React__namespace.createElement(CrossOutLine, {
      color: borderColor,
      sat: true
    }));
  }

}

const LIBRARY_ICON_SIZE = 24;

class LibraryChoiceIcon extends React__namespace.Component {
  getChoiceInner() {
    const {
      letter,
      showCorrectness,
      correct
    } = this.props;

    if (!showCorrectness) {
      return letter;
    }

    if (correct) {
      return /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends$1({}, iconCheck, {
        style: {
          position: "relative",
          top: -1
        }
      }));
    }

    return /*#__PURE__*/React__namespace.createElement(InlineIcon, iconMinus);
  } // Handle dynamic styling of the multiple choice icon. Most
  // MC icon styles are constant, but we do allow the caller
  // to specify the selected color, and thus must control styles
  // related to the selected state dynamically.


  getDynamicStyles() {
    const {
      checked,
      showCorrectness,
      pressed,
      primaryProductColor,
      correct,
      transparentBackground
    } = this.props;

    if (!showCorrectness && pressed) {
      return {
        borderColor: primaryProductColor,
        color: primaryProductColor,
        backgroundColor: transparentBackground ? "transparent" : white$1
      };
    }

    if (checked) {
      // Note: kaGreen is not only the default product color,
      // but also the "correctness" color
      const bg = showCorrectness && correct ? Color__default["default"].green : primaryProductColor;
      return {
        color: white$1,
        backgroundColor: bg,
        borderColor: bg
      };
    }

    return {
      borderColor: Color__default["default"].offBlack64,
      color: Color__default["default"].offBlack64
    };
  }

  render() {
    const {
      a11yText,
      checked,
      crossedOut,
      showCorrectness,
      correct,
      focused,
      primaryProductColor,
      previouslyAnswered
    } = this.props;
    const dynamicStyles = this.getDynamicStyles();
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$y.iconWrapper)
    }, /*#__PURE__*/React__namespace.createElement(FocusRing, {
      color: primaryProductColor,
      visible: focused
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: dynamicStyles,
      className: aphrodite.css(styles$y.libraryCircle, showCorrectness && correct && styles$y.libraryCircleCorrect, showCorrectness && !correct && styles$y.libraryCircleIncorrect, showCorrectness && !correct && (checked || previouslyAnswered) && styles$y.libraryCircleIncorrectAnswered) // used in BaseRadio to check if we actually clicked on the
      // radio icon
      ,
      "data-is-radio-icon": true
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-sr-only"
    }, a11yText), /*#__PURE__*/React__namespace.createElement("div", {
      "aria-hidden": true
    }, this.getChoiceInner()))), crossedOut && /*#__PURE__*/React__namespace.createElement(CrossOutLine, {
      color: dynamicStyles.borderColor
    }));
  }

} // The "cross-out line" SVG is a bit bigger than the library icon, to provide
// extra space for the cute rounded line cap.


const CROSS_OUT_LINE_PADDING = 2;
const CROSS_OUT_LINE_SIZE = LIBRARY_ICON_SIZE + CROSS_OUT_LINE_PADDING * 2;
const SAT_CROSS_OUT_LINE_SIZE = SAT_ICON_SIZE + CROSS_OUT_LINE_PADDING * 2;
/**
 * The "cross-out line" that appears over the icon when the choice has been
 * `crossedOut`.
 */

function CrossOutLine(props) {
  const crossOutLineSize = props.sat ? SAT_CROSS_OUT_LINE_SIZE : CROSS_OUT_LINE_SIZE;
  return /*#__PURE__*/React__namespace.createElement("svg", {
    width: crossOutLineSize,
    height: crossOutLineSize,
    viewBox: "0 0 ".concat(crossOutLineSize, " ").concat(crossOutLineSize),
    className: aphrodite.css(styles$y.crossOutLine)
  }, /*#__PURE__*/React__namespace.createElement("line", {
    // The line stretches from the bottom-left to top-right.
    // We don't quite go to the _very_ corner, because the cute
    // rounded line cap needs to bleed into our padding.
    x1: CROSS_OUT_LINE_PADDING,
    x2: crossOutLineSize - CROSS_OUT_LINE_PADDING,
    y1: crossOutLineSize - CROSS_OUT_LINE_PADDING,
    y2: CROSS_OUT_LINE_PADDING,
    stroke: props.color,
    strokeWidth: "2",
    strokeLinecap: "round"
  }));
}

class ChoiceIcon extends React__namespace.Component {
  a11yText(letter) {
    const {
      checked,
      correct,
      crossedOut,
      showCorrectness
    } = this.props; // There are two pieces of metadata we want to add to each a11yText:
    // whether the answer was checked/crossed-out/neither, and whether the
    // answer is correct/incorrect/not-yet-revealed.
    //
    // Translation is tricky for cross-product situations like this, so
    // we've just enumerated all 9 possibilities as separate strings.

    if (showCorrectness && correct) {
      if (checked) {
        return i18n__namespace._("(Choice %(letter)s, Checked, Correct)", {
          letter
        });
      }

      if (crossedOut) {
        return i18n__namespace._("(Choice %(letter)s, Crossed out, Correct)", {
          letter
        });
      }

      return i18n__namespace._("(Choice %(letter)s, Correct)", {
        letter
      });
    }

    if (showCorrectness && !correct) {
      if (checked) {
        return i18n__namespace._("(Choice %(letter)s, Checked, Incorrect)", {
          letter
        });
      }

      if (crossedOut) {
        return i18n__namespace._("(Choice %(letter)s, Crossed out, Incorrect)", {
          letter
        });
      }

      return i18n__namespace._("(Choice %(letter)s, Incorrect)", {
        letter
      });
    }

    if (checked) {
      return i18n__namespace._("(Choice %(letter)s, Checked)", {
        letter
      });
    }

    if (crossedOut) {
      return i18n__namespace._("(Choice %(letter)s, Crossed out)", {
        letter
      });
    }

    return i18n__namespace._("(Choice %(letter)s)", {
      letter
    });
  }

  render() {
    const {
      pos,
      reviewMode,
      checked,
      crossedOut,
      correct,
      product,
      showCorrectness,
      pressed,
      focused,
      primaryProductColor,
      previouslyAnswered,
      transparentBackground
    } = this.props;
    const letter = getChoiceLetter(pos);

    if (product === "sat") {
      return /*#__PURE__*/React__namespace.createElement(SATChoiceIcon, {
        letter: letter,
        a11yText: this.a11yText(letter),
        reviewMode: reviewMode,
        checked: checked,
        correct: correct,
        crossedOut: crossedOut
      });
    }

    return /*#__PURE__*/React__namespace.createElement(LibraryChoiceIcon, {
      letter: letter,
      a11yText: this.a11yText(letter),
      reviewMode: reviewMode,
      checked: checked,
      crossedOut: crossedOut,
      pressed: pressed,
      focused: focused,
      correct: correct,
      showCorrectness: showCorrectness,
      primaryProductColor: primaryProductColor,
      previouslyAnswered: previouslyAnswered,
      transparentBackground: transparentBackground
    });
  }

}

_defineProperty(ChoiceIcon, "defaultProps", {
  primaryProductColor: Color__default["default"].blue
});

const styles$y = aphrodite.StyleSheet.create({
  satCircle: {
    display: "block",
    borderRadius: SAT_ICON_SIZE,
    borderStyle: "solid",
    borderWidth: 2,
    content: "''",
    height: SAT_ICON_SIZE,
    width: SAT_ICON_SIZE,
    top: 1,
    left: 1
  },
  iconWrapper: {
    display: "inline-block",
    position: "relative"
  },
  crossOutLine: {
    // Center the icon within the container.
    position: "absolute",
    top: "calc(50% - ".concat(CROSS_OUT_LINE_SIZE / 2, "px)"),
    left: "calc(50% - ".concat(CROSS_OUT_LINE_SIZE / 2, "px)")
  },
  libraryCircle: {
    // Make the circle
    width: LIBRARY_ICON_SIZE,
    height: LIBRARY_ICON_SIZE,
    boxSizing: "border-box",
    borderRadius: LIBRARY_ICON_SIZE,
    borderStyle: "solid",
    borderWidth: 2,
    // The default icons have letters in them. Style those letters.
    fontFamily: baseFontFamily$1,
    // NOTE(emily): We explicitly set the font weight instead of using the
    // "bold font family" so that characters which fall back to the default
    // font get bolded too.
    fontWeight: "bold",
    fontSize: 12,
    // Center the contents of the icon.
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    // HACK(emily): I don't know why adding this line height makes the text
    // appear centered better than any other value, but it does. In
    // particular, at large zoom levels this line height does almost
    // nothing, but at the default size this shifts the letter down one
    // pixel so it is much better centered.
    lineHeight: "1px"
  },
  libraryCircleCorrect: {
    fontSize: LIBRARY_ICON_SIZE
  },
  libraryCircleIncorrect: {
    fontSize: LIBRARY_ICON_SIZE,
    borderColor: gray68,
    color: gray68
  },
  libraryCircleIncorrectAnswered: {
    backgroundColor: Color__default["default"].red,
    borderColor: Color__default["default"].red,
    color: Color__default["default"].white
  },
  letter: {
    // These properties make sure that this element has the exact
    // same size as `circle` so that we can center things
    // inside of it.
    border: "2px solid transparent",
    width: SAT_ICON_SIZE,
    height: SAT_ICON_SIZE,
    position: "absolute",
    top: 1,
    // Center contained items.
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    fontFamily: boldFontFamily,
    fontSize: 13
  }
});

/**
 * Renders text indicating whether the choice was correct or
 * not and whether the choice was selected or not.
 * This information is redundant with that provided in the
 * ChoiceIcon visualizations but is meant to make the distinctions
 * between the states more immediately clear to users.
 */

class OptionStatus extends React__namespace.Component {
  _renderText() {
    const {
      checked,
      correct,
      crossedOut
    } = this.props;

    if (correct) {
      // For correct answers, we surface checked _or_ crossedOut state,
      // because any interaction with the correct answer is noteworthy!
      if (checked) {
        return i18n__namespace._("Correct (selected)");
      }

      if (crossedOut) {
        return i18n__namespace._("Correct (but you crossed it out)");
      }

      return i18n__namespace._("Correct");
    } // But, for incorrect answers, we only surface checked state,
    // because crossing out an incorrect answer is not noteworthy.


    if (checked) {
      return i18n__namespace._("Incorrect (selected)");
    }

    return i18n__namespace._("Incorrect");
  }

  render() {
    const {
      checked,
      correct,
      previouslyAnswered
    } = this.props;
    let textStyle;

    if (correct) {
      textStyle = styles$x.correct;
    } else {
      if (checked || previouslyAnswered) {
        textStyle = styles$x.incorrectAnswered;
      } else {
        textStyle = styles$x.incorrect;
      }
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$x.text, textStyle)
    }, this._renderText());
  }

}

const styles$x = aphrodite.StyleSheet.create({
  text: {
    alignItems: "center",
    display: "flex",
    fontSize: 12,
    height: 32,
    textTransform: "uppercase"
  },
  correct: {
    color: Color__default["default"].green
  },
  incorrectAnswered: {
    color: Color__default["default"].red
  },
  incorrect: {
    color: Color__default["default"].offBlack64
  }
});

const intermediateCheckboxPadding = "16px 16px";
const intermediateCheckboxPaddingPhone = "12px 16px";
const ellipsisHorizontalIcon = {
  path: "M27.218 6.82l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836zm36.27 0l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836zm36.27 0l0 13.578q0 2.852-1.984 4.836t-4.836 1.984l-13.578 0q-2.852 0-4.836-1.984t-1.984-4.836l0-13.578q0-2.852 1.984-4.836t4.836-1.984l13.578 0q2.852 0 4.836 1.984t1.984 4.836z",
  width: 100,
  height: 27.284
};

class Choice extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "justFinishedTouch", void 0);

    _defineProperty(this, "justFinishedTimeoutID", void 0);

    _defineProperty(this, "_input", void 0);

    _defineProperty(this, "state", {
      isInputFocused: false,
      isInputActive: false
    });

    _defineProperty(this, "inputRef", ref => {
      this._input = ref;
    });

    _defineProperty(this, "renderOptionStatus", () => {
      const {
        correct,
        checked,
        crossedOut,
        reviewMode,
        previouslyAnswered
      } = this.props; // Option status is exclued for SAT

      if (this.props.apiOptions.satStyling) {
        return null;
      } // Option status is shown only in review mode, or for incorrectly
      // answered items.


      if (!reviewMode && !previouslyAnswered) {
        return null;
      }

      return /*#__PURE__*/React__namespace.createElement(OptionStatus, {
        checked: checked,
        correct: correct,
        crossedOut: crossedOut,
        previouslyAnswered: previouslyAnswered
      });
    });

    _defineProperty(this, "renderChoiceIcon", _ref => {
      let {
        isFocused,
        isPressed
      } = _ref;
      const {
        radioStyleVersion,
        primaryProductColor
      } = this.props.apiOptions.styling;
      const finalStyles = typeof radioStyleVersion === "undefined" ? false : radioStyleVersion === "final";

      if (!finalStyles && !this.props.apiOptions.satStyling) {
        return null;
      }

      return /*#__PURE__*/React__namespace.createElement(ChoiceIcon, {
        pos: this.props.pos,
        correct: this.props.correct,
        crossedOut: this.props.crossedOut,
        pressed: isPressed,
        focused: isFocused,
        checked: this.props.checked,
        showCorrectness: this.props.showCorrectness,
        reviewMode: this.props.reviewMode,
        product: this.props.apiOptions.satStyling ? "sat" : "library",
        primaryProductColor: primaryProductColor,
        previouslyAnswered: this.props.previouslyAnswered
      });
    });

    _defineProperty(this, "_sendChange", newValues => {
      var _newValues$checked, _newValues$crossedOut;

      const checked = (_newValues$checked = newValues.checked) !== null && _newValues$checked !== void 0 ? _newValues$checked : this.props.checked;
      const crossedOut = (_newValues$crossedOut = newValues.crossedOut) !== null && _newValues$crossedOut !== void 0 ? _newValues$crossedOut : this.props.crossedOut;
      this.props.onChange({
        checked,
        crossedOut
      });
    });

    _defineProperty(this, "focusInput", () => {
      var _this$_input;

      (_this$_input = this._input) === null || _this$_input === void 0 ? void 0 : _this$_input.focus();
    });
  }

  UNSAFE_componentWillUpdate(nextProps) {
    if (this.state.isInputFocused && nextProps.disabled) {
      this.setState({
        isInputFocused: false
      });
    }
  }

  render() {
    const sat = this.props.apiOptions.satStyling;
    const {
      reviewMode,
      correct,
      checked
    } = this.props; // HACK: while most of the styling for rendering SAT items is handled
    // via aphrodite, we also need to assign normal CSS classnames here to
    // special-case the coloring of MathJax formulas (see .MathJax .math in
    // stylesheets/task-package/tasks.less)

    const satCorrectChoice = sat && reviewMode && correct;
    const satIncorrectChecked = sat && reviewMode && !correct && checked;
    const descriptionClassName = classNames__default["default"]("description", satCorrectChoice && "sat-correct", satIncorrectChecked && "sat-incorrect", aphrodite.css(!sat && styles$w.description, sat && styles$w.satDescription, satCorrectChoice && styles$w.satDescriptionCorrect, satCorrectChoice && checked && styles$w.satDescriptionCorrectChecked, satIncorrectChecked && styles$w.satDescriptionIncorrectChecked));
    const rationaleClassName = classNames__default["default"]("perseus-radio-rationale-content", aphrodite.css(styles$w.rationale, !sat && styles$w.nonSatRationale, sat && styles$w.satReviewRationale)); // We want to show the choices as dimmed out when the choices are
    // disabled. However, we don't want to do this in the SAT product and
    // we also don't want to do this when we're in review mode in the
    // content library.

    const showDimmed = !sat && !reviewMode && this.props.apiOptions.readOnly || this.props.crossedOut;
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        dispay: "flex",
        flexDirection: "column"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: "flex",
        flexDirection: "row",
        width: "100%",
        opacity: showDimmed ? 0.5 : 1.0
      }
    }, /*#__PURE__*/React__namespace.createElement(Clickable, {
      onClick: () => {
        // If we're checking a crossed-out option, let's
        // also uncross it.
        this._sendChange({
          checked: true,
          crossedOut: false
        });
      },
      className: descriptionClassName,
      disabled: this.props.disabled || this.props.apiOptions.staticRender || this.props.apiOptions.readOnly,
      "aria-label": "Select Choice ".concat(getChoiceLetter(this.props.pos)),
      "aria-checked": this.props.checked,
      role: "checkbox",
      style: {
        flex: 1
      }
    }, _ref2 => {
      let {
        hovered,
        focused,
        pressed
      } = _ref2;
      return /*#__PURE__*/React__namespace.createElement("div", {
        style: {
          display: "flex",
          flexDirection: "row",
          justifyContent: "center",
          alignContent: "center",
          paddingTop: Spacing__default["default"].xSmall_8,
          paddingBottom: Spacing__default["default"].xSmall_8
        }
      }, /*#__PURE__*/React__namespace.createElement("span", null, this.renderChoiceIcon({
        isFocused: focused,
        isPressed: pressed
      })), /*#__PURE__*/React__namespace.createElement("span", {
        style: {
          paddingLeft: Spacing__default["default"].small_12,
          textAlign: "left",
          flex: 1,
          paddingTop: 4
        }
      }, /*#__PURE__*/React__namespace.createElement("div", null, this.renderOptionStatus()), /*#__PURE__*/React__namespace.createElement("div", null, this.props.content)));
    }), this.props.apiOptions.crossOutEnabled && !reviewMode && /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.Popover, {
      dismissEnabled: true,
      content: _ref3 => {
        let {
          close
        } = _ref3;
        return /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.PopoverContent, {
          title: "Cross out",
          content: "Cross out option",
          closeButtonVisible: true,
          actions: /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, /*#__PURE__*/React__namespace.createElement(wonderBlocksLayout.Strut, {
            size: Spacing__default["default"].medium_16
          }), /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
            kind: "primary",
            "aria-label": "Cross out Choice ".concat(getChoiceLetter(this.props.pos)),
            disabled: this.props.apiOptions.readOnly || reviewMode,
            onClick: () => {
              if (!this.props.crossedOut) {
                // If we're crossing
                // out a checked
                // option, let's also
                // uncheck it.
                this._sendChange({
                  checked: false,
                  crossedOut: true
                });
              } else {
                this._sendChange({
                  crossedOut: false
                });
              }

              close();
            }
          }, this.props.crossedOut ? "Bring back" : "Cross out"))
        });
      }
    }, _ref4 => {
      let {
        open
      } = _ref4;
      return /*#__PURE__*/React__namespace.createElement(Clickable, {
        onClick: open,
        "aria-label": "Open menu for Choice ".concat(getChoiceLetter(this.props.pos)),
        disabled: this.props.apiOptions.staticRender
      }, _ref5 => {
        return /*#__PURE__*/React__namespace.createElement(Icon, {
          icon: ellipsisHorizontalIcon,
          size: 3,
          color: Color__default["default"].offBlack64
        });
      });
    })), this.props.showRationale && /*#__PURE__*/React__namespace.createElement("div", {
      className: rationaleClassName,
      "data-test-id": "perseus-radio-rationale-content-".concat(this.props.pos)
    }, this.props.rationale));
  }

}

_defineProperty(Choice, "propTypes", {
  // TODO(kevinb) use Options.propTypes from perseus-api.jsx
  // This change will also require make sure that item-renderer.jsx and
  // server-item-renderer.jsx have appropriate defaults for apiOptions
  // because many of the properties on Options.propTypes are required.
  apiOptions: PropTypes__default["default"].shape({
    satStyling: PropTypes__default["default"].bool,
    isMobile: PropTypes__default["default"].bool,
    styling: PropTypes__default["default"].shape({
      radioStyleVersion: PropTypes__default["default"].oneOf(["intermediate", "final"]),
      primaryProductColor: PropTypes__default["default"].string
    }),
    readOnly: PropTypes__default["default"].bool
  }),
  checked: PropTypes__default["default"].bool,
  className: PropTypes__default["default"].string,
  rationale: PropTypes__default["default"].node,
  content: PropTypes__default["default"].node,
  correct: PropTypes__default["default"].bool,
  deselectEnabled: PropTypes__default["default"].bool,
  disabled: PropTypes__default["default"].bool,
  editMode: PropTypes__default["default"].bool,
  groupName: PropTypes__default["default"].string,
  isLastChoice: PropTypes__default["default"].bool,
  // Needed for border styling
  // This indicates the position of the choice relative to others
  // (so that we can display a nice little (A), (B), etc. next to it)
  // Also used to generate an id for each input.
  pos: PropTypes__default["default"].number,
  reviewMode: PropTypes__default["default"].bool,
  showRationale: PropTypes__default["default"].bool,
  showCorrectness: PropTypes__default["default"].bool,
  type: PropTypes__default["default"].string,
  // Indicates whether the user has "crossed out" this choice, meaning
  // that they don't think it's correct. This value does not affect
  // scoring or other behavior; it's just a note for the user's
  // reference.
  crossedOut: PropTypes__default["default"].bool,
  // Indicates that the user has previously selected this answer. These
  // answers may be rendered orange in review, rather than grey if
  // incorrect.
  previouslyAnswered: PropTypes__default["default"].bool,
  // A callback indicating that this choice has changed. Its argument is
  // an object with two keys: `checked` and `crossedOut`. Each contains a
  // boolean value specifying the new checked and crossed-out value of
  // this choice.
  onChange: PropTypes__default["default"].func,
  // Callbacks for when the user presses the up arrow or down arrow
  // (respectively) to navigate between choices. When called, the parent
  // finds the prev/next choice, focuses the input, and checks the radio
  // button if appropriate. (The reason we have custom behavior is that
  // we actually _don't_ want to auto-select crossed-out choices!)
  goToPrevChoice: PropTypes__default["default"].func.isRequired,
  goToNextChoice: PropTypes__default["default"].func.isRequired
});

_defineProperty(Choice, "defaultProps", {
  apiOptions: {
    styling: {}
  },
  checked: false,
  classSet: {},
  correct: false,
  disabled: false,
  editMode: false,
  onChange: function () {},
  showRationale: false,
  type: "radio",
  pos: 0,
  previouslyAnswered: false
});

const styles$w = aphrodite.StyleSheet.create({
  description: {
    display: "inline-block",
    width: "100%"
  },
  satDescription: {
    display: "block",
    position: "relative",
    boxSizing: "border-box",
    cursor: "pointer",
    marginLeft: 0,
    padding: "17px 14px"
  },
  satDescriptionCorrect: {
    color: satCorrectColor
  },
  satDescriptionCorrectChecked: {
    backgroundColor: satCorrectBackgroundColor
  },
  satDescriptionIncorrectChecked: {
    color: satIncorrectColor,
    backgroundColor: satIncorrectBackgroundColor
  },
  rationale: {
    display: "block"
  },
  nonSatRationale: {
    padding: intermediateCheckboxPadding,
    paddingTop: 0,
    marginLeft: 44,
    [mediaQueries.smOrSmaller]: {
      padding: intermediateCheckboxPaddingPhone,
      paddingTop: 0
    }
  },
  satReviewRationale: {
    marginTop: 13,
    marginLeft: 45
  }
});

class ChoiceNoneAbove extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_choice", void 0);

    _defineProperty(this, "focusInput", () => {
      this._choice.focusInput();
    });
  }

  render() {
    const choiceProps = { ...this.props,
      className: classNames__default["default"](this.props.className, "none-of-above"),
      content: this.props.showContent ? this.props.content :
      /*#__PURE__*/
      // We use a Renderer here because that is how
      // `this.props.content` is wrapped otherwise.
      // We pass in a key here so that we avoid a semi-spurious
      // react warning when we render this in the same place
      // as the previous choice content renderer.
      // Note this destroys state, but since all we're doing
      // is outputting "None of the above", that is okay.
      React__namespace.createElement(Renderer, {
        key: "noneOfTheAboveRenderer",
        content: i18n__namespace._("None of the above")
      }),
      ref: el => this._choice = el
    };
    return /*#__PURE__*/React__namespace.createElement(Choice, choiceProps);
  }

}

_defineProperty(ChoiceNoneAbove, "propTypes", {
  className: PropTypes__default["default"].string,
  content: PropTypes__default["default"].node,
  showContent: PropTypes__default["default"].bool
});

_defineProperty(ChoiceNoneAbove, "defaultProps", {
  showContent: true
});

const {
  captureScratchpadTouchStart: captureScratchpadTouchStart$2
} = Util;
const ChoicesType = PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
  // Indicates whether this choice is checked.
  checked: PropTypes__default["default"].bool,
  // Indicates whether the user has "crossed out" this choice, meaning
  // that they don't think it's correct. This value does not affect
  // scoring or other behavior; it's just a note for the user's
  // reference.
  crossedOut: PropTypes__default["default"].bool,
  content: PropTypes__default["default"].node,
  rationale: PropTypes__default["default"].node,
  hasRationale: PropTypes__default["default"].bool,
  showRationale: PropTypes__default["default"].bool,
  showCorrectness: PropTypes__default["default"].bool,
  correct: PropTypes__default["default"].bool,
  originalIndex: PropTypes__default["default"].number,
  isNoneOfTheAbove: PropTypes__default["default"].bool
}));
const radioBorderColor = radioBorderColor$2;

class BaseRadio extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      // TODO(mdr): This keeps the ID stable across re-renders on the
      //     same machine, but, at time of writing, the server's state
      //     isn't rehydrated to the client during SSR, so the server and
      //     client will generate different IDs and cause a mismatch
      //     during SSR :(
      radioGroupName: ___default["default"].uniqueId("perseus_radio_")
    });

    _defineProperty(this, "updateChoice", (choiceIndex, newValues) => {
      // Get the baseline `checked` values. If we're checking a new answer
      // and multiple-select is not on, we should clear all choices to be
      // unchecked. Otherwise, we should copy the old checked values.
      let newCheckedList;

      if (newValues.checked && !this.props.multipleSelect) {
        newCheckedList = this.props.choices.map(_ => false);
      } else {
        newCheckedList = this.props.choices.map(c => c.checked);
      } // Get the baseline `crossedOut` values.


      const newCrossedOutList = this.props.choices.map(c => c.crossedOut); // Update this choice's `checked` and `crossedOut` values.

      newCheckedList[choiceIndex] = newValues.checked;
      newCrossedOutList[choiceIndex] = newValues.crossedOut;
      this.props.onChange({
        checked: newCheckedList,
        crossedOut: newCrossedOutList
      });
    });

    _defineProperty(this, "focus", i => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this.refs["radio" + (i || 0)]).focus(); // eslint-disable-line react/no-string-refs

      return true;
    });

    _defineProperty(this, "getInstructionsText", () => {
      if (this.props.multipleSelect) {
        if (this.props.countChoices) {
          return i18n__namespace._("Choose %(numCorrect)s answers:", {
            numCorrect: this.props.numCorrect
          });
        }

        return i18n__namespace._("Choose all answers that apply:");
      }

      return i18n__namespace._("Choose 1 answer:");
    });

    _defineProperty(this, "deselectEnabled", () => {
      // We want to force enable deselect on mobile.
      return this.props.apiOptions.isMobile || this.props.deselectEnabled;
    });

    _defineProperty(this, "goToChoice", newChoiceIndex => {
      const numChoices = this.props.choices.length; // Wrap the newChoiceIndex around the start/end, if necessary.

      if (newChoiceIndex < 0) {
        newChoiceIndex += numChoices;
      }

      if (newChoiceIndex >= numChoices) {
        newChoiceIndex -= numChoices;
      } // Focus the new choice's input element.
      // eslint-disable-next-line react/no-string-refs


      const choiceInstance = this.refs["radio".concat(newChoiceIndex)];

      if (!choiceInstance) {
        Log.error("found no choice at index ".concat(newChoiceIndex, ", even after ") + "wrapping it to be within bounds", Errors.Internal, {
          loggedMetadata: {
            choices: JSON.stringify(this.props.choices)
          }
        });
        return;
      }

      choiceInstance.focusInput(); // We aren't going to change any choices' crossed-out state, but we
      // _are_ going to deselect all choices.

      const newCrossedOutList = this.props.choices.map(c => c.crossedOut);
      const newCheckedList = this.props.choices.map(c => false); // And, if the new choice isn't crossed out, we'll select it.

      if (!this.props.choices[newChoiceIndex].crossedOut) {
        newCheckedList[newChoiceIndex] = true;
      }

      this.props.onChange({
        checked: newCheckedList,
        crossedOut: newCrossedOutList
      });
    });
  }

  componentDidUpdate(prevProps) {
    const {
      apiOptions,
      choices,
      isLastUsedWidget,
      reviewModeRubric
    } = this.props; // Switching into review mode can sometimes cause the selected answer
    // to scroll out of view - for example, when we reveal all those tall
    // rationales. This can be disorienting for the user.
    //
    // So, if this widget just switched into review mode, ensure that the
    // checked choice (or first checked choice, if there are multiple) is
    // scrolled into view.
    //
    // This only happens if the `canScrollPage` API option is set (so that
    // call sites aren't surprised by scrolling), and if this widget was
    // the most recently used widget (because, if the user has since
    // touched something else, they're probably not trying to keep their
    // eye on this widget anymore).

    if (apiOptions.canScrollPage && isLastUsedWidget && reviewModeRubric && !prevProps.reviewModeRubric) {
      const checkedIndex = choices.findIndex(c => c.checked);

      if (checkedIndex >= 0) {
        const checkedNode = ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
        this.refs["radio" + checkedIndex]);
        scrollElementIntoView(checkedNode);
      }
    }
  } // When a particular choice's `onChange` handler is called, indicating a
  // change in a single choice's values, we need to call our `onChange`
  // handler in order to notify our parent. However, our API with our parent
  // is that we always provide *all* values for *all* choices, even if just
  // one choice's values changed. (This is because sometimes an interaction
  // with one choice can affect many choices, like how checking a new answer
  // will usually cause the old answer to become unchecked.)
  //
  // So, given the new values for a particular choice, compute the new values
  // for all choices, and pass them to `this.props.onChange`.
  //
  // `newValues` is an object with two keys: `checked` and `crossedOut`. Each
  // contains a boolean value specifying the new checked and crossed-out
  // value of this choice.


  render() {
    const inputType = this.props.multipleSelect ? "checkbox" : "radio";
    const rubric = this.props.reviewModeRubric;
    const reviewMode = !!rubric;
    const styles = BaseRadio.styles;
    const sat = this.props.apiOptions.satStyling;
    const isMobile = this.props.apiOptions.isMobile;
    const choices = this.props.choices;
    const firstChoiceHighlighted = choices[0].highlighted;
    const lastChoiceHighlighted = choices[choices.length - 1].highlighted;
    const className = classNames__default["default"]("perseus-widget-radio", !this.props.editMode && "perseus-rendered-radio", aphrodite.css(styles.radio, // SAT doesn't use the "responsive styling" as it conflicts
    // with their custom theming.
    !sat && styles.responsiveRadioContainer, !sat && firstChoiceHighlighted && isMobile && styles.radioContainerFirstHighlighted, !sat && lastChoiceHighlighted && isMobile && styles.radioContainerLastHighlighted, sat && styles.satRadio));
    const instructionsClassName = classNames__default["default"]("instructions", aphrodite.css(styles.instructions, isMobile && styles.instructionsMobile));
    const instructions = this.getInstructionsText();
    const shouldShowInstructions = !sat;
    const responsiveClassName = aphrodite.css(styles.responsiveFieldset);
    const fieldset = /*#__PURE__*/React__namespace.createElement("fieldset", {
      className: "perseus-widget-radio-fieldset ".concat(responsiveClassName)
    }, /*#__PURE__*/React__namespace.createElement("legend", {
      className: "perseus-sr-only"
    }, instructions), shouldShowInstructions && /*#__PURE__*/React__namespace.createElement("div", {
      className: instructionsClassName
    }, instructions), /*#__PURE__*/React__namespace.createElement("ul", {
      className: className,
      style: {
        listStyle: "none"
      }
    }, this.props.choices.map(function (choice, i) {
      let Element = Choice;
      const elementProps = {
        ref: "radio".concat(i),
        apiOptions: this.props.apiOptions,
        checked: choice.checked,
        crossedOut: choice.crossedOut,
        previouslyAnswered: choice.previouslyAnswered,
        reviewMode,
        correct: choice.correct,
        rationale: choice.rationale,
        content: choice.content,
        disabled: this.props.apiOptions.readOnly || choice.disabled,
        editMode: this.props.editMode,
        groupName: this.state.radioGroupName,
        isLastChoice: i === this.props.choices.length - 1,
        showCorrectness: reviewMode || !!choice.showCorrectness,
        showRationale: choice.hasRationale && (reviewMode || choice.showRationale),
        type: inputType,
        pos: i,
        deselectEnabled: this.deselectEnabled(),
        onChange: newValues => {
          this.updateChoice(i, newValues);
        },
        goToPrevChoice: () => this.goToChoice(i - 1),
        goToNextChoice: () => this.goToChoice(i + 1)
      };

      if (choice.isNoneOfTheAbove) {
        Element = ChoiceNoneAbove;

        ___default["default"].extend(elementProps, {
          showContent: choice.revealNoneOfTheAbove
        });
      }

      const nextChoice = this.props.choices[i + 1];
      const nextChoiceHighlighted = !!nextChoice && nextChoice.highlighted;

      const aphroditeClassName = checked => {
        // Whether or not to show correctness borders
        // for this choice and the next choice.
        const satShowCorrectness = sat && reviewMode && checked;
        const satShowCorrectnessNext = sat && reviewMode && nextChoice && nextChoice.checked;
        return aphrodite.css(sharedStyles.aboveScratchpad, styles.item, !sat && styles.responsiveItem, !sat && checked && styles.selectedItem, !sat && checked && choice.highlighted && styles.aboveBackdrop, !sat && checked && choice.highlighted && this.props.apiOptions.isMobile && styles.aboveBackdropMobile, !sat && nextChoiceHighlighted && this.props.apiOptions.isMobile && styles.nextHighlighted, sat && styles.satRadioOption, satShowCorrectness && !choice.correct && styles.satRadioOptionIncorrect, satShowCorrectness && choice.correct && styles.satRadioOptionCorrect, satShowCorrectnessNext && !nextChoice.correct && styles.satRadioOptionNextIncorrect, satShowCorrectnessNext && nextChoice.correct && styles.satRadioOptionNextCorrect, sat && rubric && styles.satReviewRadioOption);
      }; // HACK(abdulrahman): Preloads the selection-state
      // css because of a bug that causes iOS to lag
      // when selecting the button for the first time.


      aphroditeClassName(true);
      const className = classNames__default["default"](aphroditeClassName(choice.checked), // TODO(aria): Make test case for these API
      // classNames
      ClassNames.RADIO.OPTION, choice.checked && ClassNames.RADIO.SELECTED, reviewMode && rubric.choices[i].correct && ClassNames.CORRECT, reviewMode && !rubric.choices[i].correct && ClassNames.INCORRECT); // In edit mode, the Choice renders a Div in order to
      // allow for the contentEditable area to be selected
      // (label forces any clicks inside to select the input
      // element) We have to add some extra behavior to make
      // sure that we can still check the choice.

      let listElem = null;
      let clickHandler = null;

      if (this.props.editMode) {
        clickHandler = e => {
          // Traverse the parent nodes of the clicked
          // element.
          let elem = e.target;

          while (elem && elem !== listElem) {
            // If the clicked element is inside of the
            // radio icon, then we want to trigger the
            // check by flipping the choice of the icon.
            if (elem.getAttribute("data-is-radio-icon")) {
              this.updateChoice(i, {
                checked: !choice.checked
              });
              return;
            }

            elem = elem.parentNode;
          }
        };
      } // TODO(mattdr): Index isn't a *good* choice of key
      // here; is there a better one? Can we use choice
      // content somehow? Would changing our choice of key
      // somehow break something happening inside a choice's
      // child Renderers, by changing when we mount/unmount?


      return /*#__PURE__*/React__namespace.createElement("li", {
        key: i,
        ref: e => listElem = e,
        className: className,
        onClick: clickHandler,
        onTouchStart: !this.props.labelWrap ? null : captureScratchpadTouchStart$2
      }, /*#__PURE__*/React__namespace.createElement(Element, elementProps));
    }, this))); // Allow for horizontal scrolling if content is too wide, which may be
    // an issue especially on phones.
    // This is disabled in SAT, since it conflicts with their theming.

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(!sat && styles.responsiveContainer)
    }, fieldset);
  }

}

_defineProperty(BaseRadio, "propTypes", {
  apiOptions: PropTypes__default["default"].shape({
    readOnly: PropTypes__default["default"].bool,
    satStyling: PropTypes__default["default"].bool,
    isMobile: PropTypes__default["default"].bool,
    styling: PropTypes__default["default"].shape({
      radioStyleVersion: PropTypes__default["default"].oneOf(["intermediate", "final"])
    }),
    canScrollPage: PropTypes__default["default"].bool
  }),
  choices: ChoicesType,
  deselectEnabled: PropTypes__default["default"].bool,
  editMode: PropTypes__default["default"].bool,
  labelWrap: PropTypes__default["default"].bool,
  countChoices: PropTypes__default["default"].bool,
  numCorrect: PropTypes__default["default"].number,
  multipleSelect: PropTypes__default["default"].bool,
  reviewModeRubric: PropTypes__default["default"].shape({
    choices: ChoicesType
  }),
  // A callback indicating that this choice has changed. Its argument is
  // an object with two keys: `checked` and `crossedOut`. Each contains
  // an array of boolean values, specifying the new checked and
  // crossed-out value of each choice.
  onChange: PropTypes__default["default"].func,
  // Whether this widget was the most recently used widget in this
  // Renderer. Determines whether we'll auto-scroll the page upon
  // entering review mode.
  isLastUsedWidget: PropTypes__default["default"].bool
});

_defineProperty(BaseRadio, "styles", aphrodite.StyleSheet.create({
  // eslint-disable-next-line react-native/no-unused-styles
  instructions: {
    display: "block",
    color: gray17,
    fontSize: 14,
    lineHeight: 1.25,
    fontStyle: "normal",
    fontWeight: "bold",
    marginBottom: 16
  },
  // eslint-disable-next-line react-native/no-unused-styles
  instructionsMobile: {
    fontSize: 18,
    [mediaQueries.smOrSmaller]: {
      fontSize: 16
    },
    // TODO(emily): We want this to match choice text, which turns
    // to 20px at min-width 1200px, but this media query is
    // min-width 1280px because our media queries don't exactly
    // match pure. Make those match up.
    [mediaQueries.xl]: {
      fontSize: 20
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  radio: {
    // Avoid centering
    width: "100%"
  },
  // eslint-disable-next-line react-native/no-unused-styles
  responsiveRadioContainer: {
    borderBottom: "1px solid ".concat(radioBorderColor),
    borderTop: "1px solid ".concat(radioBorderColor),
    width: "auto",
    [mediaQueries.smOrSmaller]: {
      marginLeft: negativePhoneMargin,
      marginRight: negativePhoneMargin
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  radioContainerFirstHighlighted: {
    borderTop: "1px solid rgba(0, 0, 0, 0)"
  },
  // eslint-disable-next-line react-native/no-unused-styles
  radioContainerLastHighlighted: {
    borderBottom: "1px solid rgba(0, 0, 0, 0)"
  },
  // eslint-disable-next-line react-native/no-unused-styles
  satRadio: {
    background: "none",
    marginLeft: 0,
    userSelect: "none"
  },
  // eslint-disable-next-line react-native/no-unused-styles
  satRadioOption: {
    margin: 0,
    padding: 0,
    borderBottom: "1px solid #ccc",
    ":first-child": {
      borderTop: "1px solid #ccc"
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  satRadioOptionCorrect: {
    borderBottomColor: satCorrectBorderColor,
    ":first-child": {
      borderTopColor: satCorrectBorderColor
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  satRadioOptionIncorrect: {
    borderBottomColor: satIncorrectBorderColor,
    ":first-child": {
      borderTopColor: satIncorrectBorderColor
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  satRadioOptionNextCorrect: {
    borderBottomColor: satCorrectBorderColor
  },
  // eslint-disable-next-line react-native/no-unused-styles
  satRadioOptionNextIncorrect: {
    borderBottomColor: satIncorrectBorderColor
  },
  // eslint-disable-next-line react-native/no-unused-styles
  satReviewRadioOption: {
    pointerEvents: "none"
  },
  // eslint-disable-next-line react-native/no-unused-styles
  item: {
    marginLeft: 20
  },
  // eslint-disable-next-line react-native/no-unused-styles
  inlineItem: {
    display: "inline-block",
    paddingLeft: 20,
    verticalAlign: "middle" // See http://stackoverflow.com/q/8120466 for explanation of
    // why vertical align property is needed

  },
  // eslint-disable-next-line react-native/no-unused-styles
  responsiveItem: {
    marginLeft: 0,
    padding: 0,
    ":not(:last-child)": {
      borderBottom: "1px solid ".concat(radioBorderColor)
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  selectedItem: {
    background: "white"
  },
  // eslint-disable-next-line react-native/no-unused-styles
  aboveBackdrop: {
    position: "relative",
    // HACK(emily): We want selected choices to show up above our
    // exercise backdrop, but below the exercise footer and
    // "feedback popover" that shows up. This z-index is carefully
    // coordinated between here and webapp. :(
    zIndex: 1062
  },
  // eslint-disable-next-line react-native/no-unused-styles
  aboveBackdropMobile: {
    boxShadow: "0 0 4px 0 rgba(0, 0, 0, 0.2)," + "0 0 2px 0 rgba(0, 0, 0, 0.1)",
    ":not(:last-child)": {
      borderBottom: "1px solid rgba(0, 0, 0, 0)"
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  nextHighlighted: {
    ":not(:last-child)": {
      borderBottom: "1px solid rgba(0, 0, 0, 0)"
    }
  },
  // eslint-disable-next-line react-native/no-unused-styles
  responsiveContainer: {
    overflow: "auto",
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingLeft: phoneMargin // paddingRight is handled by responsiveFieldset

  },
  // eslint-disable-next-line react-native/no-unused-styles
  responsiveFieldset: {
    paddingRight: phoneMargin
  }
}));

_defineProperty(BaseRadio, "defaultProps", {
  editMode: false
});

class Radio$1 extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_renderRenderer", content => {
      content = content || "";
      let nextPassageRefId = 1;
      const widgets = {};
      const modContent = content.replace(/\{\{passage-ref (\d+) (\d+)(?: "([^"]*)")?\}\}/g, (match, passageNum, refNum, summaryText) => {
        const widgetId = "passage-ref " + nextPassageRefId;
        nextPassageRefId++;
        widgets[widgetId] = {
          type: "passage-ref",
          graded: false,
          options: {
            passageNumber: parseInt(passageNum),
            referenceNumber: parseInt(refNum),
            summaryText: summaryText
          },
          version: PassageRef$1.version
        };
        return "[[" + Util.snowman + " " + widgetId + "]]";
      }); // alwaysUpdate={true} so that passage-refs findWidgets
      // get called when the outer passage updates the renderer
      // TODO(aria): This is really hacky
      // We pass in a key here so that we avoid a semi-spurious
      // react warning when the ChoiceNoneAbove renders a
      // different renderer in the same place. Note this destroys
      // state, but since all we're doing is outputting
      // "None of the above", that is okay.
      // TODO(mdr): Widgets inside this Renderer are not discoverable through
      //     the parent Renderer's `findWidgets` function.

      return /*#__PURE__*/React__namespace.createElement(Renderer, {
        key: "choiceContentRenderer",
        content: modContent,
        widgets: widgets,
        findExternalWidgets: this.props.findWidgets,
        alwaysUpdate: true,
        linterContext: { ...this.props.linterContext,
          blockHighlight: true
        }
      });
    });

    _defineProperty(this, "focus", i => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.baseRadio.focus(i);
    });

    _defineProperty(this, "updateChoices", newValueLists => {
      const {
        choiceStates,
        choices
      } = this.props; // Construct the baseline `choiceStates` objects. If this is the user's
      // first interaction with the widget, we'll need to initialize them to
      // new objects with all fields set to the default values. Otherwise, we
      // should clone the old `choiceStates` objects, in preparation to
      // mutate them.

      let newChoiceStates;

      if (choiceStates) {
        newChoiceStates = choiceStates.map(state => ({ ...state
        }));
      } else {
        newChoiceStates = choices.map(() => ({
          selected: false,
          crossedOut: false,
          highlighted: false,
          rationaleShown: false,
          correctnessShown: false,
          previouslyAnswered: false,
          readOnly: false
        }));
      } // Mutate the new `choiceState` objects, according to the new `checked`
      // and `crossedOut` values provided in `newValueLists`.


      newChoiceStates.forEach((choiceState, i) => {
        choiceState.selected = newValueLists.checked[i];
        choiceState.crossedOut = newValueLists.crossedOut[i];
      });
      this.props.onChange({
        choiceStates: newChoiceStates
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "getUserInput", () => {
      return Radio$1.getUserInputFromProps(this.props);
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Radio$1.validate(this.getUserInput(), rubric);
    });

    _defineProperty(this, "showRationalesForCurrentlySelectedChoices", rubric => {
      const {
        choiceStates
      } = this.props;

      if (choiceStates) {
        const score = this.simpleValidate(rubric);
        const widgetCorrect = score.type === "points" && score.total === score.earned;
        const newStates = choiceStates.map(state => ({ ...state,
          highlighted: state.selected,
          // If the choice is selected, show the rationale now
          rationaleShown: state.selected || // If the choice already had a rationale, keep it shown
          state.rationaleShown || // If the widget is correctly answered, show the rationale
          // for all the choices
          widgetCorrect,
          // We use the same behavior for the readOnly flag as for
          // rationaleShown, but we keep it separate in case other
          // behaviors want to disable choices without showing rationales.
          readOnly: state.selected || state.readOnly || widgetCorrect,
          correctnessShown: state.selected || state.correctnessShown,
          previouslyAnswered: state.previouslyAnswered || state.selected
        }));
        this.props.onChange({
          choiceStates: newStates
        }, null, // cb
        true // silent
        );
      }
    });

    _defineProperty(this, "deselectIncorrectSelectedChoices", () => {
      if (this.props.choiceStates) {
        const newStates = this.props.choiceStates.map((state, i) => ({ ...state,
          selected: state.selected && !!this.props.choices[i].correct,
          highlighted: false
        }));
        this.props.onChange({
          choiceStates: newStates
        }, null, // cb
        false // silent
        );
      }
    });
  }

  render() {
    let choices = this.props.choices;
    let choiceStates;

    if (this.props.static) {
      choiceStates = ___default["default"].map(choices, val => ({
        selected: val.correct,
        crossedOut: val.crossedOut,
        readOnly: true,
        highlighted: false,
        rationaleShown: true,
        correctnessShown: true,
        previouslyAnswered: false
      }));
    } else if (this.props.choiceStates) {
      choiceStates = this.props.choiceStates; // $FlowFixMe[prop-missing]
    } else if (this.props.values) {
      // Support legacy choiceStates implementation

      /* istanbul ignore next - props.values is deprecated */
      choiceStates = ___default["default"].map(this.props.values, val => ({
        selected: val,
        crossedOut: false,
        readOnly: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false,
        previouslyAnswered: false
      }));
    } else {
      choiceStates = ___default["default"].map(choices, () => ({
        selected: false,
        crossedOut: false,
        readOnly: false,
        highlighted: false,
        rationaleShown: false,
        correctnessShown: false,
        previouslyAnswered: false
      }));
    }

    choices = ___default["default"].map(choices, (choice, i) => {
      const content = choice.isNoneOfTheAbove && !choice.content ? // we use i18n._ instead of $_ here because the content
      // sent to a renderer needs to be a string, not a react
      // node (/renderable/fragment).
      i18n__namespace._("None of the above") : choice.content;
      const {
        selected,
        crossedOut,
        rationaleShown,
        correctnessShown,
        readOnly,
        highlighted,
        previouslyAnswered
      } = choiceStates[i];
      const reviewChoice = this.props.reviewModeRubric && this.props.reviewModeRubric.choices[i];
      return {
        content: this._renderRenderer(content),
        checked: selected,
        // Current versions of the radio widget always pass in the
        // "correct" value through the choices. Old serialized state
        // for radio widgets doesn't have this though, so we have to
        // pull the correctness out of the review mode rubric. This
        // only works because all of the places we use
        // `restoreSerializedState()` also turn on reviewMode, but is
        // fine for now.
        // TODO(emily): Come up with a more comprehensive way to solve
        // this sort of "serialized state breaks when internal
        // structure changes" problem.
        correct: typeof choice.correct === "undefined" ? !!reviewChoice && reviewChoice.correct : choice.correct,
        disabled: readOnly,
        hasRationale: !!choice.clue,
        rationale: this._renderRenderer(choice.clue),
        showRationale: rationaleShown,
        showCorrectness: correctnessShown,
        isNoneOfTheAbove: choice.isNoneOfTheAbove,
        revealNoneOfTheAbove: this.props.questionCompleted && selected,
        crossedOut,
        highlighted,
        previouslyAnswered: previouslyAnswered
      };
    });
    return /*#__PURE__*/React__namespace.createElement(BaseRadio // eslint-disable-next-line react/no-string-refs
    , {
      ref: "baseRadio",
      labelWrap: true,
      multipleSelect: this.props.multipleSelect,
      countChoices: this.props.countChoices,
      numCorrect: this.props.numCorrect,
      choices: choices,
      onChange: this.updateChoices,
      reviewModeRubric: this.props.reviewModeRubric,
      deselectEnabled: this.props.deselectEnabled,
      apiOptions: this.props.apiOptions,
      isLastUsedWidget: this.props.isLastUsedWidget
    });
  }

  static validate(userInput, rubric) {
    const numSelected = ___default["default"].reduce(userInput.choicesSelected, (sum, selected) => {
      return sum + (selected ? 1 : 0);
    }, 0);

    if (numSelected === 0) {
      return {
        type: "invalid",
        message: null
      };
    } // $FlowFixMe[invalid-compare]


    if (userInput.numCorrect > 1 && numSelected !== userInput.numCorrect) {
      return {
        type: "invalid",
        message: i18n__namespace._("Please choose the correct number of answers.")
      }; // If NOTA and some other answer are checked, ...
    }

    if (userInput.noneOfTheAboveSelected && numSelected > 1) {
      return {
        type: "invalid",
        message: i18n__namespace._("'None of the above' may not be selected " + "when other answers are selected.")
      };
    }
    /* jshint -W018 */


    const correct = ___default["default"].all(userInput.choicesSelected, (selected, i) => {
      let isCorrect;

      if (userInput.noneOfTheAboveIndex === i) {
        isCorrect = ___default["default"].all(rubric.choices, (choice, j) => {
          return i === j || !choice.correct;
        });
      } else {
        isCorrect = !!rubric.choices[i].correct;
      }

      return isCorrect === selected;
    });
    /* jshint +W018 */


    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }

  static getUserInputFromProps(props) {
    // Return checked inputs in the form {choicesSelected: [bool]}. (Dear
    // future timeline implementers: this used to be {value: i} before
    // multiple select was added)
    if (props.choiceStates) {
      let noneOfTheAboveIndex = null;
      let noneOfTheAboveSelected = false;
      const choiceStates = props.choiceStates;
      const choicesSelected = choiceStates.map(() => false);
      const countChoices = props.countChoices;
      const numCorrect = props.numCorrect;

      for (let i = 0; i < choicesSelected.length; i++) {
        // $FlowFixMe[prop-missing]
        const index = props.choices[i].originalIndex; // $FlowFixMe[incompatible-use]

        choicesSelected[index] = choiceStates[i].selected;

        if (props.choices[i].isNoneOfTheAbove) {
          noneOfTheAboveIndex = index;

          if (choicesSelected[i]) {
            noneOfTheAboveSelected = true;
          }
        }
      }

      return {
        countChoices,
        choicesSelected,
        numCorrect,
        noneOfTheAboveIndex,
        noneOfTheAboveSelected
      }; // Support legacy choiceState implementation
    }
    /* istanbul ignore if - props.values is deprecated */
    // $FlowFixMe[prop-missing]


    if (props.values) {
      let noneOfTheAboveIndex = null;
      let noneOfTheAboveSelected = false;
      const values = props.values.slice();
      const countChoices = props.countChoices;
      const numCorrect = props.numCorrect;

      for (let i = 0; i < props.values.length; i++) {
        const index = props.choices[i].originalIndex;
        values[index] = props.values[i];

        if (props.choices[i].isNoneOfTheAbove) {
          noneOfTheAboveIndex = index;

          if (values[i]) {
            noneOfTheAboveSelected = true;
          }
        }
      }

      return {
        choicesSelected: values,
        noneOfTheAboveIndex,
        noneOfTheAboveSelected,
        countChoices,
        numCorrect
      };
    } // Nothing checked


    return {
      choicesSelected: ___default["default"].map(props.choices, () => false)
    };
  }

}

_defineProperty(Radio$1, "defaultProps", {
  choices: [{}],
  displayCount: null,
  multipleSelect: false,
  countChoices: false,
  deselectEnabled: false,
  linterContext: PerseusLinter.linterContextDefault
});

const {
  shuffle: shuffle$2,
  random
} = Util; // Represents choices that we automatically re-order if encountered.
// Note: these are in the reversed (incorrect) order that we will swap, if
// found.
// Note 2: these are internationalized when compared later on.

const ReversedChoices = [[i18n__namespace._("False"), i18n__namespace._("True")], [i18n__namespace._("No"), i18n__namespace._("Yes")]]; // Transforms the choices for display.

const _choiceTransform = (widgetOptions, problemNum) => {
  const _maybeRandomize = function (array) {
    const randomSeed = problemNum === undefined ? random : problemNum; // NOTE: `problemNum` will only be set when the radio widget is
    // rendered at the root of an exercise question. It will be `undefined`
    // if it's rendered embedded in another widget, such as `graded-group`,
    // or if rendered within an article. This results in a predictable
    // shuffle order. To avoid this we use a random seed when `problemNum`
    // is `undefined`.

    return widgetOptions.randomize ? shuffle$2(array, randomSeed !== null && randomSeed !== void 0 ? randomSeed : 0) : array;
  };

  const _addNoneOfAbove = function (choices) {
    let noneOfTheAbove = null;

    const newChoices = ___default["default"].reject(choices, function (choice, index) {
      if (choice.isNoneOfTheAbove) {
        noneOfTheAbove = choice;
        return true;
      }
    }); // Place the "None of the above" options last


    if (noneOfTheAbove) {
      newChoices.push(noneOfTheAbove);
    }

    return newChoices;
  };

  const enforceOrdering = choices => {
    const content = choices.map(c => c.content);

    if (ReversedChoices.some(reversed => ___default["default"].isEqual(content, reversed))) {
      return [choices[1], choices[0]];
    }

    return choices;
  }; // Add meta-information to choices


  let choices = widgetOptions.choices.slice();
  choices = ___default["default"].map(choices, (choice, i) => {
    return ___default["default"].extend({}, choice, {
      originalIndex: i,
      correct: Boolean(choice.correct)
    });
  }); // Apply all the transforms. Note that the order we call these is
  // important!
  // 3) finally add "None of the above" to the bottom

  return _addNoneOfAbove( // 2) then (potentially) enforce ordering (eg. False, True becomes
  //    True, False)
  enforceOrdering( // 1) we randomize the order first
  _maybeRandomize(choices)));
};

const transform = (widgetOptions, problemNum) => {
  const choices = _choiceTransform(widgetOptions, problemNum);

  const numCorrect = ___default["default"].reduce(widgetOptions.choices, function (memo, choice) {
    return choice.correct ? memo + 1 : memo;
  }, 0);

  const {
    hasNoneOfTheAbove,
    multipleSelect,
    countChoices,
    deselectEnabled
  } = widgetOptions;
  return {
    numCorrect,
    hasNoneOfTheAbove,
    multipleSelect,
    countChoices,
    deselectEnabled,
    choices,
    selectedChoices: ___default["default"].pluck(choices, "correct")
  };
};

const propUpgrades$1 = {
  "1": v0props => {
    let choices;
    let hasNoneOfTheAbove;

    if (!v0props.noneOfTheAbove) {
      choices = v0props.choices;
      hasNoneOfTheAbove = false;
    } else {
      throw new Error("radio widget v0 no longer supports auto noneOfTheAbove");
    }

    return ___default["default"].extend(___default["default"].omit(v0props, "noneOfTheAbove"), {
      choices: choices,
      hasNoneOfTheAbove: hasNoneOfTheAbove
    });
  }
};
var Radio = {
  name: "radio",
  displayName: "Multiple choice",
  accessible: true,
  widget: Radio$1,
  transform: transform,
  staticTransform: transform,
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades$1,
  isLintable: true
};

// As new widgets get added here, please also make sure they get added in
var basicWidgets = [Radio, InputNumber$1, NumericInput$1, Expression$1];

class Categorizer extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "state", {
      uniqueId: ___default["default"].uniqueId("perseus_radio_")
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "getUserInput", () => {
      return Categorizer.getUserInputFromProps(this.props);
    });

    _defineProperty(this, "onChange", (itemNum, catNum) => {
      const values = [...this.props.values];
      values[itemNum] = catNum;
      this.change("values", values);
      this.props.trackInteraction();
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Categorizer.validate(this.getUserInput(), rubric);
    });
  }

  render() {
    const self = this; // In this context, isMobile is used to differentiate mobile from
    // desktop.

    const isMobile = this.props.apiOptions.isMobile;
    let indexedItems = this.props.items.map((item, n) => [item, n]);

    if (this.props.randomizeItems) {
      // $FlowFixMe[incompatible-call]
      indexedItems = Util.shuffle(indexedItems, this.props.problemNum);
    }

    const table = /*#__PURE__*/React__namespace.createElement("table", {
      className: "categorizer-table " + aphrodite.css(styles$v.mobileTable)
    }, /*#__PURE__*/React__namespace.createElement("thead", null, /*#__PURE__*/React__namespace.createElement("tr", null, /*#__PURE__*/React__namespace.createElement("th", null, "\xA0"), this.props.categories.map((category, i) => {
      // Array index is the correct key here, as that's
      // how category grading actually works -- no way
      // to add or remove categories or items in the
      // middle. (If we later add that, this should be
      // fixed.)
      return /*#__PURE__*/React__namespace.createElement("th", {
        className: aphrodite.css(styles$v.header),
        key: i
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: category,
        linterContext: this.props.linterContext
      }));
    }))), /*#__PURE__*/React__namespace.createElement("tbody", null, indexedItems.map(indexedItem => {
      const item = indexedItem[0];
      const itemNum = indexedItem[1];
      const uniqueId = self.state.uniqueId + "_" + itemNum;
      return /*#__PURE__*/React__namespace.createElement("tr", {
        key: itemNum
      }, /*#__PURE__*/React__namespace.createElement("td", null, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: item,
        linterContext: this.props.linterContext
      })), self.props.categories.map((catName, catNum) => {
        const selected = self.props.values[itemNum] === catNum;
        return /*#__PURE__*/React__namespace.createElement("td", {
          className: "category " + aphrodite.css(styles$v.cell),
          key: catNum
        }, /*#__PURE__*/React__namespace.createElement("div", {
          className: ClassNames.INTERACTIVE,
          role: "button",
          "aria-label": catName // eslint-disable-next-line react/jsx-no-bind
          ,
          onClick: this.onChange.bind(this, itemNum, catNum)
        }, isMobile && /*#__PURE__*/React__namespace.createElement("input", {
          type: "radio",
          name: uniqueId,
          className: aphrodite.css(sharedStyles.responsiveInput, sharedStyles.responsiveRadioInput),
          checked: selected // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.onChange.bind(this, itemNum, catNum),
          onClick: e => e.stopPropagation()
        }), !isMobile && /*#__PURE__*/React__namespace.createElement("span", {
          className: aphrodite.css(styles$v.radioSpan, selected && styles$v.checkedRadioSpan, this.props.static && selected && styles$v.staticCheckedRadioSpan)
        }, selected ? /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircle) : /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircleThin))));
      }));
      /* eslint-enable max-len */
    }))); // TODO(benkomalo): kill CSS-based styling and move everything to
    // aphrodite.

    const extraClassNames = classNames__default["default"]({
      "categorizer-container": true,
      "static-mode": this.props.static
    });
    const inlineStyles = this.props.apiOptions.isMobile ? [styles$v.fullBleedContainer] : [];
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: extraClassNames + " " + aphrodite.css(...inlineStyles)
    }, table);
  }

  static validate(userInput, rubric) {
    let completed = true;
    let allCorrect = true;

    ___default["default"].each(rubric.values, function (value, i) {
      if (userInput.values[i] == null) {
        completed = false;
      }

      if (userInput.values[i] !== value) {
        allCorrect = false;
      }
    });

    if (!completed) {
      return {
        type: "invalid",
        message: i18n__namespace._("Make sure you select something for every row.")
      };
    }

    return {
      type: "points",
      earned: allCorrect ? 1 : 0,
      total: 1,
      message: null
    };
  }

  static getUserInputFromProps(props) {
    return WidgetJsonifyDeprecated.getUserInputFromProps(props);
  }

} // TODO(benkomalo): inject page-margin into Perseus instead of hardcoding.

_defineProperty(Categorizer, "defaultProps", {
  items: [],
  categories: [],
  values: [],
  linterContext: PerseusLinter.linterContextDefault
});

const pageMargin = 16; // Stylesheets aren't directly testable

/* istanbul ignore next */

const styles$v = aphrodite.StyleSheet.create({
  mobileTable: {
    [mediaQueries.smOrSmaller]: {
      minWidth: "auto"
    }
  },
  fullBleedContainer: {
    [mediaQueries.mdOrSmaller]: {
      marginLeft: -pageMargin,
      marginRight: -pageMargin,
      overflowX: "auto"
    }
  },
  header: {
    textAlign: "center",
    verticalAlign: "bottom"
  },
  cell: {
    textAlign: "center",
    padding: 0,
    color: "#ccc",
    verticalAlign: "middle"
  },
  radioSpan: {
    fontSize: 30,
    paddingRight: 3,
    ":hover": {
      color: "#999"
    }
  },
  checkedRadioSpan: {
    color: "#333"
  },
  // .static-mode is applied by the Categorizer when the rendered
  // widget is static; in this case we gray out the choices to show
  // the user that the widget can't be interacted with.
  staticCheckedRadioSpan: {
    color: "#888"
  }
});
var Categorizer$1 = {
  name: "categorizer",
  displayName: "Categorizer",
  widget: Categorizer,
  transform: widgetOptions => {
    return ___default["default"].pick(widgetOptions, "items", "categories", "randomizeItems");
  },
  staticTransform: editorProps => {
    return ___default["default"].pick(editorProps, "items", "categories", "values", "randomizeItems");
  },
  isLintable: true
};

/**
 * Helps us detect that we are running in a mobile native environment for
 * any js that is bundled in the mobile app (e.g. Perseus).
 *
 * @param {*} protocol protocol portion of a URL. Generally: window.location.protocol
 */
const isFileProtocol = protocol => {
  if (protocol && protocol.toLowerCase() === "file:") {
    return true;
  }

  return false;
};

// We cache the client location as we want to only ever return the initial
// location that was used to render the page.
let _cachedClientLocation;
/**
 * Get the location.
 */


const location = () => {
  /**
   * We cache the result to ensure that on subsequent requests we always get
   * the first URL that was used to initially render the page.
   */
  if (!_cachedClientLocation) {
    // eslint-disable-next-line no-restricted-syntax
    _cachedClientLocation = window.location;
  }

  return _cachedClientLocation;
};
/**
 * Parses a URL using the browser's built-in new URL(). Is also able to handle
 * relative URLs.
 *
 * @param {string} url The URL to parse.
 */


const parseUrl = url => new URL(url, location().origin);
/**
 * Turns a URL into an absolute URL.
 *
 * @param {string} url The URL to turn into an absolute URL.
 */


const toAbsoluteUrl = url => parseUrl(url).href;

const {
  updateQueryString: updateQueryString$1
} = Util;

function getUrlFromProgramID(programID) {
  const {
    InitialRequestUrl
  } = getDependencies();
  const path = "/computer-programming/program/" + "".concat(programID, "/embedded?embed=yes&author=no"); // When loading scratchpads in our native apps, the current URL will exist
  // as a `file://` URL. In this case, we want to reference `ka.org` instead
  // of defaulting to what we get from `toAbsoluteUrl`.

  if (isFileProtocol(InitialRequestUrl.protocol)) {
    return "https://khanacademy.org".concat(path);
  }

  return toAbsoluteUrl(path);
}
/* This renders the scratchpad in an iframe and handles validation via
 * window.postMessage */


class CSProgram extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "handleMessageEvent", e => {
      // We receive data from the iframe that contains {passed: true/false}
      //  and use that to set the status
      // It could also contain an optional message
      let data = {};

      try {
        data = JSON.parse(e.originalEvent.data);
      } catch (err) {
        return;
      }

      if (___default["default"].isUndefined(data.testsPassed)) {
        return;
      }

      const status = data.testsPassed ? "correct" : "incorrect";
      this.change({
        status: status,
        message: data.message
      });
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return CSProgram.validate({
        status: this.props.status,
        message: this.props.message
      }, rubric);
    });
  }

  // The widget's grading function
  static validate(state, rubric) {
    // The iframe can tell us whether it's correct or incorrect,
    //  and pass an optional message
    if (state.status === "correct") {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: state.message || null
      };
    }

    if (state.status === "incorrect") {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: state.message || null
      };
    }

    return {
      type: "invalid",
      message: "Keep going, you're not there yet!"
    };
  }

  componentDidMount() {
    $__default["default"](window).on("message", this.handleMessageEvent);
  }

  componentWillUnmount() {
    $__default["default"](window).off("message", this.handleMessageEvent);
  }

  render() {
    if (!this.props.programID) {
      return /*#__PURE__*/React__namespace.createElement("div", null);
    }

    let styleContainer = false;
    let url = getUrlFromProgramID(this.props.programID);
    let className;
    const style = {
      height: this.props.height,
      width: "100%"
    };

    if (this.props.showEditor) {
      url += "&editor=yes";
      className = "perseus-scratchpad-editor";
    } else {
      url += "&editor=no&width=".concat(articleMaxWidthInPx);
      className = "perseus-scratchpad";

      if (this.props.programType !== "webpage") {
        styleContainer = true;
      }
    }

    if (this.props.showButtons) {
      url += "&buttons=yes"; // Matches templates/scratchpads/embed_script.js
      // Toolbar height is 66, border height is 1 pixel

      style.height += 67;
    } else {
      url += "&buttons=no";
    } // Turn array of [{name: "", value: ""}] into object


    if (this.props.settings) {
      const settings = {};

      ___default["default"].each(this.props.settings, function (setting) {
        if (setting.name && setting.value) {
          settings[setting.name] = setting.value;
        }
      }); // This becomes available to programs as Program.settings()


      url = updateQueryString$1(url, "settings", JSON.stringify(settings));
    }

    const sandboxOptions = ["allow-popups", "allow-same-origin", "allow-scripts", "allow-top-navigation"].join(" "); // We sandbox the iframe so that we whitelist only the functionality
    //  that we need. This makes it a bit safer in case some content
    //  creator "went wild".
    // http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$u.widthOverride, styleContainer && styles$u.container)
    }, /*#__PURE__*/React__namespace.createElement("iframe", {
      sandbox: sandboxOptions,
      src: url,
      style: style,
      className: className,
      allowFullScreen: true
    }));
  }

}

_defineProperty(CSProgram, "propTypes", { ...propTypes,
  programID: PropTypes__default["default"].string,
  programType: PropTypes__default["default"].oneOf(["pjs", "sql", "webpage"]),
  width: PropTypes__default["default"].number,
  height: PropTypes__default["default"].number,
  // eslint-disable-next-line react/forbid-prop-types
  settings: PropTypes__default["default"].array,
  showEditor: PropTypes__default["default"].bool,
  showButtons: PropTypes__default["default"].bool,
  status: PropTypes__default["default"].oneOf(["incomplete", "incorrect", "correct"]),
  message: PropTypes__default["default"].string
});

_defineProperty(CSProgram, "defaultProps", {
  showEditor: false,
  showButtons: false,
  status: "incomplete",
  // optional message
  message: null
});

const styles$u = aphrodite.StyleSheet.create({
  // Override the inherited width from the perseus paragraph class
  // 820 is minimum width for 420px editor and 400px canvas
  widthOverride: {
    width: 820
  },
  container: {
    margin: "auto"
  }
});
var CSProgram$1 = {
  name: "cs-program",
  displayName: "CS Program",
  supportedAlignments: ["block", "full-width"],
  widget: CSProgram,
  hidden: true
};

class Definition extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "getUserInput", () => {
      return {};
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Definition.validate(this.getUserInput(), rubric);
    });
  }

  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement(DefinitionConsumer, null, _ref => {
      let {
        activeDefinitionId,
        setActiveDefinitionId
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.Popover, {
        content: /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.PopoverContentCore, {
          color: "white",
          style: styles$t.tooltipBody,
          closeButtonVisible: true
        }, /*#__PURE__*/React__namespace.createElement(Renderer, {
          apiOptions: this.props.apiOptions,
          content: this.props.definition,
          widgets: this.props.widgets
        })),
        opened: activeDefinitionId === this.props.widgetId,
        onClose: () => setActiveDefinitionId(null),
        placement: "top"
      }, /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-widget-definition"
      }, /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
        size: "small",
        kind: "tertiary",
        onClick: () => {
          this.props.trackInteraction();
          setActiveDefinitionId(this.props.widgetId);
        }
      }, this.props.togglePrompt)));
    });
  }

}

_defineProperty(Definition, "defaultProps", {
  togglePrompt: "define me",
  definition: "definition goes here"
});

const styles$t = {
  tooltipBody: {
    color: Color__default["default"].offBlack,
    fontSize: 20,
    fontWeight: 500,
    lineHeight: "30px"
  }
};
var Definition$1 = {
  name: "definition",
  displayName: "Definition",
  accessible: true,
  defaultAlignment: "inline",
  widget: Definition,
  transform: x => x
};

class Dropdown extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "focus", () => {
      // TODO(LP-10797): This focus() call doesn't do anything because our
      // root element is a <div> and that cannot be focused without a
      // tabIndex.
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this).focus();
      return true;
    });

    _defineProperty(this, "_handleChangeEvent", e => {
      this._handleChange(parseInt(e.target.value));
    });

    _defineProperty(this, "_handleChange", selected => {
      this.props.trackInteraction();
      this.props.onChange({
        selected: selected
      });
    });

    _defineProperty(this, "getUserInput", () => {
      return {
        value: this.props.selected
      };
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Dropdown.validate(this.getUserInput(), rubric);
    });
  }

  static validate(userInput, rubric) {
    const selected = userInput.value;

    if (selected === 0) {
      return {
        type: "invalid",
        message: null
      };
    }

    const correct = rubric.choices[selected - 1].correct;
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }

  render() {
    const children = [/*#__PURE__*/React__namespace.createElement(wonderBlocksDropdown.OptionItem, {
      key: "placeholder",
      value: "0",
      disabled: true,
      label: this.props.placeholder
    }), ...this.props.choices.map((choice, i) => /*#__PURE__*/React__namespace.createElement(wonderBlocksDropdown.OptionItem, {
      key: String(i + 1),
      value: String(i + 1),
      label: choice
    }))];
    return /*#__PURE__*/React__namespace.createElement("div", {
      // NOTE(jared): These are required to prevent weird behavior
      // When there's a dropdown in a zoomable table.
      onClick: e => {
        e.stopPropagation();
      },
      onTouchStart: e => {
        e.stopPropagation();
      }
    }, /*#__PURE__*/React__namespace.createElement(wonderBlocksDropdown.SingleSelect, {
      placeholder: "",
      onChange: value => this._handleChange(parseInt(value)),
      selectedValue: String(this.props.selected),
      disabled: this.props.apiOptions.readOnly
    }, children));
  }

}

_defineProperty(Dropdown, "defaultProps", {
  choices: [],
  selected: 0,
  placeholder: "",
  apiOptions: ApiOptions.defaults
});

const optionsTransform = widgetOptions => {
  return {
    placeholder: widgetOptions.placeholder,
    choices: widgetOptions.choices.map(choice => choice.content)
  };
};

var Dropdown$1 = {
  name: "dropdown",
  displayName: "Drop down",
  defaultAlignment: "inline-block",
  accessible: true,
  widget: Dropdown,
  transform: optionsTransform
};

class Explanation extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "state", {
      expanded: false
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "_onClick", () => {
      this.setState({
        expanded: !this.state.expanded
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "getUserInput", () => {
      return {};
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Explanation.validate(this.getUserInput(), rubric);
    });
  }

  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }

  render() {
    const {
      Link
    } = this.props.apiOptions.baseElements;
    const {
      isArticle,
      isMobile
    } = this.props.apiOptions;
    const linkAnchor = this.state.expanded ? this.props.hidePrompt : this.props.showPrompt;
    let linkContainer; // TODO(diedra): This isn't a valid href;
    // change this to a button that looks like a link.

    const href = "javascript:void(0)";
    const onClick = this._onClick;

    if (isMobile) {
      linkContainer = /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$s.linkContainer)
      }, /*#__PURE__*/React__namespace.createElement("a", {
        className: aphrodite.css(styles$s.mobileExplanationLink),
        href: href,
        onClick: onClick,
        role: "button",
        "aria-expanded": this.state.expanded
      }, linkAnchor), this.state.expanded && /*#__PURE__*/React__namespace.createElement("svg", {
        className: aphrodite.css(styles$s.disclosureArrow)
      }, /*#__PURE__*/React__namespace.createElement("polygon", {
        style: {
          fill: backgroundColor
        },
        points: "0,".concat(arrowHeight$1, " ") + "".concat(arrowWidth$1, ",").concat(arrowHeight$1, " ") + "".concat(arrowWidth$1 / 2, ",0")
      })));
    } else {
      if (isArticle) {
        // NOTE: For articles, the baseElements `Link` may is either be
        // an anchor tag (if rendered in a modal) or a Wonder Blocks
        // link component in lesson page, see: `article-page.jsx`.
        linkContainer = /*#__PURE__*/React__namespace.createElement("div", {
          className: aphrodite.css(styles$s.linkContainer, styles$s.articleLink)
        }, /*#__PURE__*/React__namespace.createElement(Link, {
          className: aphrodite.css(styles$s.explanationLink) // HACK(michaelpolyak): WB Link doesn't passthrough
          // class name.
          ,
          style: styles$s.explanationLink,
          href: href,
          onClick: onClick,
          role: "button",
          "aria-expanded": this.state.expanded
        }, "[".concat(linkAnchor, "]")));
      } else {
        // NOTE: For exercises, the baseElements `Link` is an
        // anchor tag, see: `perseus-api.jsx`.
        linkContainer = /*#__PURE__*/React__namespace.createElement("div", {
          className: aphrodite.css(styles$s.linkContainer, styles$s.exerciseLink)
        }, /*#__PURE__*/React__namespace.createElement(Link, {
          className: aphrodite.css(styles$s.explanationLink),
          href: href,
          onClick: onClick,
          role: "button",
          "aria-expanded": this.state.expanded
        }, "[".concat(linkAnchor, "]")));
      }
    }

    const expandedStyle = isMobile ? styles$s.contentExpandedMobile : styles$s.contentExpanded;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$s.container)
    }, linkContainer, this.state.expanded && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$s.content, isMobile && styles$s.contentMobile, this.state.expanded && expandedStyle) // eslint-disable-next-line react/no-string-refs
      ,
      ref: "content"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      apiOptions: this.props.apiOptions,
      content: this.props.explanation,
      widgets: this.props.widgets,
      linterContext: this.props.linterContext
    })));
  }

}

_defineProperty(Explanation, "defaultProps", {
  showPrompt: "Explain",
  hidePrompt: "Hide explanation",
  explanation: "explanation goes here\n\nmore explanation",
  widgets: {},
  linterContext: PerseusLinter.linterContextDefault
});

const leftBorderSpacing = 23;
const verticalContentPadding = 10;
const arrowWidth$1 = 30;
const arrowHeight$1 = 14;
const backgroundColor = gray95;
const styles$s = aphrodite.StyleSheet.create({
  container: {
    display: "inline",
    position: "relative"
  },
  linkContainer: {
    display: "inline-block"
  },
  explanationLink: {
    fontStyle: "italic",
    color: "#007d96"
  },
  articleLink: {
    // Copied from .body-text in articles.less
    fontSize: 20,
    lineHeight: "30px"
  },
  exerciseLink: {
    // Copied from .legacy-typography in util.less
    fontSize: 14,
    lineHeight: "19.6px"
  },
  mobileExplanationLink: {
    color: kaGreen$1,
    borderBottom: "dashed 1px ".concat(kaGreen$1),
    textDecoration: "none",
    // TODO(benkomalo): these should be pulled in from common typography
    // shared files so we have a single place where the type hierarchy is
    // defined; one off font sizes for individual components should be
    // avoided.
    [mediaQueries.xl]: {
      fontSize: 22,
      lineHeight: 1.4
    },
    [mediaQueries.lgOrSmaller]: {
      fontSize: 20,
      lineHeight: 1.5
    },
    [mediaQueries.smOrSmaller]: {
      fontSize: 18,
      lineHeight: 1.2
    }
  },
  content: {
    position: "relative",
    transition: "margin-top 0.1s"
  },
  contentExpanded: {
    borderLeft: "5px solid #ccc",
    marginLeft: -leftBorderSpacing,
    paddingLeft: leftBorderSpacing,
    paddingBottom: verticalContentPadding,
    // Note: we still use arrow height as the vertical margin, even on
    // desktop when there is no arrow, but it's good enough.
    marginBottom: arrowHeight$1,
    marginTop: arrowHeight$1
  },
  contentExpandedMobile: {
    boxSizing: "content-box",
    paddingTop: 32,
    paddingBottom: 32,
    marginTop: arrowHeight$1
  },
  contentMobile: {
    background: backgroundColor,
    // TODO(benkomalo): this is to "full bleed" the background.
    // The actual content padding differs depending on the host
    // container, so this needs to be fixed eventually.
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin
  },
  disclosureArrow: {
    // HACK - positioning at "bottom: 0", doesn't actually position it to
    // the real bottom, because the container is `inline-block`, and it
    // seems to position it to the baseline? We put in a generous
    // fudge factor to position it down to be flush with the content box
    // below it.
    bottom: -(arrowHeight$1 + 5),
    height: arrowHeight$1,
    left: "50%",
    marginLeft: -(arrowWidth$1 / 2),
    position: "absolute",
    width: arrowWidth$1
  }
});
var Explanation$1 = {
  name: "explanation",
  displayName: "Explanation",
  accessible: true,
  defaultAlignment: "inline",
  widget: Explanation,
  transform: ___default["default"].identity,
  isLintable: true
};

/*
 * A11y (Accessibility) style rules
 * These are used to mark up areas on the site that should only be readable
 * when using a screen reader.
 */
var a11y = aphrodite.StyleSheet.create({
  // Make content only visible to screen readers.
  // Both collegeboard.org and Bootstrap 3 use this exact implementation.
  srOnly: {
    border: 0,
    clip: "rect(0,0,0,0)",
    height: 1,
    margin: -1,
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: 1
  }
});

class GradedGroupAnswerBar extends React__namespace.Component {
  render() {
    const {
      apiOptions,
      answerBarState,
      onCheckAnswer,
      onNextQuestion
    } = this.props;
    const answerBarStyle = { ...styles$r.answerBar,
      backgroundColor: answerBarState === "CORRECT" ? Color__default["default"].offWhite : "white",
      // Center the "Correct!" message only when there's no next question
      justifyContent: answerBarState === "CORRECT" && !onNextQuestion ? "center" : "space-between"
    };
    const message = answerBarState === "INCORRECT" ? /*#__PURE__*/React__namespace.createElement("span", {
      style: styles$r.text
    }, /*#__PURE__*/React__namespace.createElement("span", {
      style: styles$r.tryAgainIcon
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconTryAgain)), /*#__PURE__*/React__namespace.createElement("span", {
      style: {
        marginLeft: 8
      }
    }, i18n__namespace._("Keep trying"))) : /*#__PURE__*/React__namespace.createElement("span", null); // empty span keeps the button on the right side

    if (answerBarState !== "CORRECT") {
      const buttonLabel = answerBarState === "INCORRECT" ? i18n__namespace._("Try again") : i18n__namespace._("Check");
      return /*#__PURE__*/React__namespace.createElement("div", {
        style: answerBarStyle
      }, message, /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
        disabled: apiOptions.readOnly || answerBarState !== "ACTIVE",
        onClick: onCheckAnswer
      }, buttonLabel));
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      style: answerBarStyle
    }, /*#__PURE__*/React__namespace.createElement("span", {
      style: styles$r.text
    }, /*#__PURE__*/React__namespace.createElement("span", {
      style: {
        fontSize: 28,
        color: Color__default["default"].green
      }
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends$1({}, iconStar, {
      style: {
        marginBottom: 5
      }
    }))), /*#__PURE__*/React__namespace.createElement("span", {
      role: "alert",
      "aria-label": i18n__namespace._("Correct!"),
      style: {
        marginLeft: 8
      }
    }, i18n__namespace._("Correct!"))), onNextQuestion && /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
      onClick: onNextQuestion
    }, i18n__namespace._("Next question")));
  }

}

const fontSize = 17;
const styles$r = {
  answerBar: {
    display: "flex",
    alignItems: "center",
    height: 68,
    // so that we don't have calculate the vertical padding
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    marginBottom: negativePhoneMargin,
    marginTop: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: 10,
    borderTop: "1px solid ".concat(Color__default["default"].offBlack50)
  },
  tryAgainIcon: {
    fontSize: 28,
    color: "#63D9EA",
    transform: "scale(-1,1) rotate(-268deg)"
  },
  text: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    fontWeight: "bold",
    fontSize: fontSize
  }
};

const GRADING_STATUSES = {
  ungraded: "ungraded",
  correct: "correct",
  incorrect: "incorrect",
  invalid: "invalid"
}; // Update answer bar state based on current state and whether the question is
// answerable (all parts have been filled out) or not.

const getNextState = (currentState, answerable) => {
  switch (currentState) {
    case "HIDDEN":
      return answerable ? "ACTIVE" : currentState;

    case "ACTIVE":
      return !answerable ? "INACTIVE" : currentState;

    case "INACTIVE":
      return answerable ? "ACTIVE" : currentState;

    case "INCORRECT":
      return answerable ? "ACTIVE" : "INACTIVE";

    default:
      return currentState;
  }
}; // Prepended to all invalid messages to make the widget messages a bit clearer


const INVALID_MESSAGE_PREFIX = i18n__namespace._("We couldn't grade your answer.");

const DEFAULT_INVALID_MESSAGE = i18n__namespace._("It looks like you left something blank or ") + i18n__namespace._("entered in an invalid answer.");

// A Graded Group is more or less a Group widget that displays a check
// answer button below the rendered content. When clicked, the widget grades
// the stuff inside and displays feedback about whether the inputted answer was
// correct or not.
class GradedGroup$1 extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "state", {
      status: GRADING_STATUSES.ungraded,
      showHint: false,
      message: "",
      answerBarState: "HIDDEN"
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "_onInteractWithWidget", id => {
      // Reset grading display when user changes answer
      this.setState({
        status: GRADING_STATUSES.ungraded,
        message: ""
      }); // eslint-disable-next-line react/no-string-refs

      if (this.refs.renderer) {
        this.change("widgets", this.props.widgets); // eslint-disable-next-line react/no-string-refs

        const emptyWidgets = this.refs.renderer.emptyWidgets();
        const answerable = emptyWidgets.length === 0;
        const answerBarState = this.state.answerBarState;
        this.setState({
          answerBarState: getNextState(answerBarState, answerable)
        });
      }
    });

    _defineProperty(this, "_checkAnswer", () => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.showRationalesForCurrentlySelectedChoices(); // eslint-disable-next-line react/no-string-refs

      const score = this.refs.renderer.score();
      const status = score.type === "points" ? score.total === score.earned ? GRADING_STATUSES.correct : GRADING_STATUSES.incorrect : GRADING_STATUSES.invalid;
      const message = score.type === "points" ? score.message || "" : score.message ? "".concat(INVALID_MESSAGE_PREFIX, " ").concat(score.message) : "".concat(INVALID_MESSAGE_PREFIX, " ").concat(DEFAULT_INVALID_MESSAGE);
      this.setState({
        status: status,
        message: message,
        // TODO(kevinb) handle 'invalid' status
        answerBarState: status === "correct" ? "CORRECT" : "INCORRECT"
      });
      this.props.trackInteraction({
        status: status
      });
    });

    _defineProperty(this, "getInputPaths", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.getInputPaths();
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.setInputValue(path, newValue, cb);
    });

    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.focus();
    });

    _defineProperty(this, "focusInputPath", path => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.focusPath(path);
    });

    _defineProperty(this, "blurInputPath", path => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.blurPath(path);
    });
  }

  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  }

  render() {
    const apiOptions = ___default["default"].extend({}, ApiOptions.defaults, this.props.apiOptions, {
      // Api Rewriting to support correct onFocus/onBlur
      // events for the mobile API
      onFocusChange: (newFocus, oldFocus) => {
        if (oldFocus) {
          this.props.onBlur(oldFocus);
        }

        if (newFocus) {
          this.props.onFocus(newFocus);
        }
      }
    });

    let gradeStatus = null;
    let icon = null; // Colors are 10% darker than the colors in graded-group.less

    if (this.state.status === GRADING_STATUSES.correct) {
      // TODO(jeremy): update to a WB colour
      icon = /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends$1({}, iconOk, {
        style: {
          color: "#526f03"
        }
      }));
      gradeStatus = i18n__namespace._("Correct");
    } else if (this.state.status === GRADING_STATUSES.incorrect) {
      // TODO(jeremy): update to a WB colour
      icon = /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends$1({}, iconRemove, {
        style: {
          color: "#ff5454"
        }
      }));
      gradeStatus = i18n__namespace._("Incorrect");
    }

    const mobileClass = this.props.inGradedGroupSet ? aphrodite.css(styles$q.gradedGroupInSet) : aphrodite.css(styles$q.gradedGroup);
    const classes = classNames__default["default"]({
      // $FlowFixMe[invalid-computed-prop]
      [mobileClass]: apiOptions.isMobile,
      "perseus-graded-group": true,
      "answer-correct": apiOptions.isMobile ? false : this.state.status === GRADING_STATUSES.correct,
      "answer-incorrect": apiOptions.isMobile ? false : this.state.status === GRADING_STATUSES.incorrect
    });
    const {
      answerBarState
    } = this.state; // Disabled widgets after the answer has been answered correctly to
    // prevent a situation where the answer has been marked correct but
    // looks incorrect because a user has modified it afterwards.

    const isCorrect = answerBarState === "CORRECT";
    const readOnly = apiOptions.readOnly || apiOptions.isMobile && isCorrect;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classes
    }, !!this.props.title && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$q.title)
    }, this.props.title), /*#__PURE__*/React__namespace.createElement(Renderer, _extends$1({}, this.props, {
      // eslint-disable-next-line react/no-string-refs
      ref: "renderer",
      apiOptions: { ...apiOptions,
        readOnly
      },
      onInteractWithWidget: this._onInteractWithWidget,
      linterContext: this.props.linterContext
    })), !apiOptions.isMobile && icon && /*#__PURE__*/React__namespace.createElement("div", {
      className: "group-icon"
    }, icon), !apiOptions.isMobile && gradeStatus && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(a11y.srOnly),
      role: "alert",
      "aria-label": gradeStatus
    }, gradeStatus), !apiOptions.isMobile && /*#__PURE__*/React__namespace.createElement("p", null, this.state.message), !apiOptions.isMobile && /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
      kind: "secondary",
      disabled: this.props.apiOptions.readOnly,
      onClick: this._checkAnswer
    }, i18n__namespace._("Check")), !apiOptions.isMobile && isCorrect && this.props.onNextQuestion && /*#__PURE__*/React__namespace.createElement(Button__default["default"], {
      kind: "secondary",
      disabled: this.props.apiOptions.readOnly,
      onClick: this.props.onNextQuestion,
      style: {
        marginLeft: 5
      }
    }, i18n__namespace._("Next question")), this.props.hint && this.props.hint.content && (this.state.showHint ? /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("button", {
      tabIndex: "0",
      className: aphrodite.css(styles$q.explanationTitle),
      onClick: () => this.setState({
        showHint: false
      }),
      onKeyPress: e => {
        // preventDefault stops the screen from scrolling down on keypress
        e.preventDefault();
        this.setState({
          showHint: false
        });
      }
    }, i18n__namespace._("Hide explanation")), /*#__PURE__*/React__namespace.createElement(Renderer, _extends$1({}, this.props.hint, {
      // eslint-disable-next-line react/no-string-refs
      ref: "hints-renderer",
      apiOptions: apiOptions,
      linterContext: this.props.linterContext
    }))) :
    /*#__PURE__*/
    // Not using Button here bc the styles won't work.
    React__namespace.createElement("button", {
      tabIndex: "0",
      onClick: () => this.setState({
        showHint: true
      }),
      onKeyPress: e => {
        // preventDefault stops the screen from scrolling down on keypress
        e.preventDefault();
        this.setState({
          showHint: true
        });
      },
      className: aphrodite.css(styles$q.showHintLink)
    }, i18n__namespace._("Explain"))), apiOptions.isMobile && answerBarState !== "HIDDEN" && /*#__PURE__*/React__namespace.createElement(GradedGroupAnswerBar, {
      apiOptions: apiOptions,
      answerBarState: answerBarState,
      onCheckAnswer: this._checkAnswer,
      onNextQuestion: this.props.onNextQuestion
    }));
  }

}

_defineProperty(GradedGroup$1, "defaultProps", {
  title: "",
  content: "",
  widgets: {},
  images: {},
  hint: null,
  hasHint: false,
  linterContext: PerseusLinter.linterContextDefault
});

const traverseChildWidgets$3 = function (props, traverseRenderer) {
  return ___default["default"].extend({}, props, traverseRenderer(props));
};

const styles$q = aphrodite.StyleSheet.create({
  gradedGroupInSet: {
    // Reset a few desktop-only styles that come from graded-group.less
    marginLeft: 0,
    paddingLeft: 0
  },
  gradedGroup: {
    borderTop: "1px solid ".concat(gray76),
    borderBottom: "1px solid ".concat(gray76),
    backgroundColor: tableBackgroundAccent$1,
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingBottom: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin,
    paddingTop: 10,
    width: "auto"
  },
  showHintLink: {
    backgroundColor: "unset",
    fontSize: 14,
    padding: 0,
    border: "none",
    marginTop: 20,
    color: kaGreen$1,
    cursor: "pointer",
    display: "block",
    clear: "both"
  },
  explanationTitle: {
    backgroundColor: "unset",
    marginTop: 20,
    color: kaGreen$1,
    marginBottom: 10,
    cursor: "pointer",
    fontSize: 14,
    padding: 0,
    border: "none",
    display: "block",
    clear: "both"
  },
  title: {
    fontSize: 12,
    color: gray76,
    textTransform: "uppercase",
    marginBottom: 11,
    letterSpacing: 0.8
  }
});
var GradedGroup$2 = {
  name: "graded-group",
  displayName: "Graded group (articles only)",
  widget: GradedGroup$1,
  traverseChildWidgets: traverseChildWidgets$3,
  // TODO(aasmund): This widget should be available for articles only
  hidden: false,
  tracking: "all",
  isLintable: true
};

const GradedGroup = GradedGroup$2.widget;

// TODO(jeremy): This indicator panel is not accessible for keyboard
// navigation. Add in keyboard handling and tab indexes to make accessible.
class Indicators extends React__namespace.Component {
  render() {
    const items = [];

    for (let i = 0; i < this.props.numGroups; i++) {
      items.push( /*#__PURE__*/React__namespace.createElement("div", {
        role: "button",
        "aria-label": i18n__namespace._("Skip to %(title)s", {
          title: this.props.groupTitles[i]
        }),
        key: i,
        className: aphrodite.css(styles$p.indicator, i === this.props.currentGroup && styles$p.selectedIndicator),
        onClick: () => this.props.onChangeCurrentGroup(i)
      }));
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$p.indicatorContainer)
    }, items);
  }

}

// TODO(jared): find a better name for this :) and for GradedGroup; the names
// are currently a little confusing.
class GradedGroupSet extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "_childGroup", void 0);

    _defineProperty(this, "state", {
      currentGroup: 0
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "getInputPaths", () => {
      return this._childGroup.getInputPaths();
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      return this._childGroup.setInputValue(path, newValue, cb);
    });

    _defineProperty(this, "focus", () => {
      return this._childGroup.focus();
    });

    _defineProperty(this, "focusInputPath", path => {
      this._childGroup.focusInputPath(path);
    });

    _defineProperty(this, "blurInputPath", path => {
      this._childGroup.blurInputPath(path);
    });

    _defineProperty(this, "handleNextQuestion", () => {
      const {
        currentGroup
      } = this.state;
      const numGroups = this.props.gradedGroups.length;

      if (currentGroup < numGroups - 1) {
        this.setState({
          currentGroup: currentGroup + 1
        });
      }
    });
  }

  shouldComponentUpdate(nextProps, nextState) {
    nextProps.gradedGroups;
    return nextProps !== this.props || nextState !== this.state;
  }

  render() {
    // When used in the context of TranslationEditor, render the
    // GradedGroup widget one below another instead of using an indicator
    // to click and switch between different graded groups. Translators
    // prefer to see all strings/labels on all GradedGroups readily visible
    // together instead of clicking on indicators to switch between them.
    const {
      JIPT
    } = getDependencies();

    if (JIPT.useJIPT && this.props.gradedGroups.length > 1) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles$p.container)
      }, this.props.gradedGroups.map((gradedGroup, i) => {
        return (
          /*#__PURE__*/
          // TODO(jeremy): Don't spread this.props, instead
          // pass in all props GradedGroup needs explicilty
          // $FlowFixMe[prop-missing]
          React__namespace.createElement(GradedGroup, _extends$1({
            key: i
          }, this.props, gradedGroup, {
            inGradedGroupSet: false,
            linterContext: this.props.linterContext
          }))
        );
      }));
    }

    const currentGroup = this.props.gradedGroups[this.state.currentGroup];

    if (!currentGroup) {
      return /*#__PURE__*/React__namespace.createElement("span", null, i18n__namespace.doNotTranslate("No current group..."));
    }

    const numGroups = this.props.gradedGroups.length;
    const handleNextQuestion = this.state.currentGroup < numGroups - 1 ? this.handleNextQuestion : null;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$p.container)
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$p.top)
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$p.title)
    }, currentGroup.title), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$p.spacer)
    }), /*#__PURE__*/React__namespace.createElement(Indicators, {
      numGroups: numGroups,
      currentGroup: this.state.currentGroup,
      groupTitles: this.props.gradedGroups.map(g => g.title),
      onChangeCurrentGroup: currentGroup => this.setState({
        currentGroup
      })
    })), /*#__PURE__*/React__namespace.createElement(GradedGroup, _extends$1({
      key: this.state.currentGroup // $FlowFixMe[incompatible-type]
      ,
      ref: comp => this._childGroup = comp // We should pass in the set of props explicitly

    }, this.props, currentGroup, {
      inGradedGroupSet: true // $FlowFixMe[incompatible-type]
      ,
      title: null // $FlowFixMe[incompatible-type]
      ,
      onNextQuestion: handleNextQuestion,
      linterContext: this.props.linterContext
    })));
  }

}

_defineProperty(GradedGroupSet, "defaultProps", {
  gradedGroups: [],
  linterContext: PerseusLinter.linterContextDefault
});

const traverseChildWidgets$2 = function (props, traverseRenderer) {
  // NOTE(jared): I have no idea how this works
  return {
    groups: props.gradedGroups.map(traverseRenderer)
  };
};

var GradedGroupSet$1 = {
  name: "graded-group-set",
  displayName: "Graded group set (articles only)",
  widget: GradedGroupSet,
  traverseChildWidgets: traverseChildWidgets$2,
  // TODO(michaelpolyak): This widget should be available for articles only
  hidden: false,
  tracking: "all",
  isLintable: true
};
const styles$p = aphrodite.StyleSheet.create({
  top: {
    display: "flex",
    flexDirection: "row"
  },
  spacer: {
    flex: 1
  },
  title: {
    fontSize: 12,
    color: gray76,
    textTransform: "uppercase",
    marginBottom: 11,
    letterSpacing: 0.8
  },
  indicatorContainer: {
    display: "flex",
    flexDirection: "row"
  },
  indicator: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: grayLight$1,
    marginLeft: 5,
    cursor: "pointer"
  },
  selectedIndicator: {
    backgroundColor: kaGreen$1
  },
  container: {
    borderTop: "1px solid ".concat(gray76),
    borderBottom: "1px solid ".concat(gray76),
    backgroundColor: tableBackgroundAccent$1,
    marginLeft: negativePhoneMargin,
    marginRight: negativePhoneMargin,
    paddingBottom: phoneMargin,
    paddingLeft: phoneMargin,
    paddingRight: phoneMargin,
    paddingTop: 10,
    width: "auto"
  }
});

/**
 * ButtonGroup is an aesthetically pleasing group of buttons.
 */
class ButtonGroup extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "container", void 0);
  }

  componentWillUnmount() {
    this.container = null;
  }

  focus() {
    if (this.container) {
      this.container.focus();
      return true;
    }
  }

  toggleSelect(newValue) {
    const value = this.props.value;

    if (this.props.allowEmpty) {
      // Select the new button or unselect if it's already selected
      this.props.onChange(value !== newValue ? newValue : null);
    } else {
      this.props.onChange(newValue);
    }
  }

  render() {
    const value = this.props.value;
    const buttons = this.props.buttons.map((button, i) => {
      return /*#__PURE__*/React__namespace.createElement("button", {
        title: button.title,
        type: "button",
        id: "" + i,
        ref: "button" + i,
        key: "" + i,
        className: aphrodite.css(styles$o.buttonStyle, button.value === value && styles$o.selectedStyle),
        onClick: () => this.toggleSelect(button.value)
      }, button.content || "" + button.value);
    });
    const outerStyle = {
      display: "inline-block"
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: outerStyle,
      ref: node => this.container = node
    }, buttons);
  }

}

_defineProperty(ButtonGroup, "defaultProps", {
  value: null,
  allowEmpty: true
});

const styles$o = aphrodite.StyleSheet.create({
  buttonStyle: {
    backgroundColor: "white",
    border: "1px solid #ccc",
    borderLeft: "0",
    cursor: "pointer",
    margin: "0",
    padding: "5px 10px",
    position: "relative",
    // for hover
    ":first-child": {
      borderLeft: "1px solid #ccc",
      borderTopLeftRadius: "3px",
      borderBottomLeftRadius: "3px"
    },
    ":last-child": {
      borderRight: "1px solid #ccc",
      borderTopRightRadius: "3px",
      borderBottomRightRadius: "3px"
    },
    ":hover": {
      backgroundColor: "#ccc"
    },
    ":focus": {
      zIndex: 2
    }
  },
  selectedStyle: {
    backgroundColor: "#ddd"
  }
});

/* eslint-disable one-var */
// $FlowFixMe[prop-missing]
const Plot$1 = Graphie.Plot;
const DEFAULT_BACKGROUND_IMAGE = {
  url: null
}; // TODO(charlie): These really need to go into a utility file as they're being
// used by both interactive-graph and now grapher.

function canonicalSineCoefficients$1(coeffs) {
  // For a curve of the form f(x) = a * Sin(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  let amplitude = coeffs[0];
  let angularFrequency = coeffs[1];
  let phase = coeffs[2];
  const verticalOffset = coeffs[3]; // Guarantee a > 0

  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }

  const period = 2 * Math.PI; // Guarantee b > 0

  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  } // Guarantee c is smallest possible positive value


  while (phase > 0) {
    phase -= period;
  }

  while (phase < 0) {
    phase += period;
  }

  return [amplitude, angularFrequency, phase, verticalOffset];
}

function canonicalTangentCoefficients(coeffs) {
  // For a curve of the form f(x) = a * Tan(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  let amplitude = coeffs[0];
  let angularFrequency = coeffs[1];
  let phase = coeffs[2];
  const verticalOffset = coeffs[3]; // Guarantee a > 0

  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }

  const period = Math.PI; // Guarantee b > 0

  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  } // Guarantee c is smallest possible positive value


  while (phase > 0) {
    phase -= period;
  }

  while (phase < 0) {
    phase += period;
  }

  return [amplitude, angularFrequency, phase, verticalOffset];
}

const PlotDefaults = {
  areEqual: function (coeffs1, coeffs2) {
    return Util.deepEq(coeffs1, coeffs2);
  },
  Movable: Plot$1,
  getPropsForCoeffs: function (coeffs) {
    return {
      fn: ___default["default"].partial(this.getFunctionForCoeffs, coeffs)
    };
  }
};

const Linear = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/67aaf581e6d9ef9038c10558a1f70ac21c11c9f8.png",
  defaultCoords: [[0.25, 0.75], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const denom = p2[0] - p1[0];
    const num = p2[1] - p1[1];

    if (denom === 0) {
      return;
    }

    const m = num / denom;
    const b = p2[1] - m * p2[0];
    return [m, b];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const m = coeffs[0],
          b = coeffs[1];
    return m * x + b;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const m = coeffs[0],
          b = coeffs[1];
    return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
  }
});

const Quadratic = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/e23d36e6fc29ee37174e92c9daba2a66677128ab.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  // $FlowFixMe[prop-missing]
  Movable: Graphie.Parabola,
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1]; // Parabola with vertex (h, k) has form: y = a * (h - k)^2 + k

    const h = p1[0];
    const k = p1[1]; // Use these to calculate familiar a, b, c

    const a = (p2[1] - k) / ((p2[0] - h) * (p2[0] - h));
    const b = -2 * h * a;
    const c = a * h * h + k;
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2];
    return (a * x + b) * x + c;
  },
  getPropsForCoeffs: function (coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2]
    };
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2];
    return "y = " + a.toFixed(3) + "x^2 + " + b.toFixed(3) + "x + " + c.toFixed(3);
  }
});

const Sinusoid = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/3d68e7718498475f53b206c2ab285626baf8857e.png",
  defaultCoords: [[0.5, 0.5], [0.6, 0.6]],
  // $FlowFixMe[prop-missing]
  Movable: Graphie.Sinusoid,
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const a = p2[1] - p1[1];
    const b = Math.PI / (2 * (p2[0] - p1[0]));
    const c = p1[0] * b;
    const d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2],
          d = coeffs[3];
    return a * Math.sin(b * x - c) + d;
  },
  getPropsForCoeffs: function (coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2],
      d: coeffs[3]
    };
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2],
          d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function (coeffs1, coeffs2) {
    return Util.deepEq(canonicalSineCoefficients$1(coeffs1), canonicalSineCoefficients$1(coeffs2));
  }
});

const Tangent = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/7db80d23c35214f98659fe1cf0765811c1bbfbba.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const a = p2[1] - p1[1];
    const b = Math.PI / (4 * (p2[0] - p1[0]));
    const c = p1[0] * b;
    const d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2],
          d = coeffs[3];
    return a * Math.tan(b * x - c) + d;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2],
          d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function (coeffs1, coeffs2) {
    return Util.deepEq(canonicalTangentCoefficients(coeffs1), canonicalTangentCoefficients(coeffs2));
  }
});

const Exponential = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/9cbfad55525e3ce755a31a631b074670a5dad611.png",
  defaultCoords: [[0.5, 0.55], [0.75, 0.75]],
  defaultAsymptote: [[0, 0.5], [1.0, 0.5]],

  /**
   * Add extra constraints for movement of the points or asymptote (below):
   *   newCoord: [x, y]
   *     The end position of the point or asymptote endpoint
   *   oldCoord: [x, y]
   *     The old position of the point or asymptote endpoint
   *   coords:
   *     An array of coordinates representing the proposed end configuration
   *     of the plot coordinates.
   *   asymptote:
   *     An array of coordinates representing the proposed end configuration
   *     of the asymptote.
   *
   * Return: either a coordinate (to be used as the resulting coordinate of
   * the move) or a boolean, where `true` uses newCoord as the resulting
   * coordinate, and `false` uses oldCoord as the resulting coordinate.
   */
  extraCoordConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const y = ___default["default"].head(asymptote)[1];

    return ___default["default"].all(coords, coord => coord[1] !== y);
  },
  extraAsymptoteConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const y = newCoord[1];

    const isValid = ___default["default"].all(coords, coord => coord[1] > y) || ___default["default"].all(coords, coord => coord[1] < y);

    if (isValid) {
      return [oldCoord[0], y];
    } // Snap the asymptote as close as possible, i.e., if the user moves
    // the mouse really quickly into an invalid region


    const oldY = oldCoord[1];

    const wasBelow = ___default["default"].all(coords, coord => coord[1] > oldY);

    if (wasBelow) {
      const bottomMost = ___default["default"].min(___default["default"].map(coords, coord => coord[1]));

      return [oldCoord[0], bottomMost - graph.snapStep[1]];
    }

    const topMost = ___default["default"].max(___default["default"].map(coords, coord => coord[1]));

    return [oldCoord[0], topMost + graph.snapStep[1]];
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function (coords, asymptote) {
    const p1 = coords[0];
    const p2 = coords[1];

    const c = ___default["default"].head(asymptote)[1];

    const b = Math.log((p1[1] - c) / (p2[1] - c)) / (p1[0] - p2[0]);
    const a = (p1[1] - c) / Math.exp(b * p1[0]);
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2];
    return a * Math.exp(b * x) + c;
  },
  getEquationString: function (coords, asymptote) {
    if (!asymptote) {
      return null;
    }

    const coeffs = this.getCoefficients(coords, asymptote);
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2];
    return "y = " + a.toFixed(3) + "e^(" + b.toFixed(3) + "x) + " + c.toFixed(3);
  }
});

const Logarithm = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/f6491e99d34af34d924bfe0231728ad912068dc3.png",
  defaultCoords: [[0.55, 0.5], [0.75, 0.75]],
  defaultAsymptote: [[0.5, 0], [0.5, 1.0]],
  extraCoordConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const x = ___default["default"].head(asymptote)[0];

    return ___default["default"].all(coords, coord => coord[0] !== x) && coords[0][1] !== coords[1][1];
  },
  extraAsymptoteConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const x = newCoord[0];

    const isValid = ___default["default"].all(coords, coord => coord[0] > x) || ___default["default"].all(coords, coord => coord[0] < x);

    if (isValid) {
      return [x, oldCoord[1]];
    } // Snap the asymptote as close as possible, i.e., if the user moves
    // the mouse really quickly into an invalid region


    const oldX = oldCoord[0];

    const wasLeft = ___default["default"].all(coords, coord => coord[0] > oldX);

    if (wasLeft) {
      const leftMost = ___default["default"].min(___default["default"].map(coords, coord => coord[0]));

      return [leftMost - graph.snapStep[0], oldCoord[1]];
    }

    const rightMost = ___default["default"].max(___default["default"].map(coords, coord => coord[0]));

    return [rightMost + graph.snapStep[0], oldCoord[1]];
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function (coords, asymptote) {
    // It's easiest to calculate the logarithm's coefficients by thinking
    // about it as the inverse of the exponential, so we flip x and y and
    // perform some algebra on the coefficients. This also unifies the
    // logic between the two 'models'.
    const flip = coord => [coord[1], coord[0]];

    const inverseCoeffs = Exponential.getCoefficients(___default["default"].map(coords, flip), ___default["default"].map(asymptote, flip));
    const c = -inverseCoeffs[2] / inverseCoeffs[0];
    const b = 1 / inverseCoeffs[0];
    const a = 1 / inverseCoeffs[1];
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x, asymptote) {
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2];
    return a * Math.log(b * x + c);
  },
  getEquationString: function (coords, asymptote) {
    if (!asymptote) {
      return null;
    }

    const coeffs = this.getCoefficients(coords, asymptote);
    const a = coeffs[0],
          b = coeffs[1],
          c = coeffs[2];
    return "y = ln(" + a.toFixed(3) + "x + " + b.toFixed(3) + ") + " + c.toFixed(3);
  }
});

const AbsoluteValue = ___default["default"].extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/8256a630175a0cb1d11de223d6de0266daf98721.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const denom = p2[0] - p1[0];
    const num = p2[1] - p1[1];

    if (denom === 0) {
      return;
    }

    let m = Math.abs(num / denom);

    if (p2[1] < p1[1]) {
      m *= -1;
    }

    const horizontalOffset = p1[0];
    const verticalOffset = p1[1];
    return [m, horizontalOffset, verticalOffset];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const m = coeffs[0],
          horizontalOffset = coeffs[1],
          verticalOffset = coeffs[2];
    return m * Math.abs(x - horizontalOffset) + verticalOffset;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const m = coeffs[0],
          horizontalOffset = coeffs[1],
          verticalOffset = coeffs[2];
    return "y = " + m.toFixed(3) + "| x - " + horizontalOffset.toFixed(3) + "| + " + verticalOffset.toFixed(3);
  }
});
/* Utility functions for dealing with graphing interfaces. */


const functionTypeMapping = {
  linear: Linear,
  quadratic: Quadratic,
  sinusoid: Sinusoid,
  tangent: Tangent,
  exponential: Exponential,
  logarithm: Logarithm,
  absolute_value: AbsoluteValue
};
const allTypes = ___default["default"].keys(functionTypeMapping);
function functionForType( // TODO(jeremy): Actually `$Keys<typeof functionTypeMapping>` but that
// triggers Flow to require all of our Plot types to be fully typed which
// is a big amount of work/change.
type) {
  return functionTypeMapping[type];
}
const validate$2 = (state, rubric) => {
  if (state.type !== rubric.correct.type) {
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  } // We haven't moved the coords


  if (state.coords == null) {
    return {
      type: "invalid",
      message: null
    };
  } // Get new function handler for grading


  const grader = functionForType(state.type);
  const guessCoeffs = grader.getCoefficients(state.coords, state.asymptote);
  const correctCoeffs = grader.getCoefficients(rubric.correct.coords, rubric.correct.asymptote);

  if (guessCoeffs == null || correctCoeffs == null) {
    return {
      type: "invalid",
      message: null
    };
  }

  if (grader.areEqual(guessCoeffs, correctCoeffs)) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  }

  return {
    type: "points",
    earned: 0,
    total: 1,
    message: null
  };
};
const getEquationString = props => {
  const plot = props.plot;

  if (plot.type && plot.coords) {
    const handler = functionForType(plot.type);
    const result = handler.getEquationString(plot.coords, plot.asymptote);
    return result || "";
  }

  return "";
};
const pointsFromNormalized = (coordsList, range, step, snapStep) => {
  const numSteps = function (range, step) {
    return Math.floor((range[1] - range[0]) / step);
  };

  return coordsList.map(coords => {
    const unsnappedPoint = coords.map((coord, i) => {
      const currRange = range[i];
      const currStep = step[i];
      const nSteps = numSteps(currRange, currStep);
      const tick = Math.round(coord * nSteps);
      return currRange[0] + currStep * tick;
    }); // In some graphing widgets, e.g. interactive-graph, you can rely
    // on the Graphie to handle snapping. Here, we need the points
    // returned to already be snapped so that the plot that goes
    // through them is correct.
    // $FlowFixMe[invalid-tuple-arity] improve unsnappedPoint type so it knows arity

    return kmath.point.roundTo(unsnappedPoint, snapStep);
  });
};
const maybePointsFromNormalized = (coordsList, range, step, snapStep) => {
  if (coordsList) {
    return pointsFromNormalized(coordsList, range, step, snapStep);
  }

  return coordsList;
};
/* Given a plot type, return the appropriate default value for a grapher
 * widget's plot props: type, default coords, default asymptote. */

const defaultPlotProps = (type, graph) => {
  // The coords are null by default, to indicate that the user has not
  // moved them from the default position, and that this widget should
  // therefore be considered empty and ineligible for grading. The user
  // *can* move the coords from the default position and then back if
  // they really want to submit the default coords as their answer, but
  // we currently don't write questions that require this.
  //
  // We *do* write questions in which the asymptote should be left in
  // the default position. For this reason, we fill in the default
  // asymptote rather than leaving it null; if the user moves the coords
  // but not the asymptote, the widget is non-empty and eligible for
  // grading.
  //
  // TODO(mattdr): Consider an updated scoring function that marks the
  // default coords as empty *unless* they're the correct coords. This
  // would remove this default-coords-are-always-wrong constraints on
  // the questions we write, while still maintaining our kind behavior
  // when users forget to update a widget... but we'd also be revealing
  // extra information. It would be valid to always submit the default
  // widget before even reading the question; you can't lose, but you
  // might get a free win.
  const model = functionForType(type);
  const gridStep = [1, 1];
  const snapStep = Util.snapStepFromGridStep(gridStep);
  return {
    type,
    asymptote: maybePointsFromNormalized(model.defaultAsymptote, graph.range, graph.step, snapStep),
    coords: null
  };
};
/* Given a list of available types, choose which to use. */

const chooseType = ___default["default"].first;
const getGridAndSnapSteps = (options, boxSize) => {
  const gridStep = options.gridStep || Util.getGridStep(options.range, options.step, boxSize);
  const snapStep = options.snapStep || Util.snapStepFromGridStep(gridStep);
  return {
    gridStep: gridStep,
    snapStep: snapStep
  };
};
const defaultGraph = {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  backgroundImage: DEFAULT_BACKGROUND_IMAGE,
  markings: "graph",
  rulerLabel: "",
  rulerTicks: 10,
  valid: true,
  showTooltips: false
};
const defaultPlot = defaultPlotProps("linear", defaultGraph);
const DEFAULT_GRAPHER_PROPS = {
  graph: defaultGraph,
  plot: defaultPlot,
  availableTypes: [defaultPlot.type]
};
const typeToButton = type => {
  const capitalized = type.charAt(0).toUpperCase() + type.substring(1);
  const staticUrl = getDependencies().staticUrl;
  return {
    value: type,
    title: capitalized,
    content: /*#__PURE__*/React__namespace.createElement("img", {
      src: staticUrl(functionForType(type).url),
      alt: capitalized
    })
  };
};

var util = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEFAULT_BACKGROUND_IMAGE: DEFAULT_BACKGROUND_IMAGE,
    allTypes: allTypes,
    functionForType: functionForType,
    validate: validate$2,
    getEquationString: getEquationString,
    pointsFromNormalized: pointsFromNormalized,
    maybePointsFromNormalized: maybePointsFromNormalized,
    defaultPlotProps: defaultPlotProps,
    chooseType: chooseType,
    getGridAndSnapSteps: getGridAndSnapSteps,
    DEFAULT_GRAPHER_PROPS: DEFAULT_GRAPHER_PROPS,
    typeToButton: typeToButton
});

// $FlowFixMe[prop-missing]
const MovablePoint$3 = Graphie.MovablePoint; // $FlowFixMe[prop-missing]

const MovableLine$2 = Graphie.MovableLine;

function isFlipped(newCoord, oldCoord, line) {
  const CCW = (a, b, c) => {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
  };

  return CCW(line[0], line[1], oldCoord) > 0 !== CCW(line[0], line[1], newCoord) > 0;
}
/* Styles */


const typeSelectorStyle = {
  padding: "5px 5px"
};

/* Graphing interface. */
class FunctionGrapher extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "_coords", () => {
      const props = this.props;
      const graph = props.graph;
      const defaultModelCoords = props.model && maybePointsFromNormalized(props.model.defaultCoords, graph.range, graph.step, graph.snapStep);
      return props.coords || defaultModelCoords || null;
    });

    _defineProperty(this, "_asymptote", () => {
      // Unlike coords, asymptotes are never null; see defaultPlotProps.
      return this.props.asymptote;
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "renderPlot", () => {
      const model = this.props.model;
      const xRange = this.props.graph.range[0];
      const style = {
        stroke: this.props.isMobile ? KhanColors.BLUE_C : KhanColors.DYNAMIC,
        ...(this.props.isMobile ? {
          "stroke-width": 3
        } : {})
      };
      const coeffs = model.getCoefficients(this._coords(), this._asymptote());

      if (!coeffs) {
        return;
      }

      const functionProps = model.getPropsForCoeffs(coeffs, xRange);
      return /*#__PURE__*/React__namespace.createElement(model.Movable, _extends$1({}, functionProps, {
        key: this.props.model.url,
        range: xRange,
        style: style
      }));
    });

    _defineProperty(this, "renderAsymptote", () => {
      const model = this.props.model;
      const graph = this.props.graph;

      const asymptote = this._asymptote();

      const dashed = {
        strokeDasharray: "- "
      };
      return asymptote && /*#__PURE__*/React__namespace.createElement(MovableLine$2, {
        onMove: (newCoord, oldCoord) => {
          // Calculate and apply displacement
          const delta = kmath.vector.subtract(newCoord, oldCoord);

          const newAsymptote = ___default["default"].map(this._asymptote(), coord => kmath.vector.add(coord, delta));

          this.props.onChange({
            asymptote: newAsymptote
          });
        },
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovableLine.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovableLine.constraints.snap(), (newCoord, oldCoord) => {
          // Calculate and apply proposed displacement
          const delta = kmath.vector.subtract(newCoord, oldCoord);

          const proposedAsymptote = ___default["default"].map(this._asymptote(), coord => kmath.vector.add(coord, delta)); // Verify that resulting asymptote is valid for graph


          if (model.extraAsymptoteConstraint) {
            return model.extraAsymptoteConstraint(newCoord, oldCoord, this._coords(), proposedAsymptote, graph);
          }

          return true;
        }],
        normalStyle: dashed,
        highlightStyle: dashed
      }, ___default["default"].map(asymptote, (coord, i) => /*#__PURE__*/React__namespace.createElement(MovablePoint$3, {
        key: "asymptoteCoord-".concat(i),
        coord: coord,
        static: true,
        draw: null,
        extendLine: true,
        showHairlines: this.props.showHairlines,
        hideHairlines: this.props.hideHairlines,
        showTooltips: this.props.showTooltips,
        isMobile: this.props.isMobile
      })));
    });
  }

  render() {
    const pointForCoord = (coord, i) => {
      return /*#__PURE__*/React__namespace.createElement(MovablePoint$3, {
        key: i,
        coord: coord,
        static: this.props.static,
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap(), coord => {
          // Always enforce that this is a function
          const isFunction = ___default["default"].all(this._coords(), (otherCoord, j) => {
            return i === j || !otherCoord || !kmath.number.equal(coord[0], otherCoord[0]);
          }); // Evaluate this criteria before per-point
          // constraints


          if (!isFunction) {
            return false;
          } // Specific functions have extra per-point
          // constraints


          if (this.props.model && this.props.model.extraCoordConstraint) {
            const extraConstraint = this.props.model.extraCoordConstraint; // Calculat resulting coords and verify that
            // they're valid for this graph

            const proposedCoords = ___default["default"].clone(this._coords());

            const oldCoord = ___default["default"].clone(proposedCoords[i]);

            proposedCoords[i] = coord;
            return extraConstraint(coord, oldCoord, proposedCoords, this._asymptote(), this.props.graph);
          }

          return isFunction;
        }],
        onMove: (newCoord, oldCoord) => {
          let coords; // Reflect over asymptote, if allowed

          const asymptote = this._asymptote();

          if (asymptote && this.props.model.allowReflectOverAsymptote && isFlipped(newCoord, oldCoord, asymptote)) {
            coords = ___default["default"].map(this._coords(), coord => {
              return kmath.point.reflectOverLine(coord, asymptote);
            });
          } else {
            coords = ___default["default"].clone(this._coords());
          }

          coords[i] = newCoord;
          this.props.onChange({
            coords: coords
          });
        },
        showHairlines: this.props.showHairlines,
        hideHairlines: this.props.hideHairlines,
        showTooltips: this.props.showTooltips,
        isMobile: this.props.isMobile
      });
    };

    const points = ___default["default"].map(this._coords(), pointForCoord);

    const box = this.props.graph.box;
    const imageDescription = this.props.graph.backgroundImage;
    let image = null;

    if (imageDescription.url) {
      const scale = box[0] / interactiveSizes$1.defaultBoxSize;
      image =
      /*#__PURE__*/
      // $FlowFixMe[prop-missing]: alt props is missing
      React__namespace.createElement(SvgImage, {
        src: imageDescription.url,
        width: imageDescription.width,
        height: imageDescription.height,
        scale: scale
      });
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-grapher",
      style: {
        width: box[0],
        height: box[1],
        boxSizing: "initial"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie-container above-scratchpad",
      style: {
        width: box[0],
        height: box[1]
      }
    }, image, /*#__PURE__*/React__namespace.createElement(Graphie, _extends$1({}, this.props.graph, {
      setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
    }), this.props.model && this.renderPlot(), this.props.model && this.renderAsymptote(), this.props.model && points)));
  }

}

_defineProperty(FunctionGrapher, "defaultProps", {
  graph: {
    range: [[-10, 10], [-10, 10]],
    step: [1, 1]
  },
  coords: null,
  asymptote: null,
  isMobile: false
});

/* Widget and editor. */
class Grapher extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "horizHairline", void 0);

    _defineProperty(this, "vertHairline", void 0);

    _defineProperty(this, "handlePlotChanges", newPlot => {
      const plot = ___default["default"].extend({}, this.props.plot, newPlot);

      this.props.onChange({
        plot: plot
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "handleActiveTypeChange", newType => {
      const graph = this.props.graph;

      const plot = ___default["default"].extend({}, this.props.plot, defaultPlotProps(newType, graph));

      this.props.onChange({
        plot: plot
      });
    });

    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      const isMobile = this.props.apiOptions.isMobile;

      if (options.markings === "graph") {
        graphie.graphInit({
          range: options.range,
          scale: ___default["default"].pluck(options.gridConfig, "scale"),
          axisArrows: "<->",
          labelFormat: function (s) {
            return "\\small{" + s + "}";
          },
          gridStep: options.gridStep,
          snapStep: options.snapStep,
          tickStep: isMobile ? this._calculateMobileTickStep(options.gridStep, options.step, options.range) : ___default["default"].pluck(options.gridConfig, "tickStep"),
          labelStep: 1,
          unityLabels: ___default["default"].pluck(options.gridConfig, "unityLabel"),
          isMobile: isMobile
        });
        graphie.label([0, options.range[1][1]], options.labels[1], isMobile ? "below right" : "above");
        graphie.label([options.range[0][1], 0], options.labels[0], isMobile ? "above left" : "right");
      } else if (options.markings === "grid") {
        graphie.graphInit({
          range: options.range,
          scale: ___default["default"].pluck(options.gridConfig, "scale"),
          gridStep: options.gridStep,
          axes: false,
          ticks: false,
          labels: false,
          isMobile: isMobile
        });
      } else if (options.markings === "none") {
        graphie.init({
          range: options.range,
          scale: ___default["default"].pluck(options.gridConfig, "scale")
        });
      }

      if (this.props.apiOptions.isMobile) {
        const hairlineStyle = {
          normalStyle: {
            strokeWidth: 1
          }
        }; // $FlowFixMe[invalid-constructor]

        this.horizHairline = new WrappedLine(graphie, [0, 0], [0, 0], hairlineStyle);
        this.horizHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        this.horizHairline.hide(); // $FlowFixMe[invalid-constructor]

        this.vertHairline = new WrappedLine(graphie, [0, 0], [0, 0], hairlineStyle);
        this.vertHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        this.vertHairline.hide();
      }
    });

    _defineProperty(this, "showHairlines", point => {
      if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
        // Hairlines are already initialized when the graph is loaded, so
        // here we just move them to the updated location and make them
        // visible.
        this.horizHairline.moveTo([this.props.graph.range[0][0], point[1]], [this.props.graph.range[0][1], point[1]]);
        this.horizHairline.show();
        this.vertHairline.moveTo([point[0], this.props.graph.range[1][0]], [point[0], this.props.graph.range[1][1]]);
        this.vertHairline.show();
      }
    });

    _defineProperty(this, "hideHairlines", () => {
      if (this.props.apiOptions.isMobile) {
        this.horizHairline.hide();
        this.vertHairline.hide();
      }
    });
  }

  render() {
    const type = this.props.plot.type;
    const coords = this.props.plot.coords;
    const asymptote = this.props.plot.asymptote;
    const typeSelector = /*#__PURE__*/React__namespace.createElement("div", {
      style: typeSelectorStyle,
      className: "above-scratchpad"
    }, /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: type,
      allowEmpty: true,
      buttons: ___default["default"].map(this.props.availableTypes, typeToButton),
      onChange: this.handleActiveTypeChange
    }));
    const box = getInteractiveBoxFromSizeClass(this.props.containerSizeClass); // Calculate additional graph properties so that the same values are
    // passed in to both FunctionGrapher and Graphie.

    const options = { ...this.props.graph,
      ...getGridAndSnapSteps(this.props.graph, box[0]),
      gridConfig: this._getGridConfig({ ...this.props.graph,
        box: box,
        ...getGridAndSnapSteps(this.props.graph, box[0])
      })
    }; // The `graph` prop will eventually be passed to the <Graphie>
    // component. In fact, if model is `null`, this is functionalliy
    // identical to a <Graphie>. Otherwise, some points and a plot will be
    // overlayed.

    const grapherProps = {
      graph: {
        box: box,
        range: options.range,
        step: options.step,
        snapStep: options.snapStep,
        backgroundImage: options.backgroundImage,
        options: options,
        setup: this._setupGraphie
      },
      onChange: this.handlePlotChanges,
      model: type && functionForType(type),
      coords: coords,
      asymptote: asymptote,
      static: this.props.static,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
      isMobile: this.props.apiOptions.isMobile,
      showTooltips: this.props.graph.showTooltips,
      showHairlines: this.showHairlines,
      hideHairlines: this.hideHairlines
    };
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(FunctionGrapher, grapherProps), this.props.availableTypes.length > 1 && typeSelector);
  }

  _getGridConfig(options) {
    return options.step.map((step, i) => {
      return Util.gridDimensionConfig(step, options.range[i], options.box[i], options.gridStep[i]);
    });
  }

  _calculateMobileTickStep(gridStep, step, ranges) {
    const tickStep = Util.constrainedTickStepsFromTickSteps(step, ranges); // According to the graphInit documentation in graphie.js, tickStep is
    // relative to the grid units so we need to adjust all values by the
    // grid step.

    tickStep[0] = tickStep[0] / gridStep[0];
    tickStep[1] = tickStep[1] / gridStep[1];
    return tickStep;
  }

  simpleValidate(rubric) {
    return validate$2(this.getUserInput(), rubric);
  }

  getUserInput() {
    return Grapher.getUserInputFromProps(this.props);
  }

  focus() {}

  static validate(state, rubric) {
    return validate$2(state, rubric);
  }

  static getUserInputFromProps(props) {
    return props.plot;
  }

}

_defineProperty(Grapher, "defaultProps", DEFAULT_GRAPHER_PROPS);

const propTransform$3 = editorProps => {
  const widgetProps = {
    availableTypes: editorProps.availableTypes,
    graph: editorProps.graph
  }; // If there's only one type, the graph type is deterministic

  if (widgetProps.availableTypes.length === 1) {
    const graph = widgetProps.graph;
    const type = chooseType(widgetProps.availableTypes);
    widgetProps.plot = defaultPlotProps(type, graph);
  }

  return widgetProps;
}; // Note that in addition to the standard staticTransform, in static
// mode we set static=true for the graph's handles in FunctionGrapher.


const staticTransform$3 = editorProps => {
  return { ...propTransform$3(editorProps),
    // Don't display graph type choices if we're in static mode
    availableTypes: [editorProps.correct.type],
    // Display the same graph marked as correct in the widget editor.
    plot: editorProps.correct
  };
};

var Grapher$1 = {
  name: "grapher",
  displayName: "Grapher",
  widget: Grapher,
  transform: propTransform$3,
  staticTransform: staticTransform$3
};

class Group extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "getUserInput", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.getUserInput();
    });

    _defineProperty(this, "getSerializedState", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.getSerializedState();
    });

    _defineProperty(this, "restoreSerializedState", (state, callback) => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.restoreSerializedState(state, callback); // Tell our renderer that we have no props to change
      // (all our changes were in state):

      return null;
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.score();
    });

    _defineProperty(this, "getInputPaths", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.getInputPaths();
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.setInputValue(path, newValue, cb);
    });

    _defineProperty(this, "focus", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.focus();
    });

    _defineProperty(this, "focusInputPath", path => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.focusPath(path);
    });

    _defineProperty(this, "blurInputPath", path => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.blurPath(path);
    });

    _defineProperty(this, "showRationalesForCurrentlySelectedChoices", () => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.showRationalesForCurrentlySelectedChoices();
    });
  }

  componentDidMount() {
    // TODO(marcia): See comment in render method about our cyclical
    // numbering scheme. We force another render so that we can annotate
    // the group with the correct number.
    this.forceUpdate();
  }

  render() {
    const apiOptions = ___default["default"].extend({}, ApiOptions.defaults, this.props.apiOptions, {
      // Api Rewriting to support correct onFocus/onBlur
      // events for the mobile API
      onFocusChange: (newFocus, oldFocus) => {
        if (oldFocus) {
          this.props.onBlur(oldFocus);
        }

        if (newFocus) {
          this.props.onFocus(newFocus);
        }
      }
    }); // Allow a problem number annotation to be added.
    // This is cyclical and should probably be reconsidered. In order to
    // render the annotation ("Question 3 of 10"), we call findWidgets to
    // figure out our index in the list of all fellow group widgets. On
    // first render, though, we don't exist yet in this list, and so we
    // give ourselves number -1. To combat this, we forceUpdate in
    // componentDidMount so that we can number ourselves properly. But,
    // really we should have a more unidirectional flow. TODO(marcia): fix.


    const number = ___default["default"].indexOf(this.props.findWidgets("group"), this);

    const problemNumComponent = this.props.apiOptions.groupAnnotator(number, this.props.widgetId); // This is a little strange because the id of the widget that actually
    // changed is going to be lost in favor of the group widget's id. The
    // widgets prop also wasn't actually changed, and this only serves to
    // alert our renderer (our parent) of the fact that some interaction
    // has occurred.

    const onInteractWithWidget = id => {
      // eslint-disable-next-line react/no-string-refs
      if (this.refs.renderer) {
        // eslint-disable-next-line react/no-string-refs
        this.change("widgets", this.refs.renderer.props.widgets);
      }
    }; // eslint-disable-next-line react/no-string-refs


    const score = this.refs.renderer && this.refs.renderer.score();
    const isValid = score && score.type !== "invalid";
    const isInvalid = score && score.type === "invalid"; // TODO(mdr): Widgets inside this Renderer are not discoverable through
    //     the parent Renderer's `findWidgets` function.

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames__default["default"]({
        "perseus-group": true,
        "perseus-group-valid-answer": isValid,
        "perseus-group-invalid-answer": isInvalid
      })
    }, problemNumComponent, /*#__PURE__*/React__namespace.createElement(Renderer, _extends$1({}, this.props, {
      // eslint-disable-next-line react/no-string-refs
      ref: "renderer",
      apiOptions: apiOptions,
      findExternalWidgets: this.props.findWidgets,
      reviewMode: !!this.props.reviewModeRubric,
      onInteractWithWidget: onInteractWithWidget,
      linterContext: this.props.linterContext
    })), this.props.icon && /*#__PURE__*/React__namespace.createElement("div", {
      className: "group-icon"
    }, this.props.icon));
  }

}

_defineProperty(Group, "defaultProps", {
  content: "",
  widgets: {},
  images: {},
  linterContext: PerseusLinter.linterContextDefault
});

const traverseChildWidgets$1 = function (props, traverseRenderer) {
  return ___default["default"].extend({}, props, traverseRenderer(props));
};

var Group$1 = {
  name: "group",
  displayName: "Group (SAT only)",
  widget: Group,
  traverseChildWidgets: traverseChildWidgets$1,
  hidden: false,
  isLintable: true
};

const {
  updateQueryString
} = Util;
/* This renders the iframe and handles validation via window.postMessage */

class Iframe extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "getUserInput", () => {
      return WidgetJsonifyDeprecated.getUserInput.call(this);
    });

    _defineProperty(this, "handleMessageEvent", e => {
      // We receive data from the iframe that contains {passed: true/false}
      //  and use that to set the status
      // It could also contain an optional message
      let data = {};

      try {
        data = JSON.parse(e.originalEvent.data);
      } catch (err) {
        return;
      }

      if (___default["default"].isUndefined(data.testsPassed)) {
        return;
      }

      const status = data.testsPassed ? "correct" : "incorrect";
      this.change({
        status: status,
        message: data.message
      });
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return Iframe.validate(this.getUserInput(), rubric);
    });
  }

  componentDidMount() {
    $__default["default"](window).on("message", this.handleMessageEvent);
  }

  componentWillUnmount() {
    $__default["default"](window).off("message", this.handleMessageEvent);
  }

  render() {
    const style = {
      width: String(this.props.width),
      height: String(this.props.height)
    };
    const {
      InitialRequestUrl
    } = getDependencies(); // Add "px" to unitless numbers

    Object.entries(style).forEach(_ref => {
      let [key, value] = _ref;

      // $FlowFixMe[incompatible-use]
      if (!value.endsWith("%") && !value.endsWith("px")) {
        // $FlowFixMe[unclear-addition]
        style[key] = value + "px";
      }
    });
    let url = this.props.url; // If the URL doesnt start with http, it must be a program ID

    if (url && url.length && url.indexOf("http") !== 0) {
      url = "https://www.khanacademy.org/computer-programming/program/" + url + "/embedded?buttons=no&embed=yes&editor=no&author=no";
      url = updateQueryString(url, "width", this.props.width);
      url = updateQueryString(url, "height", this.props.height); // Origin is used by output.js in deciding to send messages

      url = updateQueryString(url, "origin", InitialRequestUrl.origin);
    } // Turn array of [{name: "", value: ""}] into object


    if (this.props.settings) {
      const settings = {};

      ___default["default"].each(this.props.settings, function (setting) {
        if (setting.name && setting.value) {
          settings[setting.name] = setting.value;
        }
      }); // This becomes available to programs as Program.settings()


      url = updateQueryString(url, "settings", JSON.stringify(settings));
    }

    let sandboxProperties = "allow-same-origin allow-scripts"; // TODO(scottgrant): This line is an intentional hack to retain the
    // allow-top-navigation sandbox property. Once our LearnStorm articles
    // have this value checked and published, this line should be removed
    // and replaced with the conditional check below that is commented out.
    // We don't want to break LearnStorm badges, so this will be a two-part
    // deploy.

    sandboxProperties += " allow-top-navigation"; // if (this.props.allowTopNavigation === true) {
    //     sandboxProperties += " allow-top-navigation";
    // }
    // We sandbox the iframe so that we whitelist only the functionality
    //  that we need. This makes it a bit safer in case some content
    //  creator "went wild".
    // http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/

    return /*#__PURE__*/React__namespace.createElement("iframe", {
      sandbox: sandboxProperties,
      style: style,
      src: url,
      allowFullScreen: this.props.allowFullScreen
    });
  }

}
/**
 * This is the widget's grading function
 */


_defineProperty(Iframe, "propTypes", { ...propTypes,
  width: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
  height: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
  url: PropTypes__default["default"].string,
  settings: PropTypes__default["default"].array,
  status: PropTypes__default["default"].oneOf(["incomplete", "incorrect", "correct"]),
  message: PropTypes__default["default"].string,
  allowFullScreen: PropTypes__default["default"].bool,
  allowTopNavigation: PropTypes__default["default"].bool
});

_defineProperty(Iframe, "defaultProps", {
  status: "incomplete",
  // optional message
  message: null,
  allowFullScreen: false,
  allowTopNavigation: false
});

___default["default"].extend(Iframe, {
  validate: function (state, rubric) {
    // The iframe can tell us whether it's correct or incorrect,
    //  and pass an optional message
    if (state.status === "correct") {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: state.message || null
      };
    }

    if (state.status === "incorrect") {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: state.message || null
      };
    }

    return {
      type: "invalid",
      message: "Keep going, you're not there yet!"
    };
  }
});

var Iframe$1 = {
  name: "iframe",
  displayName: "Iframe",
  widget: Iframe,
  // Let's not expose it to all content creators yet
  hidden: true
};

const defaultBoxSize$2 = 400;
const defaultRange = [0, 10];
const defaultBackgroundImage$3 = {
  url: null,
  width: 0,
  height: 0
};
const editorAlignments = ["block", "full-width"];
const DEFAULT_ALIGNMENT = "block";

class ImageWidget extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "getUserInput", () => {
      return null;
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return ImageWidget.validate(this.getUserInput(), rubric);
    });

    _defineProperty(this, "focus", () => {});
  }

  // no-op
  render() {
    let image;
    let alt;
    const {
      apiOptions
    } = this.props;
    const backgroundImage = this.props.backgroundImage;

    if (backgroundImage.url) {
      image = /*#__PURE__*/React__namespace.createElement(SvgImage, {
        src: backgroundImage.url,
        alt:
        /* alt text is formatted in a sr-only
               div next to the image in addition to
               the alt attribute.
               If there is no alt text at all,
               we don't put an alt attribute on
               the image, so that screen readers
               know there's something they can't
               read there :(.
               NOTE: React <=0.13 (maybe later)
               has a bug where it won't ever
               remove an attribute, so if this
               alt node is ever defined it's
               not removed. This is sort of
               dangerous, but we usually re-key
               new renderers so that they're
               rendered from scratch anyways,
               so this shouldn't be a problem
               in practice right now, although
               it will exhibit weird behaviour
               while editing. */
        this.props.alt,
        overrideAriaHidden: true,
        width: backgroundImage.width,
        height: backgroundImage.height,
        preloader: apiOptions.imagePreloader,
        extraGraphie: {
          box: this.props.box,
          range: this.props.range,
          labels: this.props.labels
        },
        trackInteraction: this.props.trackInteraction,
        zoomToFullSizeOnMobile: apiOptions.isMobile,
        constrainHeight: apiOptions.isMobile,
        allowFullBleed: apiOptions.isMobile
      });
    }

    if (this.props.alt) {
      alt = /*#__PURE__*/React__namespace.createElement("span", {
        className: "perseus-sr-only"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: this.props.alt,
        apiOptions: apiOptions,
        linterContext: this.props.linterContext
      }));
    } // For mobile we combine an image's title and caption.


    if (apiOptions.isMobile) {
      let titleAndCaption;

      if (this.props.title || this.props.caption) {
        let title = this.props.title; // Bold the title, and make it the first sentence of the
        // caption.

        if (title) {
          // We add a period to separate the title from the caption
          // (if it exists), unless the title already ends with a
          // punctuation symbol (whitespace ignored). Copied from
          // webapp: https://github.com/Khan/webapp/blob/6e930637edb65696d0749ea0f7558214aee32b4e/javascript/tutorial-shared-package/components/content-description.jsx#L80
          // TODO(charlie): Internationalize this check, and the
          // delimiter that is being inserted.
          if (this.props.caption && !/[.?!"']\s*$/.test(title)) {
            title += ".";
          }

          title = "**".concat(title, "** ");
        }

        const className = classNames__default["default"]({
          "perseus-image-caption": true,
          "has-title": !!title
        }); // Caption is left-aligned within a container that's centered
        // below the image, with these width constraints:
        //
        // 1. Size caption to width of the image on-screen.
        // 2. ... but constrain its width to a range based on the
        //    device to optimize readability - e.g. [320px, 450px] for
        //    phones.
        // 3. ... unless the image is floated, in which case we don't
        //    want the caption to overflow the image size.
        //
        // TODO(david): If caption is only 1 line long, center-align
        //     the text.

        const alignment = this.props.alignment;
        const isImageFullWidth = alignment === "block" || alignment === "full-width"; // This minWidth takes precedence over minWidth applied via
        // Aphrodite.

        const minWidth = isImageFullWidth ? null : "0 !important";
        titleAndCaption = /*#__PURE__*/React__namespace.createElement("div", {
          className: className
        }, /*#__PURE__*/React__namespace.createElement("div", {
          className: aphrodite.css(styles$n.caption),
          style: {
            minWidth: minWidth
          }
        }, /*#__PURE__*/React__namespace.createElement(Renderer, {
          content: title + this.props.caption,
          apiOptions: apiOptions,
          linterContext: this.props.linterContext
        })));
      }

      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-image-widget"
      }, image, alt, titleAndCaption);
    }

    let title;
    let caption;

    if (this.props.title) {
      title = /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-image-title"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: this.props.title,
        apiOptions: apiOptions,
        linterContext: this.props.linterContext
      }));
    }

    if (this.props.caption) {
      caption = /*#__PURE__*/React__namespace.createElement("div", {
        className: "perseus-image-caption"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: this.props.caption,
        apiOptions: apiOptions,
        linterContext: this.props.linterContext
      }));
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-image-widget"
    }, title, image, alt, caption);
  }

  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }

}

_defineProperty(ImageWidget, "defaultProps", {
  alignment: DEFAULT_ALIGNMENT,
  title: "",
  range: [defaultRange, defaultRange],
  box: [defaultBoxSize$2, defaultBoxSize$2],
  backgroundImage: defaultBackgroundImage$3,
  labels: [],
  alt: "",
  caption: "",
  linterContext: PerseusLinter.linterContextDefault
});

const styles$n = aphrodite.StyleSheet.create({
  caption: {
    display: "inline-block",
    marginTop: baseUnitPx,
    maxWidth: 640,
    [mediaQueries.lgOrSmaller]: {
      // TODO(david): This maxWidth is not being used because
      //     it's overriden by the 512px max-width we have on
      //     paragraphs.
      maxWidth: 540
    },
    [mediaQueries.smOrSmaller]: {
      maxWidth: 450
    }
  }
});
var Image$1 = {
  name: "image",
  // This widget's accessibility depends on its contents: if the image has
  // has a background but no alt text, it is not accessible
  accessible: widgetOptions => {
    const bgImage = widgetOptions.backgroundImage;
    return !(bgImage && bgImage.url && !widgetOptions.alt);
  },
  defaultAlignment: DEFAULT_ALIGNMENT,
  supportedAlignments: editorAlignments,
  displayName: "Image",
  widget: ImageWidget,
  isLintable: true
};

// $FlowFixMe[prop-missing]
const Label$1 = Graphie.Label; // $FlowFixMe[prop-missing]

const Line$2 = Graphie.Line; // $FlowFixMe[prop-missing]

const MovablePoint$2 = Graphie.MovablePoint; // $FlowFixMe[prop-missing]

const MovableLine$1 = Graphie.MovableLine; // $FlowFixMe[prop-missing]

const Plot = Graphie.Plot; // $FlowFixMe[prop-missing]

const PlotParametric = Graphie.PlotParametric; // $FlowFixMe[prop-missing]

const Point = Graphie.Point; // $FlowFixMe[prop-missing]

const Rect = Graphie.Rect;
const {
  unescapeMathMode
} = Util; // Memoize KAS parsing

const KAShashFunc = (expr, options) => {
  options = options || {}; // $FlowFixMe[prop-missing]: decimal_separator
  // $FlowFixMe[incompatible-type]

  let result = expr + "||" + options.decimal_separator + "||";
  const functions = options.functions;
  const functionsLength = functions ? functions.length : 0;

  for (let i = 0; i < functionsLength; i++) {
    result += functions[i] + "|";
  }

  return result;
};

const _parseCache = Object.create(null);

const KASparse = (expr, options) => {
  const hash = KAShashFunc(expr, options);
  let cached = _parseCache[hash];

  if (cached) {
    return cached;
  }

  cached = KAS__namespace.parse(expr, options);
  _parseCache[hash] = cached;
  return cached;
};

const _compileCache = Object.create(null);

const KAScompile = (expr, options) => {
  const hash = KAShashFunc(expr, options);
  let cached = _compileCache[hash];

  if (cached) {
    return cached;
  }

  const parsed = KAS__namespace.parse(expr, options).expr;
  cached = parsed ? parsed.compile() : function () {
    return 0;
  };
  _compileCache[hash] = cached;
  return cached;
};

class Interaction extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "state", {
      variables: _getInitialVariables(this.props.elements),
      functions: _getInitialFunctions(this.props.elements)
    });

    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      graphie.graphInit(___default["default"].extend({}, options, {
        grid: ___default["default"].contains(["graph", "grid"], this.props.graph.markings),
        axes: ___default["default"].contains(["graph"], this.props.graph.markings),
        ticks: ___default["default"].contains(["graph"], this.props.graph.markings),
        labels: ___default["default"].contains(["graph"], this.props.graph.markings),
        labelFormat: function (s) {
          return "\\small{" + s + "}";
        },
        axisArrows: "<->",
        unityLabels: false
      }));
    });

    _defineProperty(this, "_updatePointLocation", (subscript, coord) => {
      const variables = ___default["default"].clone(this.state.variables);

      variables["x_" + subscript] = coord[0];
      variables["y_" + subscript] = coord[1];
      this.setState({
        variables: variables
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "_updateLineLocation", (options, startCoord) => {
      const xDiff = this._eval("(" + options.endX + ")-(" + options.startX + ")");

      const yDiff = this._eval("(" + options.endY + ")-(" + options.startY + ")");

      const endCoord = kmath.vector.add(startCoord, [xDiff, yDiff]);

      const variables = ___default["default"].clone(this.state.variables);

      variables["x_" + options.startSubscript] = startCoord[0];
      variables["y_" + options.startSubscript] = startCoord[1];
      variables["x_" + options.endSubscript] = endCoord[0];
      variables["y_" + options.endSubscript] = endCoord[1];
      this.setState({
        variables: variables
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "_eval", (expression, variables) => {
      const func = KAScompile(expression, {
        functions: this.state.functions
      });

      const compiledVars = ___default["default"].extend({}, this.state.variables, variables);

      ___default["default"].each(___default["default"].keys(compiledVars), name => {
        if (___default["default"].isString(compiledVars[name])) {
          const func = KAScompile(compiledVars[name], {
            functions: this.state.functions
          });

          compiledVars[name] = function (x) {
            return func( // $FlowFixMe[extra-arg]
            ___default["default"].extend({}, compiledVars, {
              x: x
            }));
          };
        }
      }); // Default to 0 if the expression couldn't be parsed
      // $FlowFixMe[extra-arg]


      return func(compiledVars) || 0;
    });

    _defineProperty(this, "_extractVars", expr => {
      if (expr == null) {
        return [];
      }

      let vars = [];

      ___default["default"].each(expr.args(), function (arg) {
        if (arg && arg.constructor.name === "Expr") {
          vars = vars.concat(this._extractVars(arg));
        }
      }, this);

      if (expr.name() === "Var") {
        vars.push(expr.prettyPrint());
      }

      return vars;
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "getUserInput", () => {
      // TODO(eater): Perhaps we want to be able to record the state of the
      // user's interaction. Unfortunately sending all the props will
      // probably make the attempt payload too large. So for now, don't send
      // anything.
      return {};
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Interaction.validate(this.getUserInput(), rubric);
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // HACK(michaelpolyak): This widget is not wired to use the Perseus
    // `onChange` callback to save user changes. Perseus re-rendering of the
    // widget results in the loss of user changes, such as reseting the
    // positions of the movable points and lines to the initial positions
    // defined in the widget editor. The workaround here is to only reset
    // the state if there are changes to props. This workaround is only
    // possible because the widget is not designed to be graded. The correct
    // fix would be to transform `variables` to the shape of `elements` and
    // call `this.props.onChange({elements})` to preserve user changes using
    // the Perseus state saving mechanism.
    if (!___default["default"].isEqual(this.props.elements, nextProps.elements)) {
      this.setState({
        variables: _getInitialVariables(nextProps.elements),
        functions: _getInitialFunctions(nextProps.elements)
      });
    }
  }

  render() {
    const range = this.props.graph.range;
    let labels = this.props.graph.labels;

    if (this.props.graph.markings === "graph") {
      // Content creators may need to explicitly add the dollar signs so
      // the strings are picked up by our translation tools. However,
      // these math annotations are redundant because we already render
      // all graph labels in math mode. For example, a label value of
      // `$\text{Dollars}$` will be translatable, but we only want to
      // pass the string `\text{Dollars}` to the Graph widget.
      labels = this.props.graph.labels.map(label => label.startsWith("$") && label.endsWith("$") ? label.slice(1, -1) : label);
    }

    return /*#__PURE__*/React__namespace.createElement(Graphie, {
      box: this.props.graph.box,
      range: this.props.graph.range,
      options: this.props.graph,
      setup: this._setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }, this.props.graph.markings === "graph" && /*#__PURE__*/React__namespace.createElement(Label$1, {
      coord: [0, range[1][1]],
      text: labels[1],
      direction: "above"
    }), this.props.graph.markings === "graph" && /*#__PURE__*/React__namespace.createElement(Label$1, {
      coord: [range[0][1], 0],
      text: labels[0],
      direction: "right"
    }), ___default["default"].map(this.props.elements, function (element, n) {
      if (element.type === "point") {
        return /*#__PURE__*/React__namespace.createElement(Point, {
          key: element.key,
          coord: [this._eval(element.options.coordX), this._eval(element.options.coordY)],
          color: element.options.color
        });
      }

      if (element.type === "line") {
        const start = [this._eval(element.options.startX), this._eval(element.options.startY)];
        const end = [this._eval(element.options.endX), this._eval(element.options.endY)];
        return /*#__PURE__*/React__namespace.createElement(Line$2, {
          key: element.key,
          start: start,
          end: end,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            arrows: element.options.arrows
          }
        });
      }

      if (element.type === "movable-point") {
        // TODO(eater): Would be nice if the constraint
        // system were more flexible.
        const constraints = [coord => {
          const coordX = Math.max(this._eval(element.options.constraintXMin), Math.min(this._eval(element.options.constraintXMax), coord[0]));
          const coordY = Math.max(this._eval(element.options.constraintYMin), Math.min(this._eval(element.options.constraintYMax), coord[1]));
          return [coordX, coordY];
        }];

        if (element.options.constraint === "snap") {
          constraints.push(MovablePoint$2.constraints.snap(element.options.snap));
        } else if (element.options.constraint === "x") {
          constraints.push(coord => {
            return [this._eval(element.options.constraintFn, {
              y: coord[1]
            }), coord[1]];
          });
        } else if (element.options.constraint === "y") {
          constraints.push(coord => {
            return [coord[0], this._eval(element.options.constraintFn, {
              x: coord[0]
            })];
          });
        } // TODO(eater): foo_[xyz] are hacky non-props to
        // get the component to update when constraints
        // change


        return /*#__PURE__*/React__namespace.createElement(MovablePoint$2, {
          key: element.key,
          coord: [this.state.variables["x_" + element.options.varSubscript], this.state.variables["y_" + element.options.varSubscript]],
          constraints: constraints,
          foo_x: element.options.constraint,
          foo_y: element.options.constraintFn,
          foo_z: element.options.snap,
          onMove: ___default["default"].partial(this._updatePointLocation, element.options.varSubscript)
        });
      }

      if (element.type === "movable-line") {
        // TODO(eater): Would be nice if the constraint
        // system were more flexible.
        // TODO(eater): Don't duplicate this code from
        // movable-point above
        const constraints = [coord => {
          const coordX = Math.max(this._eval(element.options.constraintXMin), Math.min(this._eval(element.options.constraintXMax), coord[0]));
          const coordY = Math.max(this._eval(element.options.constraintYMin), Math.min(this._eval(element.options.constraintYMax), coord[1]));
          return [coordX, coordY];
        }];

        if (element.options.constraint === "snap") {
          constraints.push(MovablePoint$2.constraints.snap(element.options.snap));
        } else if (element.options.constraint === "x") {
          constraints.push(coord => {
            return [this._eval(element.options.constraintFn, {
              y: coord[1]
            }), coord[1]];
          });
        } else if (element.options.constraint === "y") {
          constraints.push(coord => {
            return [coord[0], this._eval(element.options.constraintFn, {
              x: coord[0]
            })];
          });
        }

        const start = [this.state.variables["x_" + element.options.startSubscript], this.state.variables["y_" + element.options.startSubscript]];
        const end = [this.state.variables["x_" + element.options.endSubscript], this.state.variables["y_" + element.options.endSubscript]];
        return /*#__PURE__*/React__namespace.createElement(MovableLine$1, {
          key: element.key,
          constraints: constraints // eslint-disable-next-line react/jsx-no-bind
          ,
          onMove: ___default["default"].bind(this._updateLineLocation, this, element.options),
          foo_x: element.options.constraint,
          foo_y: element.options.constraintFn,
          foo_z: element.options.snap
        }, /*#__PURE__*/React__namespace.createElement(MovablePoint$2, {
          coord: start,
          static: true,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        }), /*#__PURE__*/React__namespace.createElement(MovablePoint$2, {
          coord: end,
          static: true,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        }));
      }

      if (element.type === "function") {
        const fn = x => {
          return this._eval(element.options.value, {
            x: x
          });
        }; // find all the variables referenced by this
        // function


        const vars = ___default["default"].without(this._extractVars(KASparse(element.options.value).expr), "x"); // and find their values, so we redraw if any
        // change


        const varValues = ___default["default"].object(vars, ___default["default"].map(vars, v => this.state.variables[v]));

        const range = [this._eval(element.options.rangeMin, this.state.variables), this._eval(element.options.rangeMax, this.state.variables)];
        return /*#__PURE__*/React__namespace.createElement(Plot, {
          key: element.key,
          fn: fn,
          foo_fn: element.options.value,
          foo_varvalues: varValues,
          range: range,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            plotPoints: 100 // TODO(eater): why
            // so slow?

          }
        });
      }

      if (element.type === "parametric") {
        const fn = t => {
          return [this._eval(element.options.x, {
            t: t
          }), this._eval(element.options.y, {
            t: t
          })];
        }; // find all the variables referenced by this
        // function


        const vars = ___default["default"].without(this._extractVars(KASparse(element.options.x).expr).concat(this._extractVars(KASparse(element.options.y).expr)), "t"); // and find their values, so we redraw if any change


        const varValues = ___default["default"].object(vars, ___default["default"].map(vars, v => this.state.variables[v]));

        const range = [this._eval(element.options.rangeMin, this.state.variables), this._eval(element.options.rangeMax, this.state.variables)];
        return /*#__PURE__*/React__namespace.createElement(PlotParametric, {
          key: element.key,
          fn: fn,
          foo_fnx: element.options.x,
          foo_fny: element.options.y,
          foo_varvalues: varValues,
          range: range,
          style: {
            stroke: element.options.color,
            strokeWidth: element.options.strokeWidth,
            strokeDasharray: element.options.strokeDasharray,
            plotPoints: 100 // TODO(eater): why
            // so slow?

          }
        });
      }

      if (element.type === "label") {
        const coord = [this._eval(element.options.coordX), this._eval(element.options.coordY)];
        return /*#__PURE__*/React__namespace.createElement(Label$1, {
          key: n + 1,
          coord: coord,
          text: unescapeMathMode(element.options.label),
          style: {
            color: element.options.color
          }
        });
      }

      if (element.type === "rectangle") {
        return /*#__PURE__*/React__namespace.createElement(Rect, {
          key: n + 1,
          x: this._eval(element.options.coordX),
          y: this._eval(element.options.coordY),
          width: ___default["default"].max([this._eval(element.options.width), 0]),
          height: ___default["default"].max([this._eval(element.options.height), 0]),
          style: {
            stroke: "none",
            fill: element.options.color
          }
        });
      }
    }, this));
  }

  static validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }

}

_defineProperty(Interaction, "defaultProps", {
  graph: {
    box: [400, 400],
    labels: ["x", "y"],
    range: [[-10, 10], [-10, 10]],
    tickStep: [1, 1],
    gridStep: [1, 1],
    markings: "graph"
  },
  elements: []
});

const _getInitialVariables = elements => {
  const variables = {}; // TODO(eater): look at all this copypasta! refactor this!

  ___default["default"].each(___default["default"].where(elements, {
    type: "movable-point"
  }), element => {
    const subscript = element.options.varSubscript;
    const startXExpr = KASparse(element.options.startX || "0").expr;
    const startYExpr = KASparse(element.options.startY || "0").expr;
    let startX = 0;
    let startY = 0;

    if (startXExpr) {
      startX = startXExpr.eval({}) || 0;
    }

    if (startYExpr) {
      startY = startYExpr.eval({}) || 0;
    }

    variables["x_" + subscript] = startX;
    variables["y_" + subscript] = startY;
  });

  ___default["default"].each(___default["default"].where(elements, {
    type: "movable-line"
  }), element => {
    const startSubscript = element.options.startSubscript;
    const endSubscript = element.options.endSubscript;
    const startXExpr = KASparse(element.options.startX || "0").expr;
    const startYExpr = KASparse(element.options.startY || "0").expr;
    const endXExpr = KASparse(element.options.endX || "0").expr;
    const endYExpr = KASparse(element.options.endY || "0").expr;
    let startX = 0;
    let startY = 0;
    let endX = 0;
    let endY = 0;

    if (startXExpr) {
      startX = startXExpr.eval({}) || 0;
    }

    if (startYExpr) {
      startY = startYExpr.eval({}) || 0;
    }

    if (endXExpr) {
      endX = endXExpr.eval({}) || 0;
    }

    if (endYExpr) {
      endY = endYExpr.eval({}) || 0;
    }

    variables["x_" + startSubscript] = startX;
    variables["y_" + startSubscript] = startY;
    variables["x_" + endSubscript] = endX;
    variables["y_" + endSubscript] = endY;
  });

  ___default["default"].each(___default["default"].where(elements, {
    type: "function"
  }), element => {
    variables[element.options.funcName] = element.options.value;
  });

  return variables;
};

const _getInitialFunctions = elements => {
  return ___default["default"].map(___default["default"].where(elements, {
    type: "function"
  }), element => element.options.funcName);
};

var Interactive = {
  name: "interaction",
  displayName: "Interaction",
  widget: Interaction,
  transform: ___default["default"].identity,
  hidden: true
};

const defaultBackgroundImage$2 = {
  url: null
};
/* Style objects */

const defaultInstructionsStyle = {
  fontStyle: "italic",
  fontWeight: "bold",
  fontSize: "32px",
  width: "100%",
  height: "100%",
  textAlign: "center",
  backgroundColor: "white",
  position: "absolute",
  zIndex: 1,
  transition: "opacity .25s ease-in-out",
  "-moz-transition": "opacity .25s ease-in-out",
  "-webkit-transition": "opacity .25s ease-in-out"
};
const instructionsTextStyle = {
  position: "relative",
  top: "25%"
};

function numSteps$1(range, step) {
  return Math.floor((range[1] - range[0]) / step);
}

class Graph extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "protractor", void 0);

    _defineProperty(this, "ruler", void 0);

    _defineProperty(this, "_graphie", void 0);

    _defineProperty(this, "_hasSetupGraphieThisUpdate", void 0);

    _defineProperty(this, "_shouldSetupGraphie", void 0);

    _defineProperty(this, "reset", () => {
      this._setupGraphie(false);
    });

    _defineProperty(this, "graphie", () => {
      return this._graphie;
    });

    _defineProperty(this, "pointsFromNormalized", (coordsList, noSnap) => {
      const self = this;
      return ___default["default"].map(coordsList, function (coords) {
        return ___default["default"].map(coords, function (coord, i) {
          const range = self.props.range[i];

          if (noSnap) {
            return range[0] + (range[1] - range[0]) * coord;
          }

          const step = self.props.step[i];
          const nSteps = numSteps$1(range, step);
          const tick = Math.round(coord * nSteps);
          return range[0] + step * tick;
        });
      });
    });

    _defineProperty(this, "_setupGraphie", initialMount => {
      // Only setupGraphie once per componentDidUpdate().
      // This prevents this component from rendering graphie
      // and then immediately re-render graphie because its
      // parent component asked it to. This will happen when
      // props on the parent and props on this component both
      // require graphie to be re-rendered.
      if (this._hasSetupGraphieThisUpdate) {
        return;
      } // eslint-disable-next-line react/no-string-refs


      const graphieDiv = ReactDOM__default["default"].findDOMNode(this.refs.graphieDiv);
      $__default["default"](graphieDiv).empty(); // Content creators may need to explicitly add the dollar signs so the
      // strings are picked up by our translation tools. However, these math
      // annotations are redundant because we already render all graph labels
      // in math mode. For example, a label value of `$\text{Dollars}$` will
      // be translatable, but we only want to pass the string
      // `\text{Dollars}` to the Graph widget.

      const labels = this.props.labels.map(label => Util.unescapeMathMode(label));
      const range = this.props.range;
      const graphie = this._graphie = GraphUtils.createGraphie(graphieDiv);

      const gridConfig = this._getGridConfig();

      graphie.snap = this.props.snapStep;

      if (this.props.markings === "graph") {
        graphie.graphInit({
          range: range,
          scale: ___default["default"].pluck(gridConfig, "scale"),
          axisArrows: "<->",
          labelFormat: function (s) {
            return "\\small{" + s + "}";
          },
          gridStep: this.props.gridStep,
          tickStep: ___default["default"].pluck(gridConfig, "tickStep"),
          labelStep: 1,
          unityLabels: ___default["default"].pluck(gridConfig, "unityLabel"),
          isMobile: this.props.isMobile
        });
        graphie.label([0, range[1][1]], labels[1], this.props.isMobile ? "below right" : "above");
        graphie.label([range[0][1], 0], labels[0], this.props.isMobile ? "above left" : "right");
      } else if (this.props.markings === "grid") {
        graphie.graphInit({
          range: range,
          scale: ___default["default"].pluck(gridConfig, "scale"),
          gridStep: this.props.gridStep,
          axes: false,
          ticks: false,
          labels: false,
          isMobile: this.props.isMobile
        });
      } else if (this.props.markings === "none") {
        graphie.init({
          range: range,
          scale: ___default["default"].pluck(gridConfig, "scale"),
          isMobile: this.props.isMobile
        });
      } // Add instructions just before mouse layer


      const visible = 0.5;
      const invisible = 0.0;
      let $instructionsWrapper;

      if (this.props.instructions) {
        $instructionsWrapper = $__default["default"]("<div/>");

        ___default["default"].each(defaultInstructionsStyle, function (value, key) {
          // $FlowFixMe[incompatible-use]
          $instructionsWrapper.css(key, value);
        }); // $FlowFixMe[incompatible-use]


        $instructionsWrapper.css("opacity", visible);
        const $instructions = $__default["default"]("<span/>", {
          text: this.props.instructions
        });

        ___default["default"].each(instructionsTextStyle, function (value, key) {
          $instructions.css(key, value);
        }); // $FlowFixMe[incompatible-use]


        $instructionsWrapper.append($instructions);
        $__default["default"](graphieDiv).append($instructionsWrapper);
      } else {
        $instructionsWrapper = undefined;
      } // Add some handlers for instructions text (if necessary)


      const onMouseDown = $instructionsWrapper || this.props.onMouseDown ? ___default["default"].bind(function (coord) {
        if ($instructionsWrapper) {
          $instructionsWrapper.remove();
          $instructionsWrapper = null;
        } // eslint-disable-next-line @babel/no-invalid-this


        this.props.onMouseDown(coord);
      }, this) : null;
      const onMouseOver = $instructionsWrapper ? function () {
        $instructionsWrapper && $instructionsWrapper.css("opacity", invisible);
      } : null;
      const onMouseOut = $instructionsWrapper ? function () {
        $instructionsWrapper && $instructionsWrapper.css("opacity", visible);
      } : null;
      /* eslint-enable indent */

      graphie.addMouseLayer({
        onClick: this.props.onClick,
        onMouseDown: onMouseDown,
        onMouseOver: onMouseOver,
        onMouseOut: onMouseOut,
        onMouseUp: this.props.onMouseUp,
        onMouseMove: this.props.onMouseMove,
        allowScratchpad: true,
        setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
      });

      this._updateProtractor();

      this._updateRuler(); // We set this flag before jumping into our callback
      // to avoid recursing if our callback calls reset() itself


      this._hasSetupGraphieThisUpdate = true;

      if (!initialMount && this.props.onGraphieUpdated) {
        // Calling a parent callback in componentDidMount is bad and
        // results in hard-to-reason-about lifecycle problems (esp. with
        // refs), so we do it only on update and rely on the parent to
        // query for the graphie object on initial mount
        this.props.onGraphieUpdated(graphie);
      }
    });

    _defineProperty(this, "_getGridConfig", () => {
      const self = this;
      return ___default["default"].map(self.props.step, function (step, i) {
        return Util.gridDimensionConfig(step, self.props.range[i], self.props.box[i], self.props.gridStep[i]);
      });
    });

    _defineProperty(this, "_updateProtractor", () => {
      if (this.protractor) {
        this.protractor.remove();
      }

      if (this.props.showProtractor) {
        const coord = this.pointsFromNormalized([[0.5, 0.05]])[0];
        this.protractor = this._graphie.protractor(coord);
      }
    });

    _defineProperty(this, "_updateRuler", () => {
      if (this.ruler) {
        this.ruler.remove();
      }

      if (this.props.showRuler) {
        const coord = this.pointsFromNormalized([[0.5, 0.25]])[0];
        const extent = this._graphie.range[0][1] - this._graphie.range[0][0];
        this.ruler = this._graphie.ruler({
          center: coord,
          label: this.props.rulerLabel,
          pixelsPerUnit: this._graphie.scale[0],
          ticksPerUnit: this.props.rulerTicks,
          units: Math.round(0.8 * extent)
        });
      }
    });

    _defineProperty(this, "toJSON", () => {
      return ___default["default"].pick(this.props, "range", "step", "markings", "labels", "backgroundImage", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "gridStep", "snapStep");
    });
  }

  render() {
    let image;
    const imageData = this.props.backgroundImage;

    if (imageData.url) {
      const scale = this.props.box[0] / interactiveSizes$1.defaultBoxSize;
      image =
      /*#__PURE__*/
      // $FlowFixMe[prop-missing]: `alt` is missing
      React__namespace.createElement(SvgImage, {
        src: imageData.url,
        width: imageData.width,
        height: imageData.height,
        scale: scale,
        responsive: false
      });
    } else {
      image = null;
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie-container above-scratchpad",
      style: {
        width: this.props.box[0],
        height: this.props.box[1]
      } // $FlowFixMe[prop-missing]: This can probably be removed
      ,
      onMouseOut: this.onMouseOut // $FlowFixMe[prop-missing]: This can probably be removed
      ,
      onMouseOver: this.onMouseOver // $FlowFixMe[prop-missing]: This can probably be removed
      ,
      onClick: this.onClick
    }, image, /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  }

  componentDidMount() {
    this._setupGraphie(true);
  }

  componentDidUpdate() {
    // Only setupGraphie once per componentDidUpdate().
    // See explanation in setupGraphie().
    this._hasSetupGraphieThisUpdate = false;

    if (this._shouldSetupGraphie) {
      this._setupGraphie(false);

      this._shouldSetupGraphie = false;
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    const potentialChanges = ["labels", "range", "step", "markings", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "gridStep", "snapStep"];
    const self = this;

    ___default["default"].each(potentialChanges, function (prop) {
      if (!___default["default"].isEqual(self.props[prop], nextProps[prop])) {
        self._shouldSetupGraphie = true;
      }
    });
  }
  /* Reset the graphie canvas to its initial state
   *
   * Use when re-rendering the parent component and you need a blank
   * graphie.
   */


}

_defineProperty(Graph, "propTypes", {
  box: PropTypes__default["default"].array.isRequired,
  labels: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  range: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].number)),
  step: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  gridStep: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  snapStep: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  markings: PropTypes__default["default"].string,
  backgroundImage: PropTypes__default["default"].shape({
    url: PropTypes__default["default"].string
  }),
  showProtractor: PropTypes__default["default"].bool,
  showRuler: PropTypes__default["default"].bool,
  rulerLabel: PropTypes__default["default"].string,
  rulerTicks: PropTypes__default["default"].number,
  onGraphieUpdated: PropTypes__default["default"].func,
  instructions: PropTypes__default["default"].string,
  onClick: PropTypes__default["default"].func,
  setDrawingAreaAvailable: PropTypes__default["default"].func,
  isMobile: PropTypes__default["default"].bool
});

_defineProperty(Graph, "defaultProps", {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  gridStep: [1, 1],
  snapStep: [0.5, 0.5],
  markings: "graph",
  backgroundImage: defaultBackgroundImage$2,
  showProtractor: false,
  showRuler: false,
  rulerLabel: "",
  rulerTicks: 10,
  instructions: null,
  onGraphieUpdated: null,
  onClick: null,
  onMouseDown: null,
  isMobile: false
});

const {
  DeprecationMixin
} = Util;
const TRASH_ICON_URI = "https://ka-perseus-graphie.s3.amazonaws.com/b1452c0d79fd0f7ff4c3af9488474a0a0decb361.png";
const defaultBackgroundImage$1 = {
  url: null
};
const eq = Util.eq;
const deepEq$2 = Util.deepEq;
const UNLIMITED = "unlimited"; // Sample background image:
// https://ka-perseus-graphie.s3.amazonaws.com/29c1b0fcd17fe63df0f148fe357044d5d5c7d0bb.png

function ccw(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
}

function collinear(a, b, c) {
  return eq(ccw(a, b, c), 0);
}

function sign(val) {
  if (eq(val, 0)) {
    return 0;
  }

  return val > 0 ? 1 : -1;
} // default to defaultValue if actual is null or undefined


function defaultVal(actual, defaultValue) {
  return actual == null ? defaultValue : actual;
} // Given rect bounding points A and B, whether point C is inside the rect


function pointInRect(a, b, c) {
  return c[0] <= Math.max(a[0], b[0]) && c[0] >= Math.min(a[0], b[0]) && c[1] <= Math.max(a[1], b[1]) && c[1] >= Math.min(a[1], b[1]);
} // Whether line segment AB intersects line segment CD
// http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/


function intersects(ab, cd) {
  const triplets = [[ab[0], ab[1], cd[0]], [ab[0], ab[1], cd[1]], [cd[0], cd[1], ab[0]], [cd[0], cd[1], ab[1]]];

  const orientations = ___default["default"].map(triplets, function (triplet) {
    return sign(ccw(...triplet));
  });

  if (orientations[0] !== orientations[1] && orientations[2] !== orientations[3]) {
    return true;
  }

  for (let i = 0; i < 4; i++) {
    if (orientations[i] === 0 && pointInRect(...triplets[i])) {
      return true;
    }
  }

  return false;
}

function vector(a, b) {
  return ___default["default"].map(___default["default"].zip(a, b), function (pair) {
    return pair[0] - pair[1];
  });
}

function magnitude(v) {
  return Math.sqrt(___default["default"].reduce(v, function (memo, el) {
    return memo + Math.pow(el, 2);
  }, 0));
}

function dotProduct(a, b) {
  return ___default["default"].reduce(___default["default"].zip(a, b), function (memo, pair) {
    return memo + pair[0] * pair[1];
  }, 0);
}

function sideLengths(coords) {
  const segments = ___default["default"].zip(coords, rotate(coords));

  return segments.map(function (segment) {
    return magnitude(vector(...segment));
  });
} // Based on http://math.stackexchange.com/a/151149


function angleMeasures(coords) {
  const triplets = ___default["default"].zip(rotate(coords, -1), coords, rotate(coords, 1));

  const offsets = ___default["default"].map(triplets, function (triplet) {
    const p = vector(triplet[1], triplet[0]);
    const q = vector(triplet[2], triplet[1]);
    const raw = Math.acos(dotProduct(p, q) / (magnitude(p) * magnitude(q)));
    return sign(ccw(...triplet)) > 0 ? raw : -raw;
  });

  const sum = ___default["default"].reduce(offsets, function (memo, arg) {
    return memo + arg;
  }, 0);

  return ___default["default"].map(offsets, function (offset) {
    return sum > 0 ? Math.PI - offset : Math.PI + offset;
  });
} // Whether two polygons are similar (or if specified, congruent)


function similar(coords1, coords2, tolerance) {
  if (coords1.length !== coords2.length) {
    return false;
  }

  const n = coords1.length;
  const angles1 = angleMeasures(coords1);
  const angles2 = angleMeasures(coords2);
  const sides1 = sideLengths(coords1);
  const sides2 = sideLengths(coords2);

  for (let i = 0; i < 2 * n; i++) {
    let angles = angles2.slice();
    let sides = sides2.slice(); // Reverse angles and sides to allow matching reflected polygons

    if (i >= n) {
      angles.reverse();
      sides.reverse(); // Since sides are calculated from two coordinates,
      // simply reversing results in an off by one error

      sides = rotate(sides, 1);
    }

    angles = rotate(angles, i);
    sides = rotate(sides, i);

    if (deepEq$2(angles1, angles)) {
      const sidePairs = ___default["default"].zip(sides1, sides);

      const factors = ___default["default"].map(sidePairs, function (pair) {
        return pair[0] / pair[1];
      });

      const same = ___default["default"].all(factors, function (factor) {
        return eq(factors[0], factor);
      });

      const congruentEnough = ___default["default"].all(sidePairs, function (pair) {
        return kmath.number.equal(pair[0], pair[1], tolerance);
      });

      if (same && congruentEnough) {
        return true;
      }
    }
  }

  return false;
} // Less than or approximately equal


function leq(a, b) {
  return a < b || eq(a, b);
} // Given triangle with sides ABC return angle opposite side C in degrees


function lawOfCosines(a, b, c) {
  return Math.acos((a * a + b * b - c * c) / (2 * a * b)) * 180 / Math.PI;
}

function canonicalSineCoefficients(_ref) {
  let [amplitude, angularFrequency, phase, verticalOffset] = _ref;

  // For a curve of the form f(x) = a * Sin(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  // Guarantee a > 0
  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }

  const period = 2 * Math.PI; // Guarantee b > 0

  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  } // Guarantee c is smallest possible positive value


  while (phase > 0) {
    phase -= period;
  }

  while (phase < 0) {
    phase += period;
  }

  return [amplitude, angularFrequency, phase, verticalOffset];
} // e.g. rotate([1, 2, 3]) -> [2, 3, 1]


function rotate(array, n) {
  n = typeof n === "undefined" ? 1 : n % array.length;
  return array.slice(n).concat(array.slice(0, n));
}

function capitalize(str) {
  return str.replace(/(?:^|-)(.)/g, function (match, letter) {
    return letter.toUpperCase();
  });
}

function getLineEquation(first, second) {
  if (eq(first[0], second[0])) {
    return "x = " + first[0].toFixed(3);
  }

  const m = (second[1] - first[1]) / (second[0] - first[0]);
  const b = first[1] - m * first[0];
  return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
} // Stolen from the wikipedia article
// http://en.wikipedia.org/wiki/Line-line_intersection


function getLineIntersection( // TODO(LP-10725): update these to be 2-tuples
firstPoints, secondPoints) {
  const x1 = firstPoints[0][0];
  const y1 = firstPoints[0][1];
  const x2 = firstPoints[1][0];
  const y2 = firstPoints[1][1];
  const x3 = secondPoints[0][0];
  const y3 = secondPoints[0][1];
  const x4 = secondPoints[1][0];
  const y4 = secondPoints[1][1];
  const determinant = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (Math.abs(determinant) < 1e-9) {
    return "Lines are parallel";
  }

  const x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / determinant;
  const y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / determinant;
  return "Intersection: (" + x.toFixed(3) + ", " + y.toFixed(3) + ")";
}

function numSteps(range, step) {
  return Math.floor((range[1] - range[0]) / step);
}

const deprecatedProps = {
  showGraph: function (props) {
    return {
      markings: props.showGraph ? "graph" : "none"
    };
  }
};

const _getShouldShowInstructions = props => {
  return _isClickToAddPoints(props) && (props.graph.coords == null || props.graph.coords.length === 0);
};

const _isClickToAddPoints = props => {
  return props.graph.type === "point" && props.graph.numPoints === UNLIMITED || props.graph.type === "polygon" && props.graph.numSides === UNLIMITED;
};

const makeInvalidTypeError = (functionName, graphType) => {
  return new PerseusError("".concat(functionName, " called but current graph type is not a '").concat(graphType, "'"), Errors.NotAllowed, {
    metadata: {
      graphType
    }
  });
};

class InteractiveGraph extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "angle", void 0);

    _defineProperty(this, "circle", void 0);

    _defineProperty(this, "graphie", void 0);

    _defineProperty(this, "horizHairline", void 0);

    _defineProperty(this, "line", void 0);

    _defineProperty(this, "lines", void 0);

    _defineProperty(this, "parabola", void 0);

    _defineProperty(this, "pointA", void 0);

    _defineProperty(this, "pointB", void 0);

    _defineProperty(this, "pointC", void 0);

    _defineProperty(this, "points", void 0);

    _defineProperty(this, "polygon", void 0);

    _defineProperty(this, "shouldResetGraphie", void 0);

    _defineProperty(this, "sinusoid", void 0);

    _defineProperty(this, "trashCan", void 0);

    _defineProperty(this, "vertHairline", void 0);

    _defineProperty(this, "state", {
      shouldShowInstructions: _getShouldShowInstructions(this.props)
    });

    _defineProperty(this, "_getShouldShowInstructions", props => {
      props = props || this.props;
      return this.isClickToAddPoints(props) && (props.graph.coords == null || props.graph.coords.length === 0);
    });

    _defineProperty(this, "deprecatedProps", deprecatedProps);

    _defineProperty(this, "setGraphie", newGraphie => {
      this.graphie = newGraphie;
      this.setupGraphie();
    });

    _defineProperty(this, "handleAddPointsMouseDown", coord => {
      // This function should only be called when this.isClickToAddPoints()
      // is true
      if (!this.isClickToAddPoints()) {
        throw new PerseusError("handleAddPointsClick should not be registered" + "when isClickToAddPoints() is false", Errors.NotAllowed);
      }

      if (!this.isCoordInTrash(coord)) {
        let point;

        if (this.props.graph.type === "point") {
          point = this.createPointForPointsType(coord, this.points.length);

          if (!point.constrain()) {
            point.remove();
            return;
          }

          this.points.push(point); // interactive2 allows us to grab the point

          const idx = this.points.length - 1;
          this.points[idx].grab(coord);
          this.updateCoordsFromPoints();
        } else if (this.props.graph.type === "polygon") {
          var _this$polygon;

          if ((_this$polygon = this.polygon) !== null && _this$polygon !== void 0 && _this$polygon.closed()) {
            return;
          }

          point = this.createPointForPolygonType(coord, this.points.length);
          this.points.push(point);
          const idx = this.points.length - 1;
          this.points[idx].grab(coord); // We don't call updateCoordsFromPoints for
          // polygons, since the polygon won't be
          // closed yet.

          this.updatePolygon();
        }

        this.setState({
          shouldShowInstructions: false
        });
      }
    });

    _defineProperty(this, "resetGraphie", () => {
      this.shouldResetGraphie = false;
      this.parabola = null;
      this.sinusoid = null; // eslint-disable-next-line react/no-string-refs

      this.refs.graph.reset();
    });

    _defineProperty(this, "setupGraphie", () => {
      this.setTrashCanVisibility(0);

      if (this.isClickToAddPoints()) {
        this.setTrashCanVisibility(0.5);
      }

      if (this.props.apiOptions.isMobile) {
        var _this$horizHairline, _this$vertHairline;

        // $FlowFixMe[invalid-constructor]
        this.horizHairline = new WrappedLine(this.graphie, [0, 0], [0, 0], {
          normalStyle: {
            strokeWidth: 1
          }
        });
        this.horizHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        (_this$horizHairline = this.horizHairline) === null || _this$horizHairline === void 0 ? void 0 : _this$horizHairline.hide(); // $FlowFixMe[invalid-constructor]

        this.vertHairline = new WrappedLine(this.graphie, [0, 0], [0, 0], {
          normalStyle: {
            strokeWidth: 1
          }
        });
        this.vertHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        (_this$vertHairline = this.vertHairline) === null || _this$vertHairline === void 0 ? void 0 : _this$vertHairline.hide();
      }

      const type = this.props.graph.type; // $FlowFixMe[incompatible-use]

      this["add" + capitalize(type) + "Controls"]();
    });

    _defineProperty(this, "showHairlines", point => {
      if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
        var _this$horizHairline2, _this$horizHairline3, _this$vertHairline2, _this$vertHairline3;

        // Hairlines are already initialized when the graph is loaded, so
        // here we just move them to the updated location and make them
        // visible.
        (_this$horizHairline2 = this.horizHairline) === null || _this$horizHairline2 === void 0 ? void 0 : _this$horizHairline2.moveTo([this.props.range[0][0], point[1]], [this.props.range[0][1], point[1]]);
        (_this$horizHairline3 = this.horizHairline) === null || _this$horizHairline3 === void 0 ? void 0 : _this$horizHairline3.show();
        (_this$vertHairline2 = this.vertHairline) === null || _this$vertHairline2 === void 0 ? void 0 : _this$vertHairline2.moveTo([point[0], this.props.range[1][0]], [point[0], this.props.range[1][1]]);
        (_this$vertHairline3 = this.vertHairline) === null || _this$vertHairline3 === void 0 ? void 0 : _this$vertHairline3.show();
      }
    });

    _defineProperty(this, "hideHairlines", () => {
      if (this.props.apiOptions.isMobile) {
        var _this$horizHairline4, _this$vertHairline4;

        (_this$horizHairline4 = this.horizHairline) === null || _this$horizHairline4 === void 0 ? void 0 : _this$horizHairline4.hide();
        (_this$vertHairline4 = this.vertHairline) === null || _this$vertHairline4 === void 0 ? void 0 : _this$vertHairline4.hide();
      }
    });

    _defineProperty(this, "setTrashCanVisibility", opacity => {
      const graphie = this.graphie;

      if (kmath.number.equal(opacity, 0)) {
        if (this.trashCan) {
          this.trashCan.remove();
          this.trashCan = null;
        }
      } else if (!this.props.apiOptions.isMobile) {
        var _this$trashCan;

        // Only if trash tooltips are not being used, we initialize the old
        // trash can area.
        if (!this.trashCan) {
          var _graphie$raphael;

          this.trashCan = graphie === null || graphie === void 0 ? void 0 : (_graphie$raphael = graphie.raphael) === null || _graphie$raphael === void 0 ? void 0 : _graphie$raphael.image(TRASH_ICON_URI, graphie.xpixels - 40, graphie.ypixels - 40, 40, 40);
        }

        (_this$trashCan = this.trashCan) === null || _this$trashCan === void 0 ? void 0 : _this$trashCan.attr({
          opacity: opacity
        });
      }
    });

    _defineProperty(this, "isClickToAddPoints", props => {
      props = props || this.props;
      return _isClickToAddPoints(props);
    });

    _defineProperty(this, "_lineStroke", () => {
      // This should probably use: this.props.apiOptions.isMobile
      // $FlowFixMe[prop-missing]
      // $FlowFixMe[incompatible-exact]
      return this.props.isMobile ? {
        "stroke-width": 3
      } : {};
    });

    _defineProperty(this, "addLine", type => {
      const self = this;
      const graphie = self.graphie;
      const coords = InteractiveGraph.getLineCoords(self.props.graph, self.props);

      const points = self.points = ___default["default"].map(coords, coord => {
        return Interactive2.addMaybeMobileMovablePoint(this, {
          coord: coord,
          constraints: [// $FlowFixMe[prop-missing]
          Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
          Interactive2.MovablePoint.constraints.snap()],
          onMove: () => {
            const graph = ___default["default"].extend({}, self.props.graph, {
              coords: ___default["default"].invoke(points, "coord")
            });

            self.onChange({
              graph: graph
            });
          }
        });
      });

      const lineConfig = {
        points: points,
        static: true,
        normalStyle: {
          stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTIVE,
          ...this._lineStroke()
        }
      };

      if (type === "line") {
        // $FlowFixMe[prop-missing]
        lineConfig.extendLine = true;
      } else if (type === "ray") {
        // $FlowFixMe[prop-missing]
        lineConfig.extendRay = true;
      }

      self.line = Interactive2.addMovableLine(graphie, lineConfig); // A and B can't be in the same place

      points[0].listen("constraints", "isLine", coord => {
        return !kmath.point.equal(coord, points[1].coord());
      });
      points[1].listen("constraints", "isLine", coord => {
        return !kmath.point.equal(coord, points[0].coord());
      });
    });

    _defineProperty(this, "removeLine", () => {
      var _this$line;

      ___default["default"].invoke(this.points, "remove");

      (_this$line = this.line) === null || _this$line === void 0 ? void 0 : _this$line.remove();
    });

    _defineProperty(this, "addLinearControls", () => {
      this.addLine("line");
    });

    _defineProperty(this, "removeLinearControls", () => {
      this.removeLine();
    });

    _defineProperty(this, "addQuadraticControls", () => {
      if (this.props.graph.type !== "quadratic") {
        throw makeInvalidTypeError("addQuadraticControls", "quadratic");
      }

      let coords = this.props.graph.coords;

      if (!coords) {
        coords = InteractiveGraph.defaultQuadraticCoords(this.props);
      }

      const onMoveHandler = () => {
        const graph = ___default["default"].extend({}, this.props.graph, {
          // $FlowFixMe[incompatible-use]
          coords: [pointA.coord(), pointB.coord(), pointC.coord()]
        });

        this.onChange({
          graph
        });
        this.updateQuadratic();
      }; // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.


      let pointA = null;
      pointA = this.pointA = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[0],
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointA || // $FlowFixMe[incompatible-use]
          coord[0] !== pointB.coord()[0] && // $FlowFixMe[incompatible-use]
          coord[0] !== pointC.coord()[0];
        }],
        onMove: onMoveHandler
      }); // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.

      let pointB = null;
      pointB = this.pointB = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[1],
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointB || // $FlowFixMe[incompatible-use]
          coord[0] !== pointA.coord()[0] && // $FlowFixMe[incompatible-use]
          coord[0] !== pointC.coord()[0];
        }],
        onMove: onMoveHandler
      }); // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.

      let pointC = null;
      pointC = this.pointC = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[2],
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointC || // $FlowFixMe[incompatible-use]
          coord[0] !== pointA.coord()[0] && // $FlowFixMe[incompatible-use]
          coord[0] !== pointB.coord()[0];
        }],
        onMove: onMoveHandler
      });
      this.updateQuadratic();
    });

    _defineProperty(this, "updateQuadratic", () => {
      const coeffs = InteractiveGraph.getCurrentQuadraticCoefficients(this.props);

      if (!coeffs) {
        return;
      } // Extract coefficients the parabola


      const a = coeffs[0];
      const b = coeffs[1];
      const c = coeffs[2]; // Plot and style

      if (this.parabola) {
        var _this$graphie, _this$parabola;

        const path = (_this$graphie = this.graphie) === null || _this$graphie === void 0 ? void 0 : _this$graphie.svgParabolaPath(a, b, c);
        (_this$parabola = this.parabola) === null || _this$parabola === void 0 ? void 0 : _this$parabola.attr({
          path: path
        });
      } else {
        var _this$graphie2, _this$parabola2, _this$parabola3;

        this.parabola = (_this$graphie2 = this.graphie) === null || _this$graphie2 === void 0 ? void 0 : _this$graphie2.parabola(a, b, c);
        (_this$parabola2 = this.parabola) === null || _this$parabola2 === void 0 ? void 0 : _this$parabola2.attr({
          stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.DYNAMIC,
          ...this._lineStroke()
        });
        (_this$parabola3 = this.parabola) === null || _this$parabola3 === void 0 ? void 0 : _this$parabola3.toBack();
      }
    });

    _defineProperty(this, "removeQuadraticControls", () => {
      var _this$pointA, _this$pointB, _this$pointC;

      (_this$pointA = this.pointA) === null || _this$pointA === void 0 ? void 0 : _this$pointA.remove();
      (_this$pointB = this.pointB) === null || _this$pointB === void 0 ? void 0 : _this$pointB.remove();
      (_this$pointC = this.pointC) === null || _this$pointC === void 0 ? void 0 : _this$pointC.remove();

      if (this.parabola) {
        this.parabola.remove();
        this.parabola = null;
      }
    });

    _defineProperty(this, "addSinusoidControls", () => {
      if (this.props.graph.type !== "sinusoid") {
        throw makeInvalidTypeError("addSinusoidControls", "sinusoid");
      }

      let coords = this.props.graph.coords;

      if (!coords) {
        coords = InteractiveGraph.defaultSinusoidCoords(this.props);
      }

      const onMoveHandler = () => {
        const graph = ___default["default"].extend({}, this.props.graph, {
          // $FlowFixMe[incompatible-use]
          coords: [pointA.coord(), pointB.coord()]
        });

        this.onChange({
          graph: graph
        });
        this.updateSinusoid();
      }; // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.


      let pointA = null;
      pointA = this.pointA = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[0],
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointA || coord[0] !== pointB.coord()[0];
        }],
        onMove: onMoveHandler
      });
      const pointB = this.pointB = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coords[1],
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap(), coord => {
          return !pointA || coord[0] !== pointA.coord()[0];
        }],
        onMove: onMoveHandler
      });
      this.updateSinusoid();
    });

    _defineProperty(this, "updateSinusoid", () => {
      const coeffs = InteractiveGraph.getCurrentSinusoidCoefficients(this.props);

      if (!coeffs) {
        return;
      }

      const a = coeffs[0];
      const b = coeffs[1];
      const c = coeffs[2];
      const d = coeffs[3]; // Plot and style

      if (this.sinusoid) {
        var _this$graphie3, _this$sinusoid;

        const path = (_this$graphie3 = this.graphie) === null || _this$graphie3 === void 0 ? void 0 : _this$graphie3.svgSinusoidPath(a, b, c, d);
        (_this$sinusoid = this.sinusoid) === null || _this$sinusoid === void 0 ? void 0 : _this$sinusoid.attr({
          path: path
        });
      } else {
        var _this$graphie4, _this$sinusoid2, _this$sinusoid3;

        this.sinusoid = (_this$graphie4 = this.graphie) === null || _this$graphie4 === void 0 ? void 0 : _this$graphie4.sinusoid(a, b, c, d);
        (_this$sinusoid2 = this.sinusoid) === null || _this$sinusoid2 === void 0 ? void 0 : _this$sinusoid2.attr({
          stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.DYNAMIC,
          ...this._lineStroke()
        });
        (_this$sinusoid3 = this.sinusoid) === null || _this$sinusoid3 === void 0 ? void 0 : _this$sinusoid3.toBack();
      }
    });

    _defineProperty(this, "removeSinusoidControls", () => {
      var _this$pointA2, _this$pointB2;

      (_this$pointA2 = this.pointA) === null || _this$pointA2 === void 0 ? void 0 : _this$pointA2.remove();
      (_this$pointB2 = this.pointB) === null || _this$pointB2 === void 0 ? void 0 : _this$pointB2.remove();

      if (this.sinusoid) {
        this.sinusoid.remove();
        this.sinusoid = null;
      }
    });

    _defineProperty(this, "addCircleControls", () => {
      const graphie = this.graphie; // $FlowFixMe[incompatible-use]

      const minSnap = ___default["default"].min(graphie.snap);

      const circle = this.circle = graphie === null || graphie === void 0 ? void 0 : graphie.addCircleGraph({
        center: this.props.graph.center || [0, 0],
        radius: this.props.graph.radius || ___default["default"].min(this.props.step),
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        minRadius: minSnap,
        snapRadius: minSnap
      });
      $__default["default"](circle).on("move", () => {
        const graph = ___default["default"].extend({}, this.props.graph, {
          // $FlowFixMe[incompatible-use]
          center: circle.center,
          // $FlowFixMe[incompatible-use]
          radius: circle.radius
        });

        this.onChange({
          graph: graph
        });
      });
    });

    _defineProperty(this, "removeCircleControls", () => {
      var _this$circle;

      (_this$circle = this.circle) === null || _this$circle === void 0 ? void 0 : _this$circle.remove();
    });

    _defineProperty(this, "addLinearSystemControls", () => {
      const graphie = this.graphie;
      const coords = InteractiveGraph.getLinearSystemCoords(this.props.graph, this.props);
      const segmentColors = [KhanColors.INTERACTIVE, KhanColors.GREEN];

      const points = this.points = ___default["default"].map(coords, (segmentCoords, segmentIndex) => {
        // NOTE(jeresig): This code attempts to access the variable
        // while it's still being defined, it should be refactored!
        // The callbacks appear to be executed synchronously, which
        // causes this issue.
        const segmentPoints = [];

        for (let i = 0; i < segmentCoords.length; i += 1) {
          const coord = segmentCoords[i];
          segmentPoints.push(Interactive2.addMaybeMobileMovablePoint(this, {
            coord: coord,
            constraints: [// $FlowFixMe[prop-missing]
            Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
            Interactive2.MovablePoint.constraints.snap(), coord => {
              const otherSegment = segmentPoints[1 - i];

              if (!otherSegment) {
                // segment hasn't been defined yet
                // because we're still creating them
                return;
              }

              return !kmath.point.equal(coord, otherSegment.coord());
            }],
            onMove: () => {
              const graph = ___default["default"].extend({}, this.props.graph, {
                coords: ___default["default"].map(this.points, segment => ___default["default"].invoke(segment, "coord"))
              });

              this.onChange({
                graph: graph
              });
            },
            normalStyle: {
              fill: segmentColors[segmentIndex]
            },
            highlightStyle: {
              fill: segmentColors[segmentIndex]
            }
          }));
        }

        return segmentPoints;
      });

      this.lines = ___default["default"].map(points, (segmentPoints, segmentIndex) => {
        return Interactive2.addMovableLine(graphie, {
          points: segmentPoints,
          static: true,
          extendLine: true,
          normalStyle: {
            stroke: segmentColors[segmentIndex]
          }
        });
      });
    });

    _defineProperty(this, "removeLinearSystemControls", () => {
      ___default["default"].invoke(this.lines, "remove");

      ___default["default"].map(this.points, segment => ___default["default"].invoke(segment, "remove"));
    });

    _defineProperty(this, "isCoordInTrash", coord => {
      if (this.props.apiOptions.isMobile) {
        return false;
      }

      const graphie = this.graphie;
      const screenPoint = graphie === null || graphie === void 0 ? void 0 : graphie.scalePoint(coord);
      return (// $FlowFixMe[incompatible-use]
        screenPoint[0] >= graphie.xpixels - 40 && // $FlowFixMe[incompatible-use]
        screenPoint[1] >= graphie.ypixels - 40
      );
    });

    _defineProperty(this, "createPointForPointsType", (coord, i) => {
      const self = this;

      const remove = () => {
        self.points = ___default["default"].filter(self.points, function (pt) {
          return pt !== point;
        }); // update the correct answer box

        self.updateCoordsFromPoints(); // remove this movablePoint from graphie.
        // we wait to do this until we're not inside of
        // said point's onMoveEnd method so its state is
        // consistent throughout this method call
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // $FlowFixMe[incompatible-use]

        setTimeout(point.remove.bind(point), 0); // eslint-disable-line no-restricted-syntax
      }; // NOTE(jeresig): This code attempts to access the variable while it's
      // still being defined, it should be refactored! The callbacks appear
      // to be executed synchronously, which causes this issue.


      let point = null;
      point = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coord,
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap(), function (coord) {
          // TODO(jack): There ought to be a
          // MovablePoint.constraints.avoid
          // default that lets you do things like this
          return ___default["default"].all(self.points, function (pt) {
            return point === pt || !kmath.point.equal(coord, pt.coord());
          });
        }],
        onMoveStart: function () {
          if (self.isClickToAddPoints()) {
            self.setTrashCanVisibility(1);
          }
        },
        onMove: self.updateCoordsFromPoints,
        onMoveEnd: function (coord) {
          if (self.isClickToAddPoints()) {
            if (self.isCoordInTrash(coord)) {
              remove();
            } // In case we mouseup'd off the graphie and that
            // stopped the move (in which case, we might not
            // be in isCoordInTrash()


            self.setTrashCanVisibility(0.5);
          }
        },
        ...(this.props.apiOptions.isMobile && self.isClickToAddPoints() ? {
          onRemove: remove
        } : {})
      });
      return point;
    });

    _defineProperty(this, "removePoint", point => {
      let index = null;
      this.points = ___default["default"].filter(this.points, function (pt, i) {
        if (pt === point) {
          index = i;
          return false;
        }

        return true;
      });
      return index;
    });

    _defineProperty(this, "createPointForPolygonType", (coord, i) => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("createPointForPolygonType", "polygon");
      } // TODO(alex): check against "grid" instead, use constants


      const snapToGrid = !___default["default"].contains(["angles", "sides"], this.props.graph.snapTo); // Index relative to current point -> absolute index
      // NOTE: This does not work when isClickToAddPoints() == true,
      // as `i` can be changed by dragging a point to the trash
      // Currently this function is only called when !isClickToAddPoints()

      const rel = j => {
        return (i + j + this.points.length) % this.points.length;
      };

      const remove = () => {
        var _this$polygon2;

        // remove this point from points
        const index = this.removePoint(point);

        if ((_this$polygon2 = this.polygon) !== null && _this$polygon2 !== void 0 && _this$polygon2.closed()) {
          var _this$polygon3;

          // We should be checking if this.points is defined before rotating them.
          // $FlowFixMe[incompatible-call]
          // $FlowFixMe[incompatible-type]
          this.points = rotate(this.points, index);
          (_this$polygon3 = this.polygon) === null || _this$polygon3 === void 0 ? void 0 : _this$polygon3.update({
            closed: false
          });
        }

        this.updatePolygon(); // the polygon is now unclosed, so we need to
        // remove any points props

        this.clearCoords(); // remove this movablePoint from graphie.
        // wait to do this until we're not inside of
        // said point's onMoveEnd method so state is
        // consistent throughout the method call
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // eslint-disable-next-line no-restricted-syntax

        setTimeout(point.remove.bind(point), 0);
      };

      const setInitialMove = debounce__default["default"]((point, bool) => {
        point.state.isInitialMove = bool;
      }, 1000);

      const onMoveEndHandler = coord => {
        // If the user clicked and dragged a point over endpoint,
        // join the them
        const overlappedPoints = this.points.length > 1 && (point === this.points[0] && kmath.point.equal(coord, ___default["default"].last(this.points).coord()) || point === ___default["default"].last(this.points) && kmath.point.equal(coord, this.points[0].coord()));

        if (this.isClickToAddPoints()) {
          if (this.isCoordInTrash(coord)) {
            remove();
          } else if (overlappedPoints) {
            const pointToRemove = this.points.pop();

            if (this.points.length > 2) {
              var _this$polygon4;

              (_this$polygon4 = this.polygon) === null || _this$polygon4 === void 0 ? void 0 : _this$polygon4.update({
                closed: true
              });
              this.updateCoordsFromPoints();
            } else {
              var _this$polygon5;

              (_this$polygon5 = this.polygon) === null || _this$polygon5 === void 0 ? void 0 : _this$polygon5.update({
                closed: false
              });
              this.clearCoords();
            }

            this.updatePolygon(); // remove this movablePoint from graphie.
            // wait to do this until we're not inside of
            // said point's onMoveEnd method so state is
            // consistent throughout the method call
            // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
            // eslint-disable-next-line no-restricted-syntax

            setTimeout(pointToRemove.remove.bind(pointToRemove), 0);
          } else {
            // If the user clicked and dragged a point over any other
            // existing point, fix shape
            const shouldRemove = ___default["default"].any(this.points, function (pt) {
              return pt !== point && kmath.point.equal(pt.coord(), coord);
            });

            if (shouldRemove) {
              var _this$polygon7;

              this.removePoint(point);

              if (this.points.length < 3) {
                var _this$polygon6;

                (_this$polygon6 = this.polygon) === null || _this$polygon6 === void 0 ? void 0 : _this$polygon6.update({
                  closed: false
                });
                this.clearCoords();
              } else if ((_this$polygon7 = this.polygon) !== null && _this$polygon7 !== void 0 && _this$polygon7.closed()) {
                this.updateCoordsFromPoints();
              }

              this.updatePolygon(); // remove this movablePoint from graphie.
              // wait to do this until we're not inside
              // said point's onMoveEnd method so state
              // is consistent throughout the method call
              // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
              // eslint-disable-next-line no-restricted-syntax

              setTimeout(point.remove.bind(point), 0);
            } else {
              var _this$polygon8;

              // If this was
              //  * a click on the first or last point
              //  * and not a deletion
              //  * and not a drag,
              //  * and not a creation of a new point
              //    (see !point.state.isInitialMove, below),
              //  * and our polygon is not closed,
              //  * and we can close it (we need at least the same
              //    number of points as coordinates asked for in the
              //    question),
              // then close it
              const isFirstOrLastPoint = point === ___default["default"].head(this.points) || point === ___default["default"].last(this.points);

              const pointNotMoved = !point.hasMoved(); // NOTE (jsatk): Currently different on mobile versus
              // destkop

              const notANewPoint = !point.state.isInitialMove;
              const polygonNotClosed = !((_this$polygon8 = this.polygon) !== null && _this$polygon8 !== void 0 && _this$polygon8.closed());
              const allPointsPlotted = this.points.length > 2;
              const canCloseUnclosedPolygon = isFirstOrLastPoint && pointNotMoved && notANewPoint && polygonNotClosed && allPointsPlotted;

              if (canCloseUnclosedPolygon) {
                var _this$polygon9;

                (_this$polygon9 = this.polygon) === null || _this$polygon9 === void 0 ? void 0 : _this$polygon9.update({
                  closed: true
                });
                this.updatePolygon(); // We finally have a closed polygon, so save our
                // points to props

                this.updateCoordsFromPoints();
              }
            }
          } // In case we mouseup'd off the graphie and that
          // stopped the move


          this.setTrashCanVisibility(0.5);
        }

        setInitialMove(point, false);
      };

      const graphConstraint = coord => {
        // These constraints are all relative to the other points, so if
        // we're creating the initial points and haven't added any others
        // to the graph, we can't enforce them.
        if (this.points == null || this.points.length === 0) {
          return true;
        } // eslint-disable-next-line ft-flow/no-mutable-array


        const coords = ___default["default"].invoke(this.points, "coord");

        coords[i] = coord; // Check for invalid positioning, but only if we aren't adding
        // points one click at a time, since those added points could
        // have already violated these constraints

        if (!this.isClickToAddPoints()) {
          // Polygons can't have consecutive collinear points
          if (collinear(coords[rel(-2)], coords[rel(-1)], coords[i]) || collinear(coords[rel(-1)], coords[i], coords[rel(1)]) || collinear(coords[i], coords[rel(1)], coords[rel(2)])) {
            return false;
          }

          const segments = ___default["default"].zip(coords, rotate(coords));

          if (this.points.length > 3) {
            // Constrain to simple (non self-intersecting) polygon by
            // testing whether adjacent segments intersect any others
            for (let j = -1; j <= 0; j++) {
              const segment = segments[rel(j)];

              const others = ___default["default"].without(segments, segment, segments[rel(j - 1)], segments[rel(j + 1)]);

              for (let k = 0; k < others.length; k++) {
                const other = others[k];

                if (intersects(segment, other)) {
                  return false;
                }
              }
            }
          }
        }

        if (this.props.graph.snapTo === "angles" && this.points.length > 2) {
          var _this$graphie5, _this$graphie6;

          // Snap to whole degree interior angles
          const angles = ___default["default"].map(angleMeasures(coords), function (rad) {
            return rad * 180 / Math.PI;
          });

          ___default["default"].each([-1, 1], function (j) {
            angles[rel(j)] = Math.round(angles[rel(j)]);
          });

          const getAngle = function (a, vertex, b) {
            const angle = GraphUtils.findAngle(coords[rel(a)], coords[rel(b)], coords[rel(vertex)]);
            return (angle + 360) % 360;
          };

          const innerAngles = [angles[rel(-1)] - getAngle(-2, -1, 1), angles[rel(1)] - getAngle(-1, 1, 2)];
          innerAngles[2] = 180 - (innerAngles[0] + innerAngles[1]); // Avoid degenerate triangles

          if (___default["default"].any(innerAngles, function (angle) {
            return leq(angle, 1);
          })) {
            return false;
          }

          const knownSide = magnitude(vector(coords[rel(-1)], coords[rel(1)]));
          const onLeft = sign(ccw(coords[rel(-1)], coords[rel(1)], coords[i])) === 1; // Solve for side by using the law of sines

          const side = Math.sin(innerAngles[1] * Math.PI / 180) / Math.sin(innerAngles[2] * Math.PI / 180) * knownSide;
          const outerAngle = GraphUtils.findAngle(coords[rel(1)], coords[rel(-1)]);
          const offset = (_this$graphie5 = this.graphie) === null || _this$graphie5 === void 0 ? void 0 : _this$graphie5.polar(side, outerAngle + (onLeft ? 1 : -1) * innerAngles[0]);
          return (_this$graphie6 = this.graphie) === null || _this$graphie6 === void 0 ? void 0 : _this$graphie6.addPoints(coords[rel(-1)], offset);
        }

        if (this.props.graph.snapTo === "sides" && this.points.length > 1) {
          var _this$graphie7, _this$graphie8;

          // Snap to whole unit side measures
          const sides = ___default["default"].map([[coords[rel(-1)], coords[i]], [coords[i], coords[rel(1)]], [coords[rel(-1)], coords[rel(1)]]], function (coords) {
            return magnitude(vector(...coords));
          });

          ___default["default"].each([0, 1], function (j) {
            sides[j] = Math.round(sides[j]);
          }); // Avoid degenerate triangles


          if (leq(sides[1] + sides[2], sides[0]) || leq(sides[0] + sides[2], sides[1]) || leq(sides[0] + sides[1], sides[2])) {
            return false;
          } // Solve for angle by using the law of cosines


          const innerAngle = lawOfCosines(sides[0], sides[2], sides[1]);
          const outerAngle = GraphUtils.findAngle(coords[rel(1)], coords[rel(-1)]);
          const onLeft = sign(ccw(coords[rel(-1)], coords[rel(1)], coords[i])) === 1;
          const offset = (_this$graphie7 = this.graphie) === null || _this$graphie7 === void 0 ? void 0 : _this$graphie7.polar(sides[0], outerAngle + (onLeft ? 1 : -1) * innerAngle);
          return (_this$graphie8 = this.graphie) === null || _this$graphie8 === void 0 ? void 0 : _this$graphie8.addPoints(coords[rel(-1)], offset);
        } // Snap to grid (already done)


        return true;
      };

      const point = Interactive2.addMaybeMobileMovablePoint(this, {
        coord: coord,
        constraints: [// $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.bound(), snapToGrid ? // $FlowFixMe[prop-missing]
        Interactive2.MovablePoint.constraints.snap() : null, graphConstraint],
        onMoveStart: () => {
          if (this.isClickToAddPoints()) {
            this.setTrashCanVisibility(1);
          }
        },
        onMove: () => {
          var _this$polygon10;

          if ((_this$polygon10 = this.polygon) !== null && _this$polygon10 !== void 0 && _this$polygon10.closed()) {
            this.updateCoordsFromPoints();
          }
        },
        onMoveEnd: onMoveEndHandler,
        ...(this.props.apiOptions.isMobile && this.isClickToAddPoints() ? {
          onRemove: remove
        } : {})
      });
      point.state.isInitialMove = true;
      return point;
    });

    _defineProperty(this, "updateCoordsFromPoints", () => {
      const graph = ___default["default"].extend({}, this.props.graph, {
        // Handle old movable points with .coord, or
        // Interactive2.MovablePoint's with .coord()
        coords: ___default["default"].map(this.points, function (point) {
          return ___default["default"].result(point, "coord");
        })
      });

      this.onChange({
        graph: graph
      });
    });

    _defineProperty(this, "clearCoords", () => {
      const graph = ___default["default"].extend({}, this.props.graph, {
        coords: null
      });

      this.onChange({
        graph: graph
      });
    });

    _defineProperty(this, "onChange", data => {
      this.props.onChange(data);
      this.props.trackInteraction();
    });

    _defineProperty(this, "addPointControls", () => {
      if (this.props.graph.type !== "point") {
        throw makeInvalidTypeError("addPointControls", "point");
      }

      const coords = InteractiveGraph.getPointCoords(this.props.graph, this.props); // Clear out our old points so that newly added points don't
      // "collide" with them and reposition when being added
      // Without this, when added, each point checks whether it is on top
      // of a point in this.points, which (a) shouldn't matter since
      // we're clearing out this.points anyways, and (b) can cause problems
      // if each of this.points is a MovablePoint instead of an
      // Interactive2.MovablePoint, since one has a .coord and the other
      // has .coord()
      // TODO(jack): Figure out a better way to do this

      this.points = [];
      this.points = ___default["default"].map(coords, this.createPointForPointsType, this);
    });

    _defineProperty(this, "removePointControls", () => {
      ___default["default"].invoke(this.points, "remove");
    });

    _defineProperty(this, "addSegmentControls", () => {
      if (this.props.graph.type !== "segment") {
        throw makeInvalidTypeError("addSegmentControls", "segment");
      }

      const self = this;
      const graphie = this.graphie;
      const coords = InteractiveGraph.getSegmentCoords(this.props.graph, this.props);

      const createPoint = options => Interactive2.addMaybeMobileMovablePoint(this, options);

      this.points = [];
      this.lines = ___default["default"].map(coords, function (segment, i) {
        const updateCoordProps = function () {
          const graph = ___default["default"].extend({}, self.props.graph, {
            coords: ___default["default"].invoke(self.lines, "coords")
          });

          self.onChange({
            graph: graph
          });
        }; // NOTE(jeresig): This code attempts to access the variable
        // while it's still being defined, it should be refactored!
        // The callbacks appear to be executed synchronously, which
        // causes this issue.


        const points = [];

        for (let i = 0; i < segment.length; i += 1) {
          const coord = segment[i];
          points.push(createPoint({
            coord: coord,
            constraints: [// $FlowFixMe[prop-missing]
            Interactive2.MovablePoint.constraints.bound(), // $FlowFixMe[prop-missing]
            Interactive2.MovablePoint.constraints.snap(), coord => {
              const otherPoint = points[1 - i];

              if (!otherPoint) {
                // point hasn't been defined yet
                // because we're still creating them
                // We return false as the points aren't
                // going to be in the same position at
                // this point.
                return false;
              }

              return !kmath.point.equal(coord, otherPoint.coord());
            }],
            onMove: updateCoordProps
          }));
        }

        self.points = self.points.concat(points);
        const line = Interactive2.addMovableLine(graphie, {
          points: points,
          static: false,
          constraints: [// $FlowFixMe[prop-missing]
          Interactive2.MovableLine.constraints.bound(), // $FlowFixMe[prop-missing]
          Interactive2.MovableLine.constraints.snap()],
          onMove: [// $FlowFixMe[prop-missing]
          Interactive2.MovableLine.onMove.updatePoints, updateCoordProps],
          normalStyle: {
            stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTIVE,
            ...this._lineStroke()
          },
          highlightStyle: {
            stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTING,
            ...this._lineStroke()
          }
        });

        ___default["default"].invoke(points, "toFront");

        return line;
      }, this);
    });

    _defineProperty(this, "removeSegmentControls", () => {
      ___default["default"].invoke(this.points, "remove");

      ___default["default"].invoke(this.lines, "remove");
    });

    _defineProperty(this, "addRayControls", () => {
      this.addLine("ray");
    });

    _defineProperty(this, "removeRayControls", () => {
      this.removeLine();
    });

    _defineProperty(this, "addPolygonControls", () => {
      this.polygon = null;
      const coords = InteractiveGraph.getPolygonCoords(this.props.graph, this.props); // Clear out our old points so that newly added points don't
      // "collide", as in `addPointControls`

      this.points = [];
      this.points = ___default["default"].map(coords, this.createPointForPolygonType, this);
      this.updatePolygon();
    });

    _defineProperty(this, "updatePolygon", () => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("updatePolygon", "polygon");
      }

      let closed;

      if (this.polygon) {
        closed = this.polygon.closed();
      } else if (this.points.length >= 3) {
        closed = true;
      } else {
        // There will only be fewer than 3 points in click-to-add-vertices
        // mode, so we don't need to explicitly check for that here.
        closed = false;
      }

      const graphie = this.graphie;
      const n = this.points.length; // TODO(alex): check against "grid" instead, use constants

      const snapToGrid = !___default["default"].contains(["angles", "sides"], this.props.graph.snapTo);

      const angleLabels = ___default["default"].times(n, function (i) {
        if (!this.props.graph.showAngles || !closed && (i === 0 || i === n - 1)) {
          return "";
        }

        if (this.props.graph.snapTo === "angles") {
          return "$deg0";
        }

        return "$deg1";
      }, this);

      const showRightAngleMarkers = ___default["default"].times(n, function (i) {
        return closed || i !== 0 && i !== n - 1;
      }, this);

      const numArcs = ___default["default"].times(n, function (i) {
        if (this.props.graph.showAngles && (closed || i !== 0 && i !== n - 1)) {
          return 1;
        }

        return 0;
      }, this);

      const sideLabels = ___default["default"].times(n, function (i) {
        if (!this.props.graph.showSides || !closed && i === n - 1) {
          return "";
        }

        if (this.props.graph.snapTo === "sides") {
          return "$len0";
        }

        return "$len1";
      }, this);

      if (this.polygon == null) {
        const self = this;
        self.polygon = Interactive2.addMovablePolygon(graphie, {
          constraints: [// $FlowFixMe[prop-missing]
          Interactive2.MovablePolygon.constraints.bound(), snapToGrid ? // $FlowFixMe[prop-missing]
          Interactive2.MovablePolygon.constraints.snap() : null],
          closed: closed,
          points: self.points,
          angleLabels: angleLabels,
          showRightAngleMarkers: showRightAngleMarkers,
          numArcs: numArcs,
          sideLabels: sideLabels,
          onMove: [// $FlowFixMe[prop-missing]
          Interactive2.MovablePolygon.onMove.updatePoints, function () {
            if (this.closed()) {
              self.updateCoordsFromPoints();
            }
          }],
          normalStyle: {
            stroke: this.props.apiOptions.isMobile ? KhanColors.BLUE_C : KhanColors.INTERACTIVE,
            ...this._lineStroke()
          }
        });
      } else {
        // We only need to pass in the properties that might've changed
        this.polygon.update({
          closed: closed,
          points: this.points,
          angleLabels: angleLabels,
          showRightAngleMarkers: showRightAngleMarkers,
          numArcs: numArcs,
          sideLabels: sideLabels
        });
      }
    });

    _defineProperty(this, "removePolygonControls", () => {
      var _this$polygon11;

      ___default["default"].invoke(this.points, "remove");

      (_this$polygon11 = this.polygon) === null || _this$polygon11 === void 0 ? void 0 : _this$polygon11.remove();
    });

    _defineProperty(this, "addAngleControls", () => {
      if (this.props.graph.type !== "angle") {
        throw makeInvalidTypeError("addAngleControls", "angle");
      }

      const graph = this.props.graph;
      const graphie = this.graphie;
      const coords = InteractiveGraph.getAngleCoords(this.props.graph, this.props); // The vertex snaps to the grid, but the rays don't...

      this.points = coords.map(function (coord, i) {
        return graphie === null || graphie === void 0 ? void 0 : graphie.addMovablePoint(___default["default"].extend({
          coord: coord,
          normalStyle: {
            stroke: KhanColors.INTERACTIVE,
            fill: KhanColors.INTERACTIVE
          }
        }, i === 1 ? {
          snapX: graphie.snap[0],
          snapY: graphie.snap[1]
        } : {}));
      }); // ...they snap to whole-degree angles from the vertex.

      this.angle = graphie === null || graphie === void 0 ? void 0 : graphie.addMovableAngle({
        points: this.points,
        snapDegrees: graph.snapDegrees || 1,
        snapOffsetDeg: graph.angleOffsetDeg || 0,
        angleLabel: graph.showAngles ? "$deg0" : "",
        pushOut: 2,
        allowReflex: defaultVal(graph.allowReflexAngles, true)
      });
      $__default["default"](this.angle).on("move", () => {
        var _this$angle;

        this.onChange({
          graph: { ...graph,
            coords: (_this$angle = this.angle) === null || _this$angle === void 0 ? void 0 : _this$angle.getClockwiseCoords()
          }
        });
      });
    });

    _defineProperty(this, "removeAngleControls", () => {
      var _this$angle2;

      ___default["default"].invoke(this.points, "remove");

      (_this$angle2 = this.angle) === null || _this$angle2 === void 0 ? void 0 : _this$angle2.remove();
    });

    _defineProperty(this, "toggleShowAngles", () => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("toggleShowAngles", "polygon");
      }

      const graph = ___default["default"].extend({}, this.props.graph, {
        showAngles: !this.props.graph.showAngles
      });

      this.onChange({
        graph: graph
      });
    });

    _defineProperty(this, "toggleShowSides", () => {
      if (this.props.graph.type !== "polygon") {
        throw makeInvalidTypeError("toggleShowSides", "polygon");
      }

      const graph = ___default["default"].extend({}, this.props.graph, {
        showSides: !this.props.graph.showSides
      });

      this.onChange({
        graph: graph
      });
    });

    _defineProperty(this, "getUserInput", () => {
      return InteractiveGraph.getUserInputFromProps(this.props);
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return InteractiveGraph.validate(this.getUserInput(), rubric, this);
    });

    _defineProperty(this, "focus", $__default["default"].noop);
  }

  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount() {
    DeprecationMixin.UNSAFE_componentWillMount.call(this);
  }

  componentDidMount() {
    // eslint-disable-next-line react/no-string-refs
    this.setGraphie(this.refs.graph.graphie());
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    var _this$props$backgroun, _nextProps$background;

    if (this.isClickToAddPoints() !== this.isClickToAddPoints(nextProps)) {
      this.shouldResetGraphie = true;
      this.setState({
        shouldShowInstructions: _getShouldShowInstructions(nextProps)
      });
    }

    if (((_this$props$backgroun = this.props.backgroundImage) === null || _this$props$backgroun === void 0 ? void 0 : _this$props$backgroun.url) !== ((_nextProps$background = nextProps.backgroundImage) === null || _nextProps$background === void 0 ? void 0 : _nextProps$background.url) || this.props.backgroundImage !== nextProps.backgroundImage || this.props.containerSizeClass !== nextProps.containerSizeClass) {
      this.shouldResetGraphie = true;
    }
  }

  componentDidUpdate(prevProps, prevState) {
    // TODO(jeremy): This feels underspecified. For example, if the props
    // change the coords of a segment graph, but not the numSegments, we'd
    // not count that as an update.
    const oldType = prevProps.graph.type;
    const newType = this.props.graph.type;

    if (oldType !== newType || prevProps.graph.type === "angle" && this.props.graph.type === "angle" && this.areAngleGraphsEqual(prevProps.graph, this.props.graph) || prevProps.graph.type === "point" && this.props.graph.type === "point" && this.arePointGraphsEqual(prevProps.graph, this.props.graph) || prevProps.graph.type === "polygon" && this.props.graph.type === "polygon" && this.arePolygonGraphsEqual(prevProps.graph, this.props.graph) || prevProps.graph.type === "segment" && this.props.graph.type === "segment" && this.areSegmentGraphsEqual(prevProps.graph, this.props.graph)) {
      // $FlowFixMe[incompatible-use]
      this["remove" + capitalize(oldType) + "Controls"](); // $FlowFixMe[incompatible-use]

      this["add" + capitalize(newType) + "Controls"]();
    }

    if (this.shouldResetGraphie) {
      this.resetGraphie();
    }
  }

  areAngleGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.allowReflexAngles !== currentGraph.allowReflexAngles || prevGraph.angleOffsetDeg !== currentGraph.angleOffsetDeg || prevGraph.snapDegrees !== currentGraph.snapDegrees;
  }

  arePointGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.numPoints !== currentGraph.numPoints;
  }

  arePolygonGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.numSides !== currentGraph.numSides || prevGraph.showAngles !== currentGraph.showAngles || prevGraph.showSides !== currentGraph.showSides || prevGraph.snapTo !== currentGraph.snapTo;
  }

  areSegmentGraphsEqual(prevGraph, currentGraph) {
    return prevGraph.numSegments !== currentGraph.numSegments;
  }

  render() {
    const box = getInteractiveBoxFromSizeClass(this.props.containerSizeClass);
    let instructions;

    if (this.isClickToAddPoints() && this.state.shouldShowInstructions) {
      if (this.props.graph.type === "point") {
        instructions = i18n__namespace._("Click to add points");
      } else if (this.props.graph.type === "polygon") {
        instructions = i18n__namespace._("Click to add vertices");
      }
    } else {
      instructions = undefined;
    }

    const onMouseDown = this.isClickToAddPoints() ? this.handleAddPointsMouseDown : null;
    const gridStep = this.props.gridStep || Util.getGridStep(this.props.range, this.props.step, box[0]);
    const snapStep = this.props.snapStep || Util.snapStepFromGridStep(gridStep);
    const isMobile = this.props.apiOptions.isMobile;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-interactive-graph",
      style: {
        width: box[0],
        height: box[1]
      }
    }, /*#__PURE__*/React__namespace.createElement(Graph, {
      instructions: instructions // eslint-disable-next-line react/no-string-refs
      ,
      ref: "graph",
      box: box,
      labels: this.props.labels,
      range: this.props.range,
      step: isMobile ? Util.constrainedTickStepsFromTickSteps(this.props.step, this.props.range) : this.props.step,
      gridStep: gridStep,
      snapStep: snapStep,
      markings: this.props.markings,
      backgroundImage: this.props.backgroundImage,
      showProtractor: this.props.showProtractor,
      showRuler: this.props.showRuler,
      rulerLabel: this.props.rulerLabel,
      rulerTicks: this.props.rulerTicks,
      onMouseDown: onMouseDown,
      onGraphieUpdated: this.setGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
      isMobile: isMobile
    }));
  }

  static getQuadraticCoefficients(coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const p3 = coords[2];
    const denom = (p1[0] - p2[0]) * (p1[0] - p3[0]) * (p2[0] - p3[0]);

    if (denom === 0) {
      // Many of the callers assume that the return value is always defined.
      // $FlowFixMe[incompatible-return]
      return;
    }

    const a = (p3[0] * (p2[1] - p1[1]) + p2[0] * (p1[1] - p3[1]) + p1[0] * (p3[1] - p2[1])) / denom;
    const b = (p3[0] * p3[0] * (p1[1] - p2[1]) + p2[0] * p2[0] * (p3[1] - p1[1]) + p1[0] * p1[0] * (p2[1] - p3[1])) / denom;
    const c = (p2[0] * p3[0] * (p2[0] - p3[0]) * p1[1] + p3[0] * p1[0] * (p3[0] - p1[0]) * p2[1] + p1[0] * p2[0] * (p1[0] - p2[0]) * p3[1]) / denom;
    return [a, b, c];
  }

  static getSinusoidCoefficients(coords) {
    // It's assumed that p1 is the root and p2 is the first peak
    const p1 = coords[0];
    const p2 = coords[1]; // Resulting coefficients are canonical for this sine curve

    const amplitude = p2[1] - p1[1];
    const angularFrequency = Math.PI / (2 * (p2[0] - p1[0]));
    const phase = p1[0] * angularFrequency;
    const verticalOffset = p1[1];
    return [amplitude, angularFrequency, phase, verticalOffset];
  }
  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */


  static getLineCoords(graph, props) {
    return (// $FlowFixMe[incompatible-return]
      graph.coords || InteractiveGraph.pointsFromNormalized(props, [[0.25, 0.75], [0.75, 0.75]])
    );
  }
  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */


  static getPointCoords(graph, props) {
    const numPoints = graph.numPoints || 1;
    let coords = graph.coords;

    if (coords) {
      return coords;
    }

    switch (numPoints) {
      case 1:
        // Back in the day, one point's coords were in graph.coord
        coords = [graph.coord || [0, 0]];
        break;

      case 2:
        coords = [[-5, 0], [5, 0]];
        break;

      case 3:
        coords = [[-5, 0], [0, 0], [5, 0]];
        break;

      case 4:
        coords = [[-6, 0], [-2, 0], [2, 0], [6, 0]];
        break;

      case 5:
        coords = [[-6, 0], [-3, 0], [0, 0], [3, 0], [6, 0]];
        break;

      case 6:
        coords = [[-5, 0], [-3, 0], [-1, 0], [1, 0], [3, 0], [5, 0]];
        break;

      case UNLIMITED:
        coords = [];
        break;
    } // Transform coords from their -10 to 10 space to 0 to 1
    // because of the old graph.coord, and also it's easier.


    const range = [[-10, 10], [-10, 10]]; // $FlowFixMe[incompatible-call]

    const newCoords = InteractiveGraph.normalizeCoords(coords, range);
    return InteractiveGraph.pointsFromNormalized(props, newCoords);
  }
  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */


  static getLinearSystemCoords(graph, props) {
    return (// The callers assume that we're return an array of points
      // $FlowFixMe[incompatible-return]
      graph.coords || ___default["default"].map([[[0.25, 0.75], [0.75, 0.75]], [[0.25, 0.25], [0.75, 0.25]]], coords => {
        return InteractiveGraph.pointsFromNormalized(props, coords);
      })
    );
  }
  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */


  static getPolygonCoords(graph, props) {
    if (graph.type !== "polygon") {
      throw makeInvalidTypeError("toggleShowSides", "polygon");
    }

    let coords = graph.coords;

    if (coords) {
      return coords;
    }

    const n = graph.numSides || 3;

    if (n === UNLIMITED) {
      coords = [];
    } else {
      // $FlowFixMe[unsafe-addition]
      const angle = 2 * Math.PI / n; // $FlowFixMe[unsafe-addition]

      const offset = (1 / n - 1 / 2) * Math.PI; // TODO(alex): Generalize this to more than just triangles so that
      // all polygons have whole number side lengths if snapping to sides

      const radius = graph.snapTo === "sides" ? Math.sqrt(3) / 3 * 7 : 4; // Generate coords of a regular polygon with n sides

      coords = ___default["default"].times(n, function (i) {
        return [radius * Math.cos(i * angle + offset), radius * Math.sin(i * angle + offset)];
      });
    }

    const ranges = [[-10, 10], [-10, 10]];
    coords = InteractiveGraph.normalizeCoords(coords, ranges);
    const snapToGrid = !___default["default"].contains(["angles", "sides"], graph.snapTo);
    coords = InteractiveGraph.pointsFromNormalized(props, coords,
    /* noSnap */
    !snapToGrid);
    return coords;
  }
  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */


  static getSegmentCoords(graph, props) {
    const coords = graph.coords;

    if (coords) {
      return coords;
    }

    const n = graph.numSegments || 1;
    const ys = {
      // $FlowFixMe[unsupported-syntax]
      1: [5],
      // $FlowFixMe[unsupported-syntax]
      2: [5, -5],
      // $FlowFixMe[unsupported-syntax]
      3: [5, 0, -5],
      // $FlowFixMe[unsupported-syntax]
      4: [6, 2, -2, -6],
      // $FlowFixMe[unsupported-syntax]
      5: [6, 3, 0, -3, -6],
      // $FlowFixMe[unsupported-syntax]
      6: [5, 3, 1, -1, -3, -5]
    }[n];
    const range = [[-10, 10], [-10, 10]];
    return ys.map(function (y) {
      let segment = [[-5, y], [5, y]];
      segment = InteractiveGraph.normalizeCoords(segment, range);
      segment = InteractiveGraph.pointsFromNormalized(props, segment);
      return segment;
    });
  }
  /**
   * @param {object} graph Like props.graph or props.correct
   * @param {object} props of an InteractiveGraph instance
   */


  static getAngleCoords(graph, props) {
    let coords = graph.coords;

    if (coords) {
      return coords;
    }

    const snap = graph.snapDegrees || 1;
    let angle = snap;

    while (angle < 20) {
      angle += snap;
    }

    angle = angle * Math.PI / 180;
    const offset = (graph.angleOffsetDeg || 0) * Math.PI / 180;
    coords = InteractiveGraph.pointsFromNormalized(props, [[0.85, 0.5], [0.5, 0.5]]);
    const radius = magnitude(vector(...coords)); // Adjust the lower point by angleOffsetDeg degrees
    // $FlowFixMe[cannot-write]

    coords[0] = [coords[1][0] + radius * Math.cos(offset), coords[1][1] + radius * Math.sin(offset)]; // Position the upper point angle radians from the
    // lower point
    // $FlowFixMe[cannot-write]

    coords[2] = [coords[1][0] + radius * Math.cos(angle + offset), coords[1][1] + radius * Math.sin(angle + offset)];
    return coords;
  }

  static normalizeCoords(coordsList, ranges) {
    return ___default["default"].map(coordsList, function (coords) {
      return ___default["default"].map(coords, function (coord, i) {
        const extent = ranges[i][1] - ranges[i][0];
        return (coord + ranges[i][1]) / extent;
      });
    });
  }

  static getEquationString(props) {
    const type = props.graph.type;
    const funcName = "get" + capitalize(type) + "EquationString"; // $FlowFixMe[incompatible-use]

    return InteractiveGraph[funcName](props);
  }

  static pointsFromNormalized(props, coordsList, noSnap) {
    return ___default["default"].map(coordsList, function (coords) {
      return ___default["default"].map(coords, function (coord, i) {
        const range = props.range[i];

        if (noSnap) {
          return range[0] + (range[1] - range[0]) * coord;
        }

        const step = props.step[i];
        const nSteps = numSteps(range, step);
        const tick = Math.round(coord * nSteps);
        return range[0] + step * tick;
      });
    });
  }

  static getLinearEquationString(props) {
    const coords = InteractiveGraph.getLineCoords(props.graph, props);

    if (eq(coords[0][0], coords[1][0])) {
      return "x = " + coords[0][0].toFixed(3);
    }

    const m = (coords[1][1] - coords[0][1]) / (coords[1][0] - coords[0][0]);
    const b = coords[0][1] - m * coords[0][0];

    if (eq(m, 0)) {
      return "y = " + b.toFixed(3);
    }

    return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
  }

  static getCurrentQuadraticCoefficients(props) {
    // TODO(alpert): Don't duplicate
    const coords = props.graph.coords || InteractiveGraph.defaultQuadraticCoords(props); // $FlowFixMe[incompatible-call]

    return InteractiveGraph.getQuadraticCoefficients(coords);
  }

  static defaultQuadraticCoords(props) {
    const coords = [[0.25, 0.75], [0.5, 0.25], [0.75, 0.75]];
    return InteractiveGraph.pointsFromNormalized(props, coords);
  }

  static getQuadraticEquationString(props) {
    const coeffs = InteractiveGraph.getCurrentQuadraticCoefficients(props);
    return "y = " + coeffs[0].toFixed(3) + "x^2 + " + coeffs[1].toFixed(3) + "x + " + coeffs[2].toFixed(3);
  }

  static getCurrentSinusoidCoefficients(props) {
    const coords = props.graph.coords || InteractiveGraph.defaultSinusoidCoords(props); // $FlowFixMe[incompatible-call]

    return InteractiveGraph.getSinusoidCoefficients(coords);
  }

  static defaultSinusoidCoords(props) {
    const coords = [[0.5, 0.5], [0.65, 0.6]];
    return InteractiveGraph.pointsFromNormalized(props, coords);
  }

  static getSinusoidEquationString(props) {
    const coeffs = InteractiveGraph.getCurrentSinusoidCoefficients(props);
    return "y = " + coeffs[0].toFixed(3) + "sin(" + coeffs[1].toFixed(3) + "x - " + coeffs[2].toFixed(3) + ") + " + coeffs[3].toFixed(3);
  }

  static getCircleEquationString(props) {
    const graph = props.graph; // TODO(alpert): Don't duplicate

    const center = graph.center || [0, 0];
    const radius = graph.radius || 2;
    return "center (" + center[0] + ", " + center[1] + "), radius " + radius;
  }

  static getLinearSystemEquationString(props) {
    const coords = InteractiveGraph.getLinearSystemCoords(props.graph, props);
    return "\n" + getLineEquation(coords[0][0], coords[0][1]) + "\n" + getLineEquation(coords[1][0], coords[1][1]) + "\n" + getLineIntersection(coords[0], coords[1]);
  }

  static getPointEquationString(props) {
    if (props.graph.type !== "point") {
      throw makeInvalidTypeError("getPointEquationString", "point");
    }

    const coords = InteractiveGraph.getPointCoords(props.graph, props);
    return coords.map(function (coord) {
      return "(" + coord[0] + ", " + coord[1] + ")";
    }).join(", ");
  }

  static getSegmentEquationString(props) {
    if (props.graph.type !== "segment") {
      throw makeInvalidTypeError("getSegmentEquationString", "segment");
    }

    const segments = InteractiveGraph.getSegmentCoords(props.graph, props);
    return ___default["default"].map(segments, function (segment) {
      return "[" + ___default["default"].map(segment, function (coord) {
        return "(" + coord.join(", ") + ")";
      }).join(" ") + "]";
    }).join(" ");
  }

  static getRayEquationString(props) {
    if (props.graph.type !== "ray") {
      throw makeInvalidTypeError("createPointForPolygonType", "ray");
    }

    const coords = InteractiveGraph.getLineCoords(props.graph, props);
    const a = coords[0];
    const b = coords[1];
    let eq = InteractiveGraph.getLinearEquationString(props);

    if (a[0] > b[0]) {
      eq += " (for x <= " + a[0].toFixed(3) + ")";
    } else if (a[0] < b[0]) {
      eq += " (for x >= " + a[0].toFixed(3) + ")";
    } else if (a[1] > b[1]) {
      eq += " (for y <= " + a[1].toFixed(3) + ")";
    } else {
      eq += " (for y >= " + a[1].toFixed(3) + ")";
    }

    return eq;
  }

  static getPolygonEquationString(props) {
    if (props.graph.type !== "polygon") {
      throw makeInvalidTypeError("getPolygonEquationString", "polygon");
    }

    const coords = InteractiveGraph.getPolygonCoords(props.graph, props);
    return ___default["default"].map(coords, function (coord) {
      return "(" + coord.join(", ") + ")";
    }).join(" ");
  }

  static getAngleEquationString(props) {
    if (props.graph.type !== "angle") {
      throw makeInvalidTypeError("getAngleEquationString", "angle");
    }

    const coords = InteractiveGraph.getAngleCoords(props.graph, props);
    const angle = GraphUtils.findAngle(coords[2], coords[0], coords[1]);
    return angle.toFixed(0) + "\u00B0 angle" + " at (" + coords[1].join(", ") + ")";
  }

  static validate( // TODO(kevinb): rename state to userInput
  state, // state === userInput
  rubric, component) {
    // When nothing has moved, there will neither be coords nor the
    // circle's center/radius fields. When those fields are absent, skip
    // all these checks; just go mark the answer as empty.
    const hasValue = !!(state.coords || state.center && state.radius);

    if (state.type === rubric.correct.type && hasValue) {
      if (state.type === "linear" && rubric.correct.type === "linear" && state.coords != null) {
        const guess = state.coords;
        const correct = rubric.correct.coords; // If both of the guess points are on the correct line, it's
        // correct.

        if ( // $FlowFixMe[incompatible-use] - Fix type so coords can't be omitted
        collinear(correct[0], correct[1], guess[0]) && collinear(correct[0], correct[1], guess[1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "linear-system" && rubric.correct.type === "linear-system" && state.coords != null) {
        const guess = state.coords; // $FlowFixMe[incompatible-cast] - Fix type so this can't be undefined

        const correct = rubric.correct.coords;

        if (collinear(correct[0][0], correct[0][1], guess[0][0]) && collinear(correct[0][0], correct[0][1], guess[0][1]) && collinear(correct[1][0], correct[1][1], guess[1][0]) && collinear(correct[1][0], correct[1][1], guess[1][1]) || collinear(correct[0][0], correct[0][1], guess[1][0]) && collinear(correct[0][0], correct[0][1], guess[1][1]) && collinear(correct[1][0], correct[1][1], guess[0][0]) && collinear(correct[1][0], correct[1][1], guess[0][1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "quadratic" && rubric.correct.type === "quadratic" && state.coords != null) {
        // If the parabola coefficients match, it's correct.
        const guessCoeffs = this.getQuadraticCoefficients(state.coords);
        const correctCoeffs = this.getQuadraticCoefficients( // $FlowFixMe[incompatible-call]
        // $FlowFixMe[prop-missing]
        rubric.correct.coords);

        if (deepEq$2(guessCoeffs, correctCoeffs)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "sinusoid" && rubric.correct.type === "sinusoid" && state.coords != null) {
        const guessCoeffs = this.getSinusoidCoefficients(state.coords);
        const correctCoeffs = this.getSinusoidCoefficients( // $FlowFixMe[incompatible-call]
        // $FlowFixMe[prop-missing]
        rubric.correct.coords);
        const canonicalGuessCoeffs = canonicalSineCoefficients(guessCoeffs);
        const canonicalCorrectCoeffs = canonicalSineCoefficients(correctCoeffs); // If the canonical coefficients match, it's correct.

        if (deepEq$2(canonicalGuessCoeffs, canonicalCorrectCoeffs)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "circle" && rubric.correct.type === "circle") {
        if (deepEq$2(state.center, rubric.correct.center) && // $FlowFixMe[prop-missing]
        eq(state.radius, rubric.correct.radius)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "point" && rubric.correct.type === "point" && state.coords != null) {
        var _state$coords;

        let correct = InteractiveGraph.getPointCoords(rubric.correct, component);
        const guess = (_state$coords = state.coords) === null || _state$coords === void 0 ? void 0 : _state$coords.slice();
        correct = correct.slice(); // Everything's already rounded so we shouldn't need to do an
        // eq() comparison but _.isEqual(0, -0) is false, so we'll use
        // eq() anyway. The sort should be fine because it'll stringify
        // it and -0 converted to a string is "0"

        guess === null || guess === void 0 ? void 0 : guess.sort();
        correct.sort();

        if (deepEq$2(guess, correct)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "polygon" && rubric.correct.type === "polygon" && state.coords != null) {
        var _state$coords2, _rubric$correct$coord;

        const guess = (_state$coords2 = state.coords) === null || _state$coords2 === void 0 ? void 0 : _state$coords2.slice(); // eslint-disable-line ft-flow/no-mutable-array
        // $FlowFixMe[incompatible-type]
        // $FlowFixMe[prop-missing]

        const correct = (_rubric$correct$coord = rubric.correct.coords) === null || _rubric$correct$coord === void 0 ? void 0 : _rubric$correct$coord.slice(); // eslint-disable-line ft-flow/no-mutable-array

        let match;

        if (rubric.correct.match === "similar") {
          match = similar(guess, correct, Number.POSITIVE_INFINITY);
        } else if (rubric.correct.match === "congruent") {
          match = similar(guess, correct, kmath.number.DEFAULT_TOLERANCE);
        } else if (rubric.correct.match === "approx") {
          match = similar(guess, correct, 0.1);
        } else {
          /* exact */
          guess.sort();
          correct.sort();
          match = deepEq$2(guess, correct);
        }

        if (match) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "segment" && rubric.correct.type === "segment" && state.coords != null) {
        var _rubric$correct$coord2;

        let guess = state.coords.slice(); // $FlowFixMe[prop-missing]

        let correct = (_rubric$correct$coord2 = rubric.correct.coords) === null || _rubric$correct$coord2 === void 0 ? void 0 : _rubric$correct$coord2.slice();
        guess = ___default["default"].invoke(guess, "sort").sort();
        correct = ___default["default"].invoke(correct, "sort").sort();

        if (deepEq$2(guess, correct)) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "ray" && rubric.correct.type === "ray" && state.coords != null) {
        const guess = state.coords;
        const correct = rubric.correct.coords;

        if ( // $FlowFixMe[incompatible-use]
        deepEq$2(guess[0], correct[0]) && // $FlowFixMe[incompatible-use]
        collinear(correct[0], correct[1], guess[1])) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      } else if (state.type === "angle" && rubric.correct.type === "angle") {
        const guess = state.coords;
        const correct = rubric.correct.coords;
        let match;

        if (rubric.correct.match === "congruent") {
          const angles = ___default["default"].map([guess, correct], function (coords) {
            const angle = GraphUtils.findAngle(coords[2], coords[0], coords[1]);
            return (angle + 360) % 360;
          });

          match = eq(...angles);
        } else {
          /* exact */
          match = // $FlowFixMe[incompatible-use]
          deepEq$2(guess[1], correct[1]) && // $FlowFixMe[incompatible-use]
          collinear(correct[1], correct[0], guess[0]) && // $FlowFixMe[incompatible-use]
          collinear(correct[1], correct[2], guess[2]);
        }

        if (match) {
          return {
            type: "points",
            earned: 1,
            total: 1,
            message: null
          };
        }
      }
    } // The input wasn't correct, so check if it's a blank input or if it's
    // actually just wrong


    if (!hasValue || ___default["default"].isEqual(state, rubric.graph)) {
      // We're where we started.
      return {
        type: "invalid",
        message: null
      };
    }

    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }

  static getUserInputFromProps(props) {
    return props.graph;
  }

}

_defineProperty(InteractiveGraph, "defaultProps", {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  // $FlowFixMe[prop-missing]
  backgroundImage: defaultBackgroundImage$1,
  markings: "graph",
  showTooltips: false,
  showProtractor: false,
  showRuler: false,
  rulerLabel: "",
  rulerTicks: 10,
  graph: {
    type: "linear"
  }
});

var InteractiveGraph$1 = {
  name: "interactive-graph",
  displayName: "Interactive graph",
  widget: InteractiveGraph
};

const black = "#000000";
const grayDarker = "#333333";
const grayDark = "#555555";
const gray = "#999999";
const grayLight = "#AAAAAA";
const grayLighter = "#DDDDDD";
const white = "#FFFFFF";
const blue = "#005A88";
const blueDark = "#2C3747";
const green = "#76A005";
const red = "#CF5044";
const yellow = "#FFC40D";
const orange = "#BF4F04";
const pink = "#C3325F";
const purple = "#7A43B6";
const bodyBackground = "#FFFFFF";
const textColor = "#444444";
const linkColor = "#005987";
const linkColorHover = "#678D00";
const sansFontFamily = "'Helvetica Neue',Helvetica,Arial,sans-serif";
const serifFontFamily = "Georgia,'Times New Roman',Times,serif";
const monoFontFamily = "Monaco,Menlo,Consolas,'Courier New',monospace";
const baseFontSize = "14px";
const baseFontFamily = "inherit";
const baseLineHeight = "20px";
const altFontFamily = "Georgia,'Times New Roman',Times,serif";
const headingsFontFamily = "inherit";
const headingsFontWeight = "bold";
const headingsColor = "inherit";
const fontSizeLarge = "18px";
const fontSizeSmall = "12px";
const fontSizeMini = "10.5px";
const paddingLarge = "11px 19px";
const paddingSmall = "2px 10px";
const paddingMini = "0 6px";
const baseBorderRadius = "4px";
const borderRadiusLarge = "6px";
const borderRadiusSmall = "3px";
const tableBackground = "#000000";
const tableBackgroundAccent = "#F9F9F9";
const tableBackgroundHover = "#F5F5F5";
const tableBorder = "#DDDDDD";
const btnBackground = "#FFFFFF";
const btnBackgroundHighlight = "rgb(230, 230, 230)";
const btnBorder = "#CCCCCC";
const btnPrimaryBackground = "#0088CC";
const btnPrimaryBackgroundHighlight = "rgb(0, 68, 204)";
const btnInfoBackground = "#5BC0DE";
const btnInfoBackgroundHighlight = "#2F96B4";
const btnSuccessBackground = "#62C462";
const btnSuccessBackgroundHighlight = "#51A351";
const btnWarningBackground = "rgb(251, 180, 81)";
const btnWarningBackgroundHighlight = "#F89406";
const btnDangerBackground = "#EE5F5B";
const btnDangerBackgroundHighlight = "#BD362F";
const btnInverseBackground = "#444444";
const btnInverseBackgroundHighlight = "#222222";
const inputBackground = "#FFFFFF";
const inputBorder = "#CCCCCC";
const inputBorderRadius = "4px";
const inputDisabledBackground = "#EEEEEE";
const formActionsBackground = "#F5F5F5";
const inputHeight = "30px";
const dropdownBackground = "#FFFFFF";
const dropdownBorder = "rgba(0, 0, 0, 0.2)";
const dropdownDividerTop = "#E5E5E5";
const dropdownDividerBottom = "#FFFFFF";
const dropdownLinkColor = "#333333";
const dropdownLinkColorHover = "#FFFFFF";
const dropdownLinkColorActive = "#FFFFFF";
const dropdownLinkBackgroundActive = "#0088CC";
const dropdownLinkBackgroundHover = "#0088CC";
const zindexDropdown = 1000;
const zindexPopover = 1010;
const zindexTooltip = 1030;
const zindexFixedNavbar = 1030;
const zindexHeader = 1060;
const zindexModalBackdrop = 1070;
const zindexModal = 1080;
const zindexAboveModal = 1090;
const iconSpritePath = "../img/glyphicons-halflings.png";
const iconWhiteSpritePath = "../img/glyphicons-halflings-white.png";
const placeholderText = "#999999";
const hrBorder = "#EEEEEE";
const horizontalComponentOffset = "180px";
const wellBackground = "#F5F5F5";
const navbarCollapseWidth = "979px";
const navbarCollapseDesktopWidth = "980px";
const navbarHeight = "40px";
const navbarBackgroundHighlight = "#FFFFFF";
const navbarBackground = "rgb(242, 242, 242)";
const navbarBorder = "rgb(212, 212, 212)";
const navbarText = "#777777";
const navbarLinkColor = "#777777";
const navbarLinkColorHover = "#333333";
const navbarLinkColorActive = "#555555";
const navbarLinkBackgroundHover = "#000000";
const navbarLinkBackgroundActive = "rgb(230, 230, 230)";
const navbarBrandColor = "#777777";
const navbarInverseBackground = "#111111";
const navbarInverseBackgroundHighlight = "#222222";
const navbarInverseBorder = "#252525";
const navbarInverseText = "#999999";
const navbarInverseLinkColor = "#999999";
const navbarInverseLinkColorHover = "#FFFFFF";
const navbarInverseLinkColorActive = "#FFFFFF";
const navbarInverseLinkBackgroundHover = "#000000";
const navbarInverseLinkBackgroundActive = "#111111";
const navbarInverseSearchBackground = "rgb(82, 82, 82)";
const navbarInverseSearchBackgroundFocus = "#FFFFFF";
const navbarInverseSearchBorder = "#111111";
const navbarInverseSearchPlaceholderColor = "#CCCCCC";
const navbarInverseBrandColor = "#999999";
const paginationBackground = "#FFFFFF";
const paginationBorder = "#DDDDDD";
const paginationActiveBackground = "#F5F5F5";
const heroUnitBackground = "#EEEEEE";
const heroUnitHeadingColor = "inherit";
const heroUnitLeadColor = "inherit";
const warningText = "#C09853";
const warningBackground = "#FCF8E3";
const warningBorder = "rgb(251, 239, 213)";
const errorText = "#B94A48";
const errorBackground = "#F2DEDE";
const errorBorder = "rgb(238, 211, 215)";
const successText = "#468847";
const successBackground = "#DFF0D8";
const successBorder = "rgb(212, 232, 197)";
const infoText = "#4A7C17";
const infoBackground = "#EDF2DF";
const infoBorder = "rgb(228, 232, 197)";
const tooltipColor = "#FFFFFF";
const tooltipBackground = "#000000";
const tooltipArrowWidth = "5px";
const tooltipArrowColor = "#000000";
const popoverBackground = "#FFFFFF";
const popoverArrowWidth = "10px";
const popoverArrowColor = "#FFFFFF";
const popoverTitleBackground = "rgb(247, 247, 247)";
const popoverArrowOuterWidth = "11px";
const popoverArrowOuterColor = "rgba(0, 0, 0, 0.25)";
const gridColumns = "12";
const gridColumnWidth = "60px";
const gridGutterWidth = "20px";
const gridRowWidth = "940px";
const gridColumnWidth1200 = "70px";
const gridGutterWidth1200 = "30px";
const gridRowWidth1200 = "1170px";
const gridColumnWidth768 = "42px";
const gridGutterWidth768 = "20px";
const gridRowWidth768 = "724px";
const fluidGridColumnWidth = "6.382978723404255%";
const fluidGridGutterWidth = "2.127659574468085%";
const fluidGridColumnWidth1200 = "5.982905982905983%";
const fluidGridGutterWidth1200 = "2.564102564102564%";
const fluidGridColumnWidth768 = "5.801104972375691%";
const fluidGridGutterWidth768 = "2.7624309392265194%";
const kaGreen = "#71B307";
const kaGreenLight = "#BED47A";
const kaBlue = "#314453";
const kaBlueLight = "#4D6779";
const grayExtraDark = "#111111";
const grayExtraLight = "#EEEEEE";
const graySuperLight = "#F7F7F7";
const whiteDark = "#FDFDFD";
const dark = "#21242C";
const blueDarkUnsaturated = "#3B414E";
const blueDarkSaturated = "#1F3043";
const blueLight = "#A9C0D1";
const greenLight = "#C6D1AD";
const greenDark = "#356700";
const yellowGreen = "#9DB63B";
const okGreen = "#A7CF5B";
const alertRed = "#C42420";
const coral = "#EE6666";
const grayBlue = "#9AB3B9";
const lightPageBackground = "#FDFDFD";
const yclaBlue = "#49BAD5";
const yclaTeal = "#56D0B3";
const yclaTealDark = "#50C1A7";
const yclaGreenDark = "#3D9A82";
const yclaGreen = "#81C262";
const learnstormBlue = "#4898FC";
const homepageBlue = "#46A8BF";
const backgroundBlue = "#00294A";
const teacherSignupBlue = "#335d7d";
const homepageGreen = "#2B8E7B";
const streakColor = "#F79734";
const facebookColor = "#1A60A2";
const blueGoogleColor = "#2CAFE2";
const redGoogleColor = "#BF4434";
const homepageColor = "#2D585E";
const lightTextColor = "#898989";
const fontSizeTiny = "11px";
const fontSizeNormal = "14px";
const fontSizeMedium = "16px";
const fontSizeExtraLarge = "24px";
const fontSizeHuge = "36px";
const fontSizeBakana = "48px";
const fontSizeBananas = "60px";
const fixedWidthFontFamily = "'Helvetica Neue',Helvetica,Arial,sans-serif";
const contentPadding = "20px";
const primaryButtonBackground = "#89B908";
const primaryButtonBorder = "#76A005";
const buttonTextColor = "rgb(122, 122, 122)";
const buttonBorderRadius = "3px";
const basicBorderColor = "#CCCCCC";
const minContainerWidth = "1000px";
const maxContainerWidth = "1200px";
const formHintColor = "#999999";
const guidelineExampleText = "#606060";
const hoverCardWidth = "450px";
const menuHighlightColor = "#96AB4F";
const menuHighlightBorderColor = "#76A005";
const menuActiveTextColor = "#FFFFFF";
const menuInactiveTextColor = "#444444";
const menuSubheaderTextColor = "rgb(120, 120, 120)";
const menuBorderColor = "#94A170";
const unreadBackgroundColor = "#ECEEF4";
const menuLineHeight = "18px";
const menuSubheaderLineHeight = "17px";
const menuSubheaderFontSize = "9px";
const notificationBarColor = "#4858A4";
const modalBodyTopPadding = "20px";
const modalDialogPadding = "15px";
const modalSectionPadding = "9px";
const mathDomain1 = "#11ACCD";
const mathDomain2 = "#63D9EA";
const mathDomain3 = "#027d97";
const mathDomain4 = "#085566";
const partnerContentDomain1 = "#01A995";
const partnerContentDomain2 = "#01D1C1";
const partnerContentDomain3 = "#208170";
const partnerContentDomain4 = "#144F44";
const csDomain1 = "#1FAB54";
const csDomain2 = "#74CF70";
const csDomain3 = "#0D923F";
const csDomain4 = "#085E29";
const economicsDomain1 = "#E07D10";
const economicsDomain2 = "#FFBE26";
const economicsDomain3 = "#A75A05";
const economicsDomain4 = "#953C02";
const collegeCareersMoreDomain1 = "#01A995";
const collegeCareersMoreDomain2 = "#01D1C1";
const collegeCareersMoreDomain3 = "#208170";
const collegeCareersMoreDomain4 = "#144F44";
const humanitiesDomain1 = "#E84D39";
const humanitiesDomain2 = "#FF8482";
const humanitiesDomain3 = "#BE2612";
const humanitiesDomain4 = "#8C1C0D";
const gtpDomain1 = "#1865F2";
const gtpDomain2 = "#1865F2";
const gtpDomain3 = "#1865F2";
const gtpDomain4 = "#1865F2";
const scienceDomain1 = "#CA337C";
const scienceDomain2 = "#FF92C6";
const scienceDomain3 = "#9E034E";
const scienceDomain4 = "#6B0235";
const testPrepDomain1 = "#1865F2";
const testPrepDomain2 = "#1865F2";
const testPrepDomain3 = "#1865F2";
const testPrepDomain4 = "#1865F2";
const defaultDomain1 = "#1865F2";
const defaultDomain2 = "#66afe9";
const defaultDomain3 = "#1152b0";
const defaultDomain4 = "#0d3d82";
const defaultDomainColor = "#314453";
const defaultSubjectColor = "#4D6779";
const defaultTopicColor = "#6A8DA6";
const defaultHoverColor = "#314453";
const defaultLinkColor = "#314453";
const defaultLinkHoverColor = "#6A8DA6";
const scienceDomainColor = "#94424F";
const scienceSubjectColor = "#9D4A5A";
const scienceTopicColor = "#C55F73";
const scienceHoverColor = "#94424F";
const scienceLinkColor = "#94424F";
const scienceLinkHoverColor = "#C55F73";
const humanitiesDomainColor = "#AD3434";
const humanitiesSubjectColor = "#C13B31";
const humanitiesTopicColor = "#D24A45";
const humanitiesHoverColor = "#AD3434";
const humanitiesLinkColor = "#AD3434";
const humanitiesLinkHoverColor = "#D24A45";
const economicsDomainColor = "#B77033";
const economicsSubjectColor = "#BF7B34";
const economicsTopicColor = "#D1933B";
const economicsHoverColor = "#B77033";
const economicsLinkColor = "#B77033";
const economicsLinkHoverColor = "#D1933B";
const csDomainColor = "#437A39";
const csSubjectColor = "#53893E";
const csTopicColor = "#689B51";
const csHoverColor = "#437A39";
const csLinkColor = "#437A39";
const csLinkHoverColor = "#689B51";
const partnerContentDomainColor = "#218270";
const partnerContentSubjectColor = "#2C8D7B";
const partnerContentTopicColor = "#329A86";
const partnerContentHoverColor = "#218270";
const partnerContentLinkColor = "#218270";
const partnerContentLinkHoverColor = "#329A86";
const essayDomainColor = "#0071B3";
const mathDomainColor = "#1C758A";
const mathSubjectColor = "#46A8BF";
const mathTopicColor = "#4FBAD4";
const mathHoverColor = "#1C758A";
const mathLinkColor = "#1C758A";
const mathLinkHoverColor = "#4FBAD4";
const testPrepDomainColor = "#644172";
const testPrepSubjectColor = "#7E5F8E";
const testPrepTopicColor = "#9A72AC";
const testPrepHoverColor = "#644172";
const testPrepLinkColor = "#644172";
const testPrepLinkHoverColor = "#9A72AC";
const collegeCareersMoreDomainColor = "#218270";
const collegeCareersMoreSubjectColor = "#2C8D7B";
const collegeCareersMoreTopicColor = "#329A86";
const collegeCareersMoreHoverColor = "#218270";
const collegeCareersMoreLinkColor = "#218270";
const collegeCareersMoreLinkHoverColor = "#329A86";
const satDomainColor = "#0084CE";
const satSubjectColor = "#0084CE";
const satTopicColor = "#0084CE";
const satHoverColor = "#0084CE";
const satLinkColor = "#0084CE";
const satLinkHoverColor = "#0084CE";
const colorProficient = "#1C758A";
const colorPracticed = "rgb(158, 221, 235)";
const colorMastery1 = "rgb(90, 197, 221)";
const colorMastery2 = "rgb(42, 174, 203)";
const colorMastery3 = "#1C758A";
const colorSuggested = "#73982C";
const colorReview = "#E35D04";
const colorNotStarted = "#CCCCCC";
const colorStarted = "#C7E5F7";
const colorStruggling = "#C30202";
const colorPersonal = "#00809C";
const colorPractice = "#96D9FF";
const colorEnergyPoints = "#005987";
const pureSmMin = "568px";
const pureMdMin = "768px";
const pureLgMin = "1024px";
const pureXlMin = "1200px";
const pureXsMax = "567px";
const pureSmMax = "767px";
const pureMdMax = "1023px";
const pureLgMax = "1199px";

var globalConstants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    black: black,
    grayDarker: grayDarker,
    grayDark: grayDark,
    gray: gray,
    grayLight: grayLight,
    grayLighter: grayLighter,
    white: white,
    blue: blue,
    blueDark: blueDark,
    green: green,
    red: red,
    yellow: yellow,
    orange: orange,
    pink: pink,
    purple: purple,
    bodyBackground: bodyBackground,
    textColor: textColor,
    linkColor: linkColor,
    linkColorHover: linkColorHover,
    sansFontFamily: sansFontFamily,
    serifFontFamily: serifFontFamily,
    monoFontFamily: monoFontFamily,
    baseFontSize: baseFontSize,
    baseFontFamily: baseFontFamily,
    baseLineHeight: baseLineHeight,
    altFontFamily: altFontFamily,
    headingsFontFamily: headingsFontFamily,
    headingsFontWeight: headingsFontWeight,
    headingsColor: headingsColor,
    fontSizeLarge: fontSizeLarge,
    fontSizeSmall: fontSizeSmall,
    fontSizeMini: fontSizeMini,
    paddingLarge: paddingLarge,
    paddingSmall: paddingSmall,
    paddingMini: paddingMini,
    baseBorderRadius: baseBorderRadius,
    borderRadiusLarge: borderRadiusLarge,
    borderRadiusSmall: borderRadiusSmall,
    tableBackground: tableBackground,
    tableBackgroundAccent: tableBackgroundAccent,
    tableBackgroundHover: tableBackgroundHover,
    tableBorder: tableBorder,
    btnBackground: btnBackground,
    btnBackgroundHighlight: btnBackgroundHighlight,
    btnBorder: btnBorder,
    btnPrimaryBackground: btnPrimaryBackground,
    btnPrimaryBackgroundHighlight: btnPrimaryBackgroundHighlight,
    btnInfoBackground: btnInfoBackground,
    btnInfoBackgroundHighlight: btnInfoBackgroundHighlight,
    btnSuccessBackground: btnSuccessBackground,
    btnSuccessBackgroundHighlight: btnSuccessBackgroundHighlight,
    btnWarningBackground: btnWarningBackground,
    btnWarningBackgroundHighlight: btnWarningBackgroundHighlight,
    btnDangerBackground: btnDangerBackground,
    btnDangerBackgroundHighlight: btnDangerBackgroundHighlight,
    btnInverseBackground: btnInverseBackground,
    btnInverseBackgroundHighlight: btnInverseBackgroundHighlight,
    inputBackground: inputBackground,
    inputBorder: inputBorder,
    inputBorderRadius: inputBorderRadius,
    inputDisabledBackground: inputDisabledBackground,
    formActionsBackground: formActionsBackground,
    inputHeight: inputHeight,
    dropdownBackground: dropdownBackground,
    dropdownBorder: dropdownBorder,
    dropdownDividerTop: dropdownDividerTop,
    dropdownDividerBottom: dropdownDividerBottom,
    dropdownLinkColor: dropdownLinkColor,
    dropdownLinkColorHover: dropdownLinkColorHover,
    dropdownLinkColorActive: dropdownLinkColorActive,
    dropdownLinkBackgroundActive: dropdownLinkBackgroundActive,
    dropdownLinkBackgroundHover: dropdownLinkBackgroundHover,
    zindexDropdown: zindexDropdown,
    zindexPopover: zindexPopover,
    zindexTooltip: zindexTooltip,
    zindexFixedNavbar: zindexFixedNavbar,
    zindexHeader: zindexHeader,
    zindexModalBackdrop: zindexModalBackdrop,
    zindexModal: zindexModal,
    zindexAboveModal: zindexAboveModal,
    iconSpritePath: iconSpritePath,
    iconWhiteSpritePath: iconWhiteSpritePath,
    placeholderText: placeholderText,
    hrBorder: hrBorder,
    horizontalComponentOffset: horizontalComponentOffset,
    wellBackground: wellBackground,
    navbarCollapseWidth: navbarCollapseWidth,
    navbarCollapseDesktopWidth: navbarCollapseDesktopWidth,
    navbarHeight: navbarHeight,
    navbarBackgroundHighlight: navbarBackgroundHighlight,
    navbarBackground: navbarBackground,
    navbarBorder: navbarBorder,
    navbarText: navbarText,
    navbarLinkColor: navbarLinkColor,
    navbarLinkColorHover: navbarLinkColorHover,
    navbarLinkColorActive: navbarLinkColorActive,
    navbarLinkBackgroundHover: navbarLinkBackgroundHover,
    navbarLinkBackgroundActive: navbarLinkBackgroundActive,
    navbarBrandColor: navbarBrandColor,
    navbarInverseBackground: navbarInverseBackground,
    navbarInverseBackgroundHighlight: navbarInverseBackgroundHighlight,
    navbarInverseBorder: navbarInverseBorder,
    navbarInverseText: navbarInverseText,
    navbarInverseLinkColor: navbarInverseLinkColor,
    navbarInverseLinkColorHover: navbarInverseLinkColorHover,
    navbarInverseLinkColorActive: navbarInverseLinkColorActive,
    navbarInverseLinkBackgroundHover: navbarInverseLinkBackgroundHover,
    navbarInverseLinkBackgroundActive: navbarInverseLinkBackgroundActive,
    navbarInverseSearchBackground: navbarInverseSearchBackground,
    navbarInverseSearchBackgroundFocus: navbarInverseSearchBackgroundFocus,
    navbarInverseSearchBorder: navbarInverseSearchBorder,
    navbarInverseSearchPlaceholderColor: navbarInverseSearchPlaceholderColor,
    navbarInverseBrandColor: navbarInverseBrandColor,
    paginationBackground: paginationBackground,
    paginationBorder: paginationBorder,
    paginationActiveBackground: paginationActiveBackground,
    heroUnitBackground: heroUnitBackground,
    heroUnitHeadingColor: heroUnitHeadingColor,
    heroUnitLeadColor: heroUnitLeadColor,
    warningText: warningText,
    warningBackground: warningBackground,
    warningBorder: warningBorder,
    errorText: errorText,
    errorBackground: errorBackground,
    errorBorder: errorBorder,
    successText: successText,
    successBackground: successBackground,
    successBorder: successBorder,
    infoText: infoText,
    infoBackground: infoBackground,
    infoBorder: infoBorder,
    tooltipColor: tooltipColor,
    tooltipBackground: tooltipBackground,
    tooltipArrowWidth: tooltipArrowWidth,
    tooltipArrowColor: tooltipArrowColor,
    popoverBackground: popoverBackground,
    popoverArrowWidth: popoverArrowWidth,
    popoverArrowColor: popoverArrowColor,
    popoverTitleBackground: popoverTitleBackground,
    popoverArrowOuterWidth: popoverArrowOuterWidth,
    popoverArrowOuterColor: popoverArrowOuterColor,
    gridColumns: gridColumns,
    gridColumnWidth: gridColumnWidth,
    gridGutterWidth: gridGutterWidth,
    gridRowWidth: gridRowWidth,
    gridColumnWidth1200: gridColumnWidth1200,
    gridGutterWidth1200: gridGutterWidth1200,
    gridRowWidth1200: gridRowWidth1200,
    gridColumnWidth768: gridColumnWidth768,
    gridGutterWidth768: gridGutterWidth768,
    gridRowWidth768: gridRowWidth768,
    fluidGridColumnWidth: fluidGridColumnWidth,
    fluidGridGutterWidth: fluidGridGutterWidth,
    fluidGridColumnWidth1200: fluidGridColumnWidth1200,
    fluidGridGutterWidth1200: fluidGridGutterWidth1200,
    fluidGridColumnWidth768: fluidGridColumnWidth768,
    fluidGridGutterWidth768: fluidGridGutterWidth768,
    kaGreen: kaGreen,
    kaGreenLight: kaGreenLight,
    kaBlue: kaBlue,
    kaBlueLight: kaBlueLight,
    grayExtraDark: grayExtraDark,
    grayExtraLight: grayExtraLight,
    graySuperLight: graySuperLight,
    whiteDark: whiteDark,
    dark: dark,
    blueDarkUnsaturated: blueDarkUnsaturated,
    blueDarkSaturated: blueDarkSaturated,
    blueLight: blueLight,
    greenLight: greenLight,
    greenDark: greenDark,
    yellowGreen: yellowGreen,
    okGreen: okGreen,
    alertRed: alertRed,
    coral: coral,
    grayBlue: grayBlue,
    lightPageBackground: lightPageBackground,
    yclaBlue: yclaBlue,
    yclaTeal: yclaTeal,
    yclaTealDark: yclaTealDark,
    yclaGreenDark: yclaGreenDark,
    yclaGreen: yclaGreen,
    learnstormBlue: learnstormBlue,
    homepageBlue: homepageBlue,
    backgroundBlue: backgroundBlue,
    teacherSignupBlue: teacherSignupBlue,
    homepageGreen: homepageGreen,
    streakColor: streakColor,
    facebookColor: facebookColor,
    blueGoogleColor: blueGoogleColor,
    redGoogleColor: redGoogleColor,
    homepageColor: homepageColor,
    lightTextColor: lightTextColor,
    fontSizeTiny: fontSizeTiny,
    fontSizeNormal: fontSizeNormal,
    fontSizeMedium: fontSizeMedium,
    fontSizeExtraLarge: fontSizeExtraLarge,
    fontSizeHuge: fontSizeHuge,
    fontSizeBakana: fontSizeBakana,
    fontSizeBananas: fontSizeBananas,
    fixedWidthFontFamily: fixedWidthFontFamily,
    contentPadding: contentPadding,
    primaryButtonBackground: primaryButtonBackground,
    primaryButtonBorder: primaryButtonBorder,
    buttonTextColor: buttonTextColor,
    buttonBorderRadius: buttonBorderRadius,
    basicBorderColor: basicBorderColor,
    minContainerWidth: minContainerWidth,
    maxContainerWidth: maxContainerWidth,
    formHintColor: formHintColor,
    guidelineExampleText: guidelineExampleText,
    hoverCardWidth: hoverCardWidth,
    menuHighlightColor: menuHighlightColor,
    menuHighlightBorderColor: menuHighlightBorderColor,
    menuActiveTextColor: menuActiveTextColor,
    menuInactiveTextColor: menuInactiveTextColor,
    menuSubheaderTextColor: menuSubheaderTextColor,
    menuBorderColor: menuBorderColor,
    unreadBackgroundColor: unreadBackgroundColor,
    menuLineHeight: menuLineHeight,
    menuSubheaderLineHeight: menuSubheaderLineHeight,
    menuSubheaderFontSize: menuSubheaderFontSize,
    notificationBarColor: notificationBarColor,
    modalBodyTopPadding: modalBodyTopPadding,
    modalDialogPadding: modalDialogPadding,
    modalSectionPadding: modalSectionPadding,
    mathDomain1: mathDomain1,
    mathDomain2: mathDomain2,
    mathDomain3: mathDomain3,
    mathDomain4: mathDomain4,
    partnerContentDomain1: partnerContentDomain1,
    partnerContentDomain2: partnerContentDomain2,
    partnerContentDomain3: partnerContentDomain3,
    partnerContentDomain4: partnerContentDomain4,
    csDomain1: csDomain1,
    csDomain2: csDomain2,
    csDomain3: csDomain3,
    csDomain4: csDomain4,
    economicsDomain1: economicsDomain1,
    economicsDomain2: economicsDomain2,
    economicsDomain3: economicsDomain3,
    economicsDomain4: economicsDomain4,
    collegeCareersMoreDomain1: collegeCareersMoreDomain1,
    collegeCareersMoreDomain2: collegeCareersMoreDomain2,
    collegeCareersMoreDomain3: collegeCareersMoreDomain3,
    collegeCareersMoreDomain4: collegeCareersMoreDomain4,
    humanitiesDomain1: humanitiesDomain1,
    humanitiesDomain2: humanitiesDomain2,
    humanitiesDomain3: humanitiesDomain3,
    humanitiesDomain4: humanitiesDomain4,
    gtpDomain1: gtpDomain1,
    gtpDomain2: gtpDomain2,
    gtpDomain3: gtpDomain3,
    gtpDomain4: gtpDomain4,
    scienceDomain1: scienceDomain1,
    scienceDomain2: scienceDomain2,
    scienceDomain3: scienceDomain3,
    scienceDomain4: scienceDomain4,
    testPrepDomain1: testPrepDomain1,
    testPrepDomain2: testPrepDomain2,
    testPrepDomain3: testPrepDomain3,
    testPrepDomain4: testPrepDomain4,
    defaultDomain1: defaultDomain1,
    defaultDomain2: defaultDomain2,
    defaultDomain3: defaultDomain3,
    defaultDomain4: defaultDomain4,
    defaultDomainColor: defaultDomainColor,
    defaultSubjectColor: defaultSubjectColor,
    defaultTopicColor: defaultTopicColor,
    defaultHoverColor: defaultHoverColor,
    defaultLinkColor: defaultLinkColor,
    defaultLinkHoverColor: defaultLinkHoverColor,
    scienceDomainColor: scienceDomainColor,
    scienceSubjectColor: scienceSubjectColor,
    scienceTopicColor: scienceTopicColor,
    scienceHoverColor: scienceHoverColor,
    scienceLinkColor: scienceLinkColor,
    scienceLinkHoverColor: scienceLinkHoverColor,
    humanitiesDomainColor: humanitiesDomainColor,
    humanitiesSubjectColor: humanitiesSubjectColor,
    humanitiesTopicColor: humanitiesTopicColor,
    humanitiesHoverColor: humanitiesHoverColor,
    humanitiesLinkColor: humanitiesLinkColor,
    humanitiesLinkHoverColor: humanitiesLinkHoverColor,
    economicsDomainColor: economicsDomainColor,
    economicsSubjectColor: economicsSubjectColor,
    economicsTopicColor: economicsTopicColor,
    economicsHoverColor: economicsHoverColor,
    economicsLinkColor: economicsLinkColor,
    economicsLinkHoverColor: economicsLinkHoverColor,
    csDomainColor: csDomainColor,
    csSubjectColor: csSubjectColor,
    csTopicColor: csTopicColor,
    csHoverColor: csHoverColor,
    csLinkColor: csLinkColor,
    csLinkHoverColor: csLinkHoverColor,
    partnerContentDomainColor: partnerContentDomainColor,
    partnerContentSubjectColor: partnerContentSubjectColor,
    partnerContentTopicColor: partnerContentTopicColor,
    partnerContentHoverColor: partnerContentHoverColor,
    partnerContentLinkColor: partnerContentLinkColor,
    partnerContentLinkHoverColor: partnerContentLinkHoverColor,
    essayDomainColor: essayDomainColor,
    mathDomainColor: mathDomainColor,
    mathSubjectColor: mathSubjectColor,
    mathTopicColor: mathTopicColor,
    mathHoverColor: mathHoverColor,
    mathLinkColor: mathLinkColor,
    mathLinkHoverColor: mathLinkHoverColor,
    testPrepDomainColor: testPrepDomainColor,
    testPrepSubjectColor: testPrepSubjectColor,
    testPrepTopicColor: testPrepTopicColor,
    testPrepHoverColor: testPrepHoverColor,
    testPrepLinkColor: testPrepLinkColor,
    testPrepLinkHoverColor: testPrepLinkHoverColor,
    collegeCareersMoreDomainColor: collegeCareersMoreDomainColor,
    collegeCareersMoreSubjectColor: collegeCareersMoreSubjectColor,
    collegeCareersMoreTopicColor: collegeCareersMoreTopicColor,
    collegeCareersMoreHoverColor: collegeCareersMoreHoverColor,
    collegeCareersMoreLinkColor: collegeCareersMoreLinkColor,
    collegeCareersMoreLinkHoverColor: collegeCareersMoreLinkHoverColor,
    satDomainColor: satDomainColor,
    satSubjectColor: satSubjectColor,
    satTopicColor: satTopicColor,
    satHoverColor: satHoverColor,
    satLinkColor: satLinkColor,
    satLinkHoverColor: satLinkHoverColor,
    colorProficient: colorProficient,
    colorPracticed: colorPracticed,
    colorMastery1: colorMastery1,
    colorMastery2: colorMastery2,
    colorMastery3: colorMastery3,
    colorSuggested: colorSuggested,
    colorReview: colorReview,
    colorNotStarted: colorNotStarted,
    colorStarted: colorStarted,
    colorStruggling: colorStruggling,
    colorPersonal: colorPersonal,
    colorPractice: colorPractice,
    colorEnergyPoints: colorEnergyPoints,
    pureSmMin: pureSmMin,
    pureMdMin: pureMdMin,
    pureLgMin: pureLgMin,
    pureXlMin: pureXlMin,
    pureXsMax: pureXsMax,
    pureSmMax: pureSmMax,
    pureMdMax: pureMdMax,
    pureLgMax: pureLgMax
});

const colors$1 = {
  white: "#FFFFFF",
  gray98: "#FAFAFA",
  gray97: "#F6F7F7",
  gray95: "#F0F1F2",
  gray90: "#E3E5E6",
  gray85: "#D6D8DA",
  gray76: "#BABEC2",
  gray72: "#999A9D",
  gray68: "#888D93",
  gray55: "#707378",
  gray41: "#626569",
  gray25: "#3B3E40",
  gray17: "#21242C",
  gray10: "#1499af",
  black: "#000000",
  // These colors are pulled out from constants.js, which is itself generated
  // from variables.less. We should probably avoid duplicating these here.
  alertRed,
  homepageBlue,
  kaBlue,
  kaBlueLight,
  kaGreen,
  kaGreenLight,
  learnstormBlue,
  backgroundBlue,
  adminGreen: "#78C008",
  kaBlueExtraLight: "#39c2db",
  kaBlueHover: "#0c7f99",
  kaGreenHover: "#518005",
  // Domain-agnostic colors related to the study guide experience in the
  // content library.
  skyDark: "#001f4d",
  recommendationGold: "#ffbe26",
  starAced: "#ff9c39",
  // We interploate the domain colors into this colors object for
  // historical reasons, but everyone using domain-specific colors
  // should switch to using the domainColors() function to look up
  // colors instead.
  //
  // TODO(davidflanagan): remove this line once everything is
  // working correctly with the domainColors() accessor.
  // ...domainToColorsMap,
  // mission: missionColors,
  // Colors for various OAuth providers
  google: "#C1432f",
  modernGoogle: "#be2612",
  modernGoogleHover: "#8c1c0d",
  facebook: "#4267B2",
  modernFacebook: "#4267B2",
  modernFacebookHover: "#00294a",
  wonderBlocksGold: "#FFB100",
  wonderBlocksLightBlue: "#37C5FD",
  // We're using rgba instead of opacity to avoid affecting the focus outline
  // when we just want to make the color transparent.
  breadcrumbs: "rgba(255, 255, 255, 0.7)"
};
const borderRadius = 4;
const breadcrumbStyles = {
  color: colors$1.breadcrumbs,
  fontFamily: "inherit",
  fontSize: 15,
  fontWeight: "bold",
  letterSpacing: 0.8,
  lineHeight: "19px",
  textTransform: "uppercase",
  // Disable subpixel antialiasing for OSX (improves light on dark text)
  MozOsxFontSmoothing: "grayscale",
  WebkitFontSmoothing: "antialiased"
};
const fonts = {
  // The body of the page is setup to use 'Helvetica' by default and
  // 'Lato' if/once it downloads. For your elements to follow this
  // pattern, all you need is to make the text in your element
  // inherit from the body using the "inherit" value.
  regular: "inherit"
};
const typography = {
  // For subject names
  subjectHeadingDesktop: {
    fontFamily: "inherit",
    fontSize: 50,
    fontWeight: "bold",
    lineHeight: "61px"
  },
  subjectHeadingMobile: {
    fontFamily: "inherit",
    fontSize: 35,
    fontWeight: "bold",
    lineHeight: "37px"
  },
  // For the most important thing on the page
  conceptHeadingDesktop: {
    fontFamily: "inherit",
    fontSize: 35,
    fontWeight: "bold",
    lineHeight: "37px"
  },
  conceptHeadingMobile: {
    fontFamily: "inherit",
    fontSize: 23,
    fontWeight: "bold",
    lineHeight: "27px"
  },
  // For sections or modules
  subheadingDesktop: {
    fontFamily: "inherit",
    fontSize: 23,
    fontWeight: "bold",
    lineHeight: "27px"
  },
  subheadingMobile: {
    fontFamily: "inherit",
    fontSize: 20,
    fontWeight: "bold",
    lineHeight: "24px"
  },
  smallSubheadingDesktop: {
    fontFamily: "inherit",
    fontSize: 20,
    lineHeight: 1.25
  },
  smallSubheadingMobile: {
    fontFamily: "inherit",
    fontSize: 15,
    lineHeight: 1.25
  },
  // For callouts
  smallHeading: {
    color: colors$1.gray25,
    fontFamily: "inherit",
    fontSize: 17,
    fontWeight: "bold",
    lineHeight: "23px"
  },
  smallHeadingMobile: {
    color: colors$1.gray25,
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    lineHeight: "18px"
  },
  // Accent headings
  accentHeading: {
    color: colors$1.gray68,
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    letterSpacing: 0.8,
    lineHeight: "19px",
    textTransform: "uppercase"
  },
  bodyLarge: {
    // For articles with multiple paragraphs
    fontFamily: fonts.regular,
    fontSize: 20,
    lineHeight: "30px"
  },
  bodySmall: {
    // For small blocks of copy
    fontFamily: fonts.regular,
    fontSize: 17,
    fontWeight: "normal",
    lineHeight: "23px"
  },
  bodySmallBold: {
    // For small blocks of copy
    fontFamily: fonts.regular,
    fontSize: 17,
    fontWeight: "bold",
    lineHeight: "23px"
  },
  bodyXsmall: {
    // For metadata, descriptions, etc
    fontFamily: fonts.regular,
    fontSize: 15,
    lineHeight: "22px"
  },
  bodyXsmallBold: {
    // For emphasized metadata, descriptions, etc
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    lineHeight: "22px"
  },
  breadcrumb: breadcrumbStyles,
  // For in-page tabs, breadcrumbs
  breadcrumbSmall: { // For in-page tabs and leaf page breadcrumbs
    ...breadcrumbStyles,
    fontSize: 12,
    lineHeight: "13px"
  },
  labelLarge: {
    // For chiclets and thumbnail titles
    fontFamily: "inherit",
    fontSize: 23,
    fontWeight: "bold",
    lineHeight: "27px"
  },
  labelMedium: {
    // For chiclets and thumbnail titles
    fontFamily: "inherit",
    fontSize: 15,
    fontWeight: "bold",
    lineHeight: "18px"
  },
  labelSmall: {
    // Generally used with labelLarge, for breadcrumbs in thumbnails
    fontFamily: fonts.regular,
    fontSize: 12,
    lineHeight: "14px"
  },
  caption: {
    // For image captions
    fontFamily: fonts.regular,
    fontSize: 14,
    fontStyle: "italic",
    lineHeight: "17px"
  },
  desktopScalingOnMobile: {
    // For when you need Mobile Safari and friends to stick to desktop
    // sizes
    MozTextSizeAdjust: "100%",
    MsTextSizeAdjust: "100%",
    WebkitTextSizeAdjust: "100%"
  },
  // TODO (josh): This should move to within <ModalHeader>
  modalSubtitle: {
    fontSize: 12,
    lineHeight: 1.65,
    // NOTE (josh): Font smoothing used here to create a 'medium' weight
    // font, between normal and bold, on webkit browsers.
    // This prop is an a11y risk when used on non-bold text, since it
    // makes text very thin, but it's fine on bold text.
    WebkitFontSmoothing: "antialiased",
    fontWeight: "bold"
  },
  // HACK(kevinb): temporary wonder blocks styles for header only
  // TODO(kevinb): use components from wonder-blocks-typography instead
  wonderBlocksHeader: {
    paddingLeft: 16,
    paddingRight: 16,
    paddingBottom: 24,
    paddingTop: 34,
    [mediaQueries.mdOrLarger]: {
      paddingBottom: 32
    }
  },
  // HACK(kevinb): temporary wonder blocks styles for header only
  // TODO(kevinb): use components from wonder-blocks-typography instead
  wonderBlocksTitle: {
    color: colors$1.white,
    fontWeight: 900,
    // "Black" weight
    fontSize: 28,
    lineHeight: "32px",
    margin: 0,
    [mediaQueries.mdOrLarger]: {
      fontSize: 36,
      lineHeight: "40px"
    }
  },
  // HACK(kevinb): temporary wonder blocks styles for header only
  // TODO(kevinb): use components from wonder-blocks-typography instead
  wonderBlocksLabelLarge: {
    fontSize: 16,
    lineHeight: "20px",
    fontWeight: 700 // Bold

  }
};

var globalStyles = /*#__PURE__*/Object.freeze({
    __proto__: null,
    colors: colors$1,
    borderRadius: borderRadius,
    fonts: fonts,
    typography: typography
});

class AnswerChoice extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_input", void 0);

    _defineProperty(this, "state", {
      isInputFocused: false
    });
  }

  focusInput() {
    if (this._input) {
      this._input.focus();
    }
  }

  handleClick(e) {
    const {
      checked,
      onChange
    } = this.props;
    e.preventDefault(); // We manually handle clicks, setting focus on the input control.

    this.focusInput(); // And toggling the answer selection state.

    onChange(!checked);
  }

  handleKeyDown(e) {
    const {
      onFocusPrevAnswer,
      onFocusNextAnswer
    } = this.props; // This may override built-in browser arrow key navigation for radio
    // group. Checkbox fieldset does not have such built-in capability,
    // thus we do this manually for both input types.

    switch (e.key) {
      case "ArrowUp":
        e.preventDefault();
        onFocusPrevAnswer();
        break;

      case "ArrowDown":
        e.preventDefault();
        onFocusNextAnswer();
        break;
    }
  }

  handleInputChange(e) {
    // Prevent answer selection from double-toggling, as `handleClick` is
    // handling changes to selection state.
    e.preventDefault();
  }

  handleInputFocus() {
    this.setState({
      isInputFocused: true
    });
  }

  handleInputBlur() {
    this.setState({
      isInputFocused: false
    });
  }

  renderCheckmark() {
    const {
      checked
    } = this.props;
    return /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$m.checkmarkContainer)
    }, checked && /*#__PURE__*/React__namespace.createElement(Icon, {
      icon: iconCheckMedium,
      size: 16,
      color: Color__default["default"].offBlack
    }));
  }

  render() {
    const {
      content,
      checked,
      groupName,
      index,
      inputType
    } = this.props;
    const {
      isInputFocused
    } = this.state;
    const answerId = "".concat(groupName, "-").concat(index);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$m.answerChoice, isInputFocused && styles$m.answerFocused),
      onClick: e => this.handleClick(e),
      onKeyDown: e => this.handleKeyDown(e)
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$m.answerInputWrapper)
    }, /*#__PURE__*/React__namespace.createElement("input", {
      className: aphrodite.css(sharedStyles.perseusSrOnly),
      checked: checked,
      name: groupName,
      id: answerId,
      type: inputType,
      onChange: e => this.handleInputChange(e),
      onFocus: () => this.handleInputFocus(),
      onBlur: () => this.handleInputBlur(),
      ref: node => this._input = node
    }), this.renderCheckmark()), /*#__PURE__*/React__namespace.createElement("label", {
      htmlFor: answerId
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: content
    })));
  }

}

class AnswerChoices extends React__namespace.Component {
  // The rendered answers elements.
  // eslint-disable-next-line ft-flow/no-mutable-array
  constructor(props) {
    super(props);

    _defineProperty(this, "_choices", void 0);

    this._choices = [];
    this.state = {
      groupName: ___default["default"].uniqueId("answer_choices_")
    };
  }

  focusAnswer() {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const numChoices = this.props.choices.length; // Wrap the index if necessary.

    if (index < 0) {
      index += numChoices;
    } else if (index >= numChoices) {
      index -= numChoices;
    }

    const choice = this._choices[index];

    if (choice) {
      choice.focusInput();
    }
  }

  onAnswerChange(index, checked) {
    const {
      choices,
      multipleSelect,
      onChange
    } = this.props;
    const selection = []; // Compile the selection state of answer choices. In single selection
    // mode (radio input type), only 0 or 1 answer may be chosen.

    for (let i = 0; i < choices.length; i++) {
      selection.push(multipleSelect ? i === index ? checked : choices[i].checked : i === index ? checked : false);
    }

    onChange(selection);
  }

  onFocusAnswer(index) {
    this.focusAnswer(index);
  }

  render() {
    const {
      choices,
      multipleSelect
    } = this.props;
    const {
      groupName
    } = this.state;
    return /*#__PURE__*/React__namespace.createElement("fieldset", null, choices.map((choice, index) => /*#__PURE__*/React__namespace.createElement(AnswerChoice, _extends$1({}, choice, {
      key: choice.content,
      groupName: groupName,
      index: index,
      inputType: multipleSelect ? "checkbox" : "radio",
      onChange: checked => this.onAnswerChange(index, checked),
      onFocusPrevAnswer: () => this.onFocusAnswer(index - 1),
      onFocusNextAnswer: () => this.onFocusAnswer(index + 1),
      ref: node => this._choices[index] = node
    }))));
  }

}
const styles$m = aphrodite.StyleSheet.create({
  answerChoice: {
    display: "flex",
    alignItems: "center",
    userSelect: "none",
    padding: "10px 16px 10px 0px",
    fontWeight: "bold",
    border: "solid 2px transparent",
    borderRadius: 2,
    ":active": {
      backgroundColor: "rgba(33, 36, 44, 0.08)"
    }
  },
  answerFocused: {
    borderColor: "#1865f2",
    ":active": {
      borderColor: "transparent"
    }
  },
  answerInputWrapper: {
    marginRight: 8
  },
  checkmarkContainer: {
    display: "flex",
    position: "relative",
    width: 16,
    height: 16,
    marginLeft: 8
  }
});

class Marker extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_icon", void 0);

    _defineProperty(this, "state", {
      isFocused: false
    });
  }

  handleFocus() {
    this.setState({
      isFocused: true
    });
  }

  handleBlur() {
    this.setState({
      isFocused: false
    });
  }

  renderIcon() {
    const {
      selected,
      showCorrectness,
      showSelected,
      showPulsate
    } = this.props;
    const {
      isFocused
    } = this.state; // Only a single marker may be "selected" at a time.
    // `showSelected` is a controlled prop, that may be set to `true` for
    // one marker at a time.
    // `isFocused` is a controlled state, driven by focus events, and may
    // only be `true` when there's no answer choices popup visible, and
    // keyboard focus is given to the marker.

    const isSelected = showSelected || isFocused;
    let innerIcon;
    let iconStyles;

    if (showCorrectness) {
      innerIcon = /*#__PURE__*/React__namespace.createElement(Icon, {
        icon: showCorrectness === "correct" ? iconCheck : iconMinus,
        size: 24,
        color: Color__default["default"].white
      });

      if (showCorrectness === "correct") {
        iconStyles = [styles$l.markerCorrect, isSelected && styles$l.markerCorrectSelected];
      } else {
        iconStyles = [styles$l.markerIncorrect, isSelected && styles$l.markerIncorrectSelected];
      }
    } else if (selected && selected.length > 0) {
      iconStyles = [styles$l.markerFilled, isSelected && styles$l.markerFilledSelected];
    } else {
      iconStyles = [isSelected ? styles$l.markerUnfilledSelected : showPulsate && styles$l.markerUnfilledPulsate];
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$l.markerIcon, ...iconStyles),
      ref: node => this._icon = node
    }, innerIcon);
  }

  render() {
    const {
      label,
      x,
      y,
      showCorrectness
    } = this.props; // It should no longer be possible to interact with a marker after it
    // has been labeled (answered) correctly.

    const isDisabled = showCorrectness === "correct";
    return /*#__PURE__*/React__namespace.createElement("button", {
      "aria-label": label,
      className: aphrodite.css(styles$l.unstyledButton, styles$l.marker, isDisabled && styles$l.disabled),
      style: {
        left: "".concat(x, "%"),
        top: "".concat(y, "%")
      },
      tabIndex: isDisabled ? -1 : 0,
      onFocus: () => this.handleFocus(),
      onBlur: () => this.handleBlur(),
      onClick: e => this.props.onClick(e),
      onKeyDown: e => this.props.onKeyDown(e)
    }, this.renderIcon());
  }

}

_defineProperty(Marker, "defaultProps", {
  selected: []
});

const markerColor = "#1865f2";
const selectedColor = "#2552b0";
const activeColor = selectedColor;
const correctColor = "#00a60e";
const correctActiveColor = "#167b1f";
const incorrectColor = "#909195";
const incorrectActiveColor = "#6c6e73";
const markerShadowColor = "rgba(33, 36, 44, 0.32)";
const lightShadowColor = "rgba(33, 36, 44, 0.16)";
const styles$l = aphrodite.StyleSheet.create({
  unstyledButton: {
    padding: 0,
    overflow: "visible",
    color: "inherit",
    font: "inherit",
    lineHeight: "normal",
    background: "none",
    border: "none"
  },
  marker: {
    position: "absolute",
    // Center marker position based on it's maximum size.
    width: 30,
    height: 30,
    marginLeft: -15,
    marginTop: -15
  },
  disabled: {
    pointerEvents: "none"
  },
  // The base and unfilled marker style.
  markerIcon: {
    display: "flex",
    position: "relative",
    boxSizing: "content-box",
    width: 16,
    height: 16,
    // Center icon within marker.
    marginLeft: 5,
    cursor: "pointer",
    backgroundColor: markerColor,
    border: "solid 2px #ffffff",
    borderRadius: 16,
    boxShadow: "0 2px 6px 0 ".concat(markerShadowColor)
  },
  markerUnfilledPulsate: {
    animationName: {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(1.5)"
      }
    },
    animationDirection: "alternate",
    animationDuration: "0.8s",
    animationIterationCount: "infinite",
    animationTimingFunction: "ease-in",
    transformOrigin: "50% 50%"
  },
  markerUnfilledSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 20,
      height: 20,
      marginLeft: -4,
      marginTop: -4,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 20
    },
    ":active": {
      backgroundColor: activeColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  },
  markerFilled: {
    width: 8,
    height: 8,
    // Center icon within marker.
    marginLeft: 9,
    borderRadius: 8,
    boxShadow: "0 1px 1px 0 ".concat(lightShadowColor)
  },
  markerFilledSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 12,
      height: 12,
      marginLeft: -4,
      marginTop: -4,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 12
    },
    ":active": {
      backgroundColor: activeColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  },
  markerCorrect: {
    width: 24,
    height: 24,
    marginLeft: 1,
    marginTop: 1,
    justifyContent: "center",
    alignItems: "center",
    background: correctColor,
    boxShadow: "0 1px 1px 0 ".concat(lightShadowColor)
  },
  markerCorrectSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 28,
      height: 28,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 28
    },
    ":active": {
      backgroundColor: correctActiveColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  },
  markerIncorrect: {
    width: 24,
    height: 24,
    marginLeft: 1,
    marginTop: 1,
    justifyContent: "center",
    alignItems: "center",
    background: incorrectColor,
    boxShadow: "0 1px 1px 0 ".concat(lightShadowColor)
  },
  markerIncorrectSelected: {
    "::before": {
      content: "''",
      display: "inline-block",
      position: "absolute",
      width: 28,
      height: 28,
      border: "solid 2px ".concat(selectedColor),
      borderRadius: 28
    },
    ":active": {
      backgroundColor: incorrectActiveColor,
      boxShadow: "none",
      "::before": {
        display: "none"
      }
    }
  }
});

class LabelImage extends React__namespace.Component {
  // The rendered markers on the question image for labeling.
  // eslint-disable-next-line ft-flow/no-mutable-array
  // The popup component containing the answer choices.
  // The rendered list of answer choices for the currently selected marker.
  static gradeMarker(marker) {
    const score = {
      hasAnswers: false,
      isCorrect: false
    };

    if (marker.selected && marker.selected.length > 0) {
      score.hasAnswers = true;
    }

    if (marker.answers.length > 0) {
      if (marker.selected && marker.selected.length === marker.answers.length) {
        // All correct answers are selected by the user.
        score.isCorrect = marker.selected.every(choice => marker.answers.includes(choice));
      }
    } else if (!marker.selected || marker.selected.length === 0) {
      // Correct as no answers should be selected by the user.
      score.isCorrect = true;
    }

    return score;
  }

  static validate(state, rubric) {
    let numAnswered = 0;
    let numCorrect = 0;

    for (const marker of state.markers) {
      const score = LabelImage.gradeMarker(marker);

      if (score.hasAnswers) {
        numAnswered++;
      }

      if (score.isCorrect) {
        numCorrect++;
      }
    } // We expect all question markers to be answered before grading.


    if (numAnswered !== state.markers.length) {
      return {
        type: "invalid",
        message: null
      };
    }

    return {
      type: "points",
      // Markers with no expected answers are graded as correct if user
      // makes no answer selection.
      earned: numCorrect === state.markers.length ? 1 : 0,
      total: 1,
      message: null
    };
  }
  /**
   * Test whether point is contained within triangle.
   *
   * Implementation taken from: https://stackoverflow.com/a/2049593
   */


  static pointInTriangle(p, a, b, c) {
    const sign = (p1, p2, p3) => (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);

    const b1 = sign(p, a, b) < 0;
    const b2 = sign(p, b, c) < 0;
    const b3 = sign(p, c, a) < 0;
    return b1 === b2 && b2 === b3;
  }
  /**
   * Determine the image side given a marker position (as percent of size).
   */


  static imageSideForMarkerPosition(x, y) {
    // Special handling for when marker is positioned near the horizontal
    // edges of the image. We want to ensure the returned side would not
    // result in a popup rendering that may overflow outside the page.
    if (x < 20) {
      return "left";
    }

    if (x > 80) {
      return "right";
    } // Points to define corners (and center) of a rectangle representing
    // the constrained area of the image for which we want to determine the
    // image side.


    const tl = {
      x: 20,
      y: 0
    };
    const tr = {
      x: 80,
      y: 0
    };
    const br = {
      x: 80,
      y: 100
    };
    const bl = {
      x: 20,
      y: 100
    };
    const cp = {
      x: 50,
      y: 50
    }; // The triangles representing the sides to test.

    const triangles = {
      top: [tl, tr, cp],
      right: [cp, tr, br],
      bottom: [bl, cp, br],
      left: [tl, cp, bl]
    };
    const p = {
      x,
      y
    }; // Test whether marker is positioned within one of the triangles
    // representing the sides.

    for (const side of Object.keys(triangles)) {
      const corners = triangles[side];

      if (LabelImage.pointInTriangle(p, ...corners)) {
        return side;
      }
    } // Fallback, if side was not found for marker position.


    return "center";
  }
  /**
   * Calculate the next marker to navigate to, from the "this marker".
   *
   * Given a cardinal navigation direction (in the x or y axis), return the
   * next marker index to visit.
   */


  static navigateToMarkerIndex(navigateDirection, markers, thisIndex) {
    const thisMarker = markers[thisIndex]; // Sort markers along the direction of navigation from "this" marker.

    const sortedMarkers = markers.map((otherMarker, index) => {
      // Calculate distance and (normalized) vector to the marker from
      // "this" marker.
      const x = otherMarker.x - thisMarker.x;
      const y = otherMarker.y - thisMarker.y;
      const dist = Math.sqrt(x ** 2 + y ** 2);
      return {
        index,
        dist,
        dir: {
          x: dist !== 0 ? x / dist : 0,
          y: dist !== 0 ? y / dist : 0
        }
      };
    }).filter(marker => {
      if (marker.index === thisIndex) {
        return false;
      } // Exclude any marker that has been answered correctly,
      // as it should no longer be interacted with by the user.


      return markers[marker.index].showCorrectness !== "correct";
    }).sort((a, b) => {
      // Project distances to the two markers being sorted (from the
      // "this" marker) along the direction of navigation. This will
      // order by the "closest" marker in the direction of navigation,
      // not the "absolute" closest marker to "this" marker.
      // We round the calculated distances so that if markers are
      // found to be positioned "close enough" to the "this" marker,
      // they will be treated as coplanar with it.
      const distA = Math.round(a.dist * (navigateDirection.x * a.dir.x + navigateDirection.y * a.dir.y));
      const distB = Math.round(b.dist * (navigateDirection.x * b.dir.x + navigateDirection.y * b.dir.y));
      let dirA;
      let dirB; // Determine whether the two markers lie ahead or behind the
      // "this" marker. A marker that lies in the same plane as the
      // "this" marker will be considered to be behind it.
      // Only navigation in the "x" or "y" axis is supported, no
      // diagonals.

      if (navigateDirection.x > 0) {
        dirA = a.dir.x > 0 && distA !== 0;
        dirB = b.dir.x > 0 && distB !== 0;
      } else if (navigateDirection.x < 0) {
        dirA = a.dir.x < 0 && distA !== 0;
        dirB = b.dir.x < 0 && distB !== 0;
      } else if (navigateDirection.y > 0) {
        dirA = a.dir.y > 0 && distA !== 0;
        dirB = b.dir.y > 0 && distB !== 0;
      } else if (navigateDirection.y < 0) {
        dirA = a.dir.y < 0 && distA !== 0;
        dirB = b.dir.y < 0 && distB !== 0;
      } // If one of the markers is positioned behind, sort the other
      // marker ahead of it in the order.


      if (dirA !== dirB) {
        if (dirA) {
          return -1;
        }

        return 1;
      } // Both markers are either positioned ahead or behind, sort the
      // closest (or furthest if behind, to "wrap" navigation) marker
      // ahead in the order.


      return distA - distB;
    }); // Return the index in the provided markers array of the closest marker
    // found along the direction of navigation, or "this" index if no other
    // marker was found. This may happen if the user has answered all but
    // one ("this" marker) of the markers correctly in the question.

    return sortedMarkers.length > 0 ? sortedMarkers[0].index : thisIndex;
  }

  constructor(props) {
    super(props);

    _defineProperty(this, "_markers", void 0);

    _defineProperty(this, "_selectedMarkerPopup", void 0);

    _defineProperty(this, "_answerChoices", void 0);

    _defineProperty(this, "handleDocumentClick", e => {
      // Dismiss open popup with answer choices if user clicks outside it.
      if (this._selectedMarkerPopup && this._answerChoices) {
        const answerChoices = ReactDOM__default["default"].findDOMNode(this._answerChoices);
        const targetElement = e.target; // HACK(michaelpolyak): We want to determine if the click target is
        // contained within the popup layer. As there's no public interface
        // to get this layer from the popup, we traverse several levels of
        // answer choices parents to test whether the click target is
        // contained within.

        const containsEventTarget = function (element) {
          let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
          return element && (element.contains(targetElement) || depth > 0 && containsEventTarget(element.parentElement, depth - 1));
        };

        if (!containsEventTarget(answerChoices)) {
          // Close popup and set focus back to the marker for which it was
          // open.
          this.dismissMarkerPopup();
        }
      }
    });

    _defineProperty(this, "handleDocumentKeyDown", e => {
      // Dismiss open popup with answer choices if user presses Escape key.
      if (this._selectedMarkerPopup && e.keyCode === 27) {
        // Ensure other listeners are not triggered on key down event that
        // closes the popup, as this will also dismiss the modal that the
        // widget may be rendered within.
        e.stopPropagation(); // Close popup and set focus back to the marker for which it was
        // open.

        this.dismissMarkerPopup();
      }
    });

    this._markers = [];
    this.state = {
      selectedMarkerIndex: -1,
      markersInteracted: false
    };
  }

  componentDidMount() {
    document.addEventListener("click", this.handleDocumentClick, true);
    document.addEventListener("keydown", this.handleDocumentKeyDown, true);
  }

  componentWillUnmount() {
    document.removeEventListener("click", this.handleDocumentClick, true);
    document.removeEventListener("keydown", this.handleDocumentKeyDown, true);
  }

  simpleValidate(rubric) {
    return LabelImage.validate(this.getUserInput(), rubric);
  }

  getUserInput() {
    const {
      markers
    } = this.props;
    return {
      markers
    };
  }

  showRationalesForCurrentlySelectedChoices(rubric) {
    const {
      markers
    } = this.props;
    const {
      onChange
    } = this.props;
    const updatedMarkers = markers.map(marker => {
      const score = LabelImage.gradeMarker(marker);
      return { ...marker,
        // Reveal correctness state for markers with answers.
        showCorrectness: score.hasAnswers ? score.isCorrect ? "correct" : "incorrect" : undefined
      };
    }); // Update Perseus widget state with user selected answers without
    // triggering interaction events for listeners.

    onChange({
      markers: updatedMarkers
    }, null, true);
  }

  dismissMarkerPopup() {
    const {
      selectedMarkerIndex: index
    } = this.state; // No popup should be open if there's no selected marker.

    if (index === -1) {
      return;
    }

    this.setState({
      selectedMarkerIndex: -1
    }, () => {
      const marker = this._markers[index]; // Set focus on the just-deselected-marker, to enable to resume
      // navigating between the markers using the keyboard.

      if (marker) {
        ReactDOM__default["default"].findDOMNode(marker).focus();
      }
    });
  }

  handleMarkerChange(index, marker) {
    const {
      markers,
      onChange
    } = this.props; // Replace marker with a changed version at the specified index.

    const updatedMarkers = [...markers.slice(0, index), { ...marker,
      // Do not show correctness state if user changes answer
      // selection for marker.
      showCorrectness: undefined
    }, ...markers.slice(index + 1)]; // Update Perseus widget state with user selected answers.

    onChange({
      markers: updatedMarkers
    });
  }

  handleMarkerClick(index, e) {
    const {
      selectedMarkerIndex
    } = this.state;
    e.preventDefault(); // Select the marker, revealing answer choices.

    if (selectedMarkerIndex !== index) {
      this.setState({
        selectedMarkerIndex: index,
        markersInteracted: true
      }, () => {
        // A delay is required to allow answer choices to first render
        // before trying to set focus on the first choice.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(() => {
          if (this._answerChoices) {
            this._answerChoices.focusAnswer();
          }
        }, 100);
      });
    } else {
      // The answer choices are shown within a popup attached to the
      // selected marker. Close the popup and set focus back to the
      // marker.
      this.dismissMarkerPopup();
    }
  }

  handleMarkerKeyDown(index, e) {
    const {
      markers
    } = this.props; // One is the loneliest number.

    if (markers.length < 2) {
      return;
    } // Only navigation in the "x" or "y" axis is supported, no diagonals.


    const navigateDirection = {
      ArrowUp: {
        x: 0,
        y: -1
      },
      ArrowRight: {
        x: 1,
        y: 0
      },
      ArrowDown: {
        x: 0,
        y: 1
      },
      ArrowLeft: {
        x: -1,
        y: 0
      }
    }[e.key];

    if (!navigateDirection) {
      return;
    }

    e.preventDefault(); // Focus on the closest marker along the direction of navigation.

    const marker = this._markers[LabelImage.navigateToMarkerIndex(navigateDirection, markers, index)];

    if (marker) {
      ReactDOM__default["default"].findDOMNode(marker).focus();
    }
  }

  handleAnswerChoicesChangeForMarker(index, selection) {
    const {
      choices,
      markers,
      multipleAnswers
    } = this.props; // Compile the user selected answer choices.

    const selected = choices.filter((choice, index) => selection[index]);
    this.handleMarkerChange(index, { ...markers[index],
      selected
    });

    if (!multipleAnswers) {
      this.dismissMarkerPopup();
    }
  }

  renderAnswerChoicesForMarker(index, marker) {
    const {
      choices,
      multipleAnswers
    } = this.props; // The user selected answer choices.

    const selected = marker.selected;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames__default["default"]("perseus-label-image-widget-answer-choices", aphrodite.css(styles$k.scrollableChoices))
    }, /*#__PURE__*/React__namespace.createElement(AnswerChoices, {
      choices: choices.map(choice => ({
        content: choice,
        checked: selected ? selected.includes(choice) : false
      })),
      multipleSelect: multipleAnswers,
      onChange: selection => this.handleAnswerChoicesChangeForMarker(index, selection),
      ref: node => this._answerChoices = node
    }));
  }

  renderMarkers() {
    const {
      markers,
      questionCompleted
    } = this.props;
    const {
      selectedMarkerIndex,
      markersInteracted
    } = this.state; // Render all markers for widget.

    return markers.map((marker, index) => {
      const score = LabelImage.gradeMarker(marker);
      const element = /*#__PURE__*/React__namespace.createElement(Marker, _extends$1({}, marker, {
        // Once the question is answered, show markers
        // with correct answers, otherwise passthrough
        // the correctness state.
        showCorrectness: questionCompleted && score.hasAnswers && score.isCorrect ? "correct" : marker.showCorrectness,
        showSelected: index === selectedMarkerIndex,
        showPulsate: !markersInteracted,
        key: "".concat(marker.x, ".").concat(marker.y),
        onClick: e => this.handleMarkerClick(index, e),
        onKeyDown: e => this.handleMarkerKeyDown(index, e),
        ref: node => this._markers[index] = node
      })); // The user selected marker is wrapped with a popup that shows its
      // answer choices, otherwise it's returned as is.

      if (index !== selectedMarkerIndex) {
        return element;
      } // Determine whether page is rendered in a narrow browser window.


      const isNarrowPage = window.matchMedia(mediaQueries.xsOrSmaller.replace("@media ", "")).matches;
      let side; // Position popup closest to the center, preferring it renders
      // entirely within the image area.

      if (isNarrowPage) {
        side = marker.y > 50 ? "top" : "bottom";
      } else {
        // This mirrors the calculated side of where the marker is
        // located within the image, so that popup appears closer to
        // the image center.
        side = {
          left: "right",
          top: "bottom",
          right: "left",
          bottom: "top",
          center: "top"
        }[LabelImage.imageSideForMarkerPosition(marker.x, marker.y)];
      } // TODO(michaelpolyak): Ideally we would always render markers
      // wrapped in the popover. Setting `opened={false}` for those
      // markers that are unselected (to hide their popup), this would
      // keep the React tree more stable.


      return /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.Popover, {
        content: () => /*#__PURE__*/React__namespace.createElement(wonderBlocksPopover.PopoverContentCore, {
          style: styles$k.choicesPopover
        }, this.renderAnswerChoicesForMarker(index, marker)),
        placement: side,
        opened: true,
        key: "".concat(marker.x, ".").concat(marker.y),
        ref: node => this._selectedMarkerPopup = node
      }, element);
    });
  }

  renderInstructions() {
    const {
      apiOptions: {
        isMobile
      },
      choices,
      multipleAnswers,
      hideChoicesFromInstructions: hideChoices
    } = this.props;
    const promptString = isMobile ? multipleAnswers ? i18n__namespace._("Tap each dot on the image to select all answers that apply.") : i18n__namespace._("Tap each dot on the image to select an answer.") : multipleAnswers ? i18n__namespace._("Click each dot on the image to select all answers that apply.") : i18n__namespace._("Click each dot on the image to select an answer.");

    const choicesString = i18n__namespace._("Choices:");

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames__default["default"]("perseus-label-image-widget-instructions", aphrodite.css(styles$k.instructions))
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.instructionsCaption)
    }, promptString, " ", !hideChoices && choicesString), !hideChoices && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.instructionsChoices)
    }, choices.map((choice, index) => /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.instructionsChoice),
      key: index
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: choice
    })))));
  }

  render() {
    const {
      imageAlt,
      imageUrl,
      imageWidth,
      imageHeight
    } = this.props;
    const {
      selectedMarkerIndex
    } = this.state;
    return /*#__PURE__*/React__namespace.createElement("div", null, this.renderInstructions(), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.markersCanvas),
      style: {
        maxWidth: imageWidth,
        maxHeight: imageHeight
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$k.imageContainer, // Ensure image interaction is disabled while answer
      // choices popup is visible. This addresses specific
      // case where user may click on question image to
      // dismiss the popup. If the image is larger in size
      // than its rendered in the widget, this would
      // result in a zoom of the image.
      selectedMarkerIndex !== -1 && styles$k.imageInteractionDisabled)
    }, /*#__PURE__*/React__namespace.createElement(context$3.Consumer, null, _ref => {
      let {
        setAssetStatus
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement(SvgImage, {
        alt: imageAlt,
        src: imageUrl,
        width: imageWidth,
        height: imageHeight,
        setAssetStatus: setAssetStatus
      });
    })), this.renderMarkers()));
  }

}

const styles$k = aphrodite.StyleSheet.create({
  instructions: {
    paddingBottom: 16
  },
  instructionsCaption: { ...typography.bodyXsmallBold,
    paddingBottom: 16
  },
  instructionsChoices: {
    display: "flex",
    flexWrap: "wrap",
    margin: "-8px 0"
  },
  instructionsChoice: {
    display: "flex",
    alignItems: "center",
    margin: "8px 0",
    ":not(:last-child)": {
      "::after": {
        content: "''",
        display: "inline-block",
        position: "relative",
        width: 2,
        height: 2,
        marginLeft: 5,
        marginRight: 5,
        background: "rgba(33, 36, 44, 0.32)",
        borderRadius: 2
      }
    }
  },
  markersCanvas: {
    position: "relative"
  },
  imageContainer: {
    // Remove the additional height added due to white-spacing, this ensures
    // markers canvas will have the same height as the question image.
    display: "flex"
  },
  imageInteractionDisabled: {
    pointerEvents: "none"
  },
  scrollableChoices: {
    paddingTop: 8,
    paddingBottom: 8,
    // Enable scroll for answer choices within popup on mobile phones.
    [mediaQueries.xsOrSmaller]: {
      maxHeight: 250,
      overflowY: "auto"
    }
  },
  choicesPopover: {
    padding: 0
  }
});
var LabelImage$1 = {
  name: "label-image",
  displayName: "Label Image",
  widget: LabelImage,
  accessible: true,
  isLintable: true
};

const CELL_PADDING = 5;
const TABLE_STYLE = {
  display: "table",
  tableLayout: "fixed"
};
const ROW_STYLE = {
  display: "table-row"
};
const CELL_STYLE = {
  display: "table-cell",
  padding: CELL_PADDING
};
const BASE_TILE_STYLE = {
  borderRadius: 10,
  cursor: "pointer"
};
const MOVE_COUNT_STYLE = {
  padding: CELL_PADDING,
  display: "inline-block"
};
const RESET_BUTTON_STYLE = {
  float: "right",
  paddingRight: CELL_PADDING
};
const MAIN_TILE_SIZE = 50;

const PATTERNS = {
  plus: () => [[false, true, false], [true, true, true], [false, true, false]],
  x: () => [[true, false, true], [false, true, false], [true, false, true]],
  "plus/x": iter => {
    return iter % 2 ? PATTERNS.x() : PATTERNS.plus();
  }
};


class Tile extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_flip", () => {
      this.props.onChange(!this.props.value);
    });
  }

  render() {
    const color = this.props.value ? "#55dd55" : "#115511";

    const style = ___default["default"].extend({}, BASE_TILE_STYLE, {
      width: this.props.size,
      height: this.props.size,
      backgroundColor: color
    });

    return /*#__PURE__*/React__namespace.createElement("div", {
      style: style,
      onClick: this._flip
    });
  }

} // A grid of glowy cells


_defineProperty(Tile, "propTypes", {
  value: PropTypes__default["default"].bool.isRequired,
  size: PropTypes__default["default"].number.isRequired
});

class TileGrid extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: TABLE_STYLE,
      className: "no-select"
    }, ___default["default"].map(this.props.cells, (row, y) => {
      return /*#__PURE__*/React__namespace.createElement("div", {
        key: y,
        style: ROW_STYLE
      }, ___default["default"].map(row, (cell, x) => {
        return /*#__PURE__*/React__namespace.createElement("div", {
          key: x,
          style: CELL_STYLE
        }, /*#__PURE__*/React__namespace.createElement(Tile, {
          value: cell,
          size: this.props.size,
          onChange: ___default["default"].partial(this.props.onChange, y, x)
        }));
      }));
    }));
  }

} // Returns a copy of the tiles, with tiles flipped according to
// whether or not their y, x position satisfies the predicate


_defineProperty(TileGrid, "propTypes", {
  cells: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].bool)).isRequired,
  size: PropTypes__default["default"].number.isRequired
});

const flipTilesPredicate = (oldCells, predicate) => {
  return ___default["default"].map(oldCells, (row, y) => {
    return ___default["default"].map(row, (cell, x) => {
      return predicate(y, x) ? !cell : cell;
    });
  });
};

const flipTilesPattern = (oldCells, tileY, tileX, pattern) => {
  return flipTilesPredicate(oldCells, (y, x) => {
    const offsetY = y - tileY;
    const offsetX = x - tileX;

    if (Math.abs(offsetY) <= 1 && Math.abs(offsetX) <= 1) {
      return pattern[offsetY + 1][offsetX + 1];
    }

    return false;
  });
}; // The lights puzzle widget


class LightsPuzzle extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "_currPattern", void 0);

    _defineProperty(this, "_nextPattern", void 0);

    _defineProperty(this, "_patternIndex", void 0);

    _defineProperty(this, "getUserInput", () => {
      return WidgetJsonifyDeprecated.getUserInput.call(this);
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "_width", () => {
      if (this.props.cells.length !== 0) {
        return this.props.cells[0].length;
      }

      return 0; // default to 0
    });

    _defineProperty(this, "_initNextPatterns", () => {
      this._currPattern = PATTERNS[this.props.flipPattern](0);
      this._nextPattern = PATTERNS[this.props.flipPattern](1);
      this._patternIndex = 2;
    });

    _defineProperty(this, "_shiftPatterns", () => {
      this._currPattern = this._nextPattern;
      this._nextPattern = PATTERNS[this.props.flipPattern](this._patternIndex);
      this._patternIndex++;
    });

    _defineProperty(this, "_flipTile", (tileY, tileX) => {
      const newCells = flipTilesPattern(this.props.cells, tileY, tileX, this._currPattern);

      this._shiftPatterns();

      this.change({
        cells: newCells,
        moveCount: this.props.moveCount + 1
      });
    });

    _defineProperty(this, "_reset", () => {
      this.change({
        cells: this.props.startCells,
        moveCount: 0
      });
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return validate$1(rubric, this.getUserInput());
    });
  }

  render() {
    const width = this._width();

    const tileSize = MAIN_TILE_SIZE;
    const pxWidth = width * (tileSize + 2 * CELL_PADDING);
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(TileGrid, {
      cells: this.props.cells,
      size: tileSize,
      onChange: this._flipTile
    }), /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        width: pxWidth
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: MOVE_COUNT_STYLE
    }, i18n__namespace.ngettext("Moves: %(num)s", "Moves: %(num)s", this.props.moveCount)), /*#__PURE__*/React__namespace.createElement("div", {
      style: RESET_BUTTON_STYLE
    }, /*#__PURE__*/React__namespace.createElement("input", {
      type: "button",
      value: "Reset",
      onClick: this._reset,
      className: "simple-button"
    }))), /*#__PURE__*/React__namespace.createElement("div", {
      className: "clearfix"
    }));
  }

  componentDidMount() {
    this._initNextPatterns();
  }

  componentDidUpdate(prevProps) {
    if (prevProps.flipPattern !== this.props.flipPattern) {
      this._initNextPatterns();
    }
  }

} // grading function


_defineProperty(LightsPuzzle, "propTypes", { ...propTypes,
  cells: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].bool)),
  startCells: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].bool)),
  flipPattern: PropTypes__default["default"].string.isRequired,
  moveCount: PropTypes__default["default"].number.isRequired
});

_defineProperty(LightsPuzzle, "defaultProps", {
  cells: [[false, false, false], [false, false, false], [false, false, false]],
  startCells: [[false, false, false], [false, false, false], [false, false, false]],
  flipPattern: "plus",
  moveCount: 0
});

const validate$1 = function (rubric, state) {
  const empty = ___default["default"].all(state.cells, (row, y) => {
    return ___default["default"].all(row, (cell, x) => {
      return cell === rubric.startCells[y][x];
    });
  });

  if (empty) {
    return {
      type: "invalid",
      message: i18n__namespace._("Click on the tiles to change the lights.")
    };
  }

  const correct = ___default["default"].all(state.cells, row => {
    return ___default["default"].all(row, cell => {
      return cell;
    });
  });

  if (correct) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  }

  if (rubric.gradeIncompleteAsWrong) {
    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }

  return {
    type: "invalid",
    message: i18n__namespace._("You must turn on all of the lights to continue.")
  };
}; // The function run on the editor props to create the widget props


const transformProps = function (editorProps) {
  return {
    cells: editorProps.startCells,
    startCells: editorProps.startCells,
    flipPattern: editorProps.flipPattern
  };
};

var LightsPuzzle$1 = {
  name: "lights-puzzle",
  displayName: "Lights Puzzle",
  hidden: true,
  widget: LightsPuzzle,
  transform: transformProps
};

const HORIZONTAL$2 = "horizontal";
const VERTICAL$1 = "vertical";
const STATIC = "static";
const DRAGGING = "dragging";
const ANIMATING = "animating";
const DISABLED = "disabled"; // Augment the given position with the scroll position of the offset parent.

const addOffsetParentScroll = ($el, position) => {
  // NOTE(slim): $(el).offsetParent() is NOT equivalent to $el[0].offsetParent.
  // Specifically, when `el` is not positioned, then the native HTMLElement.offsetParent
  // returns the closest table element, which in this case is the <td> rendered by the
  // Perseus Matcher widget.
  // Conversely, jQuery's offsetParent() always returns the closest positioned ancestor,
  // even when the element is not positioned.
  const $offsetParent = $el.offsetParent();
  return {
    top: position.top + $offsetParent.scrollTop(),
    left: position.left + $offsetParent.scrollLeft()
  };
}; // A placeholder that appears in the sortable whenever an item is dragged.


class Placeholder extends React__namespace.Component {
  render() {
    const {
      layout
    } = this.props;
    const className = aphrodite.css(styles$j.card, styles$j.placeholder, layout === HORIZONTAL$2 && styles$j.horizontalCard);
    const style = {
      width: this.props.width,
      height: this.props.height
    };

    if (this.props.margin != null) {
      style.margin = this.props.margin;
    }

    return /*#__PURE__*/React__namespace.createElement("li", {
      className: className,
      style: style
    });
  }

}

_defineProperty(Placeholder, "propTypes", {
  layout: PropTypes__default["default"].oneOf([HORIZONTAL$2, VERTICAL$1]),
  width: PropTypes__default["default"].number.isRequired,
  height: PropTypes__default["default"].number.isRequired
});

// A draggable item in the sortable. Can be in one of four states:
//     Static:    The item is not being interacted with.
//     Dragging:  The item is being dragged.
//     Animating: The item has been released, and is moving to its destination.
//     Disabled:  The item cannot be interacted with.
//
// Usual flow:      Static -> Dragging -> Animating -> Static
// [Dis|en]abling:  Static|Dragging|Animating -> Disabled -> Static
class Draggable extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "animationFrameRequest", null);

    _defineProperty(this, "isMouseMoveUpBound", void 0);

    _defineProperty(this, "_mounted", void 0);

    _defineProperty(this, "state", {
      startPosition: {
        left: 0,
        top: 0
      },
      startMouse: {
        left: 0,
        top: 0
      },
      mouse: {
        left: 0,
        top: 0
      }
    });

    _defineProperty(this, "getCurrentPosition", () => {
      return {
        left: this.state.startPosition.left + this.state.mouse.left - this.state.startMouse.left,
        top: this.state.startPosition.top + this.state.mouse.top - this.state.startMouse.top
      };
    });

    _defineProperty(this, "bindMouseMoveUp", () => {
      this.isMouseMoveUpBound = true;
      $__default["default"](document).on("mousemove", this.onMouseMove);
      $__default["default"](document).on("mouseup", this.onMouseUp);
    });

    _defineProperty(this, "unbindMouseMoveUp", () => {
      this.isMouseMoveUpBound = false;
      $__default["default"](document).off("mousemove", this.onMouseMove);
      $__default["default"](document).off("mouseup", this.onMouseUp);
    });

    _defineProperty(this, "onMouseDown", event => {
      if (this.props.type !== STATIC) {
        return;
      }

      if (!(event.button === 0 || event.touches != null && event.touches.length === 1)) {
        return;
      }

      event.preventDefault();
      const loc = Util.extractPointerLocation(event); // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax

      this.animationFrameRequest = requestAnimationFrame(() => {
        const $el = $__default["default"](ReactDOM__default["default"].findDOMNode(this)); // jQuery.position() gets the position of the element wrt its offset parent,
        // but subtracts the scroll position of the parent. We need to add that back.

        const position = $el.position();
        const startPosition = addOffsetParentScroll($el, position);

        if (loc && this._mounted) {
          this.setState({
            startPosition,
            // NOTE(slim): We don't bother adjusting `loc` because we only keep track of (mouse - startMouse) in
            // this.getCurrentPosition(). Adjusting `loc` here requires us to also change how `loc` is used in
            // onMouseMove and onMouseUp, and this requires reading from the DOM each time to measure the parent's scrollTop.
            startMouse: loc,
            mouse: loc,
            dragging: true
          }, function () {
            this.bindMouseMoveUp(); // Static -> Dragging

            this.props.onMouseDown();
          });
        }
      });
    });

    _defineProperty(this, "onMouseMove", event => {
      const notDragging = this.props.type !== DRAGGING || !this.state.dragging;

      if (notDragging) {
        return;
      }

      event.preventDefault();
      const loc = Util.extractPointerLocation(event);

      if (loc) {
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
        // eslint-disable-next-line no-restricted-syntax
        this.animationFrameRequest = requestAnimationFrame(() => {
          this.setState({
            mouse: loc
          }, this.props.onMouseMove);
        });
      }
    });

    _defineProperty(this, "onMouseUp", event => {
      const notDragging = this.props.type !== DRAGGING || !this.state.dragging;

      if (notDragging) {
        return;
      }

      event.preventDefault();
      const loc = Util.extractPointerLocation(event);

      if (loc) {
        this.setState({
          dragging: false
        });
        this.unbindMouseMoveUp(); // Dragging -> Animating

        this.props.onMouseUp();
      }
    });
  }

  componentDidMount() {
    this._mounted = true;
    this.isMouseMoveUpBound = false; // On touch devices, we set up our own touchmove handler because React
    // all event subscriptions using `OnTouchMove` props are non-passive.
    // See: https://github.com/facebook/react/issues/6436
    // Also, we can't subscribe to `ontouchmove`  within the `ontouchstart`
    // handler because of a WebKit bug:
    // https://github.com/atlassian/react-beautiful-dnd/issues/413 and
    // https://bugs.webkit.org/show_bug.cgi?id=184250

    document.addEventListener("touchmove", this.onMouseMove, // Not all browsers support passive events, and when they don't
    // this third paramter is just a boolean. If we pass the "options"
    // object, it's interpreted as `capture=true` (which we don't want!)
    Util.supportsPassiveEvents() ? {
      passive: false
    } : false);
  }

  componentWillUnmount() {
    this._mounted = false; // Event handlers should be unbound before component unmounting, but
    // just in case...

    if (this.isMouseMoveUpBound) {
      this.unbindMouseMoveUp();
    }

    if (this.animationFrameRequest) {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      cancelAnimationFrame(this.animationFrameRequest);
    }

    document.removeEventListener("touchmove", this.onMouseMove);
  }

  render() {
    const {
      includePadding,
      layout,
      type
    } = this.props; // We need to keep backwards compatbility with rules specified directly
    // in CSS. Hence the hacky tacking on of manual classNames.
    // See sortable.less for details.

    let className = aphrodite.css(styles$j.card, styles$j.draggable, layout === HORIZONTAL$2 && styles$j.horizontalCard, layout === VERTICAL$1 && styles$j.verticalCard, type === DRAGGING && styles$j.dragging, type === DISABLED && styles$j.disabled, !includePadding && styles$j.unpaddedCard) + " " + ClassNames.INTERACTIVE + " perseus-sortable-draggable";

    if (!includePadding) {
      className += " perseus-sortable-draggable-unpadded";
    }

    const style = {
      position: "static"
    };

    if (this.props.type === DRAGGING || this.props.type === ANIMATING) {
      ___default["default"].extend(style, {
        position: "absolute"
      }, this.getCurrentPosition());
    }

    if (this.props.width) {
      style.minWidth = this.props.width + 1; // Fix for non-integer widths
    }

    if (this.props.height) {
      style.height = this.props.height;
    }

    if (this.props.margin != null) {
      style.margin = this.props.margin;
    }

    return /*#__PURE__*/React__namespace.createElement("li", {
      className: className,
      style: style,
      onMouseDown: this.onMouseDown,
      onTouchStart: this.onMouseDown,
      onTouchMove: this.onMouseMove,
      onTouchEnd: this.onMouseUp,
      onTouchCancel: this.onMouseUp
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.content,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "draggable"),
      onRender: this.props.onRender
    }));
  }

  componentDidUpdate(prevProps) {
    if (this.props.type === prevProps.type) {
      return;
    }

    if (this.props.type === ANIMATING) {
      // Start animating
      const current = this.getCurrentPosition();
      const duration = 15 * Math.sqrt(Math.sqrt(Math.pow(this.props.endPosition.left - current.left, 2) + Math.pow(this.props.endPosition.top - current.top, 2)));
      $__default["default"](ReactDOM__default["default"].findDOMNode(this)).animate(this.props.endPosition, {
        duration: Math.max(duration, 1),
        // Animating -> Static
        complete: this.props.onAnimationEnd
      });
    } else if (this.props.type === STATIC) {
      // Ensure that any animations are done
      $__default["default"](ReactDOM__default["default"].findDOMNode(this)).finish();
    }
  }

}

_defineProperty(Draggable, "propTypes", {
  content: PropTypes__default["default"].string.isRequired,
  endPosition: PropTypes__default["default"].object.isRequired,
  includePadding: PropTypes__default["default"].bool,
  layout: PropTypes__default["default"].oneOf([HORIZONTAL$2, VERTICAL$1]),
  onAnimationEnd: PropTypes__default["default"].func.isRequired,
  onMouseDown: PropTypes__default["default"].func.isRequired,
  onMouseMove: PropTypes__default["default"].func.isRequired,
  onMouseUp: PropTypes__default["default"].func.isRequired,
  onRender: PropTypes__default["default"].func.isRequired,
  type: PropTypes__default["default"].oneOf([STATIC, DRAGGING, ANIMATING, DISABLED]),
  linterContext: PerseusLinter__namespace.linterContextProps
});

_defineProperty(Draggable, "defaultProps", {
  includePadding: true,
  type: STATIC,
  linterContext: PerseusLinter__namespace.linterContextDefault
});

class Sortable extends React__namespace.Component {
  constructor(props) {
    super(props); // Don't call this.setState() here!

    _defineProperty(this, "remeasureItems", ___default["default"].debounce(() => {
      this.setState({
        // Clear item measurements
        items: Sortable.clearItemMeasurements(this.state.items)
      });
    }, 20));

    this.state = {
      items: Sortable.itemsFromProps(this.props),
      katex: null
    };
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    const prevProps = this.props;

    if (!___default["default"].isEqual(nextProps.options, prevProps.options)) {
      // Regenerate items
      this.setState({
        items: Sortable.itemsFromProps(nextProps)
      });
    } else if (nextProps.layout !== prevProps.layout || nextProps.padding !== prevProps.padding || nextProps.disabled !== prevProps.disabled || !___default["default"].isEqual(nextProps.constraints, prevProps.constraints)) {
      // Clear item measurements
      this.setState({
        items: Sortable.clearItemMeasurements(this.state.items)
      });
    }
  }

  componentDidUpdate() {
    // Measure items if their dimensions have been reset
    if (this.state.items.length && !this.state.items[0].width && !this.state.items[0].height) {
      // Measure on the next frame to allow items size to settle.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      setTimeout(() => {
        this.measureItems();
      }, 0);
    }
  }

  componentDidMount() {
    getDependencies().getKaTeX().then(katex => {
      this.setState({
        katex
      });
    });
  }

  static itemsFromProps(props) {
    const type = props.disabled ? DISABLED : STATIC;
    return props.options.map((option, i) => {
      return {
        option: option,
        key: i,
        type: type,
        endPosition: {},
        width: 0,
        height: 0
      };
    });
  }

  static clearItemMeasurements(items) {
    return items.map(item => {
      return { ...item,
        width: 0,
        height: 0
      };
    });
  }

  measureItems() {
    // Measure all items and cache what their dimensions should be, taking
    // into account constraints and the current layout. This allows syncing
    // widths and heights for pretty rows/columns. Note that dimensions are
    // explictly set on Draggables - this prevents them from changing size
    // or shape while being dragged.
    let items = ___default["default"].clone(this.state.items); // Fetches a jQuery list of elements for each item


    const $items = ___default["default"].map(items, function (item) {
      // eslint-disable-next-line react/no-string-refs
      return $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs[item.key]));
    }, this);

    const widths = ___default["default"].invoke($items, "outerWidth");

    const heights = ___default["default"].invoke($items, "outerHeight");

    const {
      constraints,
      layout
    } = this.props;
    let syncWidth = null;

    if (constraints !== null && constraints !== void 0 && constraints.width) {
      // Items must be at least as wide as the specified constraint
      syncWidth = ___default["default"].max(widths.concat(constraints.width));
    } else if (layout === VERTICAL$1) {
      // Sync widths to get a clean column
      syncWidth = ___default["default"].max(widths);
    }

    let syncHeight = null;

    if (constraints !== null && constraints !== void 0 && constraints.height) {
      // Items must be at least as high as the specified constraint
      syncHeight = ___default["default"].max(heights.concat(constraints.height));
    } else if (layout === HORIZONTAL$2) {
      // Sync widths to get a clean row
      syncHeight = ___default["default"].max(heights);
    }

    items = ___default["default"].map(items, function (item, i) {
      item.width = syncWidth || widths[i];
      item.height = syncHeight || heights[i];
      return item;
    });
    this.setState({
      items: items
    }, () => {
      this.props.onMeasure && this.props.onMeasure({
        widths: widths,
        heights: heights
      });
    });
  } // $FlowFixMe[signature-verification-failure]


  render() {
    var _this$props$constrain, _this$props$constrain2;

    // We don't render the sortable until KaTeX has fully loaded, in case
    // the draggables are rendering KaTeX content. This is un-optimal as
    // we end up loading KaTeX even when we may not need it, however it
    // helps to ensure that the dimensions of the draggables (and thus the
    // sortable) will be correct when they render, if their contents are
    // KaTeX-derived.
    if (this.props.waitForKatexLoad && !this.state.katex) {
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksProgressSpinner.CircularSpinner, null);
    }

    const cards = [];
    const {
      layout
    } = this.props; // We need to keep backwards compatbility with rules specified directly
    // in CSS. See sortable.less for details.

    const className = aphrodite.css(styles$j.sortable) + " perseus-sortable";
    const syncWidth = ((_this$props$constrain = this.props.constraints) === null || _this$props$constrain === void 0 ? void 0 : _this$props$constrain.width) || layout === VERTICAL$1;
    const syncHeight = ((_this$props$constrain2 = this.props.constraints) === null || _this$props$constrain2 === void 0 ? void 0 : _this$props$constrain2.height) || layout === HORIZONTAL$2;

    ___default["default"].each(this.state.items, function (item, i, items) {
      const isLast = i === items.length - 1;
      const isStatic = item.type === STATIC || item.type === DISABLED;
      let margin;

      if (this.props.layout === HORIZONTAL$2) {
        margin = "0 " + this.props.margin + "px 0 0"; // right
      } else if (this.props.layout === VERTICAL$1) {
        margin = "0 0 " + this.props.margin + "px 0"; // bottom
      }

      cards.push( /*#__PURE__*/React__namespace.createElement(Draggable, {
        content: item.option,
        key: item.key,
        type: item.type,
        ref: item.key,
        width: syncWidth ? item.width : undefined,
        height: syncHeight ? item.height : undefined,
        layout: layout,
        includePadding: this.props.padding,
        margin: isLast && isStatic ? 0 : margin,
        endPosition: item.endPosition,
        linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "sortable"),
        onRender: this.remeasureItems // eslint-disable-next-line react/jsx-no-bind
        ,
        onMouseDown: this.onMouseDown.bind(this, item.key) // eslint-disable-next-line react/jsx-no-bind
        ,
        onMouseMove: this.onMouseMove.bind(this, item.key) // eslint-disable-next-line react/jsx-no-bind
        ,
        onMouseUp: this.onMouseUp.bind(this, item.key) // eslint-disable-next-line react/jsx-no-bind
        ,
        onTouchMove: this.onMouseMove.bind(this, item.key) // eslint-disable-next-line react/jsx-no-bind
        ,
        onTouchEnd: this.onMouseUp.bind(this, item.key) // eslint-disable-next-line react/jsx-no-bind
        ,
        onTouchCancel: this.onMouseUp.bind(this, item.key) // eslint-disable-next-line react/jsx-no-bind
        ,
        onAnimationEnd: this.onAnimationEnd.bind(this, item.key)
      }));

      if (item.type === DRAGGING || item.type === ANIMATING) {
        cards.push( /*#__PURE__*/React__namespace.createElement(Placeholder, {
          key: "placeholder_" + item.key,
          ref: "placeholder_" + item.key,
          width: item.width,
          height: item.height,
          layout: layout,
          margin: isLast ? 0 : margin
        }));
      }
    }, this);

    return /*#__PURE__*/React__namespace.createElement("ul", {
      className: className
    }, cards);
  }

  onMouseDown(key) {
    // Static -> Dragging
    const items = ___default["default"].map(this.state.items, function (item) {
      if (item.key === key) {
        item.type = DRAGGING;
      }

      return item;
    });

    this.setState({
      items: items
    });
  } // This is public API and it's ok for components that use
  // this sortable to call this.
  // moveOptionToIndex takes an option and a desired index and
  // will move that item to the desired index. This is useful
  // for testing and other cases where dragging and dropping may
  // not be available


  moveOptionToIndex(option, index) {
    const {
      items
    } = this.state;

    if (index < 0 || index > items.length) {
      throw new Error("index ".concat(index, " out of bounds"));
    }

    const nextItems = ___default["default"].clone(items);

    const item = items.filter(item => {
      return item.option === option;
    })[0];

    if (item == null) {
      throw new Error("option ".concat(option, " not found"));
    }

    const currentIndex = items.findIndex(i => {
      return i.key === item.key;
    });
    nextItems.splice(currentIndex, 1);
    nextItems.splice(index, 0, item);
    this.setState({
      items: nextItems
    });
    this.props.onChange && this.props.onChange({});
  }

  onMouseMove(key) {
    // Dragging: Rearrange items based on draggable's position
    // eslint-disable-next-line react/no-string-refs
    const $draggable = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs[key]));
    const $sortable = $__default["default"](ReactDOM__default["default"].findDOMNode(this));

    const items = ___default["default"].clone(this.state.items);

    const item = ___default["default"].findWhere(this.state.items, {
      key: key
    });

    const margin = this.props.margin || 0;

    const currentIndex = ___default["default"].indexOf(items, item);

    let newIndex = 0;
    items.splice(currentIndex, 1);

    if (this.props.layout === HORIZONTAL$2) {
      const midWidth = $draggable.offset().left - $sortable.offset().left;
      let sumWidth = 0;
      let cardWidth;

      ___default["default"].each(items, function (item) {
        cardWidth = item.width;

        if (midWidth > sumWidth + cardWidth / 2) {
          newIndex += 1;
        }

        sumWidth += cardWidth + margin;
      });
    } else {
      const midHeight = $draggable.offset().top - $sortable.offset().top;
      let sumHeight = 0;
      let cardHeight;

      ___default["default"].each(items, function (item) {
        cardHeight = item.height;

        if (midHeight > sumHeight + cardHeight / 2) {
          newIndex += 1;
        }

        sumHeight += cardHeight + margin;
      });
    }

    if (newIndex !== currentIndex) {
      items.splice(newIndex, 0, item);
      this.setState({
        items: items
      });
    }
  }

  onMouseUp(key) {
    // Dragging -> Animating
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    const nextAnimationFrame = requestAnimationFrame(() => {
      const items = ___default["default"].map(this.state.items, function (item) {
        if (item.key === key) {
          item.type = ANIMATING;
          const $placeholder = $__default["default"](ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
          this.refs["placeholder_" + key]));
          const position = $placeholder.position();
          const endPosition = addOffsetParentScroll($placeholder, position);
          item.endPosition = endPosition;
        }

        return item;
      }, this);

      this.setState({
        items: items
      }); // HACK: We need to know *that* the widget changed, but currently it's
      // not set up in a nice way to tell us *how* it changed, since the
      // permutation of the items is stored in state.

      this.props.onChange && this.props.onChange({});
    }); // $FlowFixMe[prop-missing]

    this.animationFrameRequest = nextAnimationFrame;
  }

  onAnimationEnd(key) {
    // Animating -> Static
    const items = ___default["default"].map(this.state.items, function (item) {
      if (item.key === key) {
        item.type = STATIC;
      }

      return item;
    });

    this.setState({
      items: items
    });
  }

  getOptions() {
    return ___default["default"].pluck(this.state.items, "option");
  }

}

_defineProperty(Sortable, "defaultProps", {
  layout: HORIZONTAL$2,
  padding: true,
  disabled: false,
  constraints: {},
  onMeasure: function () {},
  margin: 5,
  onChange: function () {},
  linterContext: PerseusLinter__namespace.linterContextDefault,
  waitForKatexLoad: true
});

const styles$j = aphrodite.StyleSheet.create({
  sortable: {
    boxSizing: "border-box",
    float: "left",
    padding: 0,
    margin: 0
  },
  card: {
    boxSizing: "border-box",
    background: "#fff",
    border: "1px solid #ddd",
    borderRadius: 4,
    cursor: "pointer",
    minWidth: 25,
    minHeight: 44,
    padding: 10,
    listStyleType: "none",
    userSelect: "none",
    touchAction: "none"
  },
  placeholder: {
    background: "#ddd",
    border: "1px solid #ccc"
  },
  draggable: {
    textAlign: "center"
  },
  horizontalCard: {
    float: "left",
    cursor: "ew-resize"
  },
  verticalCard: {
    maxWidth: "100%",
    cursor: "ns-resize"
  },
  unpaddedCard: {
    padding: 0
  },
  dragging: {
    background: "#ffedcd",
    opacity: 0.8
  },
  disabled: {
    backgroundColor: "inherit",
    border: "1px solid transparent",
    cursor: "default"
  }
});

const {
  shuffle: shuffle$1,
  seededRNG
} = Util;
const HACKY_CSS_CLASSNAME = "perseus-widget-matcher";

class Matcher extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      leftHeight: 0,
      rightHeight: 0,
      katex: null
    });

    _defineProperty(this, "changeAndTrack", e => {
      this.props.onChange(e);
      this.props.trackInteraction();
    });

    _defineProperty(this, "onMeasureLeft", dimensions => {
      const height = ___default["default"].max(dimensions.heights);

      this.setState({
        leftHeight: height
      });
    });

    _defineProperty(this, "onMeasureRight", dimensions => {
      const height = ___default["default"].max(dimensions.heights);

      this.setState({
        rightHeight: height
      });
    });

    _defineProperty(this, "getUserInput", () => {
      // If KaTeX hasn't loaded then we won't be able to get the contents
      // of the sortables on the left and right, so we just return empty
      // arrays until we render for the first time.
      if (!this.state.katex) {
        return {
          left: [],
          right: []
        };
      }

      return {
        // eslint-disable-next-line react/no-string-refs
        left: this.refs.left.getOptions(),
        // eslint-disable-next-line react/no-string-refs
        right: this.refs.right.getOptions()
      };
    });

    _defineProperty(this, "moveLeftOptionToIndex", (option, index) => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.left.moveOptionToIndex(option, index);
    });

    _defineProperty(this, "moveRightOptionToIndex", (option, index) => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.right.moveOptionToIndex(option, index);
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return Matcher.validate(this.getUserInput(), rubric);
    });
  }

  componentDidMount() {
    getDependencies().getKaTeX().then(katex => this.setState({
      katex
    }));
  }

  render() {
    // We don't render the Matcher until KaTeX has fully loaded, in case
    // the sortables are rendering KaTeX content. This is un-optimal as
    // we end up loading KaTeX even when we may not need it, however it
    // helps to ensure that the dimensions of the sortables (and thus the
    // Matcher) will be correct when they render, if their contents are
    // KaTeX-derived.
    if (!this.state.katex) {
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksProgressSpinner.CircularSpinner, null);
    } // Use the same random() function to shuffle both columns sequentially


    const rng = seededRNG(this.props.problemNum);
    let left;

    if (!this.props.orderMatters) {
      // If the order doesn't matter, don't shuffle the left column
      left = this.props.left;
    } else {
      left = shuffle$1(this.props.left, rng,
      /* ensurePermuted */
      true);
    }

    const right = shuffle$1(this.props.right, rng,
    /* ensurePermuted */
    true);

    const showLabels = ___default["default"].any(this.props.labels);

    const constraints = {
      height: ___default["default"].max([this.state.leftHeight, this.state.rightHeight])
    };
    const cellMarginPx = this.props.apiOptions.isMobile ? 8 : 5;
    return /*#__PURE__*/React__namespace.createElement("table", {
      className: aphrodite.css(styles$i.widget) + " " + HACKY_CSS_CLASSNAME
    }, /*#__PURE__*/React__namespace.createElement("tbody", null, showLabels && /*#__PURE__*/React__namespace.createElement("tr", {
      className: aphrodite.css(styles$i.row)
    }, /*#__PURE__*/React__namespace.createElement("th", {
      className: aphrodite.css(styles$i.column, styles$i.columnLabel)
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.labels[0] || "...",
      linterContext: this.props.linterContext
    })), /*#__PURE__*/React__namespace.createElement("th", {
      className: aphrodite.css(styles$i.column, styles$i.columnRight, styles$i.columnLabel)
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.labels[1] || "...",
      linterContext: this.props.linterContext
    }))), /*#__PURE__*/React__namespace.createElement("tr", {
      className: aphrodite.css(styles$i.row)
    }, /*#__PURE__*/React__namespace.createElement("td", {
      className: aphrodite.css(styles$i.column)
    }, /*#__PURE__*/React__namespace.createElement(Sortable, {
      options: left,
      layout: "vertical",
      padding: this.props.padding,
      disabled: !this.props.orderMatters,
      constraints: constraints,
      onMeasure: this.onMeasureLeft,
      onChange: this.changeAndTrack,
      margin: cellMarginPx,
      linterContext: this.props.linterContext // eslint-disable-next-line react/no-string-refs
      ,
      ref: "left"
    })), /*#__PURE__*/React__namespace.createElement("td", {
      className: aphrodite.css(styles$i.column, styles$i.columnRight)
    }, /*#__PURE__*/React__namespace.createElement(Sortable, {
      options: right,
      layout: "vertical",
      padding: this.props.padding,
      constraints: constraints,
      onMeasure: this.onMeasureRight,
      onChange: this.changeAndTrack,
      margin: cellMarginPx,
      linterContext: this.props.linterContext // eslint-disable-next-line react/no-string-refs
      ,
      ref: "right"
    })))));
  }

}

_defineProperty(Matcher, "propTypes", {
  apiOptions: ApiOptions.propTypes,
  labels: PropTypes__default["default"].array,
  left: PropTypes__default["default"].array,
  onChange: PropTypes__default["default"].func,
  orderMatters: PropTypes__default["default"].bool,
  padding: PropTypes__default["default"].bool,
  problemNum: PropTypes__default["default"].number,
  right: PropTypes__default["default"].array,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});

_defineProperty(Matcher, "defaultProps", {
  left: [],
  right: [],
  labels: ["", ""],
  orderMatters: false,
  padding: true,
  problemNum: 0,
  onChange: function () {},
  linterContext: PerseusLinter.linterContextDefault
});

___default["default"].extend(Matcher, {
  validate: function (state, rubric) {
    const correct = ___default["default"].isEqual(state.left, rubric.left) && ___default["default"].isEqual(state.right, rubric.right);

    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
});

const padding = 5;
const border = "1px solid #444";
const styles$i = aphrodite.StyleSheet.create({
  widget: {
    paddingTop: padding,
    maxWidth: "100%",
    // Need to override minWidth in CSS :(
    minWidth: "auto"
  },
  row: {
    // Need to override global rules in CSS :(
    border: 0
  },
  column: {
    // TODO(benkomalo): constraint to half width?
    padding: 0,
    border: 0
  },
  columnRight: {
    borderLeft: border
  },
  columnLabel: {
    fontWeight: "inherit",
    borderBottom: border,
    padding: "0 ".concat(padding, "px ").concat(padding, "px ").concat(padding, "px"),
    textAlign: "center"
  }
});
var Matcher$1 = {
  name: "matcher",
  displayName: "Two column matcher",
  widget: Matcher,
  isLintable: true
};

const {
  firstNumericalParse,
  captureScratchpadTouchStart: captureScratchpadTouchStart$1
} = Util;
const toNumericString = KhanMath.toNumericString;
const getNumericFormat = KhanMath.getNumericFormat;
/* An input box that accepts only numeric strings
 *
 * Calls onChange(value, format) for valid numbers.
 * Reverts to the current value onBlur or on [ENTER],
 *   but maintains the format (i.e. 3/2, 1 1/2, 150%)
 * Accepts empty input and sends it to onChange as null
 *   if no numeric placeholder is set.
 * If given a checkValidity function, will turn
 *   the background/outline red when invalid
 * If useArrowKeys is set to true, up/down arrows will
 *   increment/decrement integers
 * Optionally takes a size ("mini", "small", "normal")
 */

class NumberInput extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      format: this.props.format
    });

    _defineProperty(this, "getValue", () => {
      return this.parseInputValue( // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this.refs.input).value // eslint-disable-line react/no-string-refs
      );
    });

    _defineProperty(this, "getStringValue", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      return ReactDOM__default["default"].findDOMNode(this.refs.input).value.toString(); // eslint-disable-line react/no-string-refs
    });

    _defineProperty(this, "parseInputValue", value => {
      if (value === "") {
        const placeholder = this.props.placeholder;
        return ___default["default"].isFinite(placeholder) ? +placeholder : null;
      }

      const result = firstNumericalParse(value);
      return ___default["default"].isFinite(result) ? result : this.props.value;
    });

    _defineProperty(this, "focus", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this.refs.input).focus(); // eslint-disable-line react/no-string-refs

      this._handleFocus();
    });

    _defineProperty(this, "blur", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this.refs.input).blur(); // eslint-disable-line react/no-string-refs

      this._handleBlur();
    });

    _defineProperty(this, "setSelectionRange", (selectionStart, selectionEnd) => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      ReactDOM__default["default"].findDOMNode(this).setSelectionRange(selectionStart, selectionEnd);
    });

    _defineProperty(this, "getSelectionStart", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      return ReactDOM__default["default"].findDOMNode(this).selectionStart;
    });

    _defineProperty(this, "getSelectionEnd", () => {
      // $FlowFixMe[incompatible-use]
      // $FlowFixMe[prop-missing]
      return ReactDOM__default["default"].findDOMNode(this).selectionEnd;
    });

    _defineProperty(this, "_checkValidity", value => {
      if (value == null) {
        return true;
      }

      const val = firstNumericalParse(value);
      const checkValidity = this.props.checkValidity;
      return ___default["default"].isFinite(val) && checkValidity(val);
    });

    _defineProperty(this, "_handleChange", e => {
      const text = e.target.value;
      const value = this.parseInputValue(text);
      const format = getNumericFormat(text);
      this.props.onChange(value);

      if (format) {
        this.props.onFormatChange(value, format);
        this.setState({
          format: format
        });
      }
    });

    _defineProperty(this, "_handleFocus", () => {
      if (this.props.onFocus) {
        this.props.onFocus();
      }
    });

    _defineProperty(this, "_handleBlur", e => {
      // Only continue on blur or "enter"
      if (e && e.type === "keypress" && e.keyCode !== 13) {
        return;
      }

      this._setValue(this.props.value, this.state.format);

      if (this.props.onBlur) {
        this.props.onBlur();
      }
    });

    _defineProperty(this, "_onKeyDown", e => {
      if (this.props.onKeyDown) {
        this.props.onKeyDown(e);
      }

      if (!this.props.useArrowKeys || !___default["default"].contains(["ArrowUp", "ArrowDown"], e.key)) {
        return;
      }

      let val = this.getValue();

      if (val !== Math.floor(val)) {
        return; // bail if not an integer
      }

      if (e.key === "ArrowUp") {
        val = val + 1;
      } else if (e.key === "ArrowDown") {
        val = val - 1;
      }

      if (this._checkValidity(val)) {
        this.props.onChange(val);
      }
    });

    _defineProperty(this, "_setValue", (val, format) => {
      // eslint-disable-next-line react/no-string-refs
      $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.input)).val(toNumericString(val, format));
    });
  }

  render() {
    let classes = classNames__default["default"]({
      "number-input": true,
      "invalid-input": !this._checkValidity(this.props.value),
      mini: this.props.size === "mini",
      small: this.props.size === "small",
      normal: this.props.size === "normal"
    });

    if (this.props.className != null) {
      classes = classes + " " + this.props.className;
    }

    const {
      // eslint-disable-next-line no-unused-vars
      onFormatChange,
      // eslint-disable-next-line no-unused-vars
      checkValidity,
      // eslint-disable-next-line no-unused-vars
      useArrowKeys,
      ...restProps
    } = this.props;
    return /*#__PURE__*/React__namespace.createElement("input", _extends$1({}, restProps, {
      className: classes,
      type: "text" // eslint-disable-next-line react/no-string-refs
      ,
      ref: "input",
      onChange: this._handleChange,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      onKeyPress: this._handleBlur,
      onKeyDown: this._onKeyDown,
      onTouchStart: captureScratchpadTouchStart$1,
      defaultValue: toNumericString(this.props.value, this.state.format),
      value: undefined
    }));
  }

  componentDidUpdate(prevProps) {
    if (!kmath.number.equal(this.getValue(), this.props.value)) {
      this._setValue(this.props.value, this.state.format);
    }
  }
  /* Return the current "value" of this input
   * If empty, it returns the placeholder (if it is a number) or null
   */


}

_defineProperty(NumberInput, "propTypes", {
  value: PropTypes__default["default"].number,
  format: PropTypes__default["default"].string,
  placeholder: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].number]),
  onChange: PropTypes__default["default"].func.isRequired,
  onFormatChange: PropTypes__default["default"].func,
  checkValidity: PropTypes__default["default"].func,
  size: PropTypes__default["default"].string,
  label: PropTypes__default["default"].oneOf(["put your labels outside your inputs!"])
});

_defineProperty(NumberInput, "defaultProps", {
  value: null,
  placeholder: null,
  format: null,
  onFormatChange: () => null,
  checkValidity: () => true,
  useArrowKeys: false
});

const {
  assert: assert$4
} = InteractiveUtil;
const {
  stringArrayOfSize
} = Util; // We store three sets of dimensions for the brackets, for our three types of
// inputs, which vary in formatting: (1) the "static" inputs rendered for the
// mobile apps (that are being deprecated), (2) the normal inputs rendered on
// desktop, and (3) the keypad-based inputs newly rendered for the mobile apps
// and mobile web. The first two sets of dimensions come from `matrix.less`;
// the keypad-based input's dimensions are provided to the component itself,
// below.

const STATIC_INPUT_DIMENSIONS = {
  INPUT_MARGIN: 4,
  INPUT_HEIGHT: 38,
  INPUT_WIDTH: 82
};
const NORMAL_DIMENSIONS = {
  INPUT_MARGIN: 3,
  INPUT_HEIGHT: 30,
  INPUT_WIDTH: 40
};
const KEYPAD_INPUT_DIMENSIONS = {
  INPUT_MARGIN: 4,
  INPUT_HEIGHT: 36,
  INPUT_WIDTH: 64
};
/* Input handling: Maps a (row, column) pair to a unique ref used by React,
 * and extracts (row, column) pairs from input paths, used to allow outsiders
 * to focus, blur, set input values, etc. */

function getInputPath$1(row, column) {
  return ["" + row, "" + column];
}

const getDefaultPath$1 = function () {
  return getInputPath$1(0, 0);
};

const getRowFromPath$1 = function (path) {
  // 'path' should be a (row, column) pair
  assert$4(___default["default"].isArray(path) && path.length === 2);
  return +path[0];
};

const getColumnFromPath$1 = function (path) {
  // 'path' should be a (row, column) pair
  assert$4(___default["default"].isArray(path) && path.length === 2);
  return +path[1];
};

const getRefForPath$1 = function (path) {
  const row = getRowFromPath$1(path);
  const column = getColumnFromPath$1(path);
  return "answer" + row + "," + column;
};

const getMatrixSize = function (matrix) {
  const matrixSize = [1, 1]; // We need to find the widest row and tallest column to get the correct
  // matrix size.

  ___default["default"](matrix).each((matrixRow, row) => {
    let rowWidth = 0;

    ___default["default"](matrixRow).each((matrixCol, col) => {
      if (matrixCol != null && matrixCol.toString().length) {
        rowWidth = col + 1;
      }
    }); // Matrix width:


    matrixSize[1] = Math.max(matrixSize[1], rowWidth); // Matrix height:

    if (rowWidth > 0) {
      matrixSize[0] = Math.max(matrixSize[0], row + 1);
    }
  });

  return matrixSize;
};

class Matrix extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "cursorPosition", void 0);

    _defineProperty(this, "state", {
      enterTheMatrix: 0
    });

    _defineProperty(this, "getInputPaths", () => {
      const inputPaths = [];
      const maxRows = this.props.matrixBoardSize[0];
      const maxCols = this.props.matrixBoardSize[1];

      ___default["default"](maxRows).times(row => {
        ___default["default"](maxCols).times(col => {
          const inputPath = getInputPath$1(row, col);
          inputPaths.push(inputPath);
        });
      });

      return inputPaths;
    });

    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      return "number";
    });

    _defineProperty(this, "_handleFocus", (row, col) => {
      this.props.onFocus(getInputPath$1(row, col));
    });

    _defineProperty(this, "_handleBlur", (row, col) => {
      this.props.onBlur(getInputPath$1(row, col));
    });

    _defineProperty(this, "focus", () => {
      this.focusInputPath(getDefaultPath$1());
      return true;
    });

    _defineProperty(this, "focusInputPath", path => {
      const inputID = getRefForPath$1(path); // eslint-disable-next-line react/no-string-refs

      this.refs[inputID].focus();
    });

    _defineProperty(this, "blurInputPath", path => {
      if (path.length === 0) {
        path = getDefaultPath$1();
      }

      const inputID = getRefForPath$1(path); // eslint-disable-next-line react/no-string-refs

      this.refs[inputID].blur();
    });

    _defineProperty(this, "getDOMNodeForPath", inputPath => {
      const inputID = getRefForPath$1(inputPath); // eslint-disable-next-line react/no-string-refs

      return ReactDOM__default["default"].findDOMNode(this.refs[inputID]);
    });

    _defineProperty(this, "setInputValue", (inputPath, value, callback) => {
      const row = getRowFromPath$1(inputPath);
      const col = getColumnFromPath$1(inputPath);
      this.onValueChange(row, col, value, callback);
    });

    _defineProperty(this, "handleKeyDown", (row, col, e) => {
      const maxRow = this.props.matrixBoardSize[0];
      const maxCol = this.props.matrixBoardSize[1];
      let enterTheMatrix = null; // eslint-disable-next-line react/no-string-refs

      const curInput = this.refs[getRefForPath$1(getInputPath$1(row, col))];
      const curValueString = curInput.getStringValue();
      const cursorStartPosition = curInput.getSelectionStart();
      const cursorEndPosition = curInput.getSelectionEnd();
      let nextPath = null;

      if (e.key === "ArrowUp" && row > 0) {
        nextPath = getInputPath$1(row - 1, col);
      } else if (e.key === "ArrowDown" && row + 1 < maxRow) {
        nextPath = getInputPath$1(row + 1, col);
      } else if (e.key === "ArrowLeft" && col > 0) {
        if (cursorStartPosition === 0 && cursorEndPosition === 0) {
          // Only go to next input if we're at the *start* of the content
          nextPath = getInputPath$1(row, col - 1);
        }
      } else if (e.key === "ArrowRight" && col + 1 < maxCol) {
        if (cursorStartPosition === curValueString.length) {
          // Only go to next input if we're at the *end* of the content
          nextPath = getInputPath$1(row, col + 1);
        }
      } else if (e.key === "Enter") {
        enterTheMatrix = this.state.enterTheMatrix + 1;
      } else if (e.key === "Escape") {
        enterTheMatrix = 0;
      }

      if (nextPath) {
        // Prevent the cursor from jumping again inside the next input
        e.preventDefault(); // Focus the input and move the cursor to the end of it.
        // eslint-disable-next-line react/no-string-refs

        const input = this.refs[getRefForPath$1(nextPath)]; // Multiply by 2 to ensure the cursor always ends up at the end;
        // Opera sometimes sees a carriage return as 2 characters.

        const inputValString = input.getStringValue();
        const valueLength = inputValString.length * 2;
        input.focus();

        if (e.key === "ArrowRight") {
          input.setSelectionRange(0, 0);
        } else {
          input.setSelectionRange(valueLength, valueLength);
        }
      }

      if (enterTheMatrix != null) {
        this.setState({
          enterTheMatrix: enterTheMatrix
        });
      }
    });

    _defineProperty(this, "onValueChange", (row, column, value, cb) => {
      const answers = ___default["default"].map(this.props.answers, ___default["default"].clone);

      if (!answers[row]) {
        answers[row] = [];
      }

      answers[row][column] = value;
      this.props.onChange({
        answers: answers
      }, cb);
      this.props.trackInteraction();
    });

    _defineProperty(this, "getUserInput", () => {
      return {
        answers: this.props.answers
      };
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return Matrix.validate(this.getUserInput(), rubric);
    });
  }

  componentDidMount() {
    // Used in the `onBlur` and `onFocus` handlers
    this.cursorPosition = [0, 0];
  }

  render() {
    // Set the input sizes through JS so we can control the size of the
    // brackets. (If we set them in CSS we won't know values until the
    // inputs are rendered.)
    let dimensions;

    if (this.props.apiOptions.customKeypad) {
      dimensions = KEYPAD_INPUT_DIMENSIONS;
    } else if (this.props.apiOptions.staticRender) {
      dimensions = STATIC_INPUT_DIMENSIONS;
    } else {
      dimensions = NORMAL_DIMENSIONS;
    }

    const {
      INPUT_MARGIN,
      INPUT_HEIGHT,
      INPUT_WIDTH
    } = dimensions;
    const matrixSize = getMatrixSize(this.props.answers);
    const maxRows = this.props.matrixBoardSize[0];
    const maxCols = this.props.matrixBoardSize[1];
    const cursorRow = this.props.cursorPosition[0];
    const cursorCol = this.props.cursorPosition[1];
    const highlightedRow = Math.max(cursorRow, matrixSize[0] - 1);
    const highlightedCol = Math.max(cursorCol, matrixSize[1] - 1);
    const bracketHeight = (highlightedRow + 1) * (INPUT_HEIGHT + 2 * INPUT_MARGIN);
    const bracketOffset = (highlightedCol + 1) * (INPUT_WIDTH + 2 * INPUT_MARGIN);
    const className = classNames__default["default"]({
      "perseus-matrix": true,
      "static-mode": this.props.static,
      "the-matrix": this.state.enterTheMatrix >= 5
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: className
    }, this.props.prefix && /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-prefix"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.prefix,
      linterContext: this.props.linterContext
    })), /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-input"
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-bracket bracket-left",
      style: {
        height: bracketHeight
      }
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-bracket bracket-right",
      style: {
        height: bracketHeight,
        left: bracketOffset
      }
    }), ___default["default"](maxRows).times(row => {
      const rowVals = this.props.answers[row];
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: "matrix-row",
        key: row
      }, ___default["default"](maxCols).times(col => {
        const outside = row > highlightedRow || col > highlightedCol;
        const inputProps = {
          className: outside ? "outside" : "inside",
          ref: getRefForPath$1(getInputPath$1(row, col)),
          value: rowVals ? rowVals[col] : null,
          style: {
            height: INPUT_HEIGHT,
            width: INPUT_WIDTH,
            margin: INPUT_MARGIN
          },
          disabled: this.props.apiOptions.readOnly,
          onFocus: () => {
            // We store this locally so that we can use
            // the new information in the `onBlur`
            // handler, which happens before the props
            // change has time to propagate.
            // TODO(emily): Try to fix `MathOutput` so
            // it correctly sends blur events before
            // focus events.
            this.cursorPosition = [row, col];
            this.props.onChange({
              cursorPosition: [row, col]
            }, () => {
              // This isn't a user interaction, so
              // return false to signal that the
              // matrix shouldn't be focused
              return false;
            });

            this._handleFocus(row, col);
          },
          onBlur: () => {
            if (row === this.cursorPosition[0] && col === this.cursorPosition[1]) {
              this.props.onChange({
                cursorPosition: [0, 0]
              }, () => {
                // This isn't a user interaction,
                // so return false to signal that
                // the matrix shouldn't be focused
                return false;
              });
            }

            this._handleBlur(row, col);
          },
          onKeyDown: e => {
            this.handleKeyDown(row, col, e);
          },
          onChange: (value, cb) => {
            this.onValueChange(row, col, value, cb);
          }
        };
        let MatrixInput;

        if (this.props.apiOptions.customKeypad) {
          const style = {
            margin: INPUT_MARGIN,
            minWidth: INPUT_WIDTH,
            minHeight: INPUT_HEIGHT,
            // Ensure that any borders are included in
            // the provided width.
            boxSizing: "border-box",
            backgroundColor: outside ? "#f3f3f3" : "#fff"
          };
          MatrixInput = /*#__PURE__*/React__namespace.createElement(SimpleKeypadInput, _extends$1({}, inputProps, {
            style: style,
            scrollable: true,
            keypadElement: this.props.keypadElement
          }));
        } else if (this.props.apiOptions.staticRender) {
          MatrixInput = /*#__PURE__*/React__namespace.createElement(MathOutput, inputProps);
        } else if (this.props.numericInput) {
          MatrixInput = /*#__PURE__*/React__namespace.createElement(NumberInput, inputProps);
        } else {
          MatrixInput = /*#__PURE__*/React__namespace.createElement(TextInput, inputProps);
        }

        return /*#__PURE__*/React__namespace.createElement("span", {
          key: col,
          className: "matrix-input-field"
        }, MatrixInput);
      }));
    })), this.props.suffix && /*#__PURE__*/React__namespace.createElement("div", {
      className: "matrix-suffix"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.suffix,
      linterContext: this.props.linterContext
    })));
  }

}

_defineProperty(Matrix, "defaultProps", {
  matrixBoardSize: [3, 3],
  answers: [[]],
  prefix: "",
  suffix: "",
  cursorPosition: [0, 0],
  apiOptions: ApiOptions.defaults,
  linterContext: PerseusLinter.linterContextDefault
});

___default["default"].extend(Matrix, {
  validate: function (state, rubric) {
    const solution = rubric.answers;
    const supplied = state.answers;
    const solutionSize = getMatrixSize(solution);
    const suppliedSize = getMatrixSize(supplied);
    const incorrectSize = solutionSize[0] !== suppliedSize[0] || solutionSize[1] !== suppliedSize[1];
    const createValidator = KhanAnswerTypes.number.createValidatorFunctional;
    let message = null;
    let hasEmptyCell = false;
    let incorrect = false;

    ___default["default"](suppliedSize[0]).times(row => {
      ___default["default"](suppliedSize[1]).times(col => {
        if (supplied[row][col] == null || supplied[row][col].toString().length === 0) {
          hasEmptyCell = true;
        }

        if (!incorrectSize) {
          const validator = createValidator(solution[row][col], {
            simplify: true
          });
          const result = validator(supplied[row][col]);

          if (result.message) {
            message = result.message;
          }

          if (!result.correct) {
            incorrect = true;
          }
        }
      });
    });

    if (hasEmptyCell) {
      return {
        type: "invalid",
        message: i18n__namespace._("Make sure you fill in all cells in the matrix.")
      };
    }

    if (incorrectSize) {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }

    return {
      type: "points",
      earned: incorrect ? 0 : 1,
      total: 1,
      message: message
    };
  }
});

const propTransform$2 = editorProps => {
  // Remove answers before passing to widget
  const blankAnswers = ___default["default"](editorProps.matrixBoardSize[0]).times(function () {
    return stringArrayOfSize(editorProps.matrixBoardSize[1]);
  });

  editorProps = ___default["default"].pick(editorProps, "matrixBoardSize", "prefix", "suffix");
  return ___default["default"].extend(editorProps, {
    answers: blankAnswers
  });
};

const staticTransform$2 = editorProps => {
  const widgetProps = ___default["default"].pick(editorProps, "matrixBoardSize", "prefix", "suffix"); // We convert matrix cells from numbers to string to match the expected
  // input into the rendered widget.


  widgetProps.answers = ___default["default"].map(editorProps.answers, row => {
    // Replace null values with empty string
    return ___default["default"].map(row, cell => cell != null ? String(cell) : "");
  });
  return widgetProps;
};

var Matrix$1 = {
  name: "matrix",
  displayName: "Matrix",
  widget: Matrix,
  transform: propTransform$2,
  staticTransform: staticTransform$2,
  isLintable: true
};

/* eslint-disable @babel/no-invalid-this, react/sort-comp */
const defaultImage = {
  url: null,
  top: 0,
  left: 0
};
const Measurer = createReactClass__default["default"]({
  displayName: "Measurer",
  propTypes: {
    apiOptions: ApiOptions.propTypes,
    box: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
    image: PropTypes__default["default"].shape({
      url: PropTypes__default["default"].string,
      top: PropTypes__default["default"].number,
      left: PropTypes__default["default"].number
    }),
    showProtractor: PropTypes__default["default"].bool,
    protractorX: PropTypes__default["default"].number,
    protractorY: PropTypes__default["default"].number,
    showRuler: PropTypes__default["default"].bool,
    rulerLabel: PropTypes__default["default"].string,
    rulerTicks: PropTypes__default["default"].number,
    rulerPixels: PropTypes__default["default"].number,
    rulerLength: PropTypes__default["default"].number
  },
  getDefaultProps: function () {
    return {
      box: [480, 480],
      image: {},
      showProtractor: true,
      protractorX: 7.5,
      protractorY: 0.5,
      showRuler: false,
      rulerLabel: "",
      rulerTicks: 10,
      rulerPixels: 40,
      rulerLength: 10
    };
  },
  getInitialState: function () {
    return {};
  },
  render: function () {
    const image = ___default["default"].extend({}, defaultImage, this.props.image); // TODO(scottgrant): This isn't a11y-friendly! We should insist on
    // finding some valid alt text when this widget is used.


    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget perseus-widget-measurer " + "graphie-container above-scratchpad",
      style: {
        width: this.props.box[0],
        height: this.props.box[1]
      }
    }, image.url && /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        position: "relative",
        top: image.top,
        left: image.left
      }
    }, /*#__PURE__*/React__namespace.createElement(SvgImage, {
      src: image.url
    })), /*#__PURE__*/React__namespace.createElement("div", {
      className: "graphie",
      ref: "graphieDiv"
    }));
  },
  componentDidMount: function () {
    this.setupGraphie();
  },
  componentDidUpdate: function (prevProps) {
    const shouldSetupGraphie = ___default["default"].any(["box", "showProtractor", "showRuler", "rulerLabel", "rulerTicks", "rulerPixels", "rulerLength"], function (prop) {
      return prevProps[prop] !== this.props[prop];
    }, this);

    if (shouldSetupGraphie) {
      this.setupGraphie();
    }
  },
  setupGraphie: function () {
    // eslint-disable-next-line react/no-string-refs
    const graphieDiv = ReactDOM__default["default"].findDOMNode(this.refs.graphieDiv);
    $__default["default"](graphieDiv).empty();
    const graphie = this.graphie = GraphUtils.createGraphie(graphieDiv);
    const scale = [40, 40];
    const range = [[0, this.props.box[0] / scale[0]], [0, this.props.box[1] / scale[1]]];
    graphie.init({
      range: range,
      scale: scale
    });
    graphie.addMouseLayer({
      allowScratchpad: true,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    });

    if (this.protractor) {
      this.protractor.remove();
    }

    if (this.props.showProtractor) {
      this.protractor = graphie.protractor([this.props.protractorX, this.props.protractorY]);
    }

    if (this.ruler) {
      this.ruler.remove();
    }

    if (this.props.showRuler) {
      this.ruler = graphie.ruler({
        center: [(range[0][0] + range[0][1]) / 2, (range[1][0] + range[1][1]) / 2],
        label: this.props.rulerLabel,
        pixelsPerUnit: this.props.rulerPixels,
        ticksPerUnit: this.props.rulerTicks,
        units: this.props.rulerLength
      });
    }
  },
  getUserInput: function () {
    return {};
  },
  simpleValidate: function (rubric) {
    // TODO(joel) - I don't understand how this is useful!
    return Measurer.validate(this.getUserInput(), rubric);
  },
  focus: $__default["default"].noop
});

___default["default"].extend(Measurer, {
  validate: function (state, rubric) {
    return {
      type: "points",
      earned: 1,
      total: 1,
      message: null
    };
  }
});

const propUpgrades = {
  "1": v0props => {
    const v1props = ___default["default"](v0props).chain().omit("imageUrl", "imageTop", "imageLeft").extend({
      image: {
        url: v0props.imageUrl,
        top: v0props.imageTop,
        left: v0props.imageLeft
      }
    }).value();

    return v1props;
  }
};
var Measurer$1 = {
  name: "measurer",
  displayName: "Measurer",
  widget: Measurer,
  version: {
    major: 1,
    minor: 0
  },
  propUpgrades: propUpgrades
};

/**
 * Draw some text into a 2D canvas drawing context.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the text.  Must look like: {
 *         type: "text",
 *         pos: [x, y],
 *         value: "some text to draw",
 *     }
 *
 */
function drawText(ctx, item) {
  if (item.value === null) {
    return;
  }

  ctx.fillStyle = styles$h.fgColor;
  ctx.font = styles$h.font;
  ctx.fillText(item.value, item.pos[0] - styles$h.fontSizePx / 2 + 1, item.pos[1] + styles$h.fontSizePx / 2);
}
/**
 * Draw a double line into a 2D canvas drawing context.
 *
 * Apparently the way you do this is to stroke an extra-wide line in the
 * foreground color and then a smaller line in the background color. 5:3
 * foreground:background width looks reasonable for drawing chemical bonds.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:double",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */


function drawDoubleLine(ctx, item) {
  // Outer line that forms both of the bond lines.
  let path = new Path2D();
  ctx.lineWidth = 5 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path); // Inner white line that separates the two bond lines.

  path = new Path2D();
  ctx.lineWidth = 3 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.bgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);
}
/**
 * Draw a triple line into a 2D canvas drawing context.
 *
 * Following the strategy for the double line, we stroke a very wide
 * foreground-color line, then a medium background-color line, then a narrow
 * foreground-color line.
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:triple",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */


function drawTripleLine(ctx, item) {
  // TODO(colin): consolidate duplicated code from the three line drawing
  // functions.
  // Outer line that will form the two outer bond lines.
  let path = new Path2D();
  ctx.lineWidth = 7 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path); // Middle white line that separates the bonds

  path = new Path2D();
  ctx.lineWidth = 5 * styles$h.lineWidth;
  ctx.strokeStyle = styles$h.bgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path); // Inner line that forms the middle bond line.

  drawLine(ctx, item);
}
/**
 * Draw a single line into a 2D canvas drawing context
 *
 * Args:
 *     ctx: the 2D drawing context
 *     item: the rendering instruction for the line.  Must look like: {
 *         type: "line:single",
 *         startPos: [x, y],
 *         endPos: [x, y],
 *     }
 */


function drawLine(ctx, item) {
  const path = new Path2D();
  ctx.lineWidth = styles$h.lineWidth;
  ctx.strokeStyle = styles$h.fgColor;
  path.moveTo(item.startPos[0], item.startPos[1]);
  path.lineTo(item.endPos[0], item.endPos[1]);
  ctx.stroke(path);
}
/**
 * Lookup table that maps drawing instruction types to the functions that
 * render them.
 */


const drawingFuncs = {
  text: drawText,
  "line:single": drawLine,
  "line:double": drawDoubleLine,
  "line:triple": drawTripleLine
};
/**
 * Draw a single rendering instruction into a 2D canvas drawing context.
 */

function drawItem(ctx) {
  return function (item) {
    drawingFuncs[item.type](ctx, item);
  };
}
/**
 * Lookup table for drawing priorities.
 *
 * Types with lower priorities are drawn first.
 */


const ordering = {
  "line:single": 0,
  "line:double": 0,
  "line:triple": 0,
  text: 1
};
/**
 * Sorting comparison function that orders rendering instructions according to
 * their type's priority.
 */

function compareElements(item0, item1) {
  return ordering[item0.type] - ordering[item1.type];
}
/**
 * Draw an array of rendering instructions into a 2D canvas drawing context.
 */
// eslint-disable-next-line ft-flow/no-mutable-array


function draw(ctx, items) {
  items.sort(compareElements).forEach(drawItem(ctx));
}

const styles$h = {
  bgColor: "rgb(255, 255, 255)",
  fgColor: "rgb(0, 0, 0)",
  fontSizePx: 12,
  lineWidth: 1,
  font: "12px sans"
};

/**
 * A molecule layout engine.
 *
 * This module transforms the SMILES syntax tree into a set of rendering
 * instructions.  A rendering instruction is an object indicating what type of
 * thing to render (e.g. text or line), where to render it, and any other style
 * properties needed.
 *
 * For instance, an oxygen atom might be rendered as
 * {type: "text", value: "O", pos: [0, 0], idx: "1,0"}
 */
// Default length of the bond.  This currently corresponds directly to pixels
// in the renderer, but we may want this just to be arbitrary in the future.
const bondLength = 30;
/**
 * Compute a coordinate by moving an angle and length from an origin point.
 *
 * Args:
 *     origin: a list of the [x, y] coordinates of the origin
 *     angle: an angle in degrees from the origin, following the typical
 *         convention of +x axis = 0 degrees, +y axis = 90 degrees.
 *     length: the distance to the new point
 * Return:
 *     a two-element list containing the [x, y] coordinates of the point.
 */

function polarAdd(origin, angle, length) {
  const x = origin[0];
  const y = origin[1];
  return [x + Math.cos(angle * 2 * Math.PI / 360) * length, y + -1.0 * Math.sin(angle * 2 * Math.PI / 360) * length];
}
/**
 * Compute the layout for a single atom.
 *
 * Args:
 *     atom: the atom node for which layout is being created, as returned from
 *         convertTree; the computed position of this atom is added to this
 *         object in place, in addition to being returned in the layout
 *         instruction.
 *         TODO(colin): refactor so that we don't need to modify this in place
 *     atoms: the list of all atoms, as returned from convertTree, used to
 *         position this atom appropriately relative to its neighbors
 *     bonds: the list of all bonds, as returned from convertTree, used to
 *         determine the geometry based on bond type
 *     rotationAngle: a constant rotation for the whole molecule (in degrees)
 *
 * Return:
 *     a rendering instruction for the atom, containing a type (text), the text
 *     to render, the position, and the atom index
 */


function atomLayout(atom, atoms, bonds, rotationAngle) {
  let textValue = atom.symbol;

  if (textValue === "C" && Object.keys(atoms).length !== 1) {
    // By convention, don't render the C for carbon in a chain.
    textValue = null;
  }

  if (atom.idx === "1,0") {
    // The first atom is special-cased because there are no neighbors for
    // relative positioning.
    const pos = [0, 0];
    atom.pos = pos; // Conventionally, molecules are rendered where the first bond is not
    // horizontal, but at a 30 degree angle, so subtract 30 degrees for the
    // first atom's direction.

    atom.baseAngle = -30 + rotationAngle;
    return {
      type: "text",
      value: textValue,
      pos: pos,
      idx: atom.idx
    };
  } // If we're an atom with any other index than the case just handled, we're
  // guaranteed to have a neighbor who has a defined position.


  const prevPositionedAtom = atoms[atom.connections.find(function (c) {
    return atoms[c].pos;
  })]; // Find this atom's index in the previous atom's connections

  const myIndex = prevPositionedAtom.connections.indexOf(atom.idx);
  let baseAngleIncrement = 60;
  let angleIncrement = 120;

  if (prevPositionedAtom.connections.length === 4) {
    // By convention, if an atom has 4 bonds, we represent it with 90
    // degree angles in 2D, even though it would have tetrahedral geometry
    // with ~110 degree angles in 3D.
    angleIncrement = 90;
    baseAngleIncrement = 90;
  } else if (bonds.find(bond => bond.bondType === "triple" && bond.to === atom.idx) || bonds.find(bond => bond.bondType === "triple" && bond.to === prevPositionedAtom.idx)) {
    // Triple bonds have a bond angle of 180 degrees, so don't change the
    // direction in which we made the previous bond.
    angleIncrement = 0;
    baseAngleIncrement = 0;
  }

  let angle = 0;
  const idxPath = prevPositionedAtom.idx.split(":");
  const lastAtomIdx = idxPath[idxPath.length - 1].split(",")[0]; // Conventionally, a single chain of atoms is rendered as a zig-zag pattern
  // with 120 degree angles.  This means we need to flip the angle every
  // other atom.  The parser ensures that indices always alternate odd-even,
  // including taking into account branch points.
  // TODO(colin): don't depend on the parser's indexing scheme and just track
  // this entirely in the layout engine.

  if (parseInt(lastAtomIdx) % 2 !== 0) {
    angle = prevPositionedAtom.baseAngle - (baseAngleIncrement - angleIncrement * myIndex);
  } else {
    angle = prevPositionedAtom.baseAngle + (baseAngleIncrement - angleIncrement * myIndex);
  }

  const pos = polarAdd(prevPositionedAtom.pos, angle, bondLength);
  atom.pos = pos;
  atom.baseAngle = angle;
  return {
    type: "text",
    value: textValue,
    pos: pos,
    idx: atom.idx
  };
}
/**
 * Get the start and end position for a bond connecting two atoms.
 *
 * If we have non-carbon atoms that render with explicit letters connected by a
 * bond, we don't want the line for the bond to extend into the lettering for
 * the atom.
 *
 * This function returns the start and end positions of the bond's line, taking
 * into account that one or both end points might need to be moved to make room
 * for text.
 *
 * TODO(colin): this makes assumptions about the relative sizes of the length
 * of a bond and the text.  Think about alternate ways to represent this that
 * might not have that problem.
 */


function maybeShrinkLines(fromAtom, toAtom) {
  const shrinkFactor = 0.25;
  let fromPos = [fromAtom.pos[0], fromAtom.pos[1]];
  let toPos = [toAtom.pos[0], toAtom.pos[1]];

  if (fromAtom.symbol !== "C") {
    fromPos = [toAtom.pos[0] - (1 - shrinkFactor) * (toAtom.pos[0] - fromAtom.pos[0]), toAtom.pos[1] - (1 - shrinkFactor) * (toAtom.pos[1] - fromAtom.pos[1])];
  }

  if (toAtom.symbol !== "C") {
    // For carbon atoms, conventionally we don't draw any letter, so this
    // special cases drawing the bond lines all the way to the point where
    // they meet.
    toPos = [fromAtom.pos[0] - (1 - shrinkFactor) * (fromAtom.pos[0] - toAtom.pos[0]), fromAtom.pos[1] - (1 - shrinkFactor) * (fromAtom.pos[1] - toAtom.pos[1])];
  }

  return [fromPos, toPos];
}
/**
 * Compute the layout for a bond between two atoms.
 *
 * Args:
 *     bond: the bond node for which the layout is being computed, as returned
 *         by convertTree
 *     atoms: the list of all atoms returned by convertTree, which should
 *         already have been processed for layout and thus have positions set
 *
 * Return:
 *     a rendering instruction for the bond containing a type
 *     (line:{single,double,triple}) and the line's endpoints
 */


function bondLayout(bond, atoms) {
  const fromAtom = atoms[bond.from];
  const toAtom = atoms[bond.to];
  const startAndEndPos = maybeShrinkLines(fromAtom, toAtom);
  return {
    type: "line:" + bond.bondType,
    startPos: startAndEndPos[0],
    endPos: startAndEndPos[1]
  };
}
/**
 * Convert an array of atom indices to a single string unique identifier.
 *
 * For linear molecules, or for atoms in the main chain, this will just be the
 * atom index, something like "0,1".  For branched molecules, however, we
 * uniquely identify atoms by an array of atoms where the branching happened,
 * followed by the index in the current branch (like ["0,1", "1,2", "1,1"]).
 * This function just joins the parts with a colon so that we can have nice
 * object keys that still track the series of branches to get to an atom, which
 * is guaranteed to be a unique identifier.
 *
 */


function idxString(idx) {
  return idx.join(":");
}
/**
 * Convert the parse tree output by the parser into an ordered list of atoms
 * and bonds to render.
 *
 * Args:
 *     atoms: the output list of atoms that we're in the process of building.
 *         This should be the empty list if not being called recursively.
 *     bonds: the output list of bonds that we're in the process of building.
 *         This should be the empty list if not being called recursively.
 *     tree: the parse tree generated by the SMILES parser module.
 *
 * Return:
 *     the final value of atoms and bonds, which are lists of all the atom
 *     nodes and bond nodes, respectively, that need to be rendered.
 */


function convertTree(atoms, bonds, tree) {
  if (tree === null) {
    return [atoms, bonds];
  }

  if (tree.type === "atom") {
    const treeIdx = idxString(tree.idx);
    atoms[treeIdx] = {
      idx: treeIdx,
      symbol: tree.symbol,
      connections: []
    };

    if (tree.bonds) {
      tree.bonds.forEach(function (b) {
        const toIdx = idxString(b.to.idx);
        atoms[treeIdx].connections.push(toIdx);
        bonds.push({
          from: treeIdx,
          to: toIdx,
          bondType: b.bondType
        });
        convertTree(atoms, bonds, b.to);
        atoms[toIdx].connections.push(treeIdx);
      });
    }
  }

  return [atoms, bonds];
}
/**
 * Recursively process the queue of atoms that need to have layout computed.
 *
 * Args:
 *     outputs: the array of atom rendering instructions we're in the process
 *         of building.  This should be the empty array if not being called
 *         recursively.
 *     atomProcessingQueue: the array of unique identifier strings (see the
 *         comment for idxString for more information about these) of atoms
 *         currently in line to be processed.  When not being called
 *         recursively, this should be a array with a single element, the
 *         unique identifier of the first atom in the structure ("1,0" in the
 *         current scheme).
 *     atoms: the array of all atom nodes to be rendered, as returned by
 *         convertTree
 *     bonds: the array of all bond nodes to be rendered, as returned by
 *         convertTree
 *
 * Return:
 *     an array of rendering instructions for all the atoms in the molecule
 */


function atomLayoutHelper(outputs, atomProcessingQueue, atoms, bonds, rotationAngle) {
  if (atomProcessingQueue.length === 0) {
    return outputs;
  }

  const queuedAtomIdx = atomProcessingQueue.shift();
  const atom = atoms[queuedAtomIdx];
  atom.connections.forEach(function (c) {
    if (!atoms[c].pos) {
      atomProcessingQueue.push(c);
    }
  });
  return atomLayoutHelper(outputs.concat(atomLayout(atom, atoms, bonds, rotationAngle)), atomProcessingQueue, atoms, bonds, rotationAngle);
}
/**
 * Recursively process the queue of bonds that need to have layout computed.
 *
 * Args:
 *     outputs: the array of bond rendering instructions we're in the process
 *         of building.  This should be the empty array or the array of all
 *         atom rendering instructions if not being called recursively.
 *     atoms: the array of all atom nodes to be rendered, as returned by
 *         convertTree
 *     bonds: the array of all bond nodes to be rendered, as returned by
 *         convertTree
 *
 * Return:
 *     an array of rendering instructions for all the bonds in the molecule
 *     concatenated to the initial value of outputs
 */


function bondLayoutHelper(outputs, atoms, bonds) {
  if (bonds.length === 0) {
    return outputs;
  }

  return bondLayoutHelper(outputs.concat(bondLayout(bonds[0], atoms)), atoms, bonds.slice(1));
}
/**
 * Compute an array of rendering instructions from the parse tree of a molecule.
 *
 * Args:
 *     tree: the parse tree as returned by the SMILES parser module
 *     rotationAngle: a global rotation (in degrees) to be applied to the whole
 *         molecule; this is manually adjustable in the widget.
 *
 * Return:
 *     an array of rendering instructions for all the atoms and bonds in the
 *     molecule suitable for processing by the renderer
 */


function layout$1(tree, rotationAngle) {
  const converted = convertTree({}, [], tree);
  const atoms = converted[0];
  const bonds = converted[1];
  const outputs = atomLayoutHelper([], ["1,0"], atoms, bonds, rotationAngle);
  return bondLayoutHelper(outputs, atoms, bonds);
}

var MoleculeLayout = {
  layout: layout$1,
  // The remainder are exported for testing and are not intended for external
  // use.
  _atomLayout: atomLayout,
  _bondLayout: bondLayout,
  _bondLength: bondLength,
  _convertTree: convertTree
};

// Regexp defining characters that are valid SMILES characters that this parser
// can parse.  In addition to serving as a sort of validation, this also keeps
// out unimplemented features (like cycles and stereochemistry), which use
// additional characters.
const smilesRe = new RegExp("^[A-Za-z\\[\\]()=#+-]*$"); // Regexp defining what characters are valid as atom names.  This includes
// common 1-character elements, Cl and Br for convenience, and the open
// bracket, which can be used to include anything as an atom name.

const atomRe = new RegExp("^(Cl|Br|[CONPSFBI]|\\[)");

function ParseError$1(message) {
  this.message = message;
}
/**
 * Perform a functional update of a possibly nested object.
 *
 * Args:
 *     obj: an object, will not be modified
 *     keylist: a list of keys whose values will be updated in the object.
 *         This represents a path to a value inside nested objects.  For
 *         example, if keylist == ["a", "b", "c"], then a new object is
 *         returned with obj["a"]["b"]["c"] updated.  Note that if any of the
 *         keys is not already present, this will insert {} as a default value
 *         for that key.
 *     val: the new value to associate with the keypath
 *
 * Return: a new object, which is a shallow copy of the original with the value
 *     at the specified keypath replaced.
 */


function _mset(obj, keylist, val) {
  const k0 = keylist[0];
  const rest = keylist.slice(1);
  let newObj;

  if (Array.isArray(obj)) {
    newObj = [...obj];
  } else {
    newObj = { ...(obj || {})
    };
  }

  let newVal = val;

  if (rest.length > 0) {
    newVal = _mset(newObj[k0], rest, val);
  }

  newObj[k0] = newVal;
  return newObj;
}
/**
 * Perform a functional increment of a value in a nested object.
 *
 * Args:
 *     obj: an object; this will not be modified
 *     keylist: a list of keys representing a path into a nested object.  (See
 *         `_mset` for examples.)
 *
 * Return:
 *     an object that is a shallow copy of obj, with the value at the specified
 *     path incremeneted.
 */


function _inc(obj, keylist) {
  const val = keylist.reduce(function (acc, elt) {
    return acc[elt];
  }, obj);
  return _mset(obj, keylist, val + 1);
}

function validate(smiles) {
  return smilesRe.test(smiles);
}
/**
 * Parse a bond modifier character, updating the context object so that the
 * next bond created has this modifier.
 */


function parseBondModifier(smiles, ctx) {
  const firstChar = smiles[0];
  const rest = smiles.slice(1);

  if (firstChar === "=") {
    return parse$2(rest, _mset(ctx, ["bond", "bondType"], "double"));
  }

  if (firstChar === "#") {
    return parse$2(rest, _mset(ctx, ["bond", "bondType"], "triple"));
  } // $FlowFixMe[invalid-constructor]


  throw new ParseError$1("Invalid character: " + firstChar);
}
/**
 * Slice the input string, removing a parenthesized expression.
 * (Will handle nested parentheses.)
 *
 * parenStack should be a list containing any open parentheses already
 * encountered.  (Usually, this will be ["("])
 */


function sliceFromMatchingCloseParen(smiles, parenStack) {
  if (parenStack.length === 0) {
    return smiles;
  }

  if (smiles === "") {
    // $FlowFixMe[invalid-constructor]
    throw new ParseError$1("Mismatched parentheses");
  }

  const firstChar = smiles[0];
  const rest = smiles.slice(1);

  if (firstChar === "(") {
    return sliceFromMatchingCloseParen(rest, parenStack.concat(firstChar));
  }

  if (firstChar === ")") {
    return sliceFromMatchingCloseParen(rest, parenStack.slice(1));
  }

  return sliceFromMatchingCloseParen(rest, parenStack);
}
/**
 * Parse a branch, as indicated by the presence of a parenthesized experession.
 *
 * This returns a list of all branches (including the continuation of the
 * backbone) that should be added to the previous atom's bond list.
 */


function parseParenthesizedExpression(smiles, ctx) {
  const firstChar = smiles[0];
  const rest = smiles.slice(1);

  if (firstChar === "(") {
    let newCtx = { ...ctx,
      parens: ctx.parens + "("
    }; // increment the branch index

    newCtx = _inc(ctx, ["idx", ctx.idx.length - 1, 1]);
    let inBranchIdx = -1;

    if (ctx.idx[ctx.idx.length - 1][0] % 2 === 0) {
      // HACK(colin): this is so that we preserve the odd/even series in
      // indices in branches; the layout engine uses this to select
      // angles, and if we don't do this, editing one part of a molecule
      // can cause another to flop around oddly.
      // TODO(colin): this should just start at 0 all the time, and the
      // layout engine should figure out continuity.
      inBranchIdx = 0;
    }

    const parenCtx = { ...newCtx,
      idx: newCtx.idx.concat([[inBranchIdx, 0]]),
      parens: newCtx.parens.concat("(")
    };
    const parenExpr = parse$2(rest, parenCtx);
    const remainder = parse$2(sliceFromMatchingCloseParen(rest, ["("]), newCtx);
    return [parenExpr].concat(remainder);
  }

  if (firstChar === ")") {
    if (ctx.parens[ctx.parens.length - 1] !== "(") {
      // $FlowFixMe[invalid-constructor]
      throw new ParseError$1("Mismatched parentheses");
    }

    return null;
  } // $FlowFixMe[invalid-constructor]


  throw new ParseError$1("Invalid bare character: " + firstChar);
}
/**
 * Get the symbol of the next atom in the molecule.
 *
 * Return a 2-element list containing that symbol and the remainder of the
 * molecule.
 */


function readAtomSymbol(smiles, _ctx) {
  let sym = null;
  let rest = null;

  if (smiles[0] === "[") {
    const closingIdx = smiles.indexOf("]");

    if (closingIdx === -1) {
      return ["", smiles];
    }

    sym = smiles.slice(1, closingIdx);
    rest = smiles.slice(closingIdx + 1);
  } else {
    const match = atomRe.exec(smiles); // $FlowFixMe[incompatible-use]: match can be null

    sym = match[1];
    rest = smiles.slice(sym.length);
  }

  return [sym, rest];
}
/**
 * Parse the next atom in the molecule, returning an atom object if this is the
 * first atom in the molecule, or a bond object with this atom as the
 * destination of the bond if this is not the first atom.
 */


function parseAtom(smiles, ctx) {
  const symbolInfo = readAtomSymbol(smiles);
  const atom = symbolInfo[0];

  if (atom === "") {
    return ["error", "Unable to parse bracketed atom."];
  }

  const rest = symbolInfo[1]; // Atoms are indexed by a list of two-element lists.  In each two-element
  // list, the first element is the atom counter, and the second element is
  // the branch counter.  Branches are 1-indexed so that the main chain of
  // the molecule can be indicated by 0.  Atoms may be either 0- or
  // 1-indexed, defaulting to 1, to maintain a alternating pattern of
  // odd/even indices. So, for example, if an atom has a branch off the main
  // chain, and its atom index is x, then the indices of atoms are:
  //     Atom where branch occurs: [[x, 0]]
  //     First atom in the branch: [[x, 1], [1, 0]]  (assuming x is even)
  //     Next atom in the main chain: [[x + 1, 0]]
  // increment the atom counter and reset the branch counter

  const newCtx = _mset(ctx, ["idx", ctx.idx.length - 1], [1 + ctx.idx[ctx.idx.length - 1][0], 0]);

  let restOfMolecule = parse$2(rest, _mset(newCtx, ["bond", "bondType"], "single"));

  if (!Array.isArray(restOfMolecule) && !!restOfMolecule) {
    //TODO(colin): fix this awkwardness.
    restOfMolecule = [restOfMolecule];
  }

  const atomObj = {
    type: "atom",
    symbol: atom,
    bonds: restOfMolecule,
    idx: newCtx.idx
  };

  if (ctx.bond) {
    return {
      type: "bond",
      bondType: ctx.bond.bondType,
      to: atomObj
    };
  }

  return atomObj;
}

function startsWithAtom(s) {
  return atomRe.test(s);
}

function isModifierChar(s) {
  return s === "=" || s === "#";
}
/**
 * Parse a SMILES string to an internal tree representation.
 *
 * Args:
 *   smiles [string]: a string representing the molecule.
 *
 * Returns: the parse tree (see top-of file docstring for details).
 *
 * Throws:
 *     ParseError: if the input is not valid SMILES or contains features not
 *         yet implemented.
 */


function parse$2(smiles, ctx) {
  if (!validate(smiles)) {
    // $FlowFixMe[invalid-constructor]
    throw new ParseError$1("Invalid input.");
  }

  if (!smiles || smiles.length === 0) {
    return null;
  }

  if (startsWithAtom(smiles)) {
    return parseAtom(smiles, ctx || {
      idx: [[0, 0]],
      parens: [],
      stack: [],
      bondModifiers: []
    });
  }

  if (isModifierChar(smiles[0])) {
    // TODO(colin): add a better error message in the case where the input
    // is invalid and starts with a modifier character?
    return parseBondModifier(smiles, ctx);
  } // TODO(colin): add additional cases for unimplemented bits of SMILES
  // syntax.


  return parseParenthesizedExpression(smiles, ctx);
}

var SmilesParser = {
  parse: parse$2,
  ParseError: ParseError$1
};

const {
  layout
} = MoleculeLayout;
const parse$1 = SmilesParser.parse;
const ParseError = SmilesParser.ParseError;
const borderSize = 30;
class Molecule extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      parsedSmiles: null,
      error: null
    });

    _defineProperty(this, "stateFromSmiles", smiles => {
      try {
        this.setState({
          parsedSmiles: parse$1(smiles),
          error: null
        });
      } catch (e) {
        if (e instanceof ParseError) {
          this.setState({
            error: e.message
          });
        } else {
          throw e;
        }
      }
    });

    _defineProperty(this, "setCanvasBounds", (canvas, items) => {
      const xmax = Math.max(...items.map(item => item.pos ? item.pos[0] : -Infinity));
      const ymax = Math.max(...items.map(item => item.pos ? item.pos[1] : -Infinity));
      const xmin = Math.min(...items.map(item => item.pos ? item.pos[0] : Infinity));
      const ymin = Math.min(...items.map(item => item.pos ? item.pos[1] : Infinity));
      const width = xmax - xmin + 2 * borderSize;
      const height = ymax - ymin + 2 * borderSize;
      canvas.width = width;
      canvas.height = height;
      return [borderSize - xmin, borderSize - ymin];
    });

    _defineProperty(this, "canvasRender", () => {
      // Since canvas drawing happens only through an imperative API, we sync
      // up the component with the canvas here, which happens when the
      // component mounts or updates.
      if (!!this.state.error || !this.state.parsedSmiles) {
        return;
      }

      const items = layout(this.state.parsedSmiles, this.props.rotationAngle); // eslint-disable-next-line react/no-string-refs

      const canvas = this.refs.canvas;
      const translation = this.setCanvasBounds(canvas, items);
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(translation[0], translation[1]);
      draw(ctx, items);
      ctx.restore();
    });
  }

  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount() {
    this.stateFromSmiles(this.props.smiles);
  }

  componentDidMount() {
    this.canvasRender();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    this.stateFromSmiles(nextProps.smiles);
  }

  componentDidUpdate() {
    this.canvasRender();
  }

  render() {
    // TODO(colin): escape the punctuation in the SMILES alt text for
    // screen readers?
    let content = /*#__PURE__*/React__namespace.createElement("canvas", {
      className: "molecule-canvas",
      id: this.props.id + "-molecule" // eslint-disable-next-line react/no-string-refs
      ,
      ref: "canvas"
    }, i18n__namespace.$_("A molecular structure drawing. SMILES notation: %(content)s", {
      content: this.props.smiles
    }));

    if (this.state.error) {
      content = /*#__PURE__*/React__namespace.createElement("div", {
        className: "error"
      }, this.state.error);
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "molecule-canvas"
    }, content);
  }

}

_defineProperty(Molecule, "propTypes", {
  id: PropTypes__default["default"].string.isRequired,
  rotationAngle: PropTypes__default["default"].number,
  smiles: PropTypes__default["default"].string
});

class MoleculeWidget extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "simpleValidate", () => {
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });

    _defineProperty(this, "getUserInput", () => {
      return [];
    });

    _defineProperty(this, "validate", (state, rubric) => {
      // TODO(colin): this is here as part of the interface for a component.
      // Figure out if there is something more appropriate that this should
      // return.
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement(Molecule, {
      id: this.props.widgetId,
      smiles: this.props.smiles,
      rotationAngle: this.props.rotationAngle
    });
  }

}

_defineProperty(MoleculeWidget, "propTypes", {
  rotationAngle: PropTypes__default["default"].number,
  smiles: PropTypes__default["default"].string,
  widgetId: PropTypes__default["default"].string
});

_defineProperty(MoleculeWidget, "defaultProps", {
  rotationAngle: 0
});

var Molecule$1 = {
  name: "molecule-renderer",
  displayName: "Molecule renderer",
  hidden: true,
  widget: MoleculeWidget
};

// $FlowFixMe[prop-missing]
const MovablePoint$1 = Graphie.MovablePoint; // $FlowFixMe[prop-missing]

const Line$1 = Graphie.Line;
const {
  assert: assert$3
} = InteractiveUtil;

const bound = (x, gt, lt) => Math.min(Math.max(x, gt), lt);

const EN_DASH = "\u2013";
const horizontalPadding = 30;
const reverseRel = {
  ge: "le",
  gt: "lt",
  le: "ge",
  lt: "gt"
};
const toggleStrictRel = {
  ge: "gt",
  gt: "ge",
  le: "lt",
  lt: "le"
};

function formatImproper(n, d) {
  if (d === 1) {
    return "" + n;
  }

  return "\\dfrac{".concat(n, "}{").concat(d, "}");
}

function formatMixed(n, d) {
  if (n < 0) {
    return "-" + formatMixed(-n, d);
  }

  const w = Math.floor(n / d);

  if (w === 0) {
    return formatImproper(n, d);
  }

  if (n - w * d === 0) {
    return "" + w;
  }

  return w + formatImproper(n - w * d, d);
}

function formatNonReduced(n, d, base) {
  const factor = Math.floor(base / d);
  return formatImproper(n * factor, base);
}

const _label = (graphie, labelStyle, pos, value, base) => {
  value = value || pos; // TODO(jack): Find out if any exercises have "decimal ticks" set,
  // and if so, re-save them and remove this check.

  if (labelStyle === "decimal" || labelStyle === "decimal ticks") {
    return graphie.label([pos, -0.53], Math.round(value * 100) / 100, "center");
  }

  if (labelStyle === "improper") {
    const frac = KhanMath.toFraction(value);
    return graphie.label([pos, -0.17], formatImproper(frac[0], frac[1]), "below");
  }

  if (labelStyle === "mixed") {
    const frac = KhanMath.toFraction(value);
    return graphie.label([pos, -0.17], formatMixed(frac[0], frac[1]), "below");
  }

  if (labelStyle === "non-reduced") {
    const frac = KhanMath.toFraction(value);
    return graphie.label([pos, -0.17], formatNonReduced(frac[0], frac[1], base), "below");
  }
}; // $FlowFixMe[prop-missing]


const TickMarks = Graphie.createSimpleClass((graphie, props) => {
  // Avoid infinite loop
  if (!___default["default"].isFinite(props.tickStep) || props.tickStep <= 0) {
    return []; // this has screwed me for the last time!
  }

  const results = []; // For convenience, extract some props into separate variables

  const range = props.range;
  const labelRange = props.labelRange;
  const leftLabel = labelRange[0] == null ? range[0] : labelRange[0];
  const rightLabel = labelRange[1] == null ? range[1] : labelRange[1]; // Find base via GCD for non-reduced fractions

  let base;

  if (props.labelStyle === "non-reduced") {
    const fractions = [leftLabel, rightLabel];

    for (let i = 0; i <= props.numDivisions; i++) {
      const x = range[0] + i * props.tickStep;
      fractions.push(x);
    }

    const getDenom = x => kmath.number.toFraction(x)[1];

    const denoms = ___default["default"].map(fractions, getDenom);

    base = ___default["default"].reduce(denoms, (x, y) => KhanMath.getLCM(x, y));
  } else {
    base = undefined;
  } // Draw and save the tick marks and tick labels


  for (let i = 0; i <= props.numDivisions; i++) {
    const x = range[0] + i * props.tickStep;
    results.push(graphie.line([x, -0.2], [x, 0.2]));
    const labelTicks = props.labelTicks;

    if (labelTicks || props.labelStyle === "decimal ticks") {
      // $FlowFixMe[incompatible-call]
      results.push(_label(graphie, props.labelStyle, x, x, base));
    }
  } // Render the text labels


  results.push(graphie.style(props.isMobile ? {
    color: KhanColors.BLUE_D
  } : {}, // $FlowFixMe[incompatible-call]
  () => _label(graphie, props.labelStyle, leftLabel, leftLabel, base)));
  results.push(graphie.style(props.isMobile ? {
    color: KhanColors.BLUE_D
  } : {}, () => // $FlowFixMe[incompatible-call]
  _label(graphie, props.labelStyle, rightLabel, rightLabel, base))); // Render the labels' lines

  graphie.style({
    stroke: props.isMobile ? KhanColors.BLUE_D : KhanColors.DYNAMIC,
    strokeWidth: 3.5
  }, () => {
    results.push(graphie.line([leftLabel, -0.2], [leftLabel, 0.2]));
    results.push(graphie.line([rightLabel, -0.2], [rightLabel, 0.2]));
  });
  return results;
});

class NumberLine extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "state", {
      numDivisionsEmpty: false
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "isValid", () => {
      const range = this.props.range;
      let initialX = this.props.numLinePosition;
      const divisionRange = this.props.divisionRange;
      initialX = initialX == null ? range[0] : initialX;
      return range[0] < range[1] && kmath.number.sign(initialX - range[0]) >= 0 && kmath.number.sign(initialX - range[1]) <= 0 && divisionRange[0] < divisionRange[1] && 0 < this.props.numDivisions && 0 < this.props.snapDivisions;
    });

    _defineProperty(this, "onNumDivisionsChange", (numDivisions, cb) => {
      const divRange = this.props.divisionRange.slice();
      const width = this.props.range[1] - this.props.range[0]; // Don't allow a fraction for the number of divisions

      numDivisions = Math.round(numDivisions); // Don't allow negative numbers for the number of divisions

      numDivisions = numDivisions < 0 ? numDivisions * -1 : numDivisions; // If the number of divisions isn't blank, update the number line

      if (numDivisions) {
        const nextProps = ___default["default"].extend({}, this.props, {
          tickStep: width / numDivisions
        });

        const newNumLinePosition = this.snapNumLinePosition(nextProps, this.props.numLinePosition);
        this.setState({
          numDivisionsEmpty: false
        }, () => {
          this.props.onChange({
            divisionRange: divRange,
            numDivisions: numDivisions,
            numLinePosition: newNumLinePosition
          }, cb);
        });
      } else {
        this.setState({
          numDivisionsEmpty: true
        }, cb);
      }
    });

    _defineProperty(this, "_handleTickCtrlFocus", () => {
      this.props.onFocus(["tick-ctrl"]);
    });

    _defineProperty(this, "_handleTickCtrlBlur", () => {
      this.props.onBlur(["tick-ctrl"]);
    });

    _defineProperty(this, "focus", () => {
      if (this.props.isTickCtrl) {
        // eslint-disable-next-line react/no-string-refs
        this.refs["tick-ctrl"].focus();
        return true;
      }
    });

    _defineProperty(this, "focusInputPath", path => {
      if (path.length === 1) {
        // eslint-disable-next-line react/no-string-refs
        this.refs[path[0]].focus();
      }
    });

    _defineProperty(this, "blurInputPath", path => {
      if (path.length === 1) {
        // eslint-disable-next-line react/no-string-refs
        this.refs[path[0]].blur();
      }
    });

    _defineProperty(this, "getInputPaths", () => {
      if (this.props.isTickCtrl) {
        return [["tick-ctrl"]];
      }

      return [];
    });

    _defineProperty(this, "getDOMNodeForPath", inputPath => {
      if (inputPath.length === 1) {
        // eslint-disable-next-line react/no-string-refs
        return ReactDOM__default["default"].findDOMNode(this.refs[inputPath[0]]);
      }
    });

    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      if (inputPath.length === 1 && inputPath[0] === "tick-ctrl") {
        return "number";
      }
    });

    _defineProperty(this, "setInputValue", (inputPath, value, callback) => {
      if (inputPath.length === 1 && inputPath[0] === "tick-ctrl") {
        this.onNumDivisionsChange(value, callback);
      }
    });

    _defineProperty(this, "_renderGraphie", () => {
      // Position variables
      const range = this.props.range;
      const width = range[1] - range[0];

      const options = ___default["default"].pick(this.props, ["range", "isTickCtrl"]); // TODO(aria): Maybe save this as `this.calculatedProps`?


      const props = ___default["default"].extend({}, this.props, {
        tickStep: width / this.props.numDivisions
      });

      return /*#__PURE__*/React__namespace.createElement(Graphie // eslint-disable-next-line react/no-string-refs
      , {
        ref: "graphie" // HACK(emily): We key this graphie on the label style because
        // when the label style changes we want to resize the graphie,
        // which isn't doable without throwing away the graphie and
        // making a new one.
        ,
        key: this.props.labelStyle,
        box: [this.props.apiOptions.isMobile ? 288 : 460, 80],
        options: options,
        onMouseDown: coord => {
          // eslint-disable-next-line react/no-string-refs
          this.refs.graphie.movables.numberLinePoint.grab(coord);
        },
        setup: this._setupGraphie,
        setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable,
        isMobile: this.props.apiOptions.isMobile
      }, /*#__PURE__*/React__namespace.createElement(TickMarks, _extends$1({}, ___default["default"].pick(props, ["range", "numDivisions", "labelTicks", "labelStyle", "labelRange", "tickStep"]), {
        isMobile: this.props.apiOptions.isMobile
      })), this._renderInequality(props), this._renderNumberLinePoint(props));
    });

    _defineProperty(this, "snapNumLinePosition", (props, numLinePosition) => {
      const left = props.range[0];
      const right = props.range[1];
      const snapX = props.tickStep / props.snapDivisions;
      let x = bound(numLinePosition, left, right);
      x = left + kmath.number.roundTo(x - left, snapX);
      assert$3(___default["default"].isFinite(x));
      return x;
    });

    _defineProperty(this, "movePosition", targetPosition => {
      this.change({
        numLinePosition: targetPosition
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "_renderNumberLinePoint", props => {
      const isOpen = ___default["default"](["lt", "gt"]).contains(props.rel); // In static mode the point's fill and stroke is blue to signify that
      // it can't be interacted with.


      let fill;

      if (isOpen) {
        fill = KhanColors._BACKGROUND;
      } else if (props.static) {
        fill = KhanColors.DYNAMIC;
      } else {
        fill = KhanColors.INTERACTIVE;
      }

      const normalStyle = {
        fill: fill,
        stroke: props.static ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE,
        "stroke-width": isOpen ? 3 : 1
      };
      const highlightStyle = {
        fill: isOpen ? KhanColors._BACKGROUND : KhanColors.INTERACTING,
        "stroke-width": isOpen ? 3 : 1
      };
      const mobileDotStyle = props.isInequality ? {
        stroke: KhanColors.INTERACTIVE,
        "fill-opacity": isOpen ? 0 : 1
      } : {};
      return /*#__PURE__*/React__namespace.createElement(MovablePoint$1 // eslint-disable-next-line react/no-string-refs
      , {
        ref: "numberLinePoint",
        pointSize: 6,
        coord: [props.numLinePosition, 0],
        constraints: [(coord, prevCoord) => {
          // constrain-y
          return [coord[0], prevCoord[1]];
        }, (coord, prevCoord) => {
          // snap X
          const x = this.snapNumLinePosition(props, coord[0]);
          return [x, coord[1]];
        }],
        normalStyle: normalStyle,
        highlightStyle: highlightStyle,
        onMove: coord => {
          this.movePosition(coord[0]);
        },
        isMobile: this.props.apiOptions.isMobile,
        mobileStyleOverride: mobileDotStyle,
        showTooltips: this.props.showTooltips,
        xOnlyTooltip: true
      });
    });

    _defineProperty(this, "handleReverse", () => {
      const newRel = reverseRel[this.props.rel];
      this.props.onChange({
        rel: newRel
      });
    });

    _defineProperty(this, "handleToggleStrict", () => {
      const newRel = toggleStrictRel[this.props.rel];
      this.props.onChange({
        rel: newRel
      });
    });

    _defineProperty(this, "_getInequalityEndpoint", props => {
      const isGreater = ___default["default"](["ge", "gt"]).contains(props.rel);

      const widthInPixels = 400;
      const range = props.range;
      const scale = (range[1] - range[0]) / widthInPixels;
      const buffer = horizontalPadding * scale;
      const left = range[0] - buffer;
      const right = range[1] + buffer;
      const end = isGreater ? [right, 0] : [left, 0];
      return end;
    });

    _defineProperty(this, "_renderInequality", props => {
      if (props.isInequality) {
        const end = this._getInequalityEndpoint(props);

        const style = {
          arrows: "->",
          stroke: this.props.apiOptions.isMobile ? KhanColors.INTERACTIVE : KhanColors.DYNAMIC,
          strokeWidth: 3.5
        };
        const isGreater = ["ge", "gt"].includes(props.rel);
        return /*#__PURE__*/React__namespace.createElement(Line$1 // We shift the line to either side of the dot so they don't
        // intersect
        , {
          start: [(isGreater ? 0.4 : -0.4) + props.numLinePosition, 0],
          end: end,
          style: style
        });
      }

      return null;
    });

    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      // Ensure a sane configuration to avoid infinite loops
      if (!this.isValid()) {
        return;
      } // Position variables


      const widthInPixels = this.props.apiOptions.isMobile ? 288 - horizontalPadding * 2 : 400;
      const range = options.range;
      const scale = (range[1] - range[0]) / widthInPixels;
      const buffer = horizontalPadding * scale; // Initiate the graphie without actually drawing anything

      const left = range[0] - buffer;
      const right = range[1] + buffer;
      const hasFractionalLabels = this.props.labelStyle === "improper" || this.props.labelStyle === "mixed" || this.props.labelStyle === "non-reduced";
      const bottom = hasFractionalLabels ? -1.5 : -1;
      const top = 1;
      graphie.init({
        range: [[left, right], [bottom, top]],
        scale: [1 / scale, 40],
        isMobile: this.props.apiOptions.isMobile
      }); // Draw the number line

      const center = (range[0] + range[1]) / 2;
      graphie.line([center, 0], [right, 0], {
        arrows: "->"
      });
      graphie.line([center, 0], [left, 0], {
        arrows: "->"
      });
    });

    _defineProperty(this, "getUserInput", () => {
      return {
        numLinePosition: this.props.numLinePosition,
        rel: this.props.isInequality ? this.props.rel : "eq",
        numDivisions: this.props.numDivisions,
        divisionRange: this.props.divisionRange
      };
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return NumberLine.validate(this.getUserInput(), rubric);
    });
  }

  render() {
    const divisionRange = this.props.divisionRange;
    const divRangeString = divisionRange[0] + EN_DASH + divisionRange[1];
    const invalidNumDivisions = this.props.numDivisions < divisionRange[0] || this.props.numDivisions > divisionRange[1];
    const inequalityControls = /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("input", {
      type: "button",
      className: "simple-button",
      value: i18n__namespace._("Switch direction"),
      onClick: this.handleReverse
    }), /*#__PURE__*/React__namespace.createElement("input", {
      type: "button",
      className: "simple-button",
      value: ___default["default"](["le", "ge"]).contains(this.props.rel) ? i18n__namespace._("Make circle open") : i18n__namespace._("Make circle filled"),
      onClick: this.handleToggleStrict
    }));
    let tickCtrl;

    if (this.props.isTickCtrl) {
      let Input;

      if (this.props.apiOptions.customKeypad) {
        Input = SimpleKeypadInput;
      } else if (this.props.apiOptions.staticRender) {
        Input = MathOutput;
      } else {
        Input = NumberInput;
      }

      tickCtrl = /*#__PURE__*/React__namespace.createElement("label", null, i18n__namespace._("Number of divisions:"), " ", /*#__PURE__*/React__namespace.createElement(Input // eslint-disable-next-line react/no-string-refs
      , {
        ref: "tick-ctrl",
        value: this.state.numDivisionsEmpty ? null : this.props.numDivisions || divisionRange[0],
        checkValidity: val => val >= divisionRange[0] && val <= divisionRange[1],
        onChange: this.onNumDivisionsChange,
        onFocus: this._handleTickCtrlFocus,
        onBlur: this._handleTickCtrlBlur,
        useArrowKeys: true,
        keypadElement: this.props.keypadElement
      }));
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-interactive-number-line"
    }, tickCtrl, !this.isValid() ? /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-error"
    }, i18n__namespace.doNotTranslate("Invalid number line configuration.")) : this.props.isTickCtrl && invalidNumDivisions ? /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-error"
    }, i18n__namespace.$_("Please make sure the number of divisions is " + "in the range %(divRangeString)s.", {
      divRangeString: divRangeString
    })) : this._renderGraphie(), !this.props.static && this.props.isInequality && inequalityControls);
  }

}

_defineProperty(NumberLine, "defaultProps", {
  range: [0, 10],
  labelStyle: "decimal",
  labelRange: [null, null],
  divisionRange: [1, 12],
  labelTicks: true,
  isTickCtrl: false,
  isInequality: false,
  numLinePosition: 0,
  snapDivisions: 2,
  showTooltips: false,
  rel: "ge",
  apiOptions: ApiOptions.defaults
});

___default["default"].extend(NumberLine, {
  validate: function (state, rubric) {
    const range = rubric.range;
    const divisionRange = state.divisionRange;
    const start = rubric.initialX != null ? rubric.initialX : range[0];
    const startRel = rubric.isInequality ? "ge" : "eq";
    const correctRel = rubric.correctRel || "eq";
    const correctPos = kmath.number.equal(state.numLinePosition, rubric.correctX || 0);
    const outsideAllowedRange = state.numDivisions > divisionRange[1] || state.numDivisions < divisionRange[0];

    if (state.isTickCrtl && outsideAllowedRange) {
      return {
        type: "invalid",
        message: "Number of divisions is outside the allowed range."
      };
    }

    if (correctPos && correctRel === state.rel) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    }

    if (state.numLinePosition === start && state.rel === startRel) {
      // We're where we started.
      return {
        type: "invalid",
        message: null
      };
    }

    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }
});

const numberLineTransform = editorProps => {
  const props = ___default["default"].pick(editorProps, ["range", "labelRange", "labelStyle", "labelTicks", "divisionRange", "snapDivisions", "isTickCtrl", "isInequality", "showTooltips"]);

  const numLinePosition = editorProps.initialX != null ? editorProps.initialX : editorProps.range[0];
  const width = editorProps.range[1] - editorProps.range[0];
  let numDivisions;

  if (editorProps.numDivisions != null) {
    numDivisions = editorProps.numDivisions;
  } else if (editorProps.tickStep != null) {
    numDivisions = width / editorProps.tickStep;
  } else {
    numDivisions = undefined; // send to getDefaultProps()
  }

  ___default["default"].extend(props, {
    numLinePosition: numLinePosition,
    numDivisions: numDivisions,
    // Use getDefaultProps value if null
    snapDivisions: props.snapDivisions || undefined
  });

  return props;
};

const staticTransform$1 = editorProps => {
  const props = ___default["default"].pick(editorProps, ["range", "labelRange", "labelStyle", "labelTicks", "divisionRange", "snapDivisions", // isTickCtrl is ignored since users can't interact with it anyway
  "isInequality"]); // The correct x is the initial position of the point


  const numLinePosition = editorProps.correctX != null ? editorProps.correctX : editorProps.range[0];
  const width = editorProps.range[1] - editorProps.range[0];
  let numDivisions;

  if (editorProps.numDivisions != null) {
    numDivisions = editorProps.numDivisions;
  } else if (editorProps.tickStep != null) {
    numDivisions = width / editorProps.tickStep;
  } else {
    numDivisions = undefined; // send to getDefaultProps()
  }

  ___default["default"].extend(props, {
    numLinePosition: numLinePosition,
    numDivisions: numDivisions,
    // Render the relation in the correct answer
    rel: editorProps.isInequality ? editorProps.correctRel : null,
    // Use getDefaultProps value if null
    snapDivisions: props.snapDivisions || undefined
  });

  return props;
};

var NumberLine$1 = {
  name: "number-line",
  displayName: "Number line",
  widget: NumberLine,
  transform: numberLineTransform,
  staticTransform: staticTransform$1
};

class PlaceholderCard extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "card-wrap " + ClassNames.INTERACTIVE,
      style: {
        width: this.props.width
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "card placeholder",
      style: {
        height: this.props.height
      }
    }));
  }

}

_defineProperty(PlaceholderCard, "propTypes", {
  width: PropTypes__default["default"].number.isRequired,
  height: PropTypes__default["default"].number.isRequired
});

class DragHintCard extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "card-wrap " + ClassNames.INTERACTIVE
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "card drag-hint"
    }));
  }

}

const PropTypePosition = PropTypes__default["default"].shape({
  left: PropTypes__default["default"].number,
  top: PropTypes__default["default"].number
});

class Card extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "mouseMoveUpBound", void 0);

    _defineProperty(this, "state", {
      dragging: false
    });

    _defineProperty(this, "bindMouseMoveUp", () => {
      this.mouseMoveUpBound = true;
      $__default["default"](document).on("mousemove", this.onMouseMove);
      $__default["default"](document).on("mouseup", this.onMouseUp);
    });

    _defineProperty(this, "unbindMouseMoveUp", () => {
      this.mouseMoveUpBound = false;
      $__default["default"](document).off("mousemove", this.onMouseMove);
      $__default["default"](document).off("mouseup", this.onMouseUp);
    });

    _defineProperty(this, "onMouseDown", event => {
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);

      if (loc) {
        this.setState({
          dragging: true
        });
        this.bindMouseMoveUp();
        this.props.onMouseDown && this.props.onMouseDown(loc, this);
      }
    });

    _defineProperty(this, "onMouseMove", event => {
      if (!this.state.dragging) {
        return;
      }

      event.preventDefault();
      const loc = Util.extractPointerLocation(event);

      if (loc) {
        this.props.onMouseMove && this.props.onMouseMove(loc);
      }
    });

    _defineProperty(this, "onMouseUp", event => {
      event.preventDefault();
      const loc = Util.extractPointerLocation(event);

      if (loc) {
        this.setState({
          dragging: false
        });
        this.unbindMouseMoveUp();
        this.props.onMouseUp && this.props.onMouseUp(loc);
      }
    });
  }

  render() {
    let style = {};

    if (this.props.floating) {
      style = {
        position: "absolute",
        left: this.props.startOffset.left,
        top: this.props.startOffset.top
      };
    }

    if (this.props.width) {
      // $FlowFixMe[prop-missing]
      style.minWidth = this.props.width;
    }

    const className = ["card"];

    if (this.props.stack) {
      className.push("stack");
    }

    if (this.props.floating && !this.props.animating) {
      className.push("dragging");
      style.left += this.props.mouse.left - this.props.startMouse.left;
      style.top += this.props.mouse.top - this.props.startMouse.top;
    } // Pull out the content to get rendered


    const rendererProps = ___default["default"].pick(this.props, "content");

    const onMouseDown = this.props.animating ? $__default["default"].noop : this.onMouseDown;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "card-wrap " + ClassNames.INTERACTIVE,
      style: style,
      onMouseDown: onMouseDown,
      onTouchStart: onMouseDown,
      onTouchEnd: this.onMouseUp,
      onTouchCancel: this.onMouseUp
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: className.join(" ")
    }, /*#__PURE__*/React__namespace.createElement(Renderer, _extends$1({}, rendererProps, {
      linterContext: this.props.linterContext
    }))));
  }

  shouldComponentUpdate(nextProps, nextState) {
    // Cards in the bank or drag list don't usually change -- they only
    // reorder themselves -- so we want to skip the update to things a
    // little faster. We also need to re-render if the content changes,
    // which happens only in the editor. (We do want to update the floating
    // card on mouse move to update its position.)
    return this.props.floating || nextProps.floating || this.props.content !== nextProps.content || // TODO(alpert): Remove ref here after fixing facebook/react#1392.
    this.props.fakeRef !== nextProps.fakeRef;
  }

  componentDidMount() {
    this.mouseMoveUpBound = false; // On touch devices, we set up our own touchmove handler because React
    // all event subscriptions using `OnTouchMove` props are non-passive.
    // See: https://github.com/facebook/react/issues/6436
    // Also, we can't subscribe to `ontouchmove`  within the `ontouchstart`
    // handler because of a WebKit bug:
    // https://github.com/atlassian/react-beautiful-dnd/issues/413 and
    // https://bugs.webkit.org/show_bug.cgi?id=184250

    document.addEventListener("touchmove", this.onMouseMove, // Not all browsers support passive events, and when they don't
    // this third paramter is just a boolean. If we pass the "options"
    // object, it's interpreted as `capture=true` (which we don't want!)
    Util.supportsPassiveEvents() ? {
      passive: false
    } : false);
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.animating && !prevProps.animating) {
      // If we just were changed into animating, start the animation.
      // We pick the animation speed based on the distance that the card
      // needs to travel. (Why sqrt? Just because it looks nice -- with a
      // linear scale, far things take too long to come back.)
      const ms = 15 * Math.sqrt(Math.sqrt(Math.pow(this.props.animateTo.left - this.props.startOffset.left, 2) + Math.pow(this.props.animateTo.top - this.props.startOffset.top, 2)));
      $__default["default"](ReactDOM__default["default"].findDOMNode(this)).animate(this.props.animateTo, Math.max(ms, 1), this.props.onAnimationEnd);
    }
  }

  componentWillUnmount() {
    // Event handlers should be unbound before component unmounting, but
    // just in case...
    if (this.mouseMoveUpBound) {
      Log.error("Removing an element with bound event handlers.", Errors.Internal);
      this.unbindMouseMoveUp();
      Util.resetTouchHandlers();
    }

    document.removeEventListener("touchmove", this.onMouseMove);
  }

}

_defineProperty(Card, "propTypes", {
  floating: PropTypes__default["default"].bool.isRequired,
  animating: PropTypes__default["default"].bool,
  width: PropTypes__default["default"].number,
  stack: PropTypes__default["default"].bool,
  onMouseDown: PropTypes__default["default"].func,
  onMouseMove: PropTypes__default["default"].func,
  onMouseUp: PropTypes__default["default"].func,
  // Used only for floating/animating cards
  startMouse: PropTypePosition,
  startOffset: PropTypePosition,
  animateTo: PropTypePosition,
  onAnimationEnd: PropTypes__default["default"].func,
  linterContext: PerseusLinter.linterContextProps
});

_defineProperty(Card, "defaultProps", {
  stack: false,
  animating: false,
  linterContext: PerseusLinter.linterContextDefault
});

const NORMAL = "normal",
      HORIZONTAL$1 = "horizontal";

class Orderer extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      current: [],
      dragging: false,
      placeholderIndex: null,
      dragKey: null,
      animating: false,
      dragContent: null,
      dragWidth: null,
      dragHeight: null,
      offsetPos: null,
      animateTo: null,
      grabPos: null
    });

    _defineProperty(this, "onClick", (type, index, loc, draggable) => {
      const $draggable = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable));
      const list = this.state.current.slice();
      let opt;
      let placeholderIndex = null;

      if (type === "current") {
        // If this is coming from the original list, remove the original
        // card from the list
        list.splice(index, 1);
        opt = this.state.current[index];
        placeholderIndex = index;
      } else if (type === "bank") {
        opt = this.props.options[index];
      }

      this.setState({
        current: list,
        dragging: true,
        placeholderIndex: placeholderIndex,
        // $FlowFixMe[prop-missing]
        // $FlowFixMe[incompatible-use]
        dragKey: opt.key,
        // $FlowFixMe[incompatible-use]
        dragContent: opt.content,
        dragWidth: $draggable.width(),
        dragHeight: $draggable.height(),
        grabPos: loc,
        mousePos: loc,
        offsetPos: $draggable.position()
      });
    });

    _defineProperty(this, "onRelease", loc => {
      // eslint-disable-next-line react/no-string-refs
      const draggable = this.refs.dragging;

      if (draggable == null) {
        return;
      }

      const inCardBank = this.isCardInBank(draggable);
      const index = this.state.placeholderIndex || 0; // Here, we build a callback function for the card to call when it is
      // done animating

      const onAnimationEnd = () => {
        const list = this.state.current.slice();

        if (!inCardBank) {
          // Insert the new card into the position
          const newCard = {
            content: this.state.dragContent,
            key: ___default["default"].uniqueId("perseus_draggable_card_"),
            width: this.state.dragWidth
          };
          list.splice(index, 0, newCard);
        } // $FlowFixMe[prop-missing]


        this.props.onChange({
          current: list
        });
        this.setState({
          current: list,
          dragging: false,
          placeholderIndex: null,
          animating: false
        });
        this.props.trackInteraction();
      }; // Find the position of the card we should animate to
      // TODO(alpert): Update mouse position once more before animating?


      const offset = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)).position();
      let finalOffset = null;

      if (inCardBank) {
        // If we're in the card bank, go through the options to find the
        // one with the same content
        ___default["default"].each(this.props.options, function (opt, i) {
          if (opt.content === this.state.dragContent) {
            const card = ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
            this.refs["bank" + i]);
            finalOffset = $__default["default"](card).position();
          }
        }, this); // eslint-disable-next-line react/no-string-refs

      } else if (this.refs.placeholder != null) {
        // Otherwise, go to the position that the placeholder is at
        finalOffset = $__default["default"]( // eslint-disable-next-line react/no-string-refs
        ReactDOM__default["default"].findDOMNode(this.refs.placeholder)).position();
      }

      if (finalOffset == null) {
        // If we didn't find a card to go to, simply make the changes we
        // would have made at the end. (should only happen if we are
        // messing around with card contents, and not on the real site)
        onAnimationEnd();
      } else {
        this.setState({
          offsetPos: offset,
          animateTo: finalOffset,
          onAnimationEnd: onAnimationEnd,
          animating: true,
          dragging: false
        });
      }
    });

    _defineProperty(this, "onMouseMove", loc => {
      // eslint-disable-next-line react/no-string-refs
      const draggable = this.refs.dragging;

      if (draggable == null) {
        return;
      }

      let index;

      if (this.isCardInBank(draggable)) {
        index = null;
      } else {
        index = this.findCorrectIndex(draggable, this.state.current);
      }

      this.setState({
        mousePos: loc,
        placeholderIndex: index
      });
    });

    _defineProperty(this, "findCorrectIndex", (draggable, list) => {
      // Find the correct index for a card given the current cards.
      const isHorizontal = this.props.layout === HORIZONTAL$1; // eslint-disable-next-line react/no-string-refs

      const $dragList = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.dragList));
      const leftEdge = $dragList.offset().left;
      const topEdge = $dragList.offset().top;
      const midWidth = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)).offset().left - leftEdge;
      const midHeight = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)).offset().top - topEdge;
      let index = 0;
      let sumWidth = 0;
      let sumHeight = 0;

      if (isHorizontal) {
        ___default["default"].each(list, function (opt, i) {
          const card = ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
          this.refs["sortable" + i]);
          const outerWidth = $__default["default"](card).outerWidth(true);

          if (midWidth > sumWidth + outerWidth / 2) {
            index += 1;
          }

          sumWidth += outerWidth;
        }, this);
      } else {
        ___default["default"].each(list, function (opt, i) {
          const card = ReactDOM__default["default"].findDOMNode( // eslint-disable-next-line react/no-string-refs
          this.refs["sortable" + i]);
          const outerHeight = $__default["default"](card).outerHeight(true);

          if (midHeight > sumHeight + outerHeight / 2) {
            index += 1;
          }

          sumHeight += outerHeight;
        }, this);
      }

      return index;
    });

    _defineProperty(this, "isCardInBank", draggable => {
      if (draggable == null) {
        return false;
      }

      const isHorizontal = this.props.layout === HORIZONTAL$1,
            $draggable = $__default["default"](ReactDOM__default["default"].findDOMNode(draggable)),
            // eslint-disable-next-line react/no-string-refs
      $bank = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.bank)),
            draggableOffset = $draggable.offset(),
            bankOffset = $bank.offset(),
            draggableHeight = $draggable.outerHeight(true),
            bankHeight = $bank.outerHeight(true),
            bankWidth = $bank.outerWidth(true),
            // eslint-disable-next-line react/no-string-refs
      dragList = ReactDOM__default["default"].findDOMNode(this.refs.dragList);
            $__default["default"](dragList).width();
            const draggableWidth = $draggable.outerWidth(true);

      if (isHorizontal) {
        return draggableOffset.top + draggableHeight / 2 < bankOffset.top + bankHeight;
      }

      return draggableOffset.left + draggableWidth / 2 < bankOffset.left + bankWidth;
    });

    _defineProperty(this, "setListValues", values => {
      const list = values.map(value => {
        return {
          content: value
        };
      }); // $FlowFixMe[prop-missing]

      this.props.onChange({
        current: list
      });
      this.setState({
        current: list
      });
    });

    _defineProperty(this, "getUserInput", () => {
      return {
        current: ___default["default"].map(this.props.current, function (v) {
          return v.content;
        })
      };
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return Orderer.validate(this.getUserInput(), rubric);
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (!___default["default"].isEqual(this.props.current, nextProps.current)) {
      this.setState({
        current: nextProps.current
      });
    }
  }

  render() {
    // This is the card we are currently dragging
    const dragging = this.state.dragging && /*#__PURE__*/React__namespace.createElement(Card // eslint-disable-next-line react/no-string-refs
    , {
      ref: "dragging",
      floating: true,
      content: this.state.dragContent,
      startOffset: this.state.offsetPos,
      startMouse: this.state.grabPos,
      mouse: this.state.mousePos,
      width: this.state.dragWidth,
      onMouseUp: this.onRelease,
      onMouseMove: this.onMouseMove,
      key: this.state.dragKey || "draggingCard",
      linterContext: this.props.linterContext
    }); // This is the card that is currently animating

    const animating = this.state.animating && /*#__PURE__*/React__namespace.createElement(Card, {
      floating: true,
      animating: true,
      content: this.state.dragContent,
      startOffset: this.state.offsetPos,
      width: this.state.dragWidth,
      animateTo: this.state.animateTo,
      onAnimationEnd: this.state.onAnimationEnd,
      key: this.state.dragKey || "draggingCard",
      linterContext: this.props.linterContext
    }); // This is the list of draggable, rearrangable cards

    const sortableCards = ___default["default"].map(this.state.current, function (opt, i) {
      return /*#__PURE__*/React__namespace.createElement(Card, {
        key: "sortableCard".concat(i),
        ref: "sortable" + i,
        fakeRef: "sortable" + i,
        floating: false,
        content: opt.content,
        width: opt.width,
        linterContext: this.props.linterContext // eslint-disable-next-line react/jsx-no-bind
        ,
        onMouseDown: this.state.animating ? $__default["default"].noop : this.onClick.bind(null, "current", i)
      });
    }, this);

    if (this.state.placeholderIndex != null) {
      const placeholder = /*#__PURE__*/React__namespace.createElement(PlaceholderCard // eslint-disable-next-line react/no-string-refs
      , {
        ref: "placeholder",
        width: this.state.dragWidth,
        height: this.state.dragHeight,
        key: "placeholder"
      });
      sortableCards.splice(this.state.placeholderIndex, 0, placeholder);
    }

    const anySortableCards = sortableCards.length > 0;
    sortableCards.push(dragging, animating); // If there are no cards in the list, then add a "hint" card

    const sortable = /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-clearfix draggable-box"
    }, !anySortableCards && /*#__PURE__*/React__namespace.createElement(DragHintCard, null), /*#__PURE__*/React__namespace.createElement("div", {
      ref: "dragList"
    }, sortableCards)); // This is the bank of stacks of cards

    const bank =
    /*#__PURE__*/
    // eslint-disable-next-line react/no-string-refs
    React__namespace.createElement("div", {
      ref: "bank",
      className: "bank perseus-clearfix"
    }, ___default["default"].map(this.props.options, (opt, i) => {
      return /*#__PURE__*/React__namespace.createElement(Card, {
        ref: "bank" + i,
        floating: false,
        content: opt.content,
        stack: true,
        key: i,
        linterContext: this.props.linterContext // eslint-disable-next-line react/jsx-no-bind
        ,
        onMouseDown: this.state.animating ? $__default["default"].noop : this.onClick.bind(null, "bank", i),
        onMouseMove: this.onMouseMove,
        onMouseUp: this.onRelease
      });
    }, this));
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "draggy-boxy-thing orderer " + "height-" + this.props.height + " " + "layout-" + this.props.layout + " " + "above-scratchpad blank-background " + "perseus-clearfix " + ClassNames.INTERACTIVE // eslint-disable-next-line react/no-string-refs
      ,
      ref: "orderer"
    }, bank, sortable);
  }

}

_defineProperty(Orderer, "defaultProps", {
  current: [],
  options: [],
  correctOptions: [],
  height: NORMAL,
  layout: HORIZONTAL$1,
  linterContext: PerseusLinter.linterContextDefault
});

___default["default"].extend(Orderer, {
  validate: function (state, rubric) {
    if (state.current.length === 0) {
      return {
        type: "invalid",
        message: null
      };
    }

    const correct = ___default["default"].isEqual(state.current, ___default["default"].pluck(rubric.correctOptions, "content"));

    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }
});

var Orderer$1 = {
  name: "orderer",
  displayName: "Orderer",
  widget: Orderer,
  isLintable: true
};

class PassageRefTarget extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "getUserInput", () => {
      return WidgetJsonifyDeprecated.getUserInput.call(this);
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return PassageRefTarget.validate(this.getUserInput(), rubric);
    });
  }

  static validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }

  render() {
    return (
      /*#__PURE__*/
      // $FlowFixMe[prop-missing]: inline doesn't exist in Renderer's declared props
      React__namespace.createElement(Renderer, {
        content: this.props.content,
        inline: true,
        apiOptions: this.props.apiOptions,
        linterContext: this.props.linterContext
      })
    );
  }

}

_defineProperty(PassageRefTarget, "propTypes", { ...propTypes,
  content: PropTypes__default["default"].string,
  linterContext: PerseusLinter.linterContextProps
});

_defineProperty(PassageRefTarget, "defaultProps", {
  content: "",
  linterContext: PerseusLinter.linterContextDefault
});

var PassageRefTarget$1 = {
  name: "passage-ref-target",
  displayName: "PassageRefTarget",
  defaultAlignment: "inline",
  widget: PassageRefTarget,
  hidden: true,
  transform: editorProps => {
    return ___default["default"].pick(editorProps, "content");
  },
  version: {
    major: 0,
    minor: 0
  },
  isLintable: true
};

/**
 * Utility functions for manipulating ranges of highlightable content.
 */

/**
 * Given two DOMRange objects, and a choice of start/end point for each, compare
 * the two chosen points. Return -1 if a's comes first in the document, return
 * 1 if b's comes first in the document, or 0 if they represent the same point
 * in the document.
 *
 * NOTE(mdr): This function exists primarily to cover over some confusing parts
 *     of the DOM's `compareBoundaryPoints` API, and to cover over a Flow bug
 *     documented here: https://github.com/facebook/flow/issues/3734.
 */
function compareRangeBoundaryPoints(a, whichA, b, whichB) {
  let mode;

  if (whichA === "start" && whichB === "start") {
    mode = Range.START_TO_START;
  } else if (whichA === "start" && whichB === "end") {
    // NOTE(mdr): Confusingly, the correct constant here is actually
    //     `END_TO_START`, which is the reverse of what you'd expect.
    mode = Range.END_TO_START;
  } else if (whichA === "end" && whichB === "start") {
    // NOTE(mdr): Confusingly, the correct constant here is actually
    //     `START_TO_END`, which is the reverse of what you'd expect.
    mode = Range.START_TO_END;
  } else {
    mode = Range.END_TO_END;
  }

  return a.compareBoundaryPoints(mode, b);
}
/**
 * Given two DOMRanges, return a DOMRange whose start point comes from A, and
 * whose end point comes from B.
 */


function spanRanges(a, b) {
  const range = a.cloneRange();
  range.setEnd(b.endContainer, b.endOffset);
  return range;
}
/**
 * Given two DOMRanges, return whether they overlap.
 *
 * We here treat ranges like closed intervals: the boundary points are
 * considered to be included in the range, and, if a ends exactly where b
 * starts, they are considered to overlap.
 */

function rangesOverlap(a, b) {
  // Two ranges do *not* overlap iff one ends before the other begins.
  const rangesDoNotOverlap = compareRangeBoundaryPoints(a, "end", b, "start") < 0 || compareRangeBoundaryPoints(b, "end", a, "start") < 0;
  return !rangesDoNotOverlap;
}
/**
 * Given two DOMRanges, return whether the first includes the second: whether
 * all points that B contains are also contained by A.
 */

function rangeIncludes(a, b) {
  const rangeIsIncluded = compareRangeBoundaryPoints(a, "start", b, "start") <= 0 && compareRangeBoundaryPoints(a, "end", b, "end") >= 0;
  return rangeIsIncluded;
}
/**
 * Given two DOMRanges, intersect them: return a range that contains all points
 * that both A contains and B contains, and contains no other points.
 *
 * If A and B do not overlap, no intersection exists; return null.
 */

function intersectRanges(a, b) {
  if (!rangesOverlap(a, b)) {
    return null;
  } // Find the range with the latest start point, and the range with the
  // earliest end point.


  const starter = compareRangeBoundaryPoints(a, "start", b, "start") > 0 ? a : b;
  const ender = compareRangeBoundaryPoints(a, "end", b, "end") < 0 ? a : b;
  return spanRanges(starter, ender);
}
/**
 * Given two DOMRanges, union them: return a range that contains all points
 * that either A contains or B contains, and contains no other points.
 *
 * If A and B do not overlap, no union exists; return null.
 */

function unionRanges(a, b) {
  if (!rangesOverlap(a, b)) {
    return null;
  } // Find the range with the earliest start point, and the range with the
  // latest end point.


  const starter = compareRangeBoundaryPoints(a, "start", b, "start") < 0 ? a : b;
  const ender = compareRangeBoundaryPoints(a, "end", b, "end") > 0 ? a : b;
  return spanRanges(starter, ender);
}
/**
 * Given a list of word ranges, and a selection range, binary search the list
 * and return the index of the goal word, or -1 if no satisfactory goal word
 * exists in the list.
 *
 * If `goal` is "first", return the index of the first word whose end point is
 * after the selection's start point.
 *
 * If `goal` is "last", return the index of the last word whose start point is
 * before the selection's end point.
 */

function findBoundaryWordIndex(selectionRange, wordRanges, goal, initialLowerBound, initialUpperBound) {
  let bestValidWordIndex = -1;
  let lowerBound = initialLowerBound;
  let upperBound = initialUpperBound;
  let iterationCount = 0;

  while (lowerBound <= upperBound) {
    iterationCount++;

    if (iterationCount > wordRanges.length * 2) {
      throw new Error("Assertion error: Binary search isn't terminating? " + "lower=".concat(lowerBound, ", upper=").concat(upperBound));
    }

    const mid = Math.floor((lowerBound + upperBound) / 2);

    if (goal === "first") {
      const rangeComparison = compareRangeBoundaryPoints(wordRanges[mid], "end", selectionRange, "start");

      if (rangeComparison <= 0) {
        // If this word's end point is before or equal to the
        // selection's start point, then this word is not a valid
        // candidate, nor are any of the words before it.
        //
        // Update our bounds to look for a valid word after this one.
        lowerBound = mid + 1;
      } else {
        // If this word's end point is after the selection's start
        // point, then this word is valid, and is, by nature of the
        // search, the earliest valid word we're aware of.
        //
        // Update our bounds to look for a better valid word before
        // this one.
        bestValidWordIndex = mid;
        upperBound = mid - 1;
      }
    } else {
      const rangeComparison = compareRangeBoundaryPoints(wordRanges[mid], "start", selectionRange, "end");

      if (rangeComparison >= 0) {
        // If this word's start point is after or equal to the
        // selection's end point, then this word is not a valid
        // candidate, nor are any of the words after it.
        //
        // Update our bounds to look for a valid word before this one.
        upperBound = mid - 1;
      } else {
        // If this word's start point is before the selection's end
        // point, then this word is valid, and is, by nature of the
        // search, the latest valid word we're aware of.
        //
        // Update our bounds to look for a better valid word after
        // this one.
        bestValidWordIndex = mid;
        lowerBound = mid + 1;
      }
    }
  }

  return bestValidWordIndex;
}
/**
 * Given a list of word ranges, and a selection range, binary search the list
 * and return the indexes of the first and last words that the selection
 * intersects, or `null` if the range includes no words.
 */


function findFirstAndLastWordIndexes(selectionRange, wordRanges) {
  // Find the first word whose end point is after the selection's start
  // point.
  //
  // Note that this does *not* alone prove that this word is *intersected* by
  // the current range; to intersect, the first word's start point must also
  // be before the selection's end point. This is proven by the success of
  // the second search.
  //
  // (For example, imagine highlighting the space between two words. This
  // search would return the first word after the selection, despite not
  // intersecting the selection.)
  const firstWordIndex = findBoundaryWordIndex(selectionRange, wordRanges, "first", 0, wordRanges.length - 1);

  if (firstWordIndex < 0) {
    return null;
  } // Find the last word whose start point is before the selection's end
  // point.
  //
  // Start the search with our candidate first word, because, while we don't
  // know whether our candidate first word intersects the selection, we *do*
  // know that no *earlier* word intersects the selection, or else it would
  // have been yielded as the candidate first word instead.


  const lastWordIndex = findBoundaryWordIndex(selectionRange, wordRanges, "last", firstWordIndex, wordRanges.length - 1);

  if (lastWordIndex < 0) {
    return null;
  } // Now, we have discovered a candidate first word F, and a candidate last
  // word L. Let's prove that these are indeed the first and last intersected
  // words of the selection S.
  //
  // Syntax: Let A1 and A2 represent the start and end point of range A.
  //
  // Definition: A1 <= A2 for any range A.
  //
  // Theorem 1: Two ranges A and B intersect iff A1 <= B2 and B1 <= A2.
  // Proof: See http://www.rgrjr.com/emacs/overlap.html, and extend the
  //     result to closed intervals by also accepting equality.
  //
  // Given 1: F1 <= L1 and F2 <= L2. That is, either the first and last word
  //     are the same, or the last word comes after, because we provided
  //     `firstWordIndex` as the lower bound when search for L.
  // Given 2: S1 <= F2, and no earlier word's end point is >= S1, because
  //     F was returned by `findBoundaryWordIndex` with goal "first".
  // Given 3: L1 <= S2, and no later word's start point is <= S2, because
  //     L was returned by `findBoundaryWordIndex` with goal "last".
  //
  // Conclusion 1: F intersects S.
  // Proof: By Theorem 1, we must show that F1 <= S2 and S1 <= F2.
  //     F1 <= L1 <= S2, by Given 1 and Given 3.
  //     S1 <= F2, by Given 2. QED.
  //
  // Conclusion 2: L intersects S.
  // Proof: By Theorem 1, we must show that L1 <= S2 and S1 <= L2.
  //     L1 <= S2 by Given 3.
  //     S1 <= F2 <= L2, by Given 1 and Given 2. QED.
  //
  // Conclusion 3: No word earlier than F intersects S.
  // Proof: Consider some word W earlier than F.
  //     W2 < S1, by Given 2. Therefore, it's false that S1 <= W2.
  //     Therefore, W and S do not intersect, by Theorem 1. QED.
  //
  // Conclusion 4: No word later than L intersects S.
  // Proof: Consider some word W later than L.
  //     W1 > S2, by Given 2. Therefore, it's false that W1 <= S2.
  //     Therefore, W and S do not intersect, by Theorem 1, QED.
  //
  // Therefore, while neither of these two searches alone proves that F is
  // the first intersected word of S, or that L is the last intersected word
  // of S, the implications of the two searches are sufficient proof when
  // combined. Return these two indexes with confidence, hooray!


  return [firstWordIndex, lastWordIndex];
}

/**
 * Utility functions for manipulating highlights.
 */

/**
 * Given a list of DOMHighlights, return a new list that also includes the
 * given DOMRange as a new DOMHighlight. If the DOMHighlight intersects
 * existing DOMHighlights, the other Highlights are removed and their ranges
 * are merged into the new DOMHighlight.
 */
function addHighlight(existingHighlights, newHighlight) {
  const newHighlights = {}; // Merge the new highlight with any existing highlights that intersect it.

  let mergedDomRange = newHighlight.domRange;
  let mergedFirstWordIndex = newHighlight.firstWordIndex;
  let mergedLastWordIndex = newHighlight.lastWordIndex;

  for (const key of Object.keys(existingHighlights)) {
    const h = existingHighlights[key];
    const newMergedDomRange = unionRanges(h.domRange, mergedDomRange);

    if (newMergedDomRange) {
      // This highlight's range was successfully merged into the new
      // highlight. Update `mergedDomRange`, and *don't* add it to the
      // new set of highlights.
      mergedDomRange = newMergedDomRange;
      mergedFirstWordIndex = Math.min(h.firstWordIndex, mergedFirstWordIndex);
      mergedLastWordIndex = Math.max(h.lastWordIndex, mergedLastWordIndex);
    } else {
      // This highlight's range can't be merged into the new highlight.
      // Add it to the new set of highlights.
      newHighlights[key] = h;
    }
  }

  const newMergedHighlight = {
    firstWordIndex: mergedFirstWordIndex,
    lastWordIndex: mergedLastWordIndex,
    domRange: mergedDomRange
  }; // Add the newly-merged highlight to the set of highlights, under a new,
  // unique key.

  const existingKeys = Object.keys(newHighlights);
  const newKey = createNewUniqueKey(existingKeys);
  newHighlights[newKey] = newMergedHighlight;
  return newHighlights;
}
/**
 * Given a DOMRange and a list of word ranges, build a corresponding
 * DOMHighlight.
 *
 * If the DOMRange is not a valid highlight given the word ranges, return null.
 */

function buildHighlight(existingHighlights, wordRanges, newHighlightRange) {
  // If any existing highlight fully contains the new highlight range, it's
  // redundant and therefore not valid to build this as a highlight.
  // Return null.
  //
  // NOTE(mdr): Really, our goal is to determine whether the new range's
  //     content is already fully highlighted, so you could imagine this
  //     logic not catching the case where a range's contents are fully
  //     highlighted, but by multiple ranges.
  //
  //     However, words aren't actually adjacent; they have spaces between
  //     them. So, even if each word in the range is currently highlighted,
  //     the space between a pair of words will only be highlighted if
  //     they're included in the same highlight range.
  //
  //     Therefore, if this new range isn't fully contained by an existing
  //     highlight, then there's at *least* an unhighlighted space within the
  //     range. In that case, it makes sense to offer this as a new highlight
  //     that, when added, will merge with the highlights that it intersects.
  for (const key of Object.keys(existingHighlights)) {
    const existingHighlightRange = existingHighlights[key].domRange;

    if (rangeIncludes(existingHighlightRange, newHighlightRange)) {
      return null;
    }
  } // If the new highlight range doesn't span two words from the content, it's
  // not valid to build this as a highlight. Return null.


  const indexes = findFirstAndLastWordIndexes(newHighlightRange, wordRanges);

  if (!indexes) {
    return null;
  }

  const [firstWordIndex, lastWordIndex] = indexes;
  const firstWord = wordRanges[firstWordIndex];
  const lastWord = wordRanges[lastWordIndex];
  return {
    firstWordIndex,
    lastWordIndex,
    domRange: spanRanges(firstWord, lastWord)
  };
}
/**
 * Given a list of keys, return a new unique key that is not in the list.
 */

function createNewUniqueKey(existingKeys) {
  // The base of the key is the current time, in milliseconds since epoch.
  const base = "".concat(new Date().getTime());

  if (!existingKeys.includes(base)) {
    return base;
  } // But, if the user is a fast-clicker or time-traveler or something, and
  // already has a highlight from this millisecond, then let's attach a
  // suffix and keep incrementing it until we find an unused suffix.


  let suffix = 0;
  let key;

  do {
    key = "".concat(base, "-").concat(suffix);
    suffix++;
  } while (existingKeys.includes(key));

  return key;
}
/**
 * Given a SerializedHightlight and the current set of word ranges, return a
 * DOMHighlight representing the SerializedHighlight.
 *
 * If the SerializedHighlight is not valid given the list of word ranges, throw
 * an error.
 */


function deserializeHighlight(serializedHighlight, wordRanges) {
  const {
    firstWordIndex,
    lastWordIndex
  } = serializedHighlight.range;
  const firstWord = wordRanges[firstWordIndex];

  if (!firstWord) {
    throw new PerseusError("first word index ".concat(firstWord, " is out of bounds: ") + "must be 0\u2013".concat(wordRanges.length - 1, " inclusive"), Errors.InvalidInput, {
      metadata: {
        firstWord,
        wordRanges: JSON.stringify(wordRanges)
      }
    });
  }

  const lastWord = wordRanges[lastWordIndex];

  if (!lastWord) {
    throw new PerseusError("last word index ".concat(lastWord, " is out of bounds: ") + "must be 0\u2013".concat(wordRanges.length - 1, " inclusive"), Errors.InvalidInput, {
      metadata: {
        lastWord,
        wordRanges: JSON.stringify(wordRanges)
      }
    });
  }

  return {
    firstWordIndex,
    lastWordIndex,
    domRange: spanRanges(firstWord, lastWord)
  };
}
/**
 * Return a SerializedHighlight representing the given DOMHighlight.
 */

function serializeHighlight(highlight) {
  const {
    firstWordIndex,
    lastWordIndex
  } = highlight;
  return {
    range: {
      type: "word-indexes",
      firstWordIndex,
      lastWordIndex
    }
  };
}

/**
 * Utility functions for highlighting UI.
 */

/**
 * Given two positions relative to the same origin, return `child`'s position
 * relative to `parent`'s position.
 */
function getRelativePosition(child, parent) {
  return {
    left: child.left - parent.left,
    top: child.top - parent.top
  };
}
/**
 * `getRelativePosition`, but for Rects.
 *
 * Given a rectangle and a position relative to the same origin, return a new
 * rectangle of the same size, whose position is relative to the given
 * position.
 */

function getRelativeRect(_ref, parent) {
  let {
    left,
    top,
    width,
    height
  } = _ref;
  return { ...getRelativePosition({
      left,
      top
    }, parent),
    width,
    height
  };
}
/**
 * Given a DOMRange, return a list of client-relative rects that cover the text
 * inside the DOMRange.
 *
 * This behaves differently than the browser's built-in `getClientRects` method
 * for DOMRanges, because this method only gets rects for the *text* nodes,
 * whereas the browser's method will also return rects for any fully-contained
 * *element* nodes.
 *
 * For example, if an entire paragraph is selected, then `getClientRects` will
 * return a rectangle that covers the entire paragraph block, whereas this
 * method will only return rectangles for the text inside the paragraph.
 */

function getClientRectsForTextInRange(range) {
  const mutableRects = [];
  addClientRectsForTextInNodeAndRange(range.commonAncestorContainer, range, mutableRects);
  return mutableRects;
}
/**
 * A helper method for getClientRectsForTextInRange.
 *
 * Given a node and a range, find text that is contained within both the node
 * and the range by recursing down the node's subtree, and push the text's
 * client rects onto the given `mutableRects` array.
 */

function addClientRectsForTextInNodeAndRange(node, range, // eslint-disable-next-line ft-flow/no-mutable-array
mutableRects) {
  const nodeContentsRange = new Range();
  nodeContentsRange.selectNodeContents(node);

  if (node.nodeType === Node.TEXT_NODE) {
    // Get the text that appears both in this text node and in the range
    // we're searching.
    const intersectedRange = intersectRanges(range, nodeContentsRange);

    if (intersectedRange) {
      addClientRectsForText(node, intersectedRange, mutableRects);
    }
  } else if (node.nodeType === Node.ELEMENT_NODE) {
    // Don't bother deep-traversing a node that doesn't even overlap the
    // range we're searching.
    if (!rangesOverlap(range, nodeContentsRange)) {
      return;
    } // NOTE(mdr): Safari returns a non-iterable `childNodes` object, so
    //     convert it to an array.


    for (const child of Array.from(node.childNodes)) {
      // TODO(mdr): If this parent has overflow: hidden, bound the child
      //     rects accordingly. This would allow us to remove the hack
      //     we added to .perseus-sr-only.
      addClientRectsForTextInNodeAndRange(child, range, mutableRects);
    }
  }
}
/**
 * Given a DOMRange of text fully contained by the given `textNode`, compute
 * rectangles that visually cover the range, and push them onto the given
 * `mutableRects` array.
 *
 * This function adjusts the rectangles to the line height of the text, to
 * match the visual behavior of native text selection, and remove annoying gaps
 * between lines that disrupt hover behavior.
 */


function addClientRectsForText(textNode, textRange, // eslint-disable-next-line ft-flow/no-mutable-array
mutableRects) {
  const parentElement = textNode.parentElement;
  const computedStyle = window.getComputedStyle(parentElement); // NOTE(mdr): I'm not sure how computed line height works in all contexts
  //     in all browsers. It's valid to specify line height as a ratio,
  //     relative to font size. Latest Chrome seems to transform this into a
  //     px value, but maybe some browsers don't, so I'm being defensive here
  //     and only using the computed line height if it's explicitly a px
  //     value. We could also handle other browsers by computing font size
  //     and doing the math ourselves, but let's punt that until we need it.

  let lineHeight = null;

  if (typeof computedStyle.lineHeight === "string" && computedStyle.lineHeight.endsWith("px")) {
    const parsedLineHeight = parseFloat(computedStyle.lineHeight);

    if (!isNaN(parsedLineHeight)) {
      lineHeight = parsedLineHeight;
    }
  } // NOTE(mdr): Safari returns a non-iterable `getClientRects` object, so
  //     convert it to an array.


  const boundingRects = Array.from(textRange.getClientRects());

  for (const boundingRect of boundingRects) {
    const rect = {
      left: boundingRect.left,
      top: boundingRect.top,
      height: boundingRect.height,
      width: boundingRect.width
    }; // Adjust the rectangle according to the text's line height. It should
    // keep the same bottom coordinate, so the top coordinate will move
    // accordingly.

    if (lineHeight !== null) {
      const heightIncrease = lineHeight - rect.height;
      rect.top -= heightIncrease;
      rect.height = lineHeight;
    }

    mutableRects.push(rect);
  }
}

class HighlightRenderer extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      cachedHighlightRects: this._computeRects(this.props),
      tooltipIsHovered: false
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.highlight !== nextProps.highlight || this.props.offsetParent !== nextProps.offsetParent) {
      this.setState({
        cachedHighlightRects: this._computeRects(nextProps)
      });
    }
  }
  /**
   * Compute the set of rectangles that cover the highlighted content, with
   * coordinates relative to the offset parent. That way, we can use them
   * for CSS positioning.
   */


  _computeRects(props) {
    const {
      highlight,
      offsetParent
    } = props; // Get the set of rectangles that covers the range's text, relative to
    // the offset parent.

    const clientRects = getClientRectsForTextInRange(highlight.domRange);
    const {
      left,
      top
    } = offsetParent.getBoundingClientRect();
    const relativeRects = clientRects.map(rect => getRelativeRect(rect, {
      left,
      top
    }));
    return relativeRects;
  }
  /**
   * Return whether the given mouse position (coordinates relative to this
   * component's offset parent) is hovering over the given rectangle
   * (coordinates also relative to this component's offset parent).
   */


  _rectIsHovered(rect, mouseOffsetPosition) {
    const positionWithinRect = getRelativePosition(mouseOffsetPosition, {
      left: rect.left,
      top: rect.top
    });
    return 0 <= positionWithinRect.left && positionWithinRect.left < rect.width && 0 <= positionWithinRect.top && positionWithinRect.top < rect.height;
  }
  /**
   * Return whether the given mouse position (coordinates relative to the
   * viewport) is hovering over this highlight.
   */


  isHovered(mouseClientPosition) {
    if (!mouseClientPosition) {
      return false;
    }

    const {
      offsetParent
    } = this.props;
    const {
      cachedHighlightRects
    } = this.state; // Convert the client-relative mouse coordinates to be relative to the
    // offset parent. That way, we can compare them to the cached highlight
    // rectangles.

    const {
      left,
      top
    } = offsetParent.getBoundingClientRect();
    const mouseOffsetPosition = getRelativePosition(mouseClientPosition, {
      left,
      top
    });
    return cachedHighlightRects.some(rect => this._rectIsHovered(rect, mouseOffsetPosition));
  }

  render() {
    const rects = this.state.cachedHighlightRects;
    return /*#__PURE__*/React__namespace.createElement("div", null, rects.map((rect, index) => /*#__PURE__*/React__namespace.createElement("div", {
      key: index,
      className: aphrodite.css(styles$g.highlightRect),
      style: {
        // NOTE(mdr): We apply `position: absolute` here
        //     rather than in Aphrodite styles, because
        //     Aphrodite styles are delayed. If this
        //     element temporarily has `position: static`,
        //     then it'll displace the content, and other
        //     highlights rendering during this update will
        //     measure the displaced content instead, oops!
        position: "absolute",
        width: rect.width,
        height: rect.height,
        top: rect.top,
        left: rect.left,
        zIndex: this.props.zIndexes.belowContent
      }
    })));
  }

}

const styles$g = aphrodite.StyleSheet.create({
  highlightRect: {
    background: "#fffabe" // highlighter yellow :)

  }
});

/**
 * Create a new VisibilityObserver.
 */
function createVisibilityObserver(rootElement, onVisibilityChange, rootMargin) {
  return new NativeVisibilityObserver(rootElement, onVisibilityChange, rootMargin);
}
/**
 * A VisibilityObserver that uses IntersectionObserver to leverage the
 * browser's native ability to determine how much of an element is visible.
 * https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 */

class NativeVisibilityObserver {
  constructor(rootElement, onVisibilityChange, rootMargin) {
    _defineProperty(this, "_intersectionObserver", void 0);

    _defineProperty(this, "_onVisibilityChange", void 0);

    _defineProperty(this, "_handleIntersection", entries => {
      // There should be exactly one entry, but let's be defensive and loop.
      //
      for (const entry of entries) {
        this._onVisibilityChange(entry.isIntersecting, entry.rootBounds);
      }
    });

    // Create an IntersectionObserver with a threshold of "epsilon", the
    // smallest positive non-zero number. This means that, whenever the
    // target element enters or exits total invisibility, the handler will
    // be called.
    this._intersectionObserver = new IntersectionObserver(this._handleIntersection, {
      root: rootElement,
      threshold: Number.EPSILON,
      rootMargin
    });
    this._onVisibilityChange = onVisibilityChange;
  }

  setTargetElement(targetElement) {
    // Because this class only watches one element at a time, we disconnect
    // from all other observed elements first, just in case.
    this._intersectionObserver.disconnect();

    this._intersectionObserver.observe(targetElement);
  }

  disconnect() {
    this._intersectionObserver.disconnect();
  }

}

/**
 * This is FlexiblePosition, part of NewTooltip.
 *
 * This generalizable component attempts to center its children relative to a
 * given point... but refuses to allow the children to overflow their
 * container. If the children *would* overflow, we first use the Flexbox
 * algorithm to shift the element off-center. If that still doesn't work (i.e.,
 * the children are larger than the container), then we shrink the children.
 *
 * This layout algorithm is entirely implemented via Flexbox. We have three
 * elements: the pre-content spacer, the content, and the post-content spacer.
 * The pre-content spacer and post-content spacer use their basis sizes to
 * position the content at the target point, then shrink by equal amounts in
 * order to *center* the content at the target point.
 *
 * To understand the algorithm, first consider *just* the spacer elements.
 * If the container is 80px wide, and we're targeting a point 60px from the
 * right and 20px from the left, then the spacer elements will use those values
 * as their flex-basis:
 *
 * [        pre-content         ][   post-content   ]
 *
 * They take up 100% of the container by default. But, if the content element
 * _also_ wants space, then the pre-content and post-content spacers need to
 * shrink. We've configured them to shrink by equal amounts, which therefore
 * center-aligns the target element at the target point.
 *
 * [      pre-content      ][content ][post-content ]
 *
 * (Incidentally, the flex-shrink property is surprisingly complicated: it's
 * defined relative to the element's own flex-basis. So, to get the spacers to
 * shrink at equal rates, we define each spacer's flex-shrink to match the
 * _other_ element's flex-basis. Fun! ^_^`)
 *
 * TODO(mdr): This component currently only supports horizontal positioning,
 *     but we'll probably extend it later to support vertical positioning, too.
 */
class FlexiblePosition extends React__namespace.PureComponent {
  render() {
    const {
      direction,
      pxFromStart,
      pxFromEnd
    } = this.props;
    const wrapperStyles = [styles$f.wrapper, direction === "horizontal" && styles$f.wrapperHorizontal, direction === "vertical" && styles$f.wrapperVertical];
    const contentStyles = [styles$f.content, direction === "horizontal" && styles$f.contentHorizontal, direction === "vertical" && styles$f.contentVertical]; // We need to handle the zero cases specially, because otherwise we get
    // spacer elements with `flex-shrink: 0` - that is, they don't shrink
    // for the content at all!

    if (pxFromStart === 0) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(...wrapperStyles)
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(...contentStyles)
      }, this.props.children));
    }

    if (pxFromEnd === 0) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(...wrapperStyles, styles$f.wrapperAlignToEnd)
      }, /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(...contentStyles)
      }, this.props.children));
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(...wrapperStyles)
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        flexShrink: pxFromEnd,
        flexBasis: pxFromStart
      }
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(...contentStyles)
    }, this.props.children), /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        flexShrink: pxFromStart,
        flexBasis: pxFromEnd
      }
    }));
  }

}
const styles$f = aphrodite.StyleSheet.create({
  wrapper: {
    display: "flex",
    overflow: "hidden"
  },
  wrapperHorizontal: {
    flexDirection: "row",
    // The FlexiblePosition container takes the full width of its parent,
    // and will not allow overflow (see `styles.wrapper`). This ensures
    // that we prefer to shrink our contents, rather than overflow our
    // parent.
    width: "100%"
  },
  wrapperVertical: {
    flexDirection: "column",
    // The FlexiblePosition container takes the full height of its parent,
    // and will not allow overflow (see `styles.wrapper`). This ensures
    // that we prefer to shrink our contents, rather than overflow our
    // parent.
    height: "100%"
  },
  wrapperAlignToEnd: {
    justifyContent: "flex-end"
  },
  content: {
    // The content element must not grow or shrink, and instead always use
    // its basis value.
    flex: "0 0 auto"
  },
  contentHorizontal: {
    // The only case in which the content element should "shrink" is when
    // the content itself is too large for the container. In this case, we
    // constrain the size with maximum width. (We can't use flex-shrink for
    // this behavior, because we need the spacer elements to be prioritized
    // as the only flex-shrinkable elements.)
    maxWidth: "100%"
  },
  contentVertical: {
    // The only case in which the content element should "shrink" is when
    // the content itself is too large for the container. In this case, we
    // constrain the size with maximum height. (We can't use flex-shrink
    // for this behavior, because we need the spacer elements to be
    // prioritized as the only flex-shrinkable elements.)
    maxHeight: "100%"
  }
});

/**
 * Constant style values used across the tooltip components.
 */
const arrowWidth = 18;
const arrowHeight = 9;
const bubbleBorderRadius = parseInt(borderRadiusLarge);
const dropShadowXOffset = 0;
const dropShadowYOffset = 1;
const dropShadowOpacity = 0.1;
const dropShadowRadius = 4;

/**
 * Utility functions for the NewTooltip component.
 */

/**
 * Given a set of NewTooltipProps, return the `backgroundColor` and `textColor`
 * of the tooltip. Used in TooltipArrow and TooltipBubble.
 */
function getTooltipColors(tooltipProps) {
  const {
    color,
    inverted
  } = tooltipProps;

  if (inverted) {
    return {
      backgroundColor: color,
      textColor: Color__default["default"].white
    };
  }

  return {
    backgroundColor: Color__default["default"].white,
    textColor: color
  };
}

/**
 * This is TooltipArrow, part of NewTooltip.
 *
 * This component manages the visuals for the tooltip "arrow" UI element, which
 * is visually attached to the TooltipBubble, and points to the target element.
 *
 * This component and TooltipBubble both count as part of the tooltip, and
 * trigger mouse events like `onClick`, `onMouseEnter`, and `onMouseLeave`.
 */
class TooltipArrow extends React__namespace.PureComponent {
  render() {
    const {
      onClick,
      onMouseEnter,
      onMouseLeave,
      side
    } = this.props.tooltipProps;
    const {
      backgroundColor
    } = getTooltipColors(this.props.tooltipProps); // Draw the three points of the arrow. Depending on the arrow's
    // direction (i.e., the tooltip's "side"), we choose different points,
    // and set our SVG's bounds differently.
    //
    // Note that `arrowWidth` and `arrowHeight` refer to the
    // downward-pointing arrow (i.e. side="top"). When the arrow points to
    // the left or right instead, the width/height are inverted.

    let points;
    let svgWidth;
    let svgHeight;

    if (side === "top") {
      points = ["0,0", "".concat(arrowWidth / 2, ",").concat(arrowHeight), "".concat(arrowWidth, ",0")];
      svgWidth = arrowWidth;
      svgHeight = arrowHeight;
    } else if (side === "right") {
      points = ["".concat(arrowHeight, ",0"), "0,".concat(arrowWidth / 2), "".concat(arrowHeight, ",").concat(arrowWidth)];
      svgWidth = arrowHeight;
      svgHeight = arrowWidth;
    } else if (side === "bottom") {
      points = ["0,".concat(arrowHeight), "".concat(arrowWidth / 2, ",0"), "".concat(arrowWidth, ",").concat(arrowHeight)];
      svgWidth = arrowWidth;
      svgHeight = arrowHeight;
    } else if (side === "left") {
      points = ["0,0", "".concat(arrowHeight, ",").concat(arrowWidth / 2), "0,".concat(arrowWidth)];
      svgWidth = arrowHeight;
      svgHeight = arrowWidth;
    } else {
      throw new PerseusError("unexpected side ".concat(side), Errors.InvalidInput);
    } // This SVG is copied from tooltip-package/tooltip.jsx - with some minor
    // modifications, because styling is handled differently.


    return /*#__PURE__*/React__namespace.createElement("svg", {
      width: svgWidth,
      height: svgHeight,
      className: aphrodite.css(styles$e.tooltipArrow)
    }, /*#__PURE__*/React__namespace.createElement("filter", {
      id: "tooltip-dropshadow-".concat(side),
      height: "150%"
    }, /*#__PURE__*/React__namespace.createElement("feOffset", {
      dx: dropShadowXOffset,
      dy: dropShadowYOffset,
      result: "offsetblur"
    }), /*#__PURE__*/React__namespace.createElement("feGaussianBlur", {
      in: "SourceAlpha",
      stdDeviation: dropShadowRadius / 2
    }), /*#__PURE__*/React__namespace.createElement("feComponentTransfer", null, /*#__PURE__*/React__namespace.createElement("feFuncA", {
      type: "linear",
      slope: dropShadowOpacity
    })), /*#__PURE__*/React__namespace.createElement("feMerge", null, /*#__PURE__*/React__namespace.createElement("feMergeNode", null), /*#__PURE__*/React__namespace.createElement("feMergeNode", {
      in: "SourceGraphic"
    }))), /*#__PURE__*/React__namespace.createElement("polyline", {
      fill: backgroundColor,
      stroke: backgroundColor,
      points: points.join(" ") // We attach our mouse event styles and handlers to this
      // element, instead of the root SVG element. That way, our
      // target area will only include the actual _arrow_ shape,
      // rather than the entire bounding rectangle.
      ,
      className: aphrodite.css(onClick && styles$e.tooltipArrowShapeWithOnClick),
      onClick: onClick,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave
    }), /*#__PURE__*/React__namespace.createElement("polyline", {
      // Redraw the stroke on top of the background color,
      // so that the ends aren't extra dark where they meet
      // the border of the tooltip.
      fill: backgroundColor,
      points: points.join(" "),
      stroke: "rgba(0, 0, 0, 0.1)",
      filter: "url(#tooltip-dropshadow-".concat(side, ")")
    }));
  }

}
const styles$e = aphrodite.StyleSheet.create({
  tooltipArrow: {
    display: "block",
    // Ensure that clicking on the tooltip's empty space doesn't clear the
    // user's text selection elsewhere in the page.
    userSelect: "none"
  },
  tooltipArrowShapeWithOnClick: {
    pointerEvents: "auto",
    cursor: "pointer"
  }
});

const closeIconPath = "M6.26353762,4.99851587 L9.73097464,1.53107884 C10.0836373,1.17841618 10.0842213,0.612127047 9.73530496,0.263210718 C9.38395604,-0.0881381913 8.81874474,-0.0837668714 8.46743686,0.267541014 L4.99999981,3.73497806 L1.5325628,0.267541051 C1.1812549,-0.0837668481 0.616043606, -0.0881381955 0.264694717,0.263210694 C-0.0842215912,0.612127004 -0.0836375768,1.17841613 0.269025093,1.5310788 L3.73646206,4.9985158 L0.269025109,8.46595276 C-0.083637537,8.81861541 -0.0842215923, 9.38490462 0.264694642,9.73382106 C0.616043456,10.0851701 1.18125469, 10.0807988 1.53256259,9.72949093 L4.99999988,6.26205363 L8.46743739, 9.72949117 C8.8187453,10.0807991 9.38395655,10.0851704 9.73530537, 9.73382138 C10.0842216,9.38490498 10.0836375,8.81861579 9.73097488, 8.46595313 L6.26353762,4.99851587 Z";
class TooltipBubble extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_handleClickClose", () => this.props.dismiss());
  }

  _renderCloseButton(ids) {
    const {
      inverted,
      dismissOnClickClose
    } = this.props.tooltipProps;

    if (!dismissOnClickClose) {
      // When `dismissOnClickClose` is not set, don't render a close
      // button at all.
      return null;
    }

    const buttonDescriptionId = ids.get("button-description");
    const headerId = this.getA11yHeaderId(ids);
    return /*#__PURE__*/React__namespace.createElement("button", {
      className: aphrodite.css(styles$d.closeIcon),
      onClick: this._handleClickClose,
      "aria-describedby": "".concat(buttonDescriptionId, " ").concat(headerId)
    }, /*#__PURE__*/React__namespace.createElement(Icon, {
      title: i18n__namespace._("Close"),
      icon: closeIconPath,
      size: 10,
      color: // Use a light icon if we're inverted, or dark
      // otherwise.
      inverted ? "rgba(255, 255, 255, 0.7)" : "rgba(0, 0, 0, 0.15)"
    }), /*#__PURE__*/React__namespace.createElement("div", {
      id: buttonDescriptionId,
      className: aphrodite.css(a11y.srOnly)
    }, i18n__namespace._("Closes the tooltip: ")));
  }

  getA11yHeaderId(ids) {
    const {
      tooltipProps: {
        a11y
      }
    } = this.props;

    if (!a11y || !a11y.title) {
      // No title specified so assume our content labels us.
      return this.getA11yContentId(ids);
    }

    if (typeof a11y.title === "string") {
      // We have a string title, so we'll generate our own label.
      return ids.get("header");
    } // We've been given a specific identifier, so use that.


    return a11y.title.id;
  }

  getA11yContentId(ids) {
    return ids.get("content");
  }

  renderTooltip(ids) {
    const {
      content,
      dismissOnClickClose,
      noPadding,
      onClick,
      onMouseEnter,
      onMouseLeave,
      a11y: a11y$1,
      testId
    } = this.props.tooltipProps;
    const a11yTitle = a11y$1 && a11y$1.title;
    const a11yAssertiveness = a11y$1 && a11y$1.assertiveness;
    const {
      backgroundColor,
      textColor
    } = getTooltipColors(this.props.tooltipProps);
    const headerId = this.getA11yHeaderId(ids);
    const contentId = this.getA11yContentId(ids);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$d.tooltipBubble, !noPadding && styles$d.tooltipBubbleWithPadding, dismissOnClickClose && styles$d.tooltipBubbleWithCloseIcon, onClick && styles$d.tooltipBubbleWithOnClick),
      onClick: onClick,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      style: {
        backgroundColor,
        color: textColor
      },
      role: "region",
      "aria-labelledby": headerId,
      "aria-describedby": contentId === headerId ? null : contentId,
      "data-test-id": testId
    }, this._renderCloseButton(ids), /*#__PURE__*/React__namespace.createElement("div", {
      "aria-live": a11yAssertiveness
    }, typeof a11yTitle === "string" ? /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(a11y.srOnly),
      id: headerId
    }, a11yTitle) : null, /*#__PURE__*/React__namespace.createElement("div", {
      id: contentId,
      className: aphrodite.css(styles$d.tooltipContent)
    }, content)));
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.UniqueIDProvider, {
      mockOnFirstRender: false,
      scope: "tooltip-bubble"
    }, ids => this.renderTooltip(ids));
  }

} // These styles are copied from tooltip-package/tooltip.jsx - with some minor
// modifications, because positioning is handled differently.
//
// TODO(mdr): Also, the standard tooltip seemed to have `transition` styles
//     designed to fade-in the tooltip... but they don't seem to work? I've
//     removed them for now. We'd probably have to use an
//     AphroditeCSSTransitionGroup, in order to initialize the opacity to 0,
//     then wait a tick before setting the opacity to 1.

const styles$d = aphrodite.StyleSheet.create({
  tooltipBubble: {
    // layout styles
    boxSizing: "border-box",
    position: "relative",
    // for the close icon
    // content styles
    ...typography.labelMedium,
    // border and box shadow styles
    borderRadius: bubbleBorderRadius,
    border: "1px solid rgba(0, 0, 0, 0.1)",
    boxShadow: "".concat(dropShadowXOffset, "px ").concat(dropShadowYOffset, "px ") + "".concat(dropShadowRadius, "px 0px ") + "rgba(0, 0, 0, ".concat(dropShadowOpacity, ")"),
    // Ensure that clicking on the tooltip's empty space doesn't clear the
    // user's text selection elsewhere in the page. (We reset this rule in
    // `tooltipContent`, so that the user _can_ select text _inside_ the
    // tooltip.)
    userSelect: "none"
  },
  tooltipBubbleWithPadding: {
    padding: "10px 23px"
  },
  tooltipBubbleWithCloseIcon: {
    paddingRight: 34
  },
  tooltipBubbleWithOnClick: {
    cursor: "pointer"
  },
  tooltipContent: {
    // Reset the `userSelect: none` rule in `tooltipBubble`, to enable the
    // user to select the tooltip's content.
    userSelect: "auto"
  },
  closeIcon: {
    display: "block",
    position: "absolute",
    right: 10,
    top: 10,
    padding: 0,
    background: "inherit",
    border: "none"
  }
});

class TooltipPositioner extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_mountRemeasureTimeout", void 0);

    _defineProperty(this, "state", {
      targetElementClientRect: null,
      rootElementClientRect: null
    });

    _defineProperty(this, "_handleScroll", e => {
      const {
        rootElement,
        targetElement
      } = this.props;
      const scrollContainer = e.target;

      if (rootElement.contains(scrollContainer) && scrollContainer.contains(targetElement)) {
        this.remeasure();
      }
    });

    _defineProperty(this, "remeasure", () => {
      const {
        targetElement,
        rootElement
      } = this.props;
      this.setState({
        targetElementClientRect: targetElement.getBoundingClientRect(),
        rootElementClientRect: rootElement.getBoundingClientRect()
      });
    });
  }

  componentDidMount() {
    // Wait a tick, then measure the elements.
    //
    // NOTE(mdr): This is necessary for all tooltips in IE and Edge, and
    //     some tooltips in other browsers, but I don't understand why.
    //     NewTooltip already waits a tick after mount before rendering
    //     this React subtree, so I would've expected styles to be present
    //     already when this element was initialized. But, without this,
    //     many tooltips are mis-positioned on IE and Edge, and the
    //     `CrossOutTooltip` is apparently always mispositioned, regardless
    //     of browser. So, shrug!
    // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    this._mountRemeasureTimeout = setTimeout(this.remeasure, 0);
    window.addEventListener("resize", this.remeasure);
    window.addEventListener("scroll", this._handleScroll, true);
  }

  componentWillUnmount() {
    if (this._mountRemeasureTimeout) {
      // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      clearTimeout(this._mountRemeasureTimeout);
    }

    window.removeEventListener("resize", this.remeasure);
    window.removeEventListener("scroll", this._handleScroll, true);
  }
  /**
   * This is a global scroll handler, which detects all scroll events on the
   * page. As a quick check before proceeding, we query whether the scroll
   * container sits between the root and the target element. If so, this
   * probably affected position, and we should `remeasure` ourselves. If not,
   * do nothing.
   *
   * NOTE(mdr): This is roughly the same check as in VisibilityObserver.
   */


  /**
   * Find the "target point" of the target element: the place where the
   * tooltip arrow will point.
   *
   * When side="top", this is the top-center point.
   * When side="bottom", this is the bottom-center point.
   * When side="left", this is the left-center point.
   * When side="right", this is the right-center point.
   *
   * Compute the target point's offsets from various sides of the screen,
   * and return them. We'll use these offsets to position the tooltip bubble
   * and arrow.
   */
  _computeTargetPointOffsets(targetElementClientRect, rootElementClientRect) {
    const {
      offset,
      offsetFrom,
      side
    } = this.props.tooltipProps;
    const t = targetElementClientRect;
    const r = rootElementClientRect; // When `offsetFrom` is "arrow", we need to perform offset from the
    // arrow, rather than the bubble. To do this, we simply increase the
    // offset amount by the arrow's height.

    let totalOffset = offset;

    if (offsetFrom === "arrow") {
      totalOffset += arrowHeight;
    } // Compute the position of the target point, relative to the viewport.
    // Our choice of target point depends on the `side` prop, and will be
    // shifted according to the `offset` prop.


    let targetPoint;

    if (side === "top") {
      targetPoint = {
        left: t.left + t.width / 2,
        top: t.top - totalOffset
      };
    } else if (side === "bottom") {
      targetPoint = {
        left: t.left + t.width / 2,
        top: t.bottom + totalOffset
      };
    } else if (side === "left") {
      targetPoint = {
        left: t.left - totalOffset,
        top: t.top + t.height / 2
      };
    } else if (side === "right") {
      targetPoint = {
        left: t.right + totalOffset,
        top: t.top + t.height / 2
      };
    } else {
      throw new PerseusError("unexpected side ".concat(side), Errors.InvalidInput);
    } // Take the target point, and compute its offset from each side of the
    // root element.
    //
    // Note that the client rect's `right` coordinate is the distance
    // between the element's right edge and the _left_ of the screen, not
    // the right of the screen. The `bottom` coordinate is similarly
    // unintuitive. Surprise!
    //
    // Thankfully, unlike client rects, our `pxFromRight` offset is more
    // what you'd expect: it's the distance between the target point and
    // the _right_ edge of the root element.


    return {
      pxFromTop: targetPoint.top - r.top,
      pxFromBottom: r.bottom - targetPoint.top,
      pxFromLeft: targetPoint.left - r.left,
      pxFromRight: r.right - targetPoint.left
    };
  }

  _renderBubble(targetPoint) {
    const {
      isAboveModal
    } = this.props;
    const {
      side,
      tooltipMargin
    } = this.props.tooltipProps; // Compute the wrapper styles and FlexiblePosition props to position
    // the bubble at the target point. We also apply "tooltip margin"
    // styles, to prevent the tooltip from getting too close to the sides
    // of the page. Also, in addition to the styles set here, we set one
    // more position coordinate in the following block.

    let bubblePositionerClass;
    const bubblePositionerStyles = {};
    const bubbleFlexiblePositionProps = {};
    const bubbleWrapperStyles = {};

    if (side === "top" || side === "bottom") {
      bubblePositionerClass = styles$c.tooltipBubblePositionerTopBottom;
      bubbleFlexiblePositionProps.direction = "horizontal";
      bubbleFlexiblePositionProps.pxFromStart = targetPoint.pxFromLeft;
      bubbleFlexiblePositionProps.pxFromEnd = targetPoint.pxFromRight;
      bubbleWrapperStyles.marginLeft = tooltipMargin;
      bubbleWrapperStyles.marginRight = tooltipMargin;
    } else if (side === "left" || side === "right") {
      bubblePositionerClass = styles$c.tooltipBubblePositionerLeftRight;
      bubbleFlexiblePositionProps.direction = "vertical";
      bubbleFlexiblePositionProps.pxFromStart = targetPoint.pxFromTop;
      bubbleFlexiblePositionProps.pxFromEnd = targetPoint.pxFromBottom;
      bubbleWrapperStyles.marginTop = tooltipMargin;
      bubbleWrapperStyles.marginBottom = tooltipMargin;
    } else {
      throw new PerseusError("unexpected side ".concat(side), Errors.InvalidInput);
    } // When side="top", we position ourselves relative to the bottom of the
    // root, so that the tooltip's height will grow upward from the target
    // point.
    //
    // When side="bottom", we position ourselves relative to the top of the
    // root, so that the tooltip's height will grow downward from the
    // target point.
    //
    // When side="left", we position ourselves relative to the right of the
    // root, so that the tooltip's width will grow leftward from the target
    // point.
    //
    // When side="right", we position ourselves relative to the right of
    // the root, so that the tooltip's width will grow rightward from the
    // target point.


    if (side === "top") {
      bubblePositionerStyles.bottom = targetPoint.pxFromBottom;
    } else if (side === "bottom") {
      bubblePositionerStyles.top = targetPoint.pxFromTop;
    } else if (side === "left") {
      bubblePositionerStyles.right = targetPoint.pxFromRight;
    } else if (side === "right") {
      bubblePositionerStyles.left = targetPoint.pxFromLeft;
    } else {
      throw new PerseusError("unexpected side ".concat(side), Errors.InvalidInput);
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$c.tooltipBubblePositioner, bubblePositionerClass, isAboveModal && styles$c.tooltipAboveModal),
      style: bubblePositionerStyles
    }, /*#__PURE__*/React__namespace.createElement(FlexiblePosition, bubbleFlexiblePositionProps, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$c.tooltipBubbleWrapper),
      style: bubbleWrapperStyles
    }, /*#__PURE__*/React__namespace.createElement(TooltipBubble, {
      tooltipProps: this.props.tooltipProps,
      dismiss: this.props.dismiss
    }))));
  }

  _renderArrow(targetPoint, rootElementClientRect) {
    const {
      isAboveModal
    } = this.props;
    const {
      side,
      tooltipMargin
    } = this.props.tooltipProps;
    const arrowStyles = {}; // Compute the vertical position of the arrow (if side is top/bottom),
    // or horizontal position (if side is left/right). Include one extra
    // pixel to get the overlapping just right!
    //
    // When side="top", we position ourselves relative to the bottom of the
    // root element, etc., for consistency with the tooltip bubble. This
    // ensures that, even in the face of extreme circumstances (e.g. the
    // root element unexpectedly changing size), the arrow and bubble will
    // never separate from each other.

    if (side === "top") {
      arrowStyles.bottom = targetPoint.pxFromBottom - arrowHeight + 1;
    } else if (side === "bottom") {
      arrowStyles.top = targetPoint.pxFromTop - arrowHeight + 1;
    } else if (side === "left") {
      arrowStyles.right = targetPoint.pxFromRight - arrowHeight + 1;
    } else if (side === "right") {
      arrowStyles.left = targetPoint.pxFromLeft - arrowHeight + 1;
    } else {
      throw new PerseusError("unexpected side ".concat(side), Errors.InvalidInput);
    } // Compute the horizontal position of the arrow (if side is top/bottom),
    // or vertical position (if side is left/right).
    //
    // While we don't care about the arrow lining up with any *exact* point
    // on the tooltip bubble, we *do* want to ensure that we don't align it
    // with one of the curved corners.
    //
    // So, we determine the minimum and maximum position value that would
    // be safe for the arrow to have while still leaving room for the
    // border radius, and clamp the value to that range.
    //
    // If the page is very narrow, then it's possible that the arrow is too
    // wide, and will have to exceed one bound or the other. In that case,
    // well, that's what you get for using a 18px-wide viewport :P


    const extraSpace = tooltipMargin + bubbleBorderRadius;

    if (side === "top" || side === "bottom") {
      const minLeft = extraSpace;
      const maxLeft = rootElementClientRect.width - arrowWidth - extraSpace;
      arrowStyles.left = targetPoint.pxFromLeft - arrowWidth / 2;
      arrowStyles.left = Math.min(arrowStyles.left, maxLeft);
      arrowStyles.left = Math.max(arrowStyles.left, minLeft);
    } else if (side === "left" || side === "right") {
      const minTop = extraSpace;
      const maxTop = rootElementClientRect.height - arrowWidth - extraSpace;
      arrowStyles.top = targetPoint.pxFromTop - arrowWidth / 2;
      arrowStyles.top = Math.min(arrowStyles.top, maxTop);
      arrowStyles.top = Math.max(arrowStyles.top, minTop);
    } else {
      throw new PerseusError("unexpected side ".concat(side), Errors.InvalidInput);
    }

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$c.tooltipArrowPositioner, isAboveModal && styles$c.tooltipAboveModal),
      style: arrowStyles
    }, /*#__PURE__*/React__namespace.createElement(TooltipArrow, {
      tooltipProps: this.props.tooltipProps
    }));
  }
  /**
   * Build an Aphrodite style that filters the tooltip's visibility by the
   * `media` prop provided to NewTooltip.
   *
   * When the media query is satisfied, this will have `display: block`. When
   * the media query is not satisfied, this will have `display: none`.
   *
   * If no `media` prop was provided, this returns null.
   */


  _buildMediaFilterStyle() {
    const {
      media
    } = this.props.tooltipProps;

    if (!media) {
      return null;
    } // NOTE(mdr): It's not, like, _good practice_ to create Aphrodite
    //     stylesheets inline like this, but there's no significant
    //     negative consequences! Thanks to Aphrodite's hashing strategy,
    //     this will always yield the same class name, even though we
    //     rebuild the stylesheet from scratch on each render.


    const mediaFilterStyleSheet = aphrodite.StyleSheet.create({
      mediaFilter: {
        display: "none",
        [media]: {
          display: "block"
        }
      }
    });
    return mediaFilterStyleSheet.mediaFilter;
  }

  render() {
    const {
      targetElementClientRect,
      rootElementClientRect
    } = this.state;

    if (!targetElementClientRect || !rootElementClientRect) {
      return null;
    }

    const targetPoint = this._computeTargetPointOffsets(targetElementClientRect, rootElementClientRect);

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(this._buildMediaFilterStyle())
    }, this._renderBubble(targetPoint), this._renderArrow(targetPoint, rootElementClientRect));
  }

}
const styles$c = aphrodite.StyleSheet.create({
  tooltipBubblePositioner: {
    // Absolute position.
    // `top`/`bottom`/`left`/`right` provided dynamically, and also by the
    // additional `tooltipBubblePositioner` classes.
    position: "absolute",
    zIndex: zindexTooltip,
    // Disable pointer events, so that any extra empty space consumed by
    // the FlexiblePosition element is not clickable. In
    // `tooltipBubbleWrapper`, we reset this style, so that the user can
    // interact with the tooltip content.
    pointerEvents: "none"
  },
  tooltipAboveModal: {
    zIndex: zindexAboveModal
  },
  // More positioner styles for when side="top" or side="bottom".
  tooltipBubblePositionerTopBottom: {
    // The positioner consumes the full page width, which gives the
    // FlexiblePosition element the freedom to position the tooltip
    // anywhere horizontally on the page. (Though, of course, it'll aim for
    // the target point!)
    left: 0,
    width: "100%"
  },
  // More positioner styles for when side="left" or side="right".
  tooltipBubblePositionerLeftRight: {
    // The positioner consumes the full page height, which gives the
    // FlexiblePosition element the freedom to position the tooltip
    // anywhere horizontally on the page. (Though, of course, it'll aim for
    // the target point!)
    top: 0,
    height: "100%"
  },
  tooltipBubbleWrapper: {
    // `marginLeft` and `marginRight` styles are provided dynamically, to
    // implement the `tooltipMargin` provided by the caller.
    // Re-enable pointer events, which were disabled by
    // `tooltipBubblePositioner`, so that the user can interact with the
    // tooltip content.
    pointerEvents: "auto"
  },
  tooltipArrowPositioner: {
    // `left` and `top`/`bottom` styles are provided dynamically.
    position: "absolute",
    zIndex: zindexTooltip,
    pointerEvents: "none"
  }
});

class TooltipPortal extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_mountNode", void 0);

    _defineProperty(this, "_tooltipPositioner", void 0);
  }

  // We mounted, so we should mount the TooltipPositioner! Create a node for
  // it, then mount it there.
  componentDidMount() {
    const mountNode = document.createElement("div");
    this._mountNode = mountNode;
    this.props.rootElement.appendChild(mountNode);

    this._renderInMountNode(mountNode);
  } // We updated, so we should update to the TooltipPositioner! Re-call
  // ReactDOM.render, which will trigger an update rather than a mount,
  // because the component is already mounted in that location.


  componentDidUpdate() {
    const mountNode = this._mountNode;

    if (!mountNode) {
      return;
    }

    this._renderInMountNode(mountNode);
  } // We unmounted, so we should unmount the TooltipPositioner! Ask React to
  // unmount it, then destroy the node we created.


  componentWillUnmount() {
    const mountNode = this._mountNode;

    if (!mountNode) {
      return;
    }

    ReactDOM__default["default"].unmountComponentAtNode(mountNode);
    this.props.rootElement.removeChild(mountNode);
  }

  remeasure() {
    this._tooltipPositioner && this._tooltipPositioner.remeasure();
  }

  _renderInMountNode(mountNode) {
    const {
      tooltipProps,
      dismiss,
      rootElement,
      targetElement,
      isAboveModal
    } = this.props; // TODO(LP-11406): Replace with React Portal
    // eslint-disable-next-line no-restricted-syntax

    ReactDOM__default["default"].render( /*#__PURE__*/React__namespace.createElement(TooltipPositioner, {
      tooltipProps: tooltipProps,
      dismiss: dismiss,
      rootElement: rootElement,
      targetElement: targetElement,
      isAboveModal: isAboveModal,
      ref: node => this._tooltipPositioner = node
    }), mountNode);
  }

  render() {
    return null;
  }

}

const DefaultPropValues = Object.freeze({
  side: "top",
  offset: 0,
  offsetFrom: "bubble",
  tooltipMargin: 0,
  noPadding: false,
  color: colors$1.gray17,
  inverted: false,
  dismissOnClickClose: false,
  toggleOnHover: true,
  showOnMount: false
});

class NewTooltip extends React__namespace.PureComponent {
  // The root element, where we'll mount tooltips.
  // The wrapper element that we created, to listen to mouse events.
  // The target element itself: the child of the wrapper, provided by the
  // caller.
  // Our child TooltipPortal instance. Used to pass down `remeasure` calls.
  // The VisibilityObserver, notifying us when the element enters or exits
  // total invisibility. Will be null iff the browser doesn't support the
  // necessary APIs.
  // Whether this component is mounted.
  // A timeout used in `componentDidMount`.
  constructor(props) {
    super(props);

    _defineProperty(this, "_rootElement", void 0);

    _defineProperty(this, "_wrapper", void 0);

    _defineProperty(this, "_targetElement", void 0);

    _defineProperty(this, "_tooltipPortal", void 0);

    _defineProperty(this, "_visibilityObserver", void 0);

    _defineProperty(this, "_isMounted", void 0);

    _defineProperty(this, "_targetElementMountTimeout", void 0);

    _defineProperty(this, "_handleVisibilityChange", targetElementIsVisible => {
      this.setState({
        targetElementIsVisible
      });
    });

    _defineProperty(this, "_handleMouseEnter", () => {
      this.setState({
        hovered: true
      });
    });

    _defineProperty(this, "_handleMouseLeave", () => {
      this.setState({
        hovered: false
      });
    });

    _defineProperty(this, "_handleDismiss", () => {
      if (this.props.dismissed == null) {
        // We're serving as an "uncontrolled component": our dismissed
        // state is managed by us, not by incoming props.
        this.setState({
          dismissed: true
        });
      }

      this.props.onDismiss && this.props.onDismiss();
    });

    this._isMounted = false;
    this.state = {
      dismissed: props.dismissed != null ? props.dismissed : false,
      hovered: false,
      targetElementIsVisible: false
    };
  }

  componentDidMount() {
    this._isMounted = true;

    this._registerVisibilityObserver();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (nextProps.dismissed != null) {
      // We're serving as a "controlled component": our dismissed state
      // always matches the incoming props.
      this.setState({
        dismissed: nextProps.dismissed
      });
    }
  }

  UNSAFE_componentWillUpdate() {
    // The component may receive a new root element via the context.
    // For example, we may get a modal root element that has become
    // available.
    this._registerVisibilityObserver();
  }

  componentWillUnmount() {
    this._isMounted = false;

    if (this._targetElementMountTimeout) {
      // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      clearTimeout(this._targetElementMountTimeout);
    }

    this._visibilityObserver.disconnect();
  }

  _findRootElement() {
    // In the Khan Academy webapp, the best place to mount is the
    // #outer-wrapper element, because it's our outermost scroll container.
    // But, if we're for some reason in a page without an #outer-wrapper,
    // then mounting at the body element is probably a good guess.
    // Also, if there is a modal anywhere in the context, it should be the
    // root because it obscures the visibility of the higher containers.
    //
    // HACK(davidflanagan):
    // Missions use a modal-like ../../tasks-package/task-container.jsx
    // component that does not work like our standard modal, so we handle
    // that with a special hardcoded case element id. When this component
    // is converted to a wonder block, we should upgrade Modal to use
    // the new context mechanism instead of the legacy mechanism and
    // replace this mission-task-container id with context.
    return this.context.modalContainerElement || document.getElementById("mission-task-container") || document.getElementById("outer-wrapper") || document.body;
  } // When this component mounts inside a modal, we don't have the modal
  // container in the context yet. That comes during the next cycle. If the
  // tooltip is in the modal, it will be observing with respect to the app
  // root for a moment (and won't display because it is obscured) and then
  // it will get called again on the next update because the context changes.
  // When it sees that the root is different, it will unregister the first
  // and register the new one.


  _registerVisibilityObserver() {
    const rootElement = this._findRootElement();

    if (!rootElement) {
      throw new PerseusError("Failed to mount NewTooltip: " + "we need a #outer-wrapper or document.body element.", Errors.Internal);
    }

    if (rootElement === this._rootElement) {
      return;
    }

    this._rootElement = rootElement;

    if (this._visibilityObserver) {
      this._visibilityObserver.disconnect();
    } // Create a VisibilityObserver, and start by assuming the target
    // element is invisible. On mount, we'll start observing the
    // target, and check whether it's visible.


    this._visibilityObserver = createVisibilityObserver(rootElement, this._handleVisibilityChange); // Find our target element. We do this by walking down the DOM tree,
    // until we find a node that doesn't have `data-tooltip-wrapper` on it.
    //
    // (This also enables us to compose tooltips: if you wrap an element
    // in multiple tooltips, we'll skip *all* the wrapper elements, and
    // find the correct element.)
    //
    // HACK(mdr): I'm not entirely satisfied with this :/ The whole tooltip
    //     composition "API" is a bit of a hack to support different
    //     tooltip props based on media query, and a *robust* way of
    //     specifying that would probably be preferable... but, in the
    //     meantime, I'd rather not invent new styling patterns (there's
    //     already enough fragmentation!), and instead write some
    //     well-encapsulated hacks that keep the public-facing API simple
    //     and low on new concepts.

    const wrapper = this._wrapper;

    if (!wrapper) {
      throw new PerseusError("NewTooltip expected a wrapper element after mount", Errors.Internal);
    }

    let targetElement = wrapper;

    while (targetElement.hasAttribute("data-tooltip-wrapper")) {
      targetElement = targetElement.childNodes[0];

      if (!targetElement) {
        throw new PerseusError("NewTooltip expected wrapper element to have a child", Errors.Internal);
      }
    }

    this._targetElement = targetElement; // Now that we've mounted, update our TooltipPortal (by re-rendering)
    // and our VisibilityObserver, so they can be aware of our new target
    // element.
    // TODO(jeff, WEB-1378): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax

    this._targetElementMountTimeout = setTimeout(() => {
      const targetElement = this._targetElement;

      if (!targetElement) {
        throw new PerseusError("NewTooltip should have a target element after mounting.", Errors.Internal);
      } // While we're here, let's also check whether the element is
      // block-like, as is required for position tracking to work. If
      // not, warn the developer - but in prod, skip this, because
      // it's slow.


      if (getDependencies().isDevServer) {
        if (getComputedStyle(targetElement).display === "inline") {
          Log.error("Warning: The children of a NewTooltip element " + "must be block-like, but this element seems " + "to have `display: inline`. This could break " + "position tracking.", Errors.Internal);
          Log.log("NewTooltip Target Element:", {
            targetElement: targetElement.outerHTML
          });
        }
      }

      this._visibilityObserver.setTargetElement(targetElement);

      this.forceUpdate();
    }, 0);
  }

  _shouldShowTooltip() {
    const {
      toggleOnHover,
      showOnMount
    } = this.props;
    const {
      dismissed,
      targetElementIsVisible
    } = this.state; // If the target element isn't visible, then we shouldn't show the
    // tooltip, regardless of configuration.

    if (targetElementIsVisible === false) {
      return false;
    } // If the tooltip was dismissed, or we're not sure yet, don't show it.


    if (dismissed) {
      return false;
    } // If the tooltip should show on mount, and nothing has changed yet
    // that would cause it to hide (i.e., the `dismissed` case above fell
    // through), show the tooltip.


    if (showOnMount) {
      return true;
    } // If the target is hovered, and our visibility is hover-based, show
    // the tooltip.


    if (toggleOnHover && this.state.hovered) {
      return true;
    }

    return false;
  }

  remeasure() {
    this._tooltipPortal && this._tooltipPortal.remeasure();
  }

  render() {
    const {
      children,
      toggleOnHover
    } = this.props;
    const {
      children: _,
      ...portalProps
    } = this.props;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$b.targetElement),
      onMouseEnter: toggleOnHover ? this._handleMouseEnter : undefined,
      onMouseLeave: toggleOnHover ? this._handleMouseLeave : undefined,
      ref: node => this._wrapper = node,
      "data-tooltip-wrapper": true,
      "data-test-id": "question-id"
    }, children, this._targetElement && this._shouldShowTooltip() && /*#__PURE__*/React__namespace.createElement(TooltipPortal, {
      tooltipProps: portalProps,
      dismiss: this._handleDismiss,
      rootElement: this._rootElement,
      targetElement: this._targetElement,
      isAboveModal: !!this.context.modalContainerElement,
      ref: node => this._tooltipPortal = node
    }));
  }

}

_defineProperty(NewTooltip, "defaultProps", DefaultPropValues);

NewTooltip.contextTypes = {
  modalContainerElement: PropTypes__default["default"].instanceOf(HTMLElement)
};
const styles$b = aphrodite.StyleSheet.create({
  targetElement: {
    // NOTE(mdr): By setting this container to `display: inline`, we avoid
    //     disrupting the call site's layout! Yay! Unfortunately, this
    //     requires other hacks in order to do position tracking; see the
    //     `cloneElement` call in `render`.
    display: "inline"
  }
});

class HighlightTooltip extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_tooltip", void 0);
  }

  componentDidUpdate(oldProps) {
    // If the highlight focus might've changed, then tell the tooltip to
    // remeasure itself. For "Add highlight", this happens when an existing
    // selection is updated, e.g., by using the Shift+RightArrow shortcut.
    // For "Remove highlight", this can happen when we quickly switch from
    // targeting one highlight to another: we reuse the same
    // HighlightTooltip instance, for improved performance.
    if (this.props.focusNode !== oldProps.focusNode || this.props.focusOffset !== oldProps.focusOffset || this.props.offsetParent !== oldProps.offsetParent) {
      var _this$_tooltip;

      (_this$_tooltip = this._tooltip) === null || _this$_tooltip === void 0 ? void 0 : _this$_tooltip.remeasure();
    }
  }

  _getFocusRect() {
    const {
      focusNode,
      focusOffset,
      offsetParent
    } = this.props; // Get a range of *just* the focus point of the selection.

    const focusRange = document.createRange();
    focusRange.setStart(focusNode, focusOffset);
    focusRange.setEnd(focusNode, focusOffset); // Then, get the bounding box of the collapsed range. This will be a
    // zero-width rectangle, but still have positioning information, which
    // we can use the position the tooltip.
    //
    // NOTE(mdr): If we used getClientBoundingRect here instead, Safari
    //     would return an unpositioned rect. But all tested browsers at
    //     time of writing (latest Chrome, Firefox, Safari) return at least
    //     one rectangle from getClientRects, and it's well-positioned.

    const focusRect = focusRange.getClientRects()[0]; // NOTE(mdr): ...except in the case where the focus is between two
    //     paragraphs, in which case the focus range has no client rects?
    //     Not sure why, or in what browsers (only noticed in Chrome 60),
    //     but let's catch that case and bail out.
    // TODO(mdr): Instead, we should somehow walk back the range until we
    //     find an appropriate position for the tooltip. Sounds tricky!

    if (!focusRect) {
      Log.log("[Highlighting] Known bug: Could not determine the focus " + 'position, so did not show an "Add Highlight" tooltip. ' + "https://app.asana.com/0/329800276300868/413878480039713 " + "(see also /r/asana-links)");
      return null;
    } // Compute the desired position of the tooltip relative to the offset
    // parent.


    const {
      left,
      top
    } = offsetParent.getBoundingClientRect();
    const relativeFocusRect = getRelativeRect({
      left: focusRect.left,
      top: focusRect.top,
      width: focusRect.width,
      height: focusRect.height
    }, {
      left,
      top
    });
    return relativeFocusRect;
  }

  render() {
    const focusRect = this._getFocusRect();

    if (!focusRect) {
      return null;
    }

    const content = /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$a.tooltipLabel)
    }, this.props.label);
    return /*#__PURE__*/React__namespace.createElement(NewTooltip, {
      content: content,
      color: colors$1.kaBlue,
      inverted: true,
      onClick: this.props.onClick,
      onMouseEnter: this.props.onMouseEnter,
      onMouseLeave: this.props.onMouseLeave,
      toggleOnHover: false,
      showOnMount: true,
      ref: e => this._tooltip = e
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        position: "absolute",
        left: focusRect.left,
        top: focusRect.top,
        height: focusRect.height
      }
    }));
  }

}

const styles$a = aphrodite.StyleSheet.create({
  tooltipLabel: {
    // Unlike most tooltip contents, we don't want this label to be
    // selectable. Selecting it is not only unhelpful, but dangerous: if
    // the user accidentally selects the "Add highlight" tooltip text, then
    // we lose our reference to the _actual_ text they want to highlight,
    // and the "Add highlight" action fails.
    userSelect: "none"
  }
});

class HighlightSetRenderer extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      hoveredHighlightKey: null,
      hoveringTooltipFor: null
    });

    _defineProperty(this, "_highlightRenderers", {});

    _defineProperty(this, "_handleMouseMove", e => {
      const mouseClientPosition = {
        left: e.clientX,
        top: e.clientY
      };

      const hoveredHighlightKey = this._getHoveredHighlightKey(mouseClientPosition);

      this.setState({
        hoveredHighlightKey
      });
    });
  }

  componentDidMount() {
    this._updateEditListeners(false, this.props.editable);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    this._updateEditListeners(this.props.editable, nextProps.editable); // If we were previously hovering over a highlight that has been
    // removed, reset the hover state accordingly.


    if (this.state.hoveredHighlightKey != null && !(this.state.hoveredHighlightKey in nextProps.highlights)) {
      this.setState({
        hoveredHighlightKey: null
      });
    } // Similarly, if we were previously hovering over the tooltip for a
    // highlight that has been removed, reset the hover state accordingly.


    if (this.state.hoveringTooltipFor != null && !(this.state.hoveringTooltipFor in nextProps.highlights)) {
      this.setState({
        hoveringTooltipFor: null
      });
    }
  }

  componentWillUnmount() {
    this._updateEditListeners(this.props.editable, false);
  }
  /**
   * Given whether we were previously listening to mousemove events, and
   * whether we will now listen to mousemove events, add or remove the
   * listener accordingly.
   */


  _updateEditListeners(wasListening, willListen) {
    if (!wasListening && willListen) {
      window.addEventListener("mousemove", this._handleMouseMove);
    } else if (wasListening && !willListen) {
      window.removeEventListener("mousemove", this._handleMouseMove); // Additionally, reset the hover state, to ensure that we don't
      // keep old hover state around.

      this.setState({
        hoveredHighlightKey: null,
        hoveringTooltipFor: null
      });
    }
  }

  _getHoveredHighlightKey(mouseClientPosition) {
    // If we're hovering over the tooltip, the hovered highlight is the
    // highlight that the tooltip is pointing to.
    const {
      hoveringTooltipFor
    } = this.state;

    if (typeof hoveringTooltipFor === "string") {
      return hoveringTooltipFor;
    } // Otherwise, check each highlight renderer to see whether the current
    // mouse position intersects any of the highlight rectangles.


    const highlightKeys = Object.keys(this.props.highlights);
    return highlightKeys.find(key => {
      const highlightRenderer = this._highlightRenderers[key];
      return highlightRenderer && highlightRenderer.isHovered(mouseClientPosition);
    });
  }

  _renderTooltip() {
    const {
      hoveredHighlightKey
    } = this.state;

    if (hoveredHighlightKey == null) {
      return null;
    }

    const hoveredHighlight = this.props.highlights[hoveredHighlightKey];
    return /*#__PURE__*/React__namespace.createElement(HighlightTooltip, {
      label: i18n__namespace._("Remove highlight"),
      focusNode: hoveredHighlight.domRange.endContainer,
      focusOffset: hoveredHighlight.domRange.endOffset,
      offsetParent: this.props.offsetParent,
      onClick: () => this.props.onRemoveHighlight(hoveredHighlightKey),
      onMouseEnter: () => this.setState({
        hoveringTooltipFor: hoveredHighlightKey
      }),
      onMouseLeave: () => this.setState({
        hoveringTooltipFor: null
      })
    });
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", null, Object.keys(this.props.highlights).map(key => /*#__PURE__*/React__namespace.createElement(HighlightRenderer, {
      ref: r => {
        if (r) {
          this._highlightRenderers[key] = r;
        } else {
          delete this._highlightRenderers[key];
        }
      },
      key: key,
      highlight: this.props.highlights[key],
      highlightKey: key,
      offsetParent: this.props.offsetParent,
      zIndexes: this.props.zIndexes
    })), this.props.editable && this._renderTooltip());
  }

}

class SelectionTracker extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      mouseState: "up",
      trackedSelection: null
    });

    _defineProperty(this, "_handleSelectionChange", () => {
      this._updateTrackedSelection(this.props.buildHighlight);

      if (this.state.mouseState === "down") {
        this.setState({
          mouseState: "down-and-selecting"
        });
      }
    });

    _defineProperty(this, "_handleMouseDown", () => {
      this.setState({
        mouseState: "down"
      });
    });

    _defineProperty(this, "_handleMouseUp", () => {
      this.setState({
        mouseState: "up"
      });
    });
  }

  componentDidMount() {
    this._updateListeners(false, this.props.enabled);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.buildHighlight !== nextProps.buildHighlight) {
      // The highlight-building function changed, so the
      // proposedHighlight we built with it might be different, or no
      // longer be valid. Update accordingly.
      this._updateTrackedSelection(nextProps.buildHighlight);
    }

    this._updateListeners(this.props.enabled, nextProps.enabled);
  }

  componentWillUnmount() {
    this._updateListeners(this.props.enabled, false);
  }

  _updateListeners(wasListening, willListen) {
    if (!wasListening && willListen) {
      window.addEventListener("mousedown", this._handleMouseDown);
      window.addEventListener("mouseup", this._handleMouseUp);
      document.addEventListener("selectionchange", this._handleSelectionChange);
    } else if (wasListening && !willListen) {
      window.removeEventListener("mousedown", this._handleMouseDown);
      window.removeEventListener("mouseup", this._handleMouseUp);
      document.removeEventListener("selectionchange", this._handleSelectionChange); // Additionally, reset the state, to guard against errors where we
      // re-enter listening mode and have stale values stored.

      this.setState({
        mouseState: "up",
        trackedSelection: null
      });
    }
  }
  /**
   * Get the current selection focus and range, if present and non-collapsed.
   *
   * Otherwise, if there is no current selection or it's collapsed, return
   * null.
   */


  _computeFocusAndRange() {
    const selection = document.getSelection();

    if (!selection || selection.rangeCount === 0) {
      return null;
    }

    const range = selection.getRangeAt(0);

    if (range.collapsed) {
      return null;
    } // NOTE(mdr): The focus node is guaranteed to exist, because
    //     there's a range, but the Flow type annotations for
    //     Selection don't know that. Cast it ourselves.


    const focusNode = selection.focusNode;
    const focusOffset = selection.focusOffset;
    return {
      focusNode,
      focusOffset,
      range
    };
  }
  /**
   * Compute the current TrackedSelection from the document state.
   */


  _computeTrackedSelection(buildHighlight) {
    const focusAndRange = this._computeFocusAndRange();

    if (!focusAndRange) {
      return null;
    }

    const {
      focusNode,
      focusOffset,
      range
    } = focusAndRange;
    const proposedHighlight = buildHighlight(range);

    if (!proposedHighlight) {
      return null;
    }

    return {
      focusNode,
      focusOffset,
      proposedHighlight
    };
  }
  /**
   * Update the TrackedSelection to reflect the document state.
   */


  _updateTrackedSelection(buildHighlight) {
    const trackedSelection = this._computeTrackedSelection(buildHighlight);

    this.setState({
      trackedSelection
    });
  }

  render() {
    const {
      mouseState,
      trackedSelection
    } = this.state;
    const userIsMouseSelecting = mouseState === "down-and-selecting";
    return this.props.children ? /*#__PURE__*/React__namespace.createElement("div", null, this.props.children(trackedSelection, userIsMouseSelecting)) : null;
  }

}

/**
 * This component, given a set of DOMHighlights, draws highlight rectangles in
 * the same absolute position as the highlighted content, as computed by the
 * range's `getClientRects` method.
 *
 * TODO(mdr): Many things can affect the correct positioning of highlighting,
 *     and this component does not attempt to anticipate them. If we start
 *     using this highlighting library on content with a more dynamic layout,
 *     we should add a hook to allow the parent to `forceUpdate` the
 *     `HighlightingUI`.
 */

class HighlightingUI extends React__namespace.PureComponent {
  _handleAddHighlight(highlightToAdd) {
    this.props.onAddHighlight(highlightToAdd); // Deselect the newly-highlighted text, by collapsing the selection
    // to the end of the range.

    const selection = document.getSelection();

    if (selection) {
      selection.collapseToEnd();
    }
  }

  _selectionIsValid(trackedSelection) {
    if (!trackedSelection) {
      return false;
    }

    const {
      contentNode
    } = this.props; // Create a range over the content node.

    const contentRange = new Range();
    contentRange.selectNodeContents(contentNode); // Create a range over the focus position.

    const focusRange = new Range();
    focusRange.setStart(trackedSelection.focusNode, trackedSelection.focusOffset);
    focusRange.collapse(true
    /* to start */
    ); // Determine whether the content range contains the focus, by checking
    // whether they intersect. Because the focus range is a single point,
    // intersection is equivalent to being fully contained.

    const contentContainsFocus = rangesOverlap(contentRange, focusRange); // If the content contains the focus, this is a valid selection. Some
    // parts of the range might go beyond the content, but that's okay; the
    // corresponding DOMHighlight is already trimmed to only contain valid
    // words. We're just checking that the tooltip we render will be inside
    // the content, because rendering a tooltip outside the content would
    // be weird.

    const selectionIsValid = contentContainsFocus;
    return selectionIsValid;
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement(SelectionTracker, {
      buildHighlight: this.props.buildHighlight,
      enabled: this.props.editable
    }, (trackedSelection, userIsMouseSelecting) => /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(HighlightSetRenderer, {
      editable:
      /* An existing highlight is editable when the
       * component is in editable mode, and there's no
       * selection in progress. */
      this.props.editable && !this._selectionIsValid(trackedSelection),
      highlights: this.props.highlights,
      offsetParent: this.props.offsetParent,
      onRemoveHighlight: this.props.onRemoveHighlight,
      zIndexes: this.props.zIndexes
    }), this._selectionIsValid(trackedSelection) && !userIsMouseSelecting && /*#__PURE__*/React__namespace.createElement(HighlightTooltip, {
      label: i18n__namespace._("Add highlight"),
      onClick: () => this._handleAddHighlight( // TODO(mdr): We found a new Flow error when upgrading:
      //     "proposedHighlight (Cannot get `trackedSelection.proposedHighlight` because property `proposedHighlight` is missing in null or undefined [1].)"
      // $FlowFixMe[incompatible-use](0.57.3->0.75.0)
      trackedSelection.proposedHighlight) // TODO(mdr): We found a new Flow error when upgrading:
      //     "focusNode (Cannot get `trackedSelection.focusNode` because property `focusNode` is missing in null or undefined [1].)"
      // $FlowFixMe[incompatible-use](0.57.3->0.75.0)
      ,
      focusNode: trackedSelection.focusNode // TODO(mdr): We found a new Flow error when upgrading:
      //     "focusOffset (Cannot get `trackedSelection.focusOffset` because property `focusOffset` is missing in null or undefined [1].)"
      // $FlowFixMe[incompatible-use](0.57.3->0.75.0)
      ,
      focusOffset: trackedSelection.focusOffset,
      offsetParent: this.props.offsetParent
    })));
  }

}

class WordIndexer extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_container", void 0);
  }

  /* eslint-enable react/sort-comp */
  componentDidMount() {
    this._sendWordsUpdate();
  }

  componentDidUpdate() {
    this._sendWordsUpdate();
  }

  _sendWordsUpdate() {
    this.props.onWordsUpdate(this._getWordRanges());
  }

  _getWordRanges() {
    const container = this._container;

    if (!container) {
      throw new PerseusError("invariant violation: `this._container` is not defined, but " + "this method is only called after mount/update", Errors.NotAllowed);
    } // Create a TreeWalker that visits text nodes and element nodes.
    // We select the types of nodes we're interested in by bitwise-ORing
    // the desired filters together.


    const treeWalker = container.ownerDocument.createTreeWalker(container, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, () => NodeFilter.FILTER_ACCEPT, false); // Traverse the container's descendant text nodes in DOM order,
    // indexing the words we find.

    const index = [];
    let trailingWordRange = null;

    while (treeWalker.nextNode()) {
      const node = treeWalker.currentNode;

      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;

        if (getComputedStyle(element).display !== "inline") {
          // Block-level elements interrupt text words, so set the
          // current trailing word to `null`.
          //
          // This includes exiting one paragraph to visit another,
          // but also includes text interrupted by inline-block
          // elements.
          //
          // TODO(mdr): Is this behavior *generalizably* correct?
          // TODO(mdr): I don't *fully* understand the performance
          //     implications of `getComputedStyle`, but I think it's
          //     gonna be nbd at the current call sites. If we try to
          //     generalize to frequently-updating content, we might
          //     want to watch this as a potential performance
          //     bottleneck.
          trailingWordRange = null;
        }
      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.nodeValue; // A "word" is here simply defined as a maximal-length
        // substring of non-space characters.
        //
        // Loop over all the words in the string, by repeatedly calling
        // `wordPattern.exec(text)`.

        const wordPattern = /\S+/g;
        let wordMatch;
        let newTrailingWordRange = null;

        while ((wordMatch = wordPattern.exec(text)) !== null) {
          // TODO(mdr): We found a new Flow error when upgrading:
          //     "index (Cannot get `wordMatch.index` because property `index` is missing in null [1].)"
          // $FlowFixMe[incompatible-use](0.57.3->0.75.0)
          const startOffset = wordMatch.index; // TODO(mdr): We found a new Flow error when upgrading:
          //     "index (Cannot get `wordMatch.index` because property `index` is missing in null [1].)", "0 (Cannot get `wordMatch[0]` because an indexer property is missing in null [1].)"
          // $FlowFixMe[incompatible-use](0.57.3->0.75.0)

          const endOffset = wordMatch.index + wordMatch[0].length;
          let range;

          if (startOffset === 0 && trailingWordRange) {
            // This word is at the start of this text node, and
            // there's a trailing word from the previous text node,
            // and there was no non-inline element between them.
            // This word and the trailing word are probably
            // intended to be two parts of the same word.
            //
            // So, instead of creating a new word range, we add
            // this word to the previous range by extending it.
            range = trailingWordRange;
            range.setEnd(node, endOffset);
          } else {
            // Otherwise, start a new word range here, and add it
            // to the list.
            range = node.ownerDocument.createRange();
            range.setStart(node, startOffset);
            range.setEnd(node, endOffset);
            index.push(range);
          }

          if (endOffset === text.length) {
            newTrailingWordRange = range;
          }
        }

        trailingWordRange = newTrailingWordRange;
      }
    }

    return index;
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      ref: container => this._container = container
    }, this.props.children);
  }

}

class HighlightableContent extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_container", void 0);

    _defineProperty(this, "_content", void 0);

    _defineProperty(this, "state", {
      wordRanges: []
    });

    _defineProperty(this, "_handleAddHighlight", highlight => {
      const newDomHighlights = addHighlight(this._getDOMHighlights(), highlight);
      const newSerializedHighlights = {};

      for (const key of Object.keys(newDomHighlights)) {
        newSerializedHighlights[key] = serializeHighlight(newDomHighlights[key]);
      }

      this.props.onSerializedHighlightsUpdate(newSerializedHighlights);
    });

    _defineProperty(this, "_handleRemoveHighlight", keyToRemove => {
      const {
        serializedHighlights
      } = this.props;
      const newSerializedHighlights = { ...serializedHighlights
      };
      delete newSerializedHighlights[keyToRemove];
      this.props.onSerializedHighlightsUpdate(newSerializedHighlights);
    });

    _defineProperty(this, "_handleWordsUpdate", wordRanges => {
      this.setState({
        wordRanges
      });
    });
  }

  _buildHighlight(highlightRange) {
    // TODO(mdr): If _buildHighlight starts getting called more often, we
    //     might want to cache the DOMHighlightSet instead of recomputing
    //     it here.
    return buildHighlight(this._getDOMHighlights(), this.state.wordRanges, highlightRange);
  }
  /**
   * Take the highlights from props, and deserialize them into DOMHighlights,
   * according to the latest cache of word ranges.
   */


  _getDOMHighlights() {
    const {
      serializedHighlights
    } = this.props;
    const {
      wordRanges
    } = this.state;
    const domHighlights = {};

    for (const key of Object.keys(serializedHighlights)) {
      domHighlights[key] = deserializeHighlight(serializedHighlights[key], wordRanges);
    }

    return domHighlights;
  }
  /**
   * Add the given DOMHighlight to the current set.
   */


  render() {
    const highlights = this._getDOMHighlights(); // NOTE(mdr): This lambda is rebuilt every time this component updates,
    //     so every update to HighlightableContent triggers an update in
    //     the child HighlightingUI and SelectionTracker, even if the
    //     behavior hasn't changed.
    //
    //     Over-updating is preferable to under-updating here, because some
    //     updates in this component's props/state *do* affect
    //     `buildHighlight`'s behavior, and *should* trigger an update.
    //
    //     A more performant approach would be to cache this function
    //     object until its implicitly-bound inputs change. If profiling
    //     leads us to implement such caching, this draft might be a good
    //     starting point: https://phabricator.khanacademy.org/D35623?id=170698


    const buildHighlight = r => this._buildHighlight(r);

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$9.container),
      ref: container => this._container = container
    }, /*#__PURE__*/React__namespace.createElement("div", null, this.props.enabled && this._container && this._content && /*#__PURE__*/React__namespace.createElement(HighlightingUI, {
      buildHighlight: buildHighlight,
      contentNode: this._content,
      editable: this.props.editable,
      highlights: highlights,
      offsetParent: this._container,
      zIndexes: {
        // The content has a z-index of 1, so, to
        // be below the content, use z-index of 0.
        //
        // TODO(mdr): Is this way of passing around
        //     `z-index: 0` actually worth the
        //     trouble? We used to have more, but
        //     now we don't need them...
        belowContent: 0
      },
      onAddHighlight: this._handleAddHighlight,
      onRemoveHighlight: this._handleRemoveHighlight
    })), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$9.content),
      ref: content => this._content = content
    }, /*#__PURE__*/React__namespace.createElement(WordIndexer, {
      onWordsUpdate: this._handleWordsUpdate
    }, this.props.children)));
  }

}

const styles$9 = aphrodite.StyleSheet.create({
  // We render content with z-index 1, and highlights with z-index 0, so that
  // content will receive the browser's native pointer events. (Highlights
  // have their own magic code to manage hover detection, despite being
  // behind the content.)
  container: {
    // Position the container and give it a z-index, to scope the z-indexes
    // inside by creating a stacking context.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
    //
    // This way, content's z-index of 1, and highlights' z-index of 0, and
    // tooltips' z-index of 2 don't interact with anything external;
    // external UI will see `HighlightableContent` as a single flat layer
    // with a z-index of 0. This removes the need for us to coordinate our
    // choices of z-index with external UI.
    position: "relative",
    zIndex: 0
  },
  content: {
    // NOTE(mdr): Creating a stacking context for content of z-index 1 may
    //    be problematic if the content and external page want to
    //    interleave layers between each other, e.g., if the application UI
    //    wants to render something above some parts of our content, but
    //    below other parts. It's not relevant for the current Passage-only
    //    call site, but could be relevant someday
    position: "relative",
    zIndex: 1
  }
});

const getLineHeightForNode = ($line1, $line2) => {
  return $line2.offset().top - $line1.offset().top;
};

const START_REF_PREFIX = "start-ref-";
const END_REF_PREFIX = "end-ref-";
const REF_STYLE = {
  display: "inline-block",
  width: 0,
  visibility: "hidden"
};
const LABEL_OUTER_STYLE = {
  // for some reason we need these to keep the nbsp from wrapping when the
  // inner circle/square is display: inline-block
  display: "inline",
  whiteSpace: "nowrap"
};
const SQUARE_LABEL_STYLE = {
  display: "inline-block",
  color: "rgb(255, 255, 255)",
  backgroundColor: "rgb(90, 90, 90)",
  paddingLeft: 10,
  paddingRight: 10,
  userSelect: "none",
  WebkitUserSelect: "none"
};
const CIRCLE_LABEL_STYLE = {
  display: "inline-block",
  color: "rgb(255, 255, 255)",
  backgroundColor: "rgb(90, 90, 90)",
  userSelect: "none",
  WebkitUserSelect: "none",
  width: 22,
  height: 22,
  borderRadius: "50%",
  textAlign: "center"
};

class RefStart extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "getRefContent", () => {
      return this.props.refContent;
    });
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("span", {
      style: REF_STYLE
    }, i18n__namespace.doNotTranslate("_"));
  }

}

_defineProperty(RefStart, "propTypes", {
  refContent: PropTypes__default["default"].node.isRequired
});

class RefEnd extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement("span", {
      style: REF_STYLE
    }, i18n__namespace.doNotTranslate("_"));
  }

}

const rules = {
  // $FlowFixMe[prop-missing]
  // $FlowFixMe[incompatible-use]
  newline: SimpleMarkdown__default["default"].defaultRules.newline,
  // $FlowFixMe[prop-missing]
  // $FlowFixMe[incompatible-use]
  paragraph: SimpleMarkdown__default["default"].defaultRules.paragraph,
  // $FlowFixMe[prop-missing]
  // $FlowFixMe[incompatible-use]
  escape: SimpleMarkdown__default["default"].defaultRules.escape,
  passageFootnote: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.1,
    // $FlowFixMe[prop-missing]
    match: SimpleMarkdown__default["default"].inlineRegex(/^\^/),
    parse: (capture, parse, state) => {
      // if no footnotes have been seen, we're id 1. otherwise,
      // we're the next subsequent id
      const id = state.lastFootnote.id + 1;
      const footnote = {
        id: id,
        // our text is what to output. if there is only one footnote,
        // it's a *; otherwise it's a superscript number
        text: id === 1 ? "*" : "" + id
      }; // If the previous footnote was a *, we need to adjust it to be
      // a number, since now we know there is more than one footnote

      if (state.lastFootnote.text === "*") {
        state.lastFootnote.text = "" + state.lastFootnote.id;
      } // and update our last footnote, + return.


      state.lastFootnote = footnote;
      return footnote;
    },
    react: (node, output, state) => {
      return /*#__PURE__*/React__namespace.createElement("sup", {
        key: state.key
      }, node.text);
    }
  },
  refStart: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.2,
    match: function (source, state) {
      const capture = /^\{\{/.exec(source);

      if (capture) {
        // We need to do extra processing here to capture the
        // full text of the reference, which we include so that
        // we can use that information as a screenreader
        let closeIndex = 2; // start looking after the opening "{{"

        let refNestingLevel = 0; // Find the closing "}}" for our opening "{{"

        while (closeIndex < source.length) {
          const token = source.slice(closeIndex, closeIndex + 2);

          if (token === "{{") {
            refNestingLevel++; // increment an extra character so we get the
            // full 2-char token

            closeIndex++;
          } else if (token === "}}") {
            if (refNestingLevel > 0) {
              refNestingLevel--; // increment an extra character so we get the
              // full 2-char token

              closeIndex++;
            } else {
              break;
            }
          }

          closeIndex++;
        }

        const refText = source.slice(2, closeIndex); // A "magic" capture that matches the opening {{
        // but captures the full ref text internally :D

        return [capture[0], refText];
      }

      return null;
    },
    parse: (capture, parse, state) => {
      if (!state.useRefs) {
        return {
          ref: null,
          refContent: null
        };
      }

      const ref = state.lastRef + 1;
      state.lastRef = ref;
      state.currentRef.push(ref);
      const refContent = parse( // Curly quotes
      "(\u201C" + capture[1] + "\u201D)\n\n", ___default["default"].defaults({
        // We don't want to parse refs while looking through
        // this refs contents. We definitely don't want
        // to make those refs into react refs on the
        // passage, for instance!
        useRefs: false
      }, INITIAL_PARSE_STATE));
      return {
        ref: ref,
        refContent: refContent
      };
    },
    react: (node, output, state) => {
      if (node.ref == null) {
        return null;
      } // We don't pass state here because this is parsed
      // and output out-of-band. We don't want to affect
      // our state by the double-output here :).


      const refContent = output(node.refContent, {});
      return /*#__PURE__*/React__namespace.createElement(RefStart, {
        ref: START_REF_PREFIX + node.ref,
        key: START_REF_PREFIX + node.ref,
        refContent: refContent
      });
    }
  },
  refEnd: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.3,
    // $FlowFixMe[prop-missing]
    match: SimpleMarkdown__default["default"].inlineRegex(/^\}\}/),
    parse: (capture, parse, state) => {
      if (!state.useRefs) {
        return {
          ref: null
        };
      }

      const ref = state.currentRef.pop() || null;
      return {
        ref: ref
      };
    },
    react: (node, output, state) => {
      if (node.ref != null) {
        return /*#__PURE__*/React__namespace.createElement(RefEnd, {
          ref: END_REF_PREFIX + node.ref,
          key: END_REF_PREFIX + node.ref
        });
      } // if we didn't have a matching start reference, or
      // we aren't parsing refs for this pass (we do this
      // inside of refContent), don't output a ref


      return null;
    }
  },
  squareLabel: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.4,
    // $FlowFixMe[prop-missing]
    match: SimpleMarkdown__default["default"].inlineRegex(/^\[\[(\w+)\]\]( *)/),
    parse: (capture, parse, state) => {
      if (!state.firstQuestionRef) {
        state.firstQuestionRef = capture[1];
      }

      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: "visual-square",
        className: "perseus-passage-square-label",
        style: LABEL_OUTER_STYLE,
        "aria-hidden": "true"
      }, /*#__PURE__*/React__namespace.createElement("span", {
        style: SQUARE_LABEL_STYLE
      }, node.content)), /*#__PURE__*/React__namespace.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, i18n__namespace.$_("[Marker for question %(number)s]", {
        number: node.content
      })), node.space ? "\u00A0" : null];
    }
  },
  circleLabel: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.5,
    // $FlowFixMe[prop-missing]
    match: SimpleMarkdown__default["default"].inlineRegex(/^\(\((\w+)\)\)( *)/),
    parse: (capture, parse, state) => {
      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: "visual-circle",
        className: "perseus-passage-circle-label",
        style: LABEL_OUTER_STYLE,
        "aria-hidden": true
      }, /*#__PURE__*/React__namespace.createElement("span", {
        style: CIRCLE_LABEL_STYLE
      }, node.content)), /*#__PURE__*/React__namespace.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, i18n__namespace.$_("[Circle marker %(number)s]", {
        number: node.content
      })), node.space ? "\u00A0" : null];
    }
  },
  squareBracketRef: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.6,
    // $FlowFixMe[prop-missing]
    match: SimpleMarkdown__default["default"].inlineRegex(/^\[(\d+)\]( *)/),
    parse: (capture, parse, state) => {
      if (!state.firstSentenceRef) {
        state.firstSentenceRef = capture[1];
      }

      return {
        content: capture[1],
        space: capture[2].length > 0
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: "visual-brackets",
        className: "perseus-passage-bracket-label",
        "aria-hidden": "true"
      }, "[", node.content, "]"), /*#__PURE__*/React__namespace.createElement("span", {
        key: "alt-text",
        className: "perseus-sr-only"
      }, i18n__namespace.$_("[Sentence %(number)s]", {
        number: node.content
      })), node.space ? "\u00A0" : null];
    }
  },
  highlight: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.7,
    // $FlowFixMe[prop-missing]
    match: SimpleMarkdown__default["default"].inlineRegex(/^{highlighting.start}(.+?){highlighting.end}/),
    parse: (capture, parse, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: 0,
        className: "perseus-highlight"
      }, node.content)];
    }
  },
  reviewHighlight: {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    order: SimpleMarkdown__default["default"].defaultRules.escape.order + 0.7,
    // $FlowFixMe[prop-missing]
    match: SimpleMarkdown__default["default"].inlineRegex(/^{review-highlighting.start}(.+?){review-highlighting.end}/),
    parse: (capture, parse, state) => {
      return {
        content: capture[1]
      };
    },
    react: (node, output, state) => {
      return [/*#__PURE__*/React__namespace.createElement("span", {
        key: 0,
        className: "perseus-review-highlight"
      }, node.content)];
    }
  },
  // $FlowFixMe[prop-missing]
  // $FlowFixMe[incompatible-use]
  strong: SimpleMarkdown__default["default"].defaultRules.strong,
  // $FlowFixMe[prop-missing]
  // $FlowFixMe[incompatible-use]
  u: SimpleMarkdown__default["default"].defaultRules.u,
  // $FlowFixMe[prop-missing]
  // $FlowFixMe[incompatible-use]
  em: SimpleMarkdown__default["default"].defaultRules.em,
  // $FlowFixMe[prop-missing]
  // $FlowFixMe[incompatible-use]
  del: SimpleMarkdown__default["default"].defaultRules.del,
  text: { // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-use]
    ...SimpleMarkdown__default["default"].defaultRules.text,

    react(node, output, state) {
      return /*#__PURE__*/React__namespace.createElement("span", {
        key: state.key
      }, node.content);
    }

  }
};
const INITIAL_PARSE_STATE = {
  currentRef: [],
  useRefs: true,
  lastRef: 0,
  lastFootnote: {
    id: 0,
    text: ""
  }
}; // $FlowFixMe[prop-missing]

const builtParser = SimpleMarkdown__default["default"].parserFor(rules);

const parse = (source, state) => {
  state = state || {};
  const paragraphedSource = source + "\n\n";
  return builtParser(paragraphedSource, ___default["default"].extend(state, INITIAL_PARSE_STATE));
};

var PassageMarkdown = {
  parse: parse,
  // $FlowFixMe[prop-missing]
  output: SimpleMarkdown__default["default"].reactFor( // $FlowFixMe[prop-missing]
  SimpleMarkdown__default["default"].ruleOutput(rules, "react")),
  START_REF_PREFIX: START_REF_PREFIX,
  END_REF_PREFIX: END_REF_PREFIX,
  _rulesForTesting: rules
};

// A fake paragraph to measure the line height of the passage. In CSS we always
// set the line height to 22 pixels, but when using the browser zoom feature,
// the line height often ends up being a fractional number of pixels close to
// 22 pixels.
class LineHeightMeasurer extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_cachedLineHeight", void 0);

    _defineProperty(this, "$body", void 0);

    _defineProperty(this, "$end", void 0);
  }

  measureLineHeight() {
    if (typeof this._cachedLineHeight !== "number") {
      this.forceMeasureLineHeight();
    }

    return this._cachedLineHeight;
  }

  forceMeasureLineHeight() {
    // Add some text which magically fills an entire line.
    this.$body.text(" \u0080"); // Now, the line height is the difference between the top of the
    // second line and the top of the first line.

    this._cachedLineHeight = getLineHeightForNode(this.$body, this.$end); // Clear out the first line so it doesn't overlap the passage.

    this.$body.text("");
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$8.measurer)
    }, /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("div", {
      ref: e => this.$body = $__default["default"](e),
      className: "paragraph"
    }), /*#__PURE__*/React__namespace.createElement("div", {
      ref: e => this.$end = $__default["default"](e)
    })));
  }

}

const styles$8 = aphrodite.StyleSheet.create({
  measurer: {
    position: "absolute",
    width: "100%",
    top: 0,
    left: 0
  }
});

class Passage extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_onResize", void 0);

    _defineProperty(this, "_lineHeightMeasurer", void 0);

    _defineProperty(this, "_stylesAppiedTimer", void 0);

    _defineProperty(this, "state", {
      nLines: null,
      startLineNumbersAfter: 0,
      stylesAreApplied: false
    });

    _defineProperty(this, "_handleSerializedHighlightsUpdate", serializedHighlights => {
      this.props.onChange({
        highlights: serializedHighlights
      });
    });
  }

  componentDidMount() {
    this._updateState();

    this._onResize = ___default["default"].throttle(() => {
      // If we're rendering JIPT text, we won't have line numbers or a
      // line height measurer, so skip handling this resize.
      if (this.shouldRenderJipt()) {
        return;
      } // Remeasure the line height on resize, because the only line
      // height changes we expect are subpixel changes when the user
      // zooms in/out, and the only way to listen for zoom events is to
      // listen for resize events.


      this._lineHeightMeasurer.forceMeasureLineHeight();

      this._updateState();
    }, 500);
    window.addEventListener("resize", this._onResize); // Wait for Aphrodite styles (which are guaranteed to apply after one
    // tick), then set state.
    //
    // This flag is used to set the `enabled` prop of the
    // `HighlightableContent` component. That way, we only show highlights
    // once styles are ready, and they're measured with the correct
    // position.
    //
    // HACK(mdr): It's not really the Passage's Aphrodite styles that are
    //     causing bad measures, but more so the Khan Academy Test Prep
    //     app's Aphrodite styles. We would ideally instead offer the
    //     embedding application an API to signal that the app's layout has
    //     changed in a way that affects the Renderer... but, for now, just
    //     hardcode this hack into here.
    // TODO(somewhatabstract): Use WB timing
    // eslint-disable-next-line no-restricted-syntax

    this._stylesAppiedTimer = window.setTimeout(() => {
      this.setState({
        stylesAreApplied: true
      });
    }, 0);
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !___default["default"].isEqual(this.props, nextProps) || !___default["default"].isEqual(this.state, nextState);
  }

  componentDidUpdate() {
    this._updateState();
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this._onResize); // eslint-disable-next-line no-restricted-syntax

    clearTimeout(this._stylesAppiedTimer);
  }

  /**
   * Line numbering
   *
   * These functions support passage line numbering, which is non-trivial
   * because we manually measure lines to support resizing as well as
   * continuing line numbers from previous passages.
   */
  _updateState() {
    // If we're rendering JIPT text, we're not rendering line numbers so we
    // don't need to update this state.
    if (this.shouldRenderJipt()) {
      return;
    }

    this.setState({
      nLines: this._measureLines(),
      startLineNumbersAfter: this._getInitialLineNumber()
    });
  }

  _measureLines() {
    // eslint-disable-next-line react/no-string-refs
    const $renderer = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.content));
    const contentsHeight = $renderer.height();

    const lineHeight = this._getLineHeight();

    const nLines = Math.round(contentsHeight / lineHeight);
    return nLines;
  }

  _getInitialLineNumber() {
    let isPassageBeforeThisPassage = true;
    const passagesBeforeUs = this.props.findWidgets((id, widgetInfo) => {
      if (widgetInfo.type !== "passage") {
        return false;
      }

      if (id === this.props.widgetId) {
        isPassageBeforeThisPassage = false;
      }

      return isPassageBeforeThisPassage;
    });
    return passagesBeforeUs.map(passageWidget => {
      return passageWidget.getLineCount();
    }).reduce((a, b) => a + b, 0);
  }

  _getLineHeight() {
    return this._lineHeightMeasurer.measureLineHeight();
  }

  getLineCount() {
    if (this.state.nLines != null) {
      return this.state.nLines;
    }

    return this._measureLines();
  }
  /**
   * Passage refs
   *
   * These are functions to support the passage refs inter-widgets feature
   * where other widgets can fetch the line numbers of a reference inside of
   * a passage.
   */


  _getStartRefLineNumber(referenceNumber) {
    const refRef = PassageMarkdown.START_REF_PREFIX + referenceNumber; // eslint-disable-next-line react/no-string-refs

    const ref = this.refs[refRef];

    if (!ref) {
      return null;
    }

    const $ref = $__default["default"](ReactDOM__default["default"].findDOMNode(ref)); // We really care about the first text after the ref, not the
    // ref element itself:

    let $refText = $ref.next();

    if ($refText.length === 0) {
      // But if there are no elements after the ref, just
      // use the ref itself.
      $refText = $ref;
    }

    const vPos = $refText.offset().top;
    return this.state.startLineNumbersAfter + 1 + this._convertPosToLineNumber(vPos);
  }

  _getEndRefLineNumber(referenceNumber) {
    const refRef = PassageMarkdown.END_REF_PREFIX + referenceNumber; // eslint-disable-next-line react/no-string-refs

    const ref = this.refs[refRef];

    if (!ref) {
      return null;
    }

    const $ref = $__default["default"](ReactDOM__default["default"].findDOMNode(ref)); // We really care about the last text before the ref, not the
    // ref element itself:

    let $refText = $ref.prev();

    if ($refText.length === 0) {
      // But if there are no elements before the ref, just
      // use the ref itself.
      $refText = $ref;
    }

    const height = $refText.height();
    const vPos = $refText.offset().top;

    let line = this._convertPosToLineNumber(vPos + height);

    if (height === 0) {
      // If the element before the end ref span was the start
      // ref span, it might have 0 height. This is obviously not
      // the intended use case, but we should handle it gracefully.
      // If this is the case, then the "bottom" of our element is
      // actually the top of the line we're on, so we need to add
      // one to the line number.
      line += 1;
    }

    return this.state.startLineNumbersAfter + line;
  }

  _convertPosToLineNumber(absoluteVPos) {
    // eslint-disable-next-line react/no-string-refs
    const $content = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.content));
    const relativeVPos = absoluteVPos - $content.offset().top;

    const lineHeight = this._getLineHeight();

    const line = Math.round(relativeVPos / lineHeight);
    return line;
  }

  _getRefContent(referenceNumber) {
    const refRef = PassageMarkdown.START_REF_PREFIX + referenceNumber; // eslint-disable-next-line react/no-string-refs

    const ref = this.refs[refRef];

    if (!ref) {
      return null;
    }

    return ref.getRefContent();
  }

  getReference(referenceNumber) {
    const refStartLine = this._getStartRefLineNumber(referenceNumber);

    const refEndLine = this._getEndRefLineNumber(referenceNumber);

    if (refStartLine == null || refEndLine == null) {
      return null;
    }

    const refContent = this._getRefContent(referenceNumber);

    return {
      startLine: refStartLine,
      endLine: refEndLine,
      content: refContent
    };
  }
  /**
   * Misc functions
   *
   * These are misc widget functions used for the widget API
   */


  getUserInput() {
    return null;
  }

  simpleValidate(rubric) {
    return Passage.validate(this.getUserInput(), rubric);
  }
  /* eslint-disable react/sort-comp */


  static validate(state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
  /* eslint-enable react/sort-comp */

  /**
   * Rendering
   *
   * Functions to render the passage widget.
   */


  _renderInstructions(parseState) {
    const firstQuestionNumber = parseState.firstQuestionRef;
    const firstSentenceRef = parseState.firstSentenceRef;
    let instructions = "";

    if (firstQuestionNumber) {
      instructions += i18n__namespace._("The symbol %(questionSymbol)s indicates that question " + "%(questionNumber)s references this portion of the " + "passage.", {
        questionSymbol: "[[" + firstQuestionNumber + "]]",
        questionNumber: firstQuestionNumber
      });
    }

    if (firstSentenceRef) {
      instructions += i18n__namespace._(" The symbol %(sentenceSymbol)s indicates that the " + "following sentence is referenced in a question.", {
        sentenceSymbol: "[" + firstSentenceRef + "]"
      });
    }

    const parsedInstructions = PassageMarkdown.parse(instructions);
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-passage-instructions"
    }, PassageMarkdown.output(parsedInstructions));
  }

  shouldRenderJipt() {
    // Mostly copied from `renderer.jsx`. If we're doing JIPT, we want to
    // render our content differently.
    const {
      JIPT
    } = getDependencies();
    return JIPT.useJIPT && this.props.passageText.indexOf("crwdns") !== -1;
  }

  _renderContent(parsed) {
    // Wait until Aphrodite styles are applied before enabling highlights,
    // so that we measure the correct positions.
    const enabled = this.state.stylesAreApplied; // Highlights are read-only in review mode.

    const editable = !this.props.reviewModeRubric;
    return /*#__PURE__*/React__namespace.createElement(HighlightableContent, {
      editable: editable,
      enabled: enabled,
      onSerializedHighlightsUpdate: this._handleSerializedHighlightsUpdate,
      serializedHighlights: this.props.highlights
    }, /*#__PURE__*/React__namespace.createElement("div", {
      ref: "content"
    }, /*#__PURE__*/React__namespace.createElement(LineHeightMeasurer // TODO(mdr): We found a new Flow error when upgrading:
    //     "e (null) This type is incompatible with this._lineHeightMeasurer (LineHeightMeasurer)"
    // $FlowFixMe[incompatible-type](0.52.0->0.53.0)
    , {
      ref: e => this._lineHeightMeasurer = e
    }), PassageMarkdown.output(parsed)));
  }

  _hasFootnotes() {
    const rawContent = this.props.footnotes;
    const isEmpty = /^\s*$/.test(rawContent);
    return !isEmpty;
  }

  _renderFootnotes() {
    const rawContent = this.props.footnotes;
    const parsed = PassageMarkdown.parse(rawContent);
    return PassageMarkdown.output(parsed);
  }

  render() {
    let lineNumbers;
    const nLines = this.state.nLines;

    if (this.props.showLineNumbers && nLines) {
      // lineN is the line number in the current passage
      // lineAt is the actual line number across multiple passages
      lineNumbers = ___default["default"].range(1, nLines + 1).map(lineN => {
        const lineAt = lineN + this.state.startLineNumbersAfter;

        if (lineAt === 4) {
          // we leave a space in i18n to disambiguate translations, see TP-5392
          // I18N: a label next to a reading passage to denote the line number
          const translatedLine = i18n__namespace._("Line ");

          return /*#__PURE__*/React__namespace.createElement("span", {
            key: "line-marker",
            className: "line-marker"
          }, translatedLine);
        }

        return /*#__PURE__*/React__namespace.createElement("span", {
          key: lineN
        }, lineAt);
      });
    }

    const parseState = {
      firstSentenceRef: null,
      firstQuestionRef: null
    }; // Replace the vertical double quote characters quoting text with
    // an unicode left and right double quote characters. This would
    // avoid rendering right or left unicode double quotes on both
    // ends of a sentence wrapped by double quotes.

    const re = /("{1})([^"]*)("{1})/g;
    const doubleQuoteParsedContent = this.props.passageText.replace(re, "\u201c$2\u201d");
    const parsedContent = PassageMarkdown.parse(doubleQuoteParsedContent, parseState); // Check if the title has any non-empty text in it.

    const hasTitle = /\S/.test(this.props.passageTitle);
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-passage-container"
    }, this._renderInstructions(parseState), /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-passage"
    }, hasTitle && /*#__PURE__*/React__namespace.createElement("h3", {
      className: "passage-title"
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      content: this.props.passageTitle,
      linterContext: this.props.linterContext
    })), lineNumbers && /*#__PURE__*/React__namespace.createElement("div", {
      className: "line-numbers",
      "aria-hidden": true
    }, lineNumbers), !hasTitle && /*#__PURE__*/React__namespace.createElement("h3", {
      className: "perseus-sr-only"
    }, i18n__namespace._("Beginning of reading passage.")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "passage-text"
    }, this.shouldRenderJipt() ?
    /*#__PURE__*/
    // If we're in JIPT mode, just pass off our
    // content to a <Renderer /> which knows how
    // to handle rendering JIPT text.
    React__namespace.createElement(Renderer, {
      content: this.props.passageText
    }) : this._renderContent(parsedContent)), this._hasFootnotes() && [/*#__PURE__*/React__namespace.createElement("h4", {
      key: "footnote-start",
      className: "perseus-sr-only"
    }, i18n__namespace._("Beginning of reading passage footnotes.")), /*#__PURE__*/React__namespace.createElement("div", {
      key: "footnotes",
      className: "footnotes"
    }, this._renderFootnotes())], /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-sr-only"
    }, i18n__namespace._("End of reading passage.")))));
  }

}

_defineProperty(Passage, "defaultProps", {
  passageTitle: "",
  passageText: "",
  footnotes: "",
  showLineNumbers: true,
  highlights: {},
  linterContext: PerseusLinter.linterContextDefault
});

var Passage$1 = {
  name: "passage",
  displayName: "Passage (SAT only)",
  widget: Passage,
  transform: editorProps => {
    return ___default["default"].pick(editorProps, "passageTitle", "passageText", "footnotes", "showLineNumbers");
  },
  isLintable: true
};

const {
  deepEq: deepEq$1
} = Util;
const BAR = "bar",
      LINE = "line",
      PIC = "pic",
      HISTOGRAM = "histogram",
      DOTPLOT = "dotplot";
({
  type: PropTypes__default["default"].oneOf([BAR, LINE, PIC, HISTOGRAM, DOTPLOT]),
  labels: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  categories: PropTypes__default["default"].arrayOf(PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string])),
  scaleY: PropTypes__default["default"].number,
  maxY: PropTypes__default["default"].number,
  snapsPerLine: PropTypes__default["default"].number,
  picSize: PropTypes__default["default"].number,
  pixBoxHeight: PropTypes__default["default"].number,
  picUrl: PropTypes__default["default"].string,
  plotDimensions: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  labelInterval: PropTypes__default["default"].number,
  starting: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  static: PropTypes__default["default"].bool
});

class Plotter extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "shouldSetupGraphie", void 0);

    _defineProperty(this, "_isMounted", false);

    _defineProperty(this, "horizHairline", void 0);

    _defineProperty(this, "hairlineRange", void 0);

    _defineProperty(this, "graphie", void 0);

    _defineProperty(this, "state", {
      values: this.props.starting || [1],
      // The measured rendered height of category strings. Used to calculate
      // bottom padding of plot, to prevent categories from overlapping the
      // bottom label.
      categoryHeights: {}
    });

    _defineProperty(this, "DOT_PLOT_POINT_SIZE", () => {
      return this.props.apiOptions.isMobile ? 6 : 4;
    });

    _defineProperty(this, "DOT_PLOT_POINT_PADDING", () => {
      return 8;
    });

    _defineProperty(this, "DOT_TICK_POINT_SIZE", () => {
      return 2;
    });

    _defineProperty(this, "setupGraphie", prevState => {
      const self = this;
      self.shouldSetupGraphie = false;
      const graphieDiv = ReactDOM__default["default"].findDOMNode(self.refs.graphieDiv);
      $__default["default"](graphieDiv).empty();
      const graphie = GraphUtils.createGraphie(graphieDiv); // TODO(jakesandlund): It's not the react way to hang
      // something off the component object, but since graphie
      // is outside React, it makes it easier to do this.

      self.graphie = graphie;
      self.graphie.pics = [];
      self.graphie.dotTicks = [];
      const isBar = self.props.type === BAR,
            isLine = self.props.type === LINE,
            isPic = self.props.type === PIC,
            isHistogram = self.props.type === HISTOGRAM,
            isDotplot = self.props.type === DOTPLOT;
      const isTiledPlot = isPic || isDotplot;
      const config = {};
      const c = config; // c for short

      const isMobile = this.props.apiOptions.isMobile;
      c.graph = {
        lines: [],
        bars: [],
        points: [],
        dividers: []
      };
      c.scaleY = self.props.scaleY;
      c.dimX = self.props.categories.length;
      const plotDimensions = isMobile ? [288, 336] : self.props.plotDimensions;

      if (isLine) {
        // Subtracting 0.2 makes line have equal padding on each side
        c.dimX += isMobile ? -0.2 : 1;
      } else if (isHistogram) {
        c.barPad = 0;
        c.barWidth = 1;
      } else if (isBar) {
        c.barPad = isMobile ? 0.08 : 0.15;
        c.barWidth = 1 - 2 * c.barPad;
        c.dimX += (isMobile ? -2 : 2) * c.barPad;
      } else if (isTiledPlot) {
        c.picBoxHeight = self.props.picBoxHeight;
        c.picBoxWidthPx = plotDimensions[0] / self.props.categories.length;
        const picPadAllWidth = plotDimensions[0] - c.dimX * c.picBoxWidthPx;
        c.picPad = picPadAllWidth / (2 * c.dimX + 2);
        const picFullWidth = c.picBoxWidthPx + 2 * c.picPad; // Convert from px to "unscaled"

        c.picPad = c.picPad / picFullWidth;
        c.picBoxWidth = c.picBoxWidthPx / picFullWidth;
        c.dimX += 2 * c.picPad;
      }

      if (isDotplot) {
        c.picBoxHeight = this.DOT_PLOT_POINT_SIZE() * 2 + this.DOT_PLOT_POINT_PADDING();
      }

      c.dimY = Math.ceil(self.props.maxY / c.scaleY) * c.scaleY;
      let padX = 25;

      if ((isBar || isLine) && isMobile) {
        padX = self.props.labels[1].length !== 0 ? 17 : 11;
      } // Since dotplot doesn't have an axis along the left it looks weird
      // with the same padding as the others


      if (isDotplot) {
        padX /= 2;
      }

      if (isMobile && isTiledPlot && self.props.labels[1].length === 0) {
        padX = 0;
      } // Default vertical padding.


      let padTop = 25;
      let padBottom = 25 * 3; // TODO(michaelpolyak): Handle other plot types: Dot, Histogram, Line.

      if (isMobile && (isBar || isTiledPlot)) {
        // $FlowFixMe[incompatible-call]
        const maxCategoryHeight = Math.max(0, ...Object.values(self.state.categoryHeights));

        if (maxCategoryHeight) {
          // Account for bottom label position, height.
          let offsetY = 25;

          if (isTiledPlot) {
            // Tiled plot categories have additional spacing.
            offsetY += 10;
          }

          padBottom = offsetY + maxCategoryHeight;
        }
      }

      if (isMobile) {
        c.scale = [// We multiply pad by 4 because we add 3*pad padding on the left
        // and 1*pad on the right
        (plotDimensions[0] - padX * 4) / c.dimX, (plotDimensions[1] - (padTop + padBottom)) / c.dimY];
      } else {
        c.scale = ___default["default"].map([c.dimX, c.dimY], function (dim, i) {
          return plotDimensions[i] / dim;
        });
      }

      if (isTiledPlot) {
        c.scale[1] = c.picBoxHeight / c.scaleY;
      } // Transform from screen space (pixels) to plot space.


      padX /= c.scale[0];
      padTop /= c.scale[1];
      padBottom /= c.scale[1];
      graphie.init({
        range: [[-3 * padX, c.dimX + padX], [-padBottom, c.dimY + padTop]],
        scale: c.scale,
        isMobile: this.props.apiOptions.isMobile
      });
      graphie.addMouseLayer({
        allowScratchpad: true,
        setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
      });

      if (!isTiledPlot) {
        // If we have isMobile, we skip the 0 label.
        const initialY = isMobile ? c.scaleY : 0;

        for (let y = initialY; y <= c.dimY; y += c.scaleY) {
          graphie.label([0, y], KhanMath.roundToApprox(y, 2), "left",
          /* isTeX */
          true
          /* for the \approx symbol */
          );
          graphie.style({
            stroke: isMobile ? "#e9ebec" : "#000",
            strokeWidth: 1,
            opacity: isMobile ? 1 : 0.3
          }, function () {
            graphie.line([0, y], [c.dimX, y]);
          });
        }
      }

      if ((isBar || isLine) && isMobile) {
        self.graphie.dragPrompt = graphie.label([c.dimX / 2, c.dimY / 2], i18n__namespace._("Drag handles to make graph"), "center", false).css("font-weight", "bold").css("color", KhanColors.KA_GREEN).css("display", "none");
      }

      self.setupCategories(config);

      if (isTiledPlot && isMobile) {
        self.graphie.dotPrompt = graphie.label([c.dimX / 2, c.dimY / 2], i18n__namespace._("Tap to add points"), "center", false).css("font-weight", "bold").css("color", KhanColors.KA_GREEN).css("display", "none");
      }

      if (isTiledPlot) {
        self.drawPicHeights(self.state.values, prevState.values);
      }

      graphie.style({
        stroke: "#000",
        strokeWidth: 2,
        opacity: 1.0
      }, function () {
        if (isTiledPlot) {
          if (isDotplot) {
            // Dotplot is a subtype of tiled plot, here we only draw
            // the x-axis
            graphie.style({
              stroke: isMobile ? KhanColors.GRAY_G : "#000",
              strokeWidth: isMobile ? 1 : 2
            }, () => graphie.line([isMobile ? 0 : 0.5, 0], [c.dimX - (isMobile ? 0 : 0.5), 0]));
          } else {
            graphie.line([0, 0], [c.dimX, 0]); // Draw the left axis for non-dotplots

            if (self.props.labels[1].length !== 0 || !isMobile) {
              graphie.style({
                stroke: isMobile ? KhanColors.GRAY_G : "#000",
                strokeWidth: isMobile ? 1 : 2
              }, () => graphie.line([0, 0], [0, c.dimY]));
            }
          }
        } else {
          // Draw normal axes
          graphie.style({
            stroke: isMobile ? KhanColors.GRAY_G : "#000",
            strokeWidth: isMobile ? 1 : 2
          }, () => graphie.line([isMobile ? -padX * 3 : 0, 0], [c.dimX + (isMobile ? padX : 0), 0]));

          if (!((isBar || isLine) && isMobile)) {
            graphie.style({
              stroke: isMobile ? KhanColors.GRAY_G : "#000",
              strokeWidth: isMobile ? 1 : 2
            }, () => graphie.line([0, 0], [0, c.dimY]));
          }
        }
      });
      graphie.label([c.dimX / 2, isMobile ? -padBottom : -35 / c.scale[1]], self.props.labels[0], isMobile ? "above" : "below", false).css("font-weight", "bold").css("color", isMobile && KhanColors.GRAY_F);
      graphie.label([(isMobile ? -35 : -60) / c.scale[0], c.dimY / 2], self.props.labels[1], "center", false).css("font-weight", "bold").css("color", isMobile && KhanColors.GRAY_F).addClass("rotate");

      if (this.props.apiOptions.isMobile) {
        // $FlowFixMe[invalid-constructor]
        this.horizHairline = new WrappedLine(this.graphie, [0, 0], [0, 0], {
          normalStyle: {
            strokeWidth: 1
          }
        });
        this.horizHairline.attr({
          stroke: KhanColors.INTERACTIVE
        });
        this.horizHairline.hide();
        this.hairlineRange = [[0, c.dimX], [0, c.dimY]];
      }
    });

    _defineProperty(this, "showHairlines", point => {
      if (this.props.apiOptions.isMobile && this.props.markings !== "none") {
        // Hairlines are already initialized when the graph is loaded, so
        // here we just move them to the updated location and make them
        // visible.
        this.horizHairline.moveTo([this.hairlineRange[0][0], point[1]], [this.hairlineRange[0][1], point[1]]);
        this.horizHairline.show();
      }
    });

    _defineProperty(this, "hideHairlines", () => {
      if (this.props.apiOptions.isMobile) {
        this.horizHairline.hide();
      }
    });

    _defineProperty(this, "labelCategory", (x, category) => {
      const isMobile = this.props.apiOptions.isMobile;
      const graphie = this.graphie;
      category = category + "";
      let isTeX = false;
      const mathyCategory = category.match(/^\$(.*)\$$/);

      if (mathyCategory) {
        category = mathyCategory[1];
        isTeX = true;
      }

      const translateX = 5;
      const rotationDeg = 45;
      const rotationRad = rotationDeg * (Math.PI / 180);
      const labelRotation = "translateX(-50%) translateX(".concat(translateX, "px) ") + "translateY(-50%) rotate(-".concat(rotationDeg, "deg)");
      const shouldRotate = isMobile && !mathyCategory; // We return a promise that will resolve to measured category height.

      return new Promise(resolve => {
        graphie.style({
          color: isMobile ? KhanColors.GRAY_G : "inherit",
          transform: shouldRotate ? labelRotation : "none",
          transformOrigin: "100%"
        }, () => {
          const $span = graphie.label([x, isMobile ? -0.5 : 0], category, "below", isTeX);
          const height = // Additional padding is applied by style.
          14 + (shouldRotate ? Math.round($span.height() * Math.cos(rotationRad) + ($span.width() + translateX) * Math.sin(rotationRad)) : $span.height());
          resolve({
            category,
            height
          });
        });
      });
    });

    _defineProperty(this, "setupCategories", config => {
      const self = this;
      const c = config;
      const graphie = self.graphie;
      const isMobile = this.props.apiOptions.isMobile; // The deferred measurements returned from `labelCategory`.

      const categoryHeightPromises = [];

      if (self.props.type === HISTOGRAM) {
        // Histograms with n labels/categories have n - 1 buckets
        ___default["default"].times(self.props.categories.length - 1, function (i) {
          self.setupBar({
            index: i,
            startHeight: self.state.values[i],
            config: config,
            isHistogram: true
          });
        }); // Label categories


        ___default["default"].each(self.props.categories, function (category, i) {
          const x = 0.5 + i * c.barWidth;
          categoryHeightPromises.push(self.labelCategory(x, category));
          const tickHeight = 6 / c.scale[1];
          graphie.style({
            stroke: "#000",
            strokeWidth: isMobile ? 1 : 2,
            opacity: 1.0
          }, function () {
            graphie.line([x, -tickHeight], [x, 0]);
          });
        });
      } else {
        ___default["default"].each(self.props.categories, function (category, i) {
          const startHeight = self.state.values[i];
          let x;

          if (self.props.type === BAR) {
            x = self.setupBar({
              index: i,
              startHeight: startHeight,
              config: config,
              isHistogram: false
            });
          } else if (self.props.type === LINE) {
            x = self.setupLine(i, startHeight, config);
          } else if (self.props.type === PIC) {
            x = self.setupPic(i, config);
          } else if (self.props.type === DOTPLOT) {
            x = self.setupDotplot(i, config);
          }

          let tickStart = 0;
          let tickEnd = -6 / c.scale[1];

          if (self.props.type === DOTPLOT && !isMobile) {
            tickStart = -tickEnd;
          }

          if (self.props.type === DOTPLOT) {
            // Dotplot lets you specify to only show labels every 'n'
            // ticks. It also looks nicer if it makes the labelled
            // ticks a bit bigger.
            if (i % self.props.labelInterval === 0 || i === self.props.categories.length - 1) {
              categoryHeightPromises.push(self.labelCategory(x, category));
              tickStart *= 1.5;
              tickEnd *= 1.5;
            }
          } else {
            categoryHeightPromises.push(self.labelCategory(x, category));
          }

          graphie.style({
            stroke: isMobile ? KhanColors.GRAY_G : "#000",
            strokeWidth: isMobile ? 1 : 2,
            opacity: 1.0
          }, function () {
            graphie.line([x, tickStart], [x, tickEnd]);
          });
        });
      }

      Promise.all(categoryHeightPromises).then(measurements => {
        if (self._isMounted) {
          const categoryHeights = {};
          measurements.forEach(_ref => {
            let {
              category,
              height
            } = _ref;
            return categoryHeights[category] = height;
          });
          self.setState({
            categoryHeights
          });
        }
      });
    });

    _defineProperty(this, "_clampValue", (v, min, max) => {
      return Math.max(Math.min(v, max), min);
    });

    _defineProperty(this, "_maybeShowDragPrompt", () => {
      // The drag prompt is only added on certain types of plots.
      if (this.graphie.dragPrompt != null) {
        this.graphie.dragPrompt[0].style.display = "inline";
      }
    });

    _defineProperty(this, "_maybeHideDragPrompt", () => {
      // The drag prompt is only added on certain types of plots.
      if (this.graphie.dragPrompt != null) {
        this.graphie.dragPrompt[0].style.display = "none";
      }
    });

    _defineProperty(this, "setupBar", args => {
      const isMobile = this.props.apiOptions.isMobile;
      const i = args.index;
      const startHeight = args.startHeight;
      const config = args.config;
      const isHistogram = args.isHistogram;
      const self = this;
      const graphie = self.graphie;
      const barHalfWidth = config.barWidth / 2;
      let x;

      if (isHistogram) {
        x = 0.5 + i * config.barWidth + barHalfWidth;
      } else {
        x = (isMobile ? barHalfWidth : 0.5 + config.barPad) + i;
      }
      /**
       * Updates the bar with given index to the given height
       * @param i the index of the bar to update
       * @param height the new height of the bar
       */


      const scaleBar = function (i, height) {
        const center = graphie.scalePoint(0); // Scale filled bucket (bar)

        config.graph.bars[i].scale(1, Math.max(isMobile ? 0.2 : 0.01, height / config.scaleY), center[0], center[1]);

        if (isHistogram) {
          // Scale dividers between buckets
          const leftDivider = config.graph.dividers[i - 1],
                rightDivider = config.graph.dividers[i];

          if (leftDivider) {
            const divHeight = Math.min(self.state.values[i - 1], height);
            leftDivider.scale(1, Math.max(0.01, divHeight / config.scaleY), center[0], center[1]);
          }

          if (rightDivider) {
            const divHeight = Math.min(self.state.values[i + 1], height);
            rightDivider.scale(1, Math.max(0.01, divHeight / config.scaleY), center[0], center[1]);
          }
        }
      };

      graphie.style({
        stroke: "none",
        fill: isMobile ? KhanColors.BLUE_C : KhanColors.LIGHT_BLUE,
        opacity: 1.0
      }, function () {
        config.graph.bars[i] = graphie.path([[x - barHalfWidth, 0], [x - barHalfWidth, config.scaleY], [x + barHalfWidth, config.scaleY], [x + barHalfWidth, 0], [x - barHalfWidth, 0]]);
      });

      if (isHistogram) {
        if (i > 0) {
          // Don't draw a divider to the left of the first bucket
          graphie.style({
            stroke: "#000",
            strokeWidth: 1,
            opacity: 0.3
          }, function () {
            config.graph.dividers.push(graphie.path([[x - barHalfWidth, 0], [x - barHalfWidth, config.scaleY]]));
          });
        }
      }

      if (isMobile) {
        const snap = config.scaleY / self.props.snapsPerLine;
        config.graph.lines[i] = Interactive2.addMaybeMobileMovablePoint(this, {
          coord: [x, startHeight],
          constraints: [(coord, prev, options) => {
            return [x, this._clampValue(Math.round(coord[1] / snap) * snap, 0, config.dimY)];
          }],
          onMoveStart: function () {
            config.graph.bars[i].attr({
              fill: KhanColors.INTERACTIVE
            });
          },
          onMove: function () {
            const y = config.graph.lines[i].coord()[1];

            const values = ___default["default"].clone(self.state.values);

            values[i] = y;
            self.setState({
              values: values
            });
            self.changeAndTrack({
              values: values
            });

            self._maybeHideDragPrompt();

            scaleBar(i, y);
          },
          onMoveEnd: function () {
            config.graph.bars[i].attr({
              fill: KhanColors.BLUE_C
            });
          }
        }); // We set the z-index to 1 here so that the hairlines cover up the
        // points

        config.graph.lines[i].state.visibleShape.wrapper.style.zIndex = "1";

        self._maybeShowDragPrompt();
      } else {
        config.graph.lines[i] = graphie.addMovableLineSegment({
          coordA: [x - barHalfWidth, startHeight],
          coordZ: [x + barHalfWidth, startHeight],
          snapY: config.scaleY / self.props.snapsPerLine,
          constraints: {
            constrainX: true
          },
          normalStyle: {
            stroke: KhanColors.INTERACTIVE,
            // Don't display graph handles in static mode
            "stroke-width": this.props.static ? 0 : 4
          }
        });

        config.graph.lines[i].onMove = function (dx, dy) {
          let y = this.coordA[1];

          if (y < 0 || y > config.dimY) {
            y = Math.min(Math.max(y, 0), config.dimY);
            this.coordA[1] = this.coordZ[1] = y; // Snap the line back into range.

            this.transform();
          }

          const values = ___default["default"].clone(self.state.values);

          values[i] = y;
          self.setState({
            values: values
          });
          self.changeAndTrack({
            values: values
          });
          scaleBar(i, y);
        };
      }

      scaleBar(i, startHeight);
      return x;
    });

    _defineProperty(this, "setupLine", (i, startHeight, config) => {
      const isMobile = this.props.apiOptions.isMobile;
      const self = this;
      const c = config;
      const graphie = self.graphie;
      const x = i + (isMobile ? 0.4 : 1);

      if (isMobile) {
        const snap = config.scaleY / self.props.snapsPerLine;
        c.graph.points[i] = Interactive2.addMaybeMobileMovablePoint(this, {
          coord: [x, startHeight],
          constraints: [(coord, prev, options) => {
            return [x, this._clampValue(Math.round(coord[1] / snap) * snap, 0, config.dimY)];
          }],
          onMove: function () {
            const y = c.graph.points[i].coord()[1];

            const values = ___default["default"].clone(self.state.values);

            values[i] = y;
            self.setState({
              values: values
            });
            self.changeAndTrack({
              values: values
            });

            self._maybeHideDragPrompt();
          }
        });

        self._maybeShowDragPrompt();

        if (i > 0) {
          c.graph.lines[i] = Interactive2.addMovableLine(graphie, {
            points: [c.graph.points[i - 1], c.graph.points[i]],
            // $FlowFixMe[prop-missing]
            constraints: Interactive2.MovablePoint.constraints.fixed(),
            normalStyle: {
              stroke: KhanColors.BLUE_C,
              "stroke-width": 2
            },
            highlightStyle: {
              stroke: KhanColors.BLUE_C,
              "stroke-width": 2
            }
          });
        }
      } else {
        c.graph.points[i] = graphie.addMovablePoint({
          coord: [x, startHeight],
          constraints: {
            constrainX: true
          },
          normalStyle: {
            fill: KhanColors.INTERACTIVE,
            stroke: KhanColors.INTERACTIVE
          },
          snapY: c.scaleY / self.props.snapsPerLine
        });

        c.graph.points[i].onMove = function (x, y) {
          y = Math.min(Math.max(y, 0), c.dimY);

          const values = ___default["default"].clone(self.state.values);

          values[i] = y;
          self.setState({
            values: values
          });
          self.changeAndTrack({
            values: values
          });
          return [x, y];
        };

        if (i > 0) {
          c.graph.lines[i] = graphie.addMovableLineSegment({
            pointA: c.graph.points[i - 1],
            pointZ: c.graph.points[i],
            constraints: {
              fixed: true
            },
            normalStyle: {
              stroke: "#9ab8ed",
              "stroke-width": 2
            }
          });
        }
      }

      return x;
    });

    _defineProperty(this, "setupDotplot", (i, config) => {
      const graphie = this.graphie;
      const isMobile = this.props.apiOptions.isMobile;
      return this.setupTiledPlot(i, isMobile ? 0.5 : 1, config, (x, y) => {
        return graphie.ellipse([x, y], [this.DOT_PLOT_POINT_SIZE() / graphie.scale[0], this.DOT_PLOT_POINT_SIZE() / graphie.scale[1]], {
          fill: KhanColors.INTERACTIVE,
          stroke: KhanColors.INTERACTIVE
        });
      });
    });

    _defineProperty(this, "setupPic", (i, config) => {
      const graphie = this.graphie;
      return this.setupTiledPlot(i, 0, config, (x, y) => {
        const scaledCenter = graphie.scalePoint([x, y]);
        const size = this.props.picSize;
        return graphie.raphael.image(this.props.picUrl, scaledCenter[0] - size / 2, scaledCenter[1] - size / 2, size, size);
      });
    });

    _defineProperty(this, "setupTiledPlot", (i, bottomMargin, config, createImage) => {
      const self = this;
      const c = config;
      const graphie = self.graphie;
      const pics = graphie.pics;
      const dotTicks = graphie.dotTicks;
      const x = i + 0.5 + c.picPad; // In order to make sure that manipulating the graph doesn't cause
      // dragging, we disable touch actions for the whole mouselayer.
      // TODO(emily): Figure out a way to turn of touch actions for only the
      // part of the widget that can be manipulated. Putting this style
      // directly on the rects below doesn't work.

      graphie.mouselayer.canvas.style.touchAction = "none";
      pics[i] = [];
      dotTicks[i] = [];
      const n = Math.round(c.dimY / c.scaleY) + 1;

      ___default["default"](n).times(function (j) {
        j -= 1;
        const midY = (j + 0.5) * c.scaleY;
        const leftX = x - c.picBoxWidth / 2;
        const topY = midY + 0.5 * c.scaleY;
        const coord = graphie.scalePoint([leftX, topY + bottomMargin]);
        const mouseRect = graphie.mouselayer.rect(coord[0], coord[1], c.picBoxWidthPx, c.picBoxHeight);
        $__default["default"](mouseRect[0]).css({
          fill: "#000",
          opacity: 0.0,
          cursor: "pointer"
        }).on("vmousedown", function (e) {
          e.preventDefault(); // $FlowFixMe[prop-missing]

          self.whichPicClicked = i;
          self.setPicHeight(i, topY);
          $__default["default"](document).on("vmouseup.plotTile", function (e) {
            $__default["default"](document).unbind(".plotTile");
          });
          $__default["default"](document).on("vmousemove.plotTile", function (e) {
            e.preventDefault(); // Reverse-engineer the initial calculation

            const yCoord = graphie.getMouseCoord(e)[1];
            const adjustedCoord = Math.floor(yCoord - bottomMargin); // Calculate top coord from j value, but don't let them
            // go below j = -1, which is equivalent to having '0'
            // on the dot plot (due to weird indexing).

            const newJ = Math.max(-1, Math.floor(adjustedCoord / c.scaleY));
            const newMidY = (newJ + 0.5) * c.scaleY; // Constrain the max Y value to max displayable Y of the
            // plot.  Otherwise users can unintentionally select an
            // out-of-range value and not see that they have done so.

            const newTopY = Math.min(newMidY + 0.5 * c.scaleY, c.dimY); // $FlowFixMe[prop-missing]

            self.setPicHeight(self.whichPicClicked, newTopY);
          });
        });

        if (j < 0) {
          // Don't show a pic underneath the axis!
          return;
        }

        pics[i][j] = createImage(x, midY + bottomMargin);
        dotTicks[i][j] = graphie.ellipse([x, midY + bottomMargin], [self.DOT_TICK_POINT_SIZE() / graphie.scale[0], self.DOT_TICK_POINT_SIZE() / graphie.scale[1]], {
          fill: "#dee1e3",
          stroke: "#dee1e3"
        });
      });

      return x;
    });

    _defineProperty(this, "setPicHeight", (i, y) => {
      const values = ___default["default"].clone(this.state.values);

      values[i] = y;
      this.drawPicHeights(values, this.state.values);
      this.setState({
        values: values
      });
      this.changeAndTrack({
        values: values
      });
    });

    _defineProperty(this, "changeAndTrack", data => {
      this.props.onChange(data);
      this.props.trackInteraction();
    });

    _defineProperty(this, "drawPicHeights", (values, prevValues) => {
      const self = this;
      const graphie = self.graphie;
      const pics = graphie.pics;
      const isMobile = this.props.apiOptions.isMobile;

      if (isMobile) {
        const shouldDisplay = values.every(v => v === 0);
        graphie.dotPrompt[0].style.display = shouldDisplay ? "inline" : "none";
      }

      ___default["default"].each(pics, function (ps, i) {
        ___default["default"].each(ps, function (pic, j) {
          const y = (j + 1) * self.props.scaleY;
          const show = y <= values[i];

          if (self.props.type === DOTPLOT) {
            const wasShown = y <= prevValues[i];
            const wasJustShown = show && !wasShown;

            if (wasJustShown) {
              pic.animate({
                "stroke-width": 8
              }, 75, () => pic.animate({
                "stroke-width": 2
              }, 75));
            }
          }

          $__default["default"](pic[0]).css({
            display: show ? "inline" : "none"
          });
          graphie.dotTicks[i][j][0].style.display = show || !isMobile ? "none" : "inline";
        });
      });
    });

    _defineProperty(this, "getUserInput", () => {
      return this.state.values;
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return Plotter.validate(this.getUserInput(), rubric);
    });
  }

  render() {
    // TODO(kevinb) actually compute the size of the graphie correctly and
    // make it that size so we don't have to add extra padding.  The value
    // was determined by eye-balling the layout.  :(
    const paddingForBottomLabel = 75;
    const style = {
      marginBottom: this.props.labels[0] ? paddingForBottomLabel : 0
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-plotter graphie " + ClassNames.INTERACTIVE // eslint-disable-next-line react/no-string-refs
      ,
      ref: "graphieDiv",
      style: style
    });
  }

  componentDidUpdate(prevProps, prevState) {
    this.shouldSetupGraphie = this.shouldSetupGraphie || !___default["default"].isEqual(this.state.categoryHeights, prevState.categoryHeights);

    if (this.shouldSetupGraphie) {
      this.setupGraphie(prevState);
    }
  }

  componentDidMount() {
    this._isMounted = true;
    this.setupGraphie(this.state);
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    const props = ["type", "labels", "categories", "scaleY", "maxY", "snapsPerLine", "picUrl", "labelInterval", "static"];
    this.shouldSetupGraphie = ___default["default"].any(props, function (prop) {
      return !___default["default"].isEqual(this.props[prop], nextProps[prop]);
    }, this);

    if (!___default["default"].isEqual(this.props.starting, nextProps.starting) && !___default["default"].isEqual(this.state.values, nextProps.starting)) {
      this.shouldSetupGraphie = true;
      this.setState({
        values: nextProps.starting
      });
    }
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

}

_defineProperty(Plotter, "propTypes", {
  onChange: PropTypes__default["default"].func.isRequired,
  trackInteraction: PropTypes__default["default"].func.isRequired // TODO(alex): Figure out why lint chokes on this line
  // ...widgetPropTypes,

});

_defineProperty(Plotter, "defaultProps", {
  type: BAR,
  labels: ["", ""],
  categories: [""],
  scaleY: 1,
  maxY: 10,
  snapsPerLine: 2,
  picSize: 40,
  picBoxHeight: 48,
  picUrl: "",
  plotDimensions: [380, 300],
  labelInterval: 1
});

___default["default"].extend(Plotter, {
  validate: function (guess, rubric) {
    if (deepEq$1(guess, rubric.starting)) {
      return {
        type: "invalid",
        message: null
      };
    }

    return {
      type: "points",
      earned: deepEq$1(guess, rubric.correct) ? 1 : 0,
      total: 1,
      message: null
    };
  }
}); // We don't need to change any of the original props for static mode


const staticTransform = ___default["default"].identity;
var Plotter$1 = {
  name: "plotter",
  displayName: "Plotter",
  widget: Plotter,
  staticTransform: staticTransform
};

class Separator extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "arrowLength", 100);

    _defineProperty(this, "drawArrow", () => {
      // eslint-disable-next-line react/no-string-refs
      const canvas = this.refs["arrowCanvas" + this.props.index];
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const path = new Path2D();
      ctx.strokeStyle = "rgb(0,0,0)";
      ctx.lineWidth = 1.2;
      ctx.lineCap = "round";
      const offset = 5;
      path.moveTo(offset, canvas.height / 2);
      path.lineTo(canvas.width - offset, canvas.height / 2);
      path.moveTo(canvas.width - 2 * offset, canvas.height / 2 - offset);
      path.lineTo(canvas.width - offset, canvas.height / 2);
      path.moveTo(canvas.width - 2 * offset, canvas.height / 2 + offset);
      path.lineTo(canvas.width - offset, canvas.height / 2);
      ctx.stroke(path);
    });
  }

  componentDidMount() {
    this.drawArrow();
  }

  componentDidUpdate() {
    this.drawArrow();
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "arrow-container"
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: "above-text"
    }, this.props.data.topText), /*#__PURE__*/React__namespace.createElement("canvas", {
      height: "30",
      id: "arrowCanvas" + this.props.index,
      ref: "arrowCanvas" + this.props.index,
      width: this.arrowLength
    }, i18n__namespace._("Reaction arrow pointing to the right.")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "below-text"
    }, this.props.data.bottomText));
  }

}

_defineProperty(Separator, "propTypes", {
  // TODO(colin): figure out and add shape.
  data: PropTypes__default["default"].any,
  index: PropTypes__default["default"].number
});

class ReactionDiagramWidget extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "simpleValidate", () => {
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });

    _defineProperty(this, "getUserInput", () => {
      return [];
    });

    _defineProperty(this, "validate", (state, rubric) => {
      // TODO(colin): this appears to be part of the perseus interface.
      // Figure out if there's a more appropriate value to return.
      return {
        type: "points",
        earned: 0,
        total: 0,
        message: null
      };
    });

    _defineProperty(this, "focus", () => {
      return true;
    });
  }

  render() {
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react/no-string-refs
      React__namespace.createElement("div", {
        className: "reaction",
        ref: "reaction"
      }, this.props.smiles.map((s, i) => {
        const id = this.props.widgetId + "-" + i;
        return /*#__PURE__*/React__namespace.createElement("div", {
          key: id,
          className: "molecule-container"
        }, /*#__PURE__*/React__namespace.createElement(Molecule, {
          id: id,
          rotationAngle: this.props.rotationAngle[i],
          smiles: s
        }), i === this.props.smiles.length - 1 ? null : /*#__PURE__*/React__namespace.createElement(Separator, {
          data: this.props.separators[i],
          index: i
        }));
      }))
    );
  }

}

_defineProperty(ReactionDiagramWidget, "propTypes", {
  // TODO(colin): at the moment, these must be arrays of two elements;
  // we're limited to a single reaction step.  At some point, add support
  // for more steps in the reaction.
  rotationAngle: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  // eslint-disable-next-line react/forbid-prop-types
  separators: PropTypes__default["default"].arrayOf(PropTypes__default["default"].object),
  smiles: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  widgetId: PropTypes__default["default"].string
});

_defineProperty(ReactionDiagramWidget, "defaultProps", {
  smiles: [],
  rotationAngle: [],
  separators: []
});

var ReactionDiagram = {
  name: "reaction-diagram",
  displayName: "Chemical reaction",
  hidden: true,
  widget: ReactionDiagramWidget
};

class Sequence extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "state", {
      visible: 1
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "_handleInteraction", groupWidgetId => {
      const step = parseInt(groupWidgetId.split(" ")[1]);

      if (step === this.state.visible - 1) {
        // eslint-disable-next-line react/no-string-refs
        const widget = this.refs.renderer.getWidgetInstance("group " + step);
        widget.showRationalesForCurrentlySelectedChoices();
        const score = widget.simpleValidate();

        if (score.type === "points" && score.total === score.earned) {
          this.setState({
            visible: this.state.visible + 1
          });
          this.props.trackInteraction({
            visible: this.state.visible + 1
          });
        }
      }
    });
  }

  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  }

  render() {
    const icon = /*#__PURE__*/React__namespace.createElement(InlineIcon, _extends$1({}, iconOk, {
      style: {
        color: "green"
      }
    }));

    const content = ___default["default"].chain(this.props.json).first(this.state.visible).map((step, i) => "[[".concat(Util.snowman, " group ").concat(i, "]]")).join("\n\n").value();

    const widgets = {};

    ___default["default"].each(this.props.json, (step, i) => {
      const widgetId = "group ".concat(i);
      widgets[widgetId] = {
        type: "group",
        graded: true,
        version: {
          major: 0,
          minor: 0
        },
        options: ___default["default"].extend({}, step, {
          icon: i < this.state.visible - 1 ? icon : null
        })
      };
    });

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-sequence"
    }, /*#__PURE__*/React__namespace.createElement(Renderer // eslint-disable-next-line react/no-string-refs
    , {
      ref: "renderer",
      content: content,
      widgets: widgets,
      onInteractWithWidget: this._handleInteraction,
      apiOptions: this.props.apiOptions,
      linterContext: this.props.linterContext
    }));
  }

}

_defineProperty(Sequence, "propTypes", { ...propTypes,
  apiOptions: ApiOptions.propTypes,
  json: PropTypes__default["default"].arrayOf(PropTypes__default["default"].shape({
    content: PropTypes__default["default"].string,
    images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
    widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any)
  })),
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});

_defineProperty(Sequence, "defaultProps", {
  json: [{
    content: "",
    widgets: {},
    images: {}
  }],
  linterContext: PerseusLinter.linterContextDefault
});

const traverseChildWidgets = function (props, traverseRenderer) {
  let oldJson = props.json;

  if (!___default["default"].isArray(oldJson)) {
    oldJson = [oldJson];
  }

  const json = ___default["default"].map(oldJson, rendererOptions => {
    return traverseRenderer(rendererOptions);
  });

  return ___default["default"].extend({}, props, {
    json: json
  });
};

var Sequence$1 = {
  name: "sequence",
  displayName: "Graded Sequence",
  widget: Sequence,
  traverseChildWidgets: traverseChildWidgets,
  tracking: "all",
  hidden: true,
  isLintable: true
};

const colors = {
  grayLight: "#aaa",
  basicBorderColor: "#ccc",
  white: "#fff"
};
const triangleBeforeAfter = {
  borderBottom: "9px solid transparent",
  borderTop: "9px solid transparent",
  content: '" "',
  height: "0",
  position: "absolute",
  top: "0",
  width: "0"
};
const styles$7 = aphrodite.StyleSheet.create({
  infoTip: {
    display: "inline-block",
    marginLeft: "5px",
    position: "relative"
  },
  infoTipContainer: {
    position: "absolute",
    top: "-12px",
    left: "22px",
    zIndex: 1000
  },
  infoTipTriangle: {
    height: "10px",
    left: "0",
    position: "absolute",
    top: "8px",
    width: "0",
    zIndex: 1,
    ":before": { ...triangleBeforeAfter,
      borderRight: "9px solid #bbb",
      right: "0"
    },
    ":after": { ...triangleBeforeAfter,
      borderRight: "9px solid ".concat(colors.white),
      right: "-1px"
    }
  },
  verticalShadow: {
    border: "1px solid ".concat(colors.basicBorderColor),
    boxShadow: "0 1px 3px ".concat(colors.basicBorderColor),
    borderBottom: "1px solid ".concat(colors.grayLight)
  },
  infoTipContentContainer: {
    background: colors.white,
    padding: "5px 10px",
    width: "240px"
  }
});
const questionMark = "data:image/png;base64," + "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBB" + "ZG9iZSBJbWFnZVJlYWR5ccllPAAAA3NpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/" + "eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+" + "IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2Jl" + "IFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAg" + "ICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5" + "LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9" + "IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHht" + "bG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3Vy" + "Y2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHht" + "cE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2N2M3NTAxYS04YmVlLTQ0M2Mt" + "YmRiNS04OGM2N2IxN2NhYzEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUJCRTk4" + "Qjc4NjAwMTFFMzg3QUJDNEI4Mzk2QTRGQkQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5p" + "aWQ6OUJCRTk4QjY4NjAwMTFFMzg3QUJDNEI4Mzk2QTRGQkQiIHhtcDpDcmVhdG9yVG9v" + "bD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRG" + "cm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NGE5ZDI0OTMtODk1NC00OGFkLTlh" + "MTgtZDAwM2MwYWNjNDJlIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3Yzc1MDFh" + "LThiZWUtNDQzYy1iZGI1LTg4YzY3YjE3Y2FjMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4g" + "PC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pqm89uYAAADM" + "SURBVHjaXJA9DoJAEIUH1M4TUHIFsCMGen9OwCGw1YRGW2ntKel0exsojHIBC0ouQAyU" + "viFDstmXfNmZeS+zm7XSNCXRFiRgJf0bXIHixpbhGdxBBJYC1w/xaA424MhNEATkui71" + "fU9KqfEU78UbD9PdbJRlOdae55GmhIP+1NV1TcMwkOM41DSNHvRtMhTHMRVFQW3b6mOL" + "gx99kue5GRp/gIOZuZGvNpTNwjD8oliANU+qqqKu6/TQBdymN57AHjzBT+B6Jx79BRgA" + "vc49kQA4yxgAAAAASUVORK5CYII=";

class InfoTip$1 extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      hover: false
    });

    _defineProperty(this, "handleMouseEnter", () => {
      this.setState({
        hover: true
      });
    });

    _defineProperty(this, "handleMouseLeave", () => {
      this.setState({
        hover: false
      });
    });
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.infoTip)
    }, /*#__PURE__*/React__namespace.createElement("img", {
      alt: "",
      width: 10,
      height: 10,
      src: questionMark,
      onMouseEnter: this.handleMouseEnter,
      onMouseLeave: this.handleMouseLeave
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.infoTipContainer),
      style: {
        display: this.state.hover ? "block" : "none"
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.infoTipTriangle)
    }), /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$7.verticalShadow, styles$7.infoTipContentContainer)
    }, this.props.children)));
  }

}

class InfoTip extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      didMount: false
    });
  }

  componentDidMount() {
    /* eslint-disable react/no-did-mount-set-state */
    this.setState({
      didMount: true
    });
    /* eslint-enable react/no-did-mount-set-state */
  }

  render() {
    if (this.state.didMount) {
      return /*#__PURE__*/React__namespace.createElement(InfoTip$1, this.props);
    }

    return /*#__PURE__*/React__namespace.createElement("div", null);
  }

}

const {
  assert: assert$2
} = InteractiveUtil;

const {
  Path,
  Arc,
  Circle,
  Label,
  Line,
  MovablePoint,
  MovableLine
} = Graphie;
const defaultBoxSize$1 = 400;
const maxSampleSize = 1000;

class Histogram extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_renderThresholdLine", () => {
      // Recall the the y-range goes from [-1, yMax] to allow for ticks on
      // the x-axis.
      const yRange = [0, this._range()[1][1]];

      const coords = ___default["default"].map(yRange, y => [this.state.threshold, y]); // Returns an inivisble, placeholder coord that anchors the line


      const invisiblePointForCoord = (coord, i) => {
        return /*#__PURE__*/React__namespace.createElement(MovablePoint, {
          key: i,
          static: true,
          coord: coord,
          normalStyle: {
            stroke: "none",
            fill: "none"
          }
        });
      };

      return /*#__PURE__*/React__namespace.createElement(MovableLine, {
        onMove: this.handleMouseInteraction
      }, ___default["default"].map(coords, invisiblePointForCoord));
    });

    _defineProperty(this, "_renderCircle", () => {
      const data = this.props.data; // Get proportion of results below threshold

      const total = ___default["default"].reduce(data, (sum, next) => {
        return sum + next;
      }, 0);

      const numBelow = ___default["default"].reduce(data, (sum, next, i) => {
        if (this.state.threshold != null && i <= this.state.threshold) {
          return sum + next;
        }

        return sum;
      }, 0);

      const proportionBelow = numBelow / total; // This is a hack around the arc taking angles modulo 360.
      // TODO(charlie): Find a better way around this.

      const epsilon = 1e-5;
      const radius = 20;
      const center = [this.props.box[0] - 1.5 * radius, 1.5 * radius]; // Plot little circle

      const plotBelowCircle = () => {
        const options = {
          key: "below",
          center: center,
          radius: radius,
          startAngle: 0,
          endAngle: proportionBelow < 1 ? 360 * proportionBelow : 360 - epsilon,
          sector: proportionBelow !== 1,
          unscaled: true,
          style: {
            fill: KhanColors.LIGHT_RED,
            stroke: KhanColors.RED
          }
        };
        return /*#__PURE__*/React__namespace.createElement(Arc, options);
      };

      const plotAboveCircle = () => {
        const options = {
          key: "above",
          center: center,
          radius: radius,
          startAngle: proportionBelow > 0 ? 360 * proportionBelow : epsilon,
          endAngle: 360,
          sector: proportionBelow !== 0,
          unscaled: true,
          style: {
            fill: KhanColors.LIGHT_BLUE,
            stroke: KhanColors.BLUE
          }
        };
        return /*#__PURE__*/React__namespace.createElement(Arc, options);
      }; // Plot the label below the circle


      const xRange = this._range()[0];

      const formattedThreshold = Math.min(Math.max(this.state.threshold, xRange[0]), xRange[1]).toFixed(2);

      const plotLabel = () => {
        const options = {
          key: "label",
          coord: [center[0], center[1] + 1.5 * radius],
          text: numBelow + " of " + total + " results below " + formattedThreshold + "%",
          direction: "center",
          tex: false,
          unscaled: true,
          style: {
            fontSize: "12px"
          }
        };
        return /*#__PURE__*/React__namespace.createElement(Label, options);
      };

      return [proportionBelow > 0 && plotBelowCircle(), proportionBelow < 1 && plotAboveCircle(), plotLabel()];
    });

    _defineProperty(this, "_renderData", () => {
      const data = this.props.data;

      this._range(); // Plot bars


      const barWidth = 1;

      const pathForData = (count, i) => {
        // Avoid plotting bars of height 0, else you get a thick blue line
        // over the x-axis. We don't filter these out of the data passed in
        // to this function, however, to preserve absolute indices.
        if (!count) {
          return;
        }

        const isBelow = this.state.threshold != null && i <= this.state.threshold;
        const style = {
          fill: isBelow ? KhanColors.LIGHT_RED : KhanColors.LIGHT_BLUE,
          stroke: isBelow ? KhanColors.RED : KhanColors.BLUE
        };
        const coords = [[i, 0], [i, count], [i + barWidth, count], [i + barWidth, 0]];
        return /*#__PURE__*/React__namespace.createElement(Path, {
          key: i,
          coords: coords,
          style: style
        });
      };

      return ___default["default"].map(data, pathForData);
    });

    _defineProperty(this, "_setupGraphie", (graphie, options) => {
      const data = options.data;
      const range = options.range;
      const scale = options.scale;
      /* Plot the bars that run parallel to the x-axis. */

      const xWidth = range[0][1] - range[0][0];
      const yWidth = range[1][1] - 0;
      const maxYAxisEntities = 20;
      const ySkip = Math.ceil(yWidth / maxYAxisEntities);

      ___default["default"].each(___default["default"].range(0, range[1][1], ySkip), y => {
        // If there's no data, we don't label the axes
        if (data) {
          graphie.label([range[0][0], y], KhanMath.roundToApprox(y, 2), "left",
          /* isTeX */
          true
          /* for the \approx symbol */
          );
        }

        graphie.line([range[0][0], y], [range[0][1], y], {
          stroke: "#000",
          strokeWidth: 1,
          opacity: 0.3
        });
      }); // If there's no data, we don't label the x-axis at all


      if (data) {
        // Plot the labels below the bars
        const maxXAxisEntities = 15;
        const xSkip = Math.ceil(xWidth / maxXAxisEntities);

        ___default["default"].each(___default["default"].range(range[0][0], range[0][1], xSkip), x => {
          graphie.label([x, 0], kmath.number.round(x, 2), "below", true);
          const tickHeight = 8;
          graphie.line([x, 0], [x, -tickHeight / scale[1]], {
            stroke: "#000",
            strokeWidth: 1
          });
        });
      } // Add y axis (x axis is added later to overlap the bars)


      const axisStyle = {
        stroke: "#000",
        strokeWidth: 2,
        opacity: 1.0
      };
      const origin = [range[0][0], 0];
      const topLeft = [range[0][0], range[1][1]];
      graphie.line(origin, topLeft, axisStyle); // Add axis labels

      const xMid = range[0][0] + xWidth / 2;
      const xOffset = data ? 25 : 0;
      graphie.label([xMid, -xOffset / scale[1]], options.xAxisLabel, "below", false).css("font-weight", "bold");
      const yMid = 0 + yWidth / 2;
      const yOffset = data ? 55 : 28;
      graphie.label([range[0][0] - yOffset / scale[0], yMid], options.yAxisLabel, "center", false).css("font-weight", "bold").css("-webkit-transform", "rotate(-90deg)");
    });

    _defineProperty(this, "handleMouseInteraction", point => {
      this.setState({
        threshold: point[0]
      });
    });

    _defineProperty(this, "_range", props => {
      const defaultRange = [[0, 100], [-1, 10]];
      props = props || this.props;
      return props.data ? this._getRangeForData(props.data) : defaultRange;
    });

    _defineProperty(this, "_getRangeForData", data => {
      // Find first/last non-zero entry and add some padding
      const padding = 10;

      const firstIndex = ___default["default"].indexOf(data, ___default["default"].find(data, n => n > 0));

      const xMin = Math.max(0, firstIndex - padding);

      const lastIndex = ___default["default"].lastIndexOf(data, ___default["default"].last(___default["default"].filter(data, n => n > 0)));

      const xMax = Math.min(100 + 1, lastIndex + 1 + padding); // The y-axis is bounded above by largest value, and below by 0.
      // However, the 'range' of the y-axis goes as low as -1 to allow
      // Graphie to draw ticks on the x-Axis that extend vertically below
      // y = 0.

      const yMin = -1;

      const yMax = ___default["default"].max(data);

      return [[xMin, xMax], [yMin, yMax]];
    });

    _defineProperty(this, "_getInitialThreshold", range => {
      // We pick a pretty-looking threshold, 1/3 of the way along the axis
      const xRange = range[0];
      return xRange[0] + (xRange[1] - xRange[0]) / 3;
    });

    _defineProperty(this, "state", {
      threshold: this._getInitialThreshold(this._range())
    });
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // Reset the threshold if the range has changed
    const oldRange = this._range();

    const nextRange = this._range(nextProps);

    if (!Util.deepEq(oldRange, nextRange)) {
      this.setState({
        threshold: this._getInitialThreshold(nextRange)
      });
    }
  }
  /* Renders the vertical line that users can drag across the histogram. */


  render() {
    const data = this.props.data;

    const range = this._range();

    const options = {
      xAxisLabel: this.props.xAxisLabel,
      yAxisLabel: this.props.yAxisLabel,
      box: this.props.box,
      range: range,
      data: data,
      scale: [Util.scaleFromExtent(range[0], this.props.box[0]), Util.scaleFromExtent(range[1], this.props.box[1])]
    };
    const axisStyle = {
      stroke: "#000",
      strokeWidth: 1,
      opacity: 1.0
    };
    const origin = [range[0][0], 0];
    const bottomRight = [range[0][1], 0];
    return /*#__PURE__*/React__namespace.createElement(Graphie, {
      box: options.box,
      range: options.range,
      options: options,
      setup: this._setupGraphie,
      onMouseMove: this.handleMouseInteraction,
      onMouseDown: this.handleMouseInteraction,
      setDrawingAreaAvailable: this.props.setDrawingAreaAvailable
    }, /*#__PURE__*/React__namespace.createElement(Line, {
      start: origin,
      end: bottomRight,
      style: axisStyle
    }), data && this._renderData(), data && this._renderCircle(), data && this._renderThresholdLine());
  }

}

_defineProperty(Histogram, "propTypes", {
  data: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  xAxisLabel: PropTypes__default["default"].string,
  yAxisLabel: PropTypes__default["default"].string,
  box: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number)
});

_defineProperty(Histogram, "defaultProps", {
  data: null,
  xAxisLabel: "Proportion (%)",
  yAxisLabel: "Number of times seen",
  box: [defaultBoxSize$1, defaultBoxSize$1]
});

class Simulator extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "generateNumber", void 0);

    _defineProperty(this, "state", {
      invalidInput: false
    });

    _defineProperty(this, "calculateDisplayProportion", () => {
      const userProportion = this.props.userProportion; // If we want to display as a percentage, multiply proportion by 100.0.

      if (this.props.proportionOrPercentage === "percentage") {
        return Math.round(100 * userProportion);
      }

      return userProportion;
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });

    _defineProperty(this, "checkProportionValidity", value => {
      return value >= 0.0 && this.props.proportionOrPercentage === "proportion" && value <= 1.0 || this.props.proportionOrPercentage === "percentage" && value <= 100.0;
    });

    _defineProperty(this, "handleUserProportionChange", (value, cb) => {
      let userProportion; // If "percentage" mode is enabled, user will have entered value as
      // a percentage. However, we always store as a proportion, so we cast.

      if (this.props.proportionOrPercentage === "percentage") {
        userProportion = value / 100.0;
      } else {
        userProportion = value;
      } // If they entered a number, we may need to cap it


      if (userProportion != null) {
        userProportion = Math.min(1.0, Math.max(0.0, userProportion));
      }

      this.props.onChange({
        userProportion: userProportion
      }, cb);
    });

    _defineProperty(this, "handleSampleSizeChange", (sampleSize, cb) => {
      if (sampleSize != null) {
        sampleSize = Math.min(maxSampleSize, Math.max(0, Math.floor(sampleSize)));
      }

      this.props.onChange({
        sampleSize: sampleSize
      }, cb);
    });

    _defineProperty(this, "handleRunSimulation", () => {
      // If they haven't filled out a parameter field, highlight it.
      if (this.props.numTrials == null || this.props.userProportion == null || this.props.sampleSize == null) {
        this.setState({
          invalidInput: true
        });
        return;
      }

      this.setState({
        invalidInput: false
      });
      this.props.onChange({
        data: this.generateData()
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "generateData", props => {
      props = props || this.props;

      const getSampleDistribution = (sampleSize, numTrials, proportion) => {
        const draw = () => {
          return this.generateNumber() < proportion;
        };

        const sampleDistribution = ___default["default"].times(100 + 1, () => 0);

        ___default["default"].times(numTrials, () => {
          const results = ___default["default"].times(sampleSize, draw);

          const count = ___default["default"].filter(results, ___default["default"].identity).length;

          const normalizedCount = Math.floor(100 * count / sampleSize);
          sampleDistribution[normalizedCount]++;
        });

        return sampleDistribution;
      };

      return getSampleDistribution(props.sampleSize, props.numTrials, props.userProportion);
    });

    _defineProperty(this, "getInputPaths", () => {
      return [["userProportion"], ["sampleSize"]];
    });

    _defineProperty(this, "focus", () => {
      const path = ___default["default"].head(this.getInputPaths());

      this.focusInputPath(path);
      return true;
    });

    _defineProperty(this, "focusInputPath", path => {
      assert$2(path.length > 0);

      const inputID = ___default["default"].head(path); // eslint-disable-next-line react/no-string-refs


      const inputComponent = this.refs[inputID];
      inputComponent.focus();
    });

    _defineProperty(this, "blurInputPath", path => {
      assert$2(path.length > 0);

      const inputID = ___default["default"].head(path); // eslint-disable-next-line react/no-string-refs


      const inputComponent = this.refs[inputID];
      inputComponent.blur();
    });

    _defineProperty(this, "getDOMNodeForPath", path => {
      assert$2(path.length > 0);

      const inputID = ___default["default"].head(path); // eslint-disable-next-line react/no-string-refs


      return ReactDOM__default["default"].findDOMNode(this.refs[inputID]);
    });

    _defineProperty(this, "getGrammarTypeForPath", path => {
      assert$2(path.length > 0);
      return "number";
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      assert$2(path.length > 0);

      const inputID = ___default["default"].head(path);

      const capitalizedID = inputID.charAt(0).toUpperCase() + inputID.slice(1);
      const functionName = "handle" + capitalizedID + "Change"; // $FlowFixMe[incompatible-use]

      this[functionName](newValue, cb);
    });

    _defineProperty(this, "getUserInput", () => {
      return null;
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return Simulator.validate(this.getUserInput(), rubric);
    });
  }

  // TODO(jangmi, CP-3288): Remove usage of `UNSAFE_componentWillMount`
  UNSAFE_componentWillMount() {
    if (this.props.randomSeed != null) {
      this.generateNumber = Util.seededRNG(this.props.randomSeed);
    }
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    if (nextProps.randomSeed !== this.props.randomSeed) {
      this.generateNumber = Util.seededRNG(nextProps.randomSeed);
    }
  }

  render() {
    const inputStyle = {
      marginLeft: "5px"
    };
    const highlight = "0px 0px 0px 2px rgba(255, 165, 0, 1)";

    const highlightStyle = ___default["default"].extend({}, inputStyle, {
      WebkitBoxShadow: highlight,
      MozBoxShadow: highlight,
      boxShadow: highlight,
      transition: "all 0.15s"
    });

    const unhighlightStyle = ___default["default"].extend({}, inputStyle, {
      transition: "all 0.15s"
    });

    const style = this.state.invalidInput ? highlightStyle : unhighlightStyle;
    const InputComponent = this.props.apiOptions.staticRender ? MathOutput : NumberInput;
    const proportionInput = /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(InputComponent // eslint-disable-next-line react/no-string-refs
    , {
      ref: "userProportion",
      style: style,
      value: this.calculateDisplayProportion(),
      checkValidity: this.checkProportionValidity,
      disabled: this.props.apiOptions.readOnly,
      onChange: this.handleUserProportionChange,
      onFocus: () => this.props.onFocus(["userProportion"]),
      onBlur: () => this.props.onBlur(["userProportion"])
    }), /*#__PURE__*/React__namespace.createElement(InfoTip, null, /*#__PURE__*/React__namespace.createElement("p", null, i18n__namespace._("This controls the proportion or percentage that will be used in your simulation."))));
    const sampleSizeInput = /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement(InputComponent // eslint-disable-next-line react/no-string-refs
    , {
      ref: "sampleSize",
      style: style,
      value: this.props.sampleSize,
      checkValidity: val => val >= 0,
      disabled: this.props.apiOptions.readOnly,
      onChange: this.handleSampleSizeChange,
      onFocus: () => this.props.onFocus(["sampleSize"]),
      onBlur: () => this.props.onBlur(["sampleSize"])
    }), /*#__PURE__*/React__namespace.createElement(InfoTip, null, /*#__PURE__*/React__namespace.createElement("p", null, i18n__namespace._("This controls the sample size that will be used in your simulation. For example, if you set this to 100, then for each trial, responses from 100 participants will be simulated."))));
    const numTrialsDisplay = /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        textAlign: "right"
      }
    }, /*#__PURE__*/React__namespace.createElement("b", null, this.props.numTrials), /*#__PURE__*/React__namespace.createElement(InfoTip, null, /*#__PURE__*/React__namespace.createElement("p", null, i18n__namespace._("This is the number of trials used in the simulation. For example, if set to 50, then the survey will be conducted 50 times.")))); // Generates a table from a set of titles and values.

    const generateTable = contents => {
      const header = /*#__PURE__*/React__namespace.createElement("thead", null, /*#__PURE__*/React__namespace.createElement("tr", null, /*#__PURE__*/React__namespace.createElement("th", null, i18n__namespace._("Parameter")), /*#__PURE__*/React__namespace.createElement("th", null, i18n__namespace._("Value"))));
      const body = /*#__PURE__*/React__namespace.createElement("tbody", null, ___default["default"].map(contents, (row, i) => {
        return /*#__PURE__*/React__namespace.createElement("tr", {
          key: i
        }, /*#__PURE__*/React__namespace.createElement("td", null, row.title), /*#__PURE__*/React__namespace.createElement("td", null, row.value));
      }));
      return /*#__PURE__*/React__namespace.createElement("table", null, header, body);
    }; // Contents for the table to-be generated


    const contents = [{
      title: this.props.proportionLabel + ":",
      value: proportionInput
    }, {
      title: i18n__namespace._("Sample size:"),
      value: sampleSizeInput
    }, {
      title: i18n__namespace._("Number of trials:"),
      value: numTrialsDisplay
    }]; // The 'Run Simulation' button

    const buttonStyle = {
      margin: "20px 0"
    };
    const startButton = /*#__PURE__*/React__namespace.createElement("button", {
      className: "simple-button",
      style: buttonStyle,
      disabled: this.props.apiOptions.readOnly,
      onClick: this.handleRunSimulation
    }, i18n__namespace._("Run simulation")); // When we plot data, ticks on the x-axis require some vertical padding

    const histogramStyle = {
      paddingBottom: this.props.data ? 40 : 0
    };
    const histogram = /*#__PURE__*/React__namespace.createElement("div", {
      style: histogramStyle
    }, /*#__PURE__*/React__namespace.createElement(Histogram, {
      data: this.props.data,
      xAxisLabel: this.props.xAxisLabel,
      yAxisLabel: this.props.yAxisLabel,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }));
    return /*#__PURE__*/React__namespace.createElement("div", null, generateTable(contents), startButton, histogram);
  }

}

_defineProperty(Simulator, "propTypes", { ...propTypes,
  apiOptions: ApiOptions.propTypes,
  data: PropTypes__default["default"].arrayOf(PropTypes__default["default"].number),
  numTrials: PropTypes__default["default"].number,
  proportionLabel: PropTypes__default["default"].string,
  proportionOrPercentage: PropTypes__default["default"].string,
  randomSeed: PropTypes__default["default"].number,
  sampleSize: PropTypes__default["default"].number,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  userProportion: PropTypes__default["default"].number,
  xAxisLabel: PropTypes__default["default"].string,
  yAxisLabel: PropTypes__default["default"].string
});

_defineProperty(Simulator, "defaultProps", {
  data: null,
  userProportion: null,
  sampleSize: null,
  numTrials: null,
  randomSeed: 0,
  xAxisLabel: "Proportion (%)",
  yAxisLabel: "Number of times seen",
  proportionLabel: "Underlying proportion",
  proportionOrPercentage: "proportion",
  apiOptions: ApiOptions.defaults
});

___default["default"].extend(Simulator, {
  validate: function (state, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }
});

const propTransform$1 = editorProps => {
  const widgetProps = ___default["default"].clone(editorProps);

  widgetProps.randomSeed = editorProps.problemNum;
  return widgetProps;
};

var Simulator$1 = {
  name: "simulator",
  displayName: "Simulator",
  widget: Simulator,
  transform: propTransform$1,
  hidden: true
};

const {
  shuffle
} = Util;
const HORIZONTAL = "horizontal";
const VERTICAL = "vertical";

class Sorter extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_isMounted", void 0);

    _defineProperty(this, "state", {
      changed: false
    });

    _defineProperty(this, "handleChange", e => {
      if (!this._isMounted) {
        return;
      }

      this.setState({
        changed: true
      }, () => {
        // Wait until all components have rendered. In React 16, the
        // setState callback fires immediately after componentDidUpdate,
        // and there is no guarantee that parent/siblings components have
        // finished rendering.
        // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
        // eslint-disable-next-line no-restricted-syntax
        setTimeout(() => {
          this.props.onChange(e);
          this.props.trackInteraction();
        }, 0);
      });
    });

    _defineProperty(this, "getUserInput", () => {
      // eslint-disable-next-line react/no-string-refs
      return {
        options: this.refs.sortable.getOptions()
      };
    });

    _defineProperty(this, "moveOptionToIndex", (option, index) => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.sortable.moveOptionToIndex(option, index);
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // If this widget hasn't been changed yet, we treat it as "empty" which
      // prevents the "Check" button from becoming active. We want the user
      // to make a change before trying to move forward. This makes an
      // assumption that the initial order isn't the correct order! However,
      // this should be rare if it happens, and interacting with the list
      // will enable the button, so they won't be locked out of progressing.
      if (!this.state.changed) {
        return {
          type: "invalid",
          message: null
        };
      }

      return Sorter.validate(this.getUserInput(), rubric);
    });
  }

  static validate(state, rubric) {
    const correct = ___default["default"].isEqual(state.options, rubric.correct);

    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message: null
    };
  }

  componentDidMount() {
    this._isMounted = true;
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  render() {
    const options = shuffle(this.props.correct, this.props.problemNum,
    /* ensurePermuted */
    true);
    const {
      apiOptions
    } = this.props;
    const marginPx = apiOptions.isMobile ? 8 : 5;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget-sorter perseus-clearfix"
    }, /*#__PURE__*/React__namespace.createElement(Sortable, {
      options: options,
      layout: this.props.layout,
      margin: marginPx,
      padding: this.props.padding,
      onChange: this.handleChange,
      linterContext: this.props.linterContext // eslint-disable-next-line react/no-string-refs
      ,
      ref: "sortable"
    }));
  }

}

_defineProperty(Sorter, "propTypes", {
  apiOptions: ApiOptions.propTypes,
  // eslint-disable-next-line react/forbid-prop-types
  correct: PropTypes__default["default"].array,
  layout: PropTypes__default["default"].oneOf([HORIZONTAL, VERTICAL]),
  onChange: PropTypes__default["default"].func,
  padding: PropTypes__default["default"].bool,
  problemNum: PropTypes__default["default"].number,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});

_defineProperty(Sorter, "defaultProps", {
  correct: [],
  layout: HORIZONTAL,
  padding: true,
  problemNum: 0,
  onChange: function () {},
  linterContext: PerseusLinter.linterContextDefault
});

var Sorter$1 = {
  name: "sorter",
  displayName: "Sorter",
  widget: Sorter,
  isLintable: true
};

const {
  assert: assert$1
} = InteractiveUtil;
/* Input handling: Maps a (row, column) pair to a unique ref used by React,
 * and extracts (row, column) pairs from input paths, used to allow outsiders
 * to focus, blur, set input values, etc. */

const getInputPath = function (row, column) {
  return ["" + row, "" + column];
};

const getDefaultPath = function () {
  return getInputPath(0, 0);
};

const getRowFromPath = function (path) {
  // 'path' should be a (row, column) pair
  assert$1(___default["default"].isArray(path) && path.length === 2);
  return +path[0];
};

const getColumnFromPath = function (path) {
  // 'path' should be a (row, column) pair
  assert$1(___default["default"].isArray(path) && path.length === 2);
  return +path[1];
};

const getRefForPath = function (path) {
  const row = getRowFromPath(path);
  const column = getColumnFromPath(path);
  return "answer" + row + "," + column;
};

class Table extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_getRows", () => {
      return this.props.answers.length;
    });

    _defineProperty(this, "_getColumns", () => {
      return this.props.answers[0].length;
    });

    _defineProperty(this, "getUserInput", () => {
      return ___default["default"].map(this.props.answers, ___default["default"].clone);
    });

    _defineProperty(this, "onValueChange", (row, column, eventOrValue) => {
      const answers = ___default["default"].map(this.props.answers, ___default["default"].clone); // If this is coming from an "input", the last argument will be an
      // event. If it's coming from a SimpleKeypadInput, it'll be the value.


      answers[row][column] = eventOrValue.target ? eventOrValue.target.value : eventOrValue;
      this.props.onChange({
        answers: answers
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "onHeaderChange", (index, e) => {
      const headers = this.props.headers.slice();
      headers[index] = e.content;
      this.props.onChange({
        headers: headers
      });
    });

    _defineProperty(this, "simpleValidate", rubric => {
      // $FlowFixMe[prop-missing]
      return Table.validate(this.getUserInput(), rubric);
    });

    _defineProperty(this, "_handleFocus", inputPath => {
      this.props.onFocus(inputPath);
    });

    _defineProperty(this, "_handleBlur", inputPath => {
      this.props.onBlur(inputPath);
    });

    _defineProperty(this, "focus", () => {
      this.focusInputPath(getDefaultPath());
      return true;
    });

    _defineProperty(this, "focusInputPath", path => {
      const inputID = getRefForPath(path); // eslint-disable-next-line react/no-string-refs

      const inputComponent = this.refs[inputID];

      if (this.props.apiOptions.customKeypad) {
        inputComponent.focus();
      } else if (this.props.apiOptions.staticRender) {
        inputComponent.focus();
      } else {
        // $FlowFixMe[prop-missing]
        // $FlowFixMe[incompatible-use]
        ReactDOM__default["default"].findDOMNode(inputComponent).focus();
      }
    });

    _defineProperty(this, "blurInputPath", path => {
      const inputID = getRefForPath(path); // eslint-disable-next-line react/no-string-refs

      const inputComponent = this.refs[inputID];

      if (this.props.apiOptions.customKeypad) {
        inputComponent.blur();
      } else if (this.props.apiOptions.staticRender) {
        inputComponent.blur();
      } else {
        // $FlowFixMe[prop-missing]
        // $FlowFixMe[incompatible-use]
        ReactDOM__default["default"].findDOMNode(inputComponent).blur();
      }
    });

    _defineProperty(this, "getDOMNodeForPath", path => {
      const inputID = getRefForPath(path); // eslint-disable-next-line react/no-string-refs

      return ReactDOM__default["default"].findDOMNode(this.refs[inputID]);
    });

    _defineProperty(this, "getInputPaths", () => {
      const rows = this._getRows();

      const columns = this._getColumns();

      const inputPaths = [];

      ___default["default"](rows).times(r => {
        ___default["default"](columns).times(c => {
          const inputPath = getInputPath(r, c);
          inputPaths.push(inputPath);
        });
      });

      return inputPaths;
    });

    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      return "number";
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      // Extract row, column information
      const row = getRowFromPath(path);
      const column = getColumnFromPath(path);

      const answers = ___default["default"].map(this.props.answers, ___default["default"].clone);

      answers[row][column] = newValue;
      this.props.onChange({
        answers: answers
      }, cb);
    });
  }

  render() {
    const rows = this._getRows();

    const columns = this._getColumns();

    const headers = this.props.headers;
    let InputComponent;
    let inputStyle;
    const extraInputProps = {};

    if (this.props.apiOptions.customKeypad) {
      InputComponent = SimpleKeypadInput; // NOTE(charlie): This is intended to match the "width: 80px" in
      // input in table.less. Those values should be kept in-sync.

      inputStyle = {
        width: 80
      };
      extraInputProps.keypadElement = this.props.keypadElement;
    } else if (this.props.apiOptions.staticRender) {
      InputComponent = MathOutput;
      inputStyle = {};
    } else {
      InputComponent = "input";
      inputStyle = {};
    }

    return /*#__PURE__*/React__namespace.createElement("table", {
      className: "perseus-widget-table-of-values non-markdown"
    }, /*#__PURE__*/React__namespace.createElement("thead", null, /*#__PURE__*/React__namespace.createElement("tr", null, ___default["default"].map(headers, (header, i) => {
      if (this.props.editableHeaders) {
        return /*#__PURE__*/React__namespace.createElement("th", {
          key: i
        }, /*#__PURE__*/React__namespace.createElement(this.props.Editor, {
          ref: "columnHeader" + i,
          apiOptions: this.props.apiOptions,
          content: header,
          widgetEnabled: false,
          onChange: ___default["default"].partial(this.onHeaderChange, i)
        }));
      }

      return /*#__PURE__*/React__namespace.createElement("th", {
        key: i
      }, /*#__PURE__*/React__namespace.createElement(Renderer, {
        content: header,
        linterContext: this.props.linterContext
      }));
    }))), /*#__PURE__*/React__namespace.createElement("tbody", null, ___default["default"](rows).times(r => {
      return /*#__PURE__*/React__namespace.createElement("tr", {
        key: r
      }, ___default["default"](columns).times(c => {
        return /*#__PURE__*/React__namespace.createElement("td", {
          key: c
        }, /*#__PURE__*/React__namespace.createElement(InputComponent, _extends$1({
          ref: getRefForPath(getInputPath(r, c)),
          type: "text",
          value: this.props.answers[r][c],
          disabled: this.props.apiOptions.readOnly,
          onFocus: ___default["default"].partial(this._handleFocus, getInputPath(r, c)),
          onBlur: ___default["default"].partial(this._handleBlur, getInputPath(r, c)),
          onChange: ___default["default"].partial(this.onValueChange, r, c),
          style: inputStyle
        }, extraInputProps)));
      }));
    })));
  }

}

_defineProperty(Table, "propTypes", {
  answers: PropTypes__default["default"].arrayOf(PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)),
  editableHeaders: PropTypes__default["default"].bool,
  // The editor to use when editableHeaders is enabled
  Editor: PropTypes__default["default"].func,
  headers: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
  keypadElement: mathInput.keypadElementPropType,
  trackInteraction: PropTypes__default["default"].func.isRequired,
  linterContext: PerseusLinter.linterContextProps
});

_defineProperty(Table, "defaultProps", function () {
  const defaultRows = 4;
  const defaultColumns = 1;

  const blankAnswers = ___default["default"](defaultRows).times(function () {
    return Util.stringArrayOfSize(defaultColumns);
  });

  return {
    apiOptions: ApiOptions.defaults,
    headers: [""],
    editableHeaders: false,
    rows: defaultRows,
    columns: defaultColumns,
    answers: blankAnswers,
    linterContext: PerseusLinter.linterContextDefault
  };
}());

___default["default"].extend(Table, {
  validate: function (state, rubric) {
    const filterNonEmpty = function (table) {
      return ___default["default"].filter(table, function (row) {
        // Check if row has a cell that is nonempty
        return ___default["default"].some(row, ___default["default"].identity);
      });
    };

    const solution = filterNonEmpty(rubric.answers);
    const supplied = filterNonEmpty(state);

    const hasEmptyCell = ___default["default"].some(supplied, function (row) {
      return ___default["default"].some(row, function (cell) {
        return cell === "";
      });
    });

    if (hasEmptyCell || !supplied.length) {
      return {
        type: "invalid",
        message: null
      };
    }

    if (supplied.length !== solution.length) {
      return {
        type: "points",
        earned: 0,
        total: 1,
        message: null
      };
    }

    const createValidator = KhanAnswerTypes.number.createValidatorFunctional;
    let message = null;

    const allCorrect = ___default["default"].every(solution, function (rowSolution) {
      let i;

      for (i = 0; i < supplied.length; i++) {
        const rowSupplied = supplied[i];

        const correct = ___default["default"].every(rowSupplied, function (cellSupplied, i) {
          const cellSolution = rowSolution[i];
          const validator = createValidator(cellSolution, {
            simplify: true
          });
          const result = validator(cellSupplied);

          if (result.message) {
            message = result.message;
          }

          return result.correct;
        });

        if (correct) {
          supplied.splice(i, 1);
          return true;
        }
      }

      return false;
    });

    return {
      type: "points",
      earned: allCorrect ? 1 : 0,
      total: 1,
      message: message
    };
  }
});

const propTransform = editorProps => {
  // Remove answers before passing to widget
  const rows = editorProps.answers.length;
  const columns = editorProps.answers[0].length;

  const blankAnswers = ___default["default"](rows).times(function () {
    return Util.stringArrayOfSize(columns);
  });

  return ___default["default"].extend({}, editorProps, {
    answers: blankAnswers
  });
};

var Table$1 = {
  name: "table",
  displayName: "Table of values",
  accessible: true,
  widget: Table,
  transform: propTransform,
  hidden: true,
  isLintable: true
};

const {
  deepEq,
  getGridStep,
  captureScratchpadTouchStart
} = Util;
const {
  assert
} = InteractiveUtil;
const ROTATE_SNAP_DEGREES = 15;
const DEGREE_SIGN = "\u00B0";
const RENDER_TRANSFORM_DELAY_IN_MS = 300;
const ROTATE_HANDLE_DIST = 1.5;
const REFLECT_ROTATE_HANDLE_DIST = 2;
const REFLECT_BUTTON_SIZE = 1;
const defaultBoxSize = 400;
const defaultBackgroundImage = {
  url: null
};
/* Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */

function pluckObject(object, subKey) {
  return ___default["default"].object(___default["default"].map(object, function (value, key) {
    return [key, value[subKey]];
  }));
}

const defaultGraphProps = function (setProps, boxSize) {
  setProps = setProps || {};
  const labels = setProps.labels || ["x", "y"];
  const range = setProps.range || [[-10, 10], [-10, 10]];
  const step = setProps.step || [1, 1];
  const gridStep = setProps.gridStep || getGridStep(range, step, boxSize);
  return {
    box: [boxSize, boxSize],
    labels: labels,
    range: range,
    step: step,
    gridStep: gridStep,
    valid: true,
    backgroundImage: defaultBackgroundImage,
    markings: "grid",
    showProtractor: false
  };
};

const defaultTransformerProps = {
  apiOptions: ApiOptions.defaults,
  gradeEmpty: false,
  graphMode: "interactive",
  listMode: "dynamic",
  graph: {},
  tools: {
    translation: {
      enabled: true,
      required: false,
      constraints: {}
    },
    rotation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [1, 6]
    },
    reflection: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coords: [[2, -4], [2, 2]]
    },
    dilation: {
      enabled: true,
      required: false,
      constraints: {
        fixed: false
      },
      coord: [6, 6]
    }
  },
  drawSolutionShape: true,
  starting: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  },
  correct: {
    shape: {
      type: "polygon-3",
      coords: [[2, 2], [2, 6], [7, 2]]
    },
    transformations: []
  }
};

function colorForTool(tool) {
  return tool.constraints.fixed ? KhanColors.DYNAMIC : KhanColors.INTERACTIVE;
}
/* Scales a distance from the default range of
 * [-10, 10] to a given props.range pair
 *
 * Used for sizing various transformation tools
 * (rotation handle, dilation circle)
 */


function scaleToRange(dist, range) {
  const spreadX = range[0][1] - range[0][0];
  const spreadY = range[1][1] - range[1][0];
  return dist * Math.max(spreadX, spreadY) / 20;
}

function dilatePointFromCenter(point, dilationCenter, scale) {
  const pv = kmath.vector.subtract(point, dilationCenter);
  const pvScaled = kmath.vector.scale(pv, scale);
  const transformedPoint = kmath.vector.add(dilationCenter, pvScaled);
  return transformedPoint;
} // TODO(jack): i18nize this


function stringFromDecimal(number) {
  return String(KhanMath.roundTo(9, number));
}

function stringFromFraction(number) {
  const frac = KhanMath.toFraction(number, kmath.number.DEFAULT_TOLERANCE);

  if (frac[1] === 1) {
    return stringFromDecimal(number);
  }

  return stringFromDecimal(frac[0]) + "/" + stringFromDecimal(frac[1]);
}

function texFromPoint(point) {
  const {
    TeX
  } = getDependencies();
  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "("
  }, "("), stringFromDecimal(point[0]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ","
  }, ", {}"), stringFromDecimal(point[1]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ")"
  }, ")")];
}

function texFromVector(vector) {
  const {
    TeX
  } = getDependencies();
  return [/*#__PURE__*/React__namespace.createElement(TeX, {
    key: "<"
  }, i18n__namespace.doNotTranslate("\\langle")), stringFromDecimal(vector[0]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ","
  }, ", {}"), stringFromDecimal(vector[1]), /*#__PURE__*/React__namespace.createElement(TeX, {
    key: ">"
  }, i18n__namespace.doNotTranslate("\\rangle"))];
}

function texFromAngleDeg(angleDeg) {
  return stringFromDecimal(angleDeg) + DEGREE_SIGN;
}

function orderInsensitiveCoordsEqual(coords1, coords2) {
  coords1 = ___default["default"].clone(coords1).sort(kmath.point.compare);
  coords2 = ___default["default"].clone(coords2).sort(kmath.point.compare);
  return ___default["default"].all(___default["default"].map(coords1, function (coord1, i) {
    const coord2 = coords2[i];
    return kmath.point.equal(coord1, coord2);
  }));
}

const inputComponentForApiOptions = apiOptions => {
  if (apiOptions.customKeypad) {
    return SimpleKeypadInput;
  }

  if (apiOptions.staticRender) {
    return MathOutput;
  }

  return NumberInput;
};
/* Perform operations on raw transform objects */


const TransformOps = {
  apply: function (transform) {
    // Any transformation with empty text boxes is a no-op until
    // filled out (these show up as nulls in transform.vector/line/etc).
    // TODO (jack): Merge this just into reflections now that other
    // transforms are always valid (after merging transformation
    // collapsing, which may use isValid)
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-call]
    if (!Transformations[transform.type].isValid(transform)) {
      return ___default["default"].identity; // do not transform the coord
    } // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-call]


    return Transformations[transform.type].apply(transform);
  },
  append: function (transformList, newTransform) {
    // Append newTransform to transformList, and collapse the last
    // two transforms if they are collapsable
    const results = TransformOps._appendAndCollapseLastTwo(transformList, newTransform); // Collapse any no-ops at the end of the transformation list


    return TransformOps._collapseFinalNoOps(results);
  },
  _collapseFinalNoOps: function (transforms) {
    // Collapse no-op transformations at the end of the list
    if (transforms.length && TransformOps.isNoOp(___default["default"].last(transforms))) {
      return ___default["default"].initial(transforms);
    }

    return transforms;
  },
  _appendAndCollapseLastTwo: function (transformList, newTransform) {
    if (!transformList.length) {
      return [newTransform];
    }

    const collapsed = TransformOps.collapse(___default["default"].last(transformList), newTransform);
    return ___default["default"].initial(transformList).concat(collapsed);
  },
  isNoOp: function (transform) {
    return Transformations[transform.type].isNoOp(transform);
  },
  collapse: function (transform1, transform2) {
    // We can only collapse transforms that have the same type
    if (transform1.type !== transform2.type) {
      return [transform1, transform2];
    } // Clicking the button again removes empty transformations


    if (TransformOps.isEmpty(transform1) && TransformOps.isEmpty(transform2)) {
      return [];
    } // Don't collapse invalid transformations otherwise


    if (!TransformOps.isValid(transform1) || !TransformOps.isValid(transform2)) {
      return [transform1, transform2];
    }

    return TransformOps._collapseValidMonotypedTransforms(transform1, transform2);
  },
  isValid: function (transform) {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-call]
    return Transformations[transform.type].isValid(transform);
  },
  isEmpty: function (transform) {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[incompatible-call]
    return Transformations[transform.type].isEmpty(transform);
  },
  _collapseValidMonotypedTransforms: function (transform1, transform2) {
    let collapsed = Transformations[transform1.type].collapse(transform1, transform2);

    if (collapsed) {
      // Force all answers into an array
      if (!___default["default"].isArray(collapsed)) {
        collapsed = [collapsed];
      } // Add types to all transforms in the answer


      ___default["default"].each(collapsed, function (transform) {
        transform.type = transform1.type;
      });

      return collapsed;
    } // These transforms can't be collapsed together


    return [transform1, transform2];
  },
  toTeX: function (transform) {
    return Transformations[transform.type].toTeX(transform);
  },

  /* A react representation of this transform object */
  ListItem: createReactClass__default["default"]({
    displayName: "ListItem",
    render: function () {
      if (this.props.mode === "dynamic") {
        return /*#__PURE__*/React__namespace.createElement("div", null, TransformOps.toTeX(this.props.transform));
      }

      if (this.props.mode === "interactive") {
        const TransformClass = Transformations[this.props.transform.type].Input;
        return /*#__PURE__*/React__namespace.createElement(TransformClass // eslint-disable-next-line react/no-string-refs
        , _extends$1({
          ref: "transform",
          onChange: this.handleChange,
          onFocus: this.props.onFocus,
          onBlur: this.props.onBlur,
          keypadElement: this.props.keypadElement,
          apiOptions: this.props.apiOptions
        }, this.props.transform));
      }

      throw new PerseusError("Invalid mode: " + this.props.mode, Errors.InvalidInput);
    },
    value: function () {
      if (this.props.mode === "interactive") {
        return ___default["default"].extend({
          type: this.props.transform.type
        }, // eslint-disable-next-line react/no-string-refs
        this.refs.transform.value());
      }

      return this.props.transform;
    },
    handleChange: ___default["default"].debounce(function (callback) {
      this.props.onChange(this.value(), callback);
    }, RENDER_TRANSFORM_DELAY_IN_MS),

    /* InputPath API: depending on the API call, this could involve simply
     * navigating to the right ref and calling the function on that
     * component, or threading the call down and returning the result. */
    _getComponentAtPath: function (path) {
      // eslint-disable-next-line react/no-string-refs
      const transform = this.refs.transform;

      const ref = ___default["default"].head(path);

      return transform.refs[ref];
    },
    focus: function () {
      // eslint-disable-next-line react/no-string-refs
      const transform = this.refs.transform;

      const path = ___default["default"].head(transform.getInputPaths());

      if (path) {
        this.focusInputPath(path);
      }
    },
    focusInputPath: function (path) {
      this._getComponentAtPath(path).focus();
    },
    blurInputPath: function (path) {
      this._getComponentAtPath(path).blur();
    },
    getDOMNodeForPath: function (path) {
      return ReactDOM__default["default"].findDOMNode(this._getComponentAtPath(path));
    },
    getGrammarTypeForPath: function (path) {
      return "number";
    },
    setInputValue: function (path, value, cb) {
      // `value` comes in as a string on mobile, but we need a number
      // We let through the empty string so that "Clear" works -- in
      // that case, the transformer widget will just act as if there is
      // no input, which is what we want.
      if (value.length) {
        value = parseFloat(value);

        if (isNaN(value)) {
          return;
        }
      } // eslint-disable-next-line react/no-string-refs


      this.refs.transform.setInputValue(path, value, cb);
    },
    getInputPaths: function () {
      // If we're in dynamic mode, then the list items are made up of
      // static text.
      if (this.props.mode === "dynamic") {
        return [];
      } // eslint-disable-next-line react/no-string-refs


      return this.refs.transform.getInputPaths();
    }
  })
};
const Transformations = {
  translation: {
    // I18N: As in the command, "Translate the polygon"
    verbName: i18n__namespace._("Translate"),
    nounName: i18n__namespace._("Translation"),
    lowerNounName: i18n__namespace._("translation"),
    apply: function (transform) {
      return function (coord) {
        return kmath.vector.add(coord, transform.vector);
      };
    },
    isValid: function (transform) {
      return ___default["default"].isFinite(transform.vector[0]) && ___default["default"].isFinite(transform.vector[1]);
    },
    isEmpty: function (transform) {
      return transform.vector[0] === null && transform.vector[1] === null;
    },
    isNoOp: function (transform) {
      return kmath.vector.equal(transform.vector, [0, 0]);
    },
    collapse: function (transform1, transform2) {
      return {
        vector: kmath.vector.add(transform1.vector, transform2.vector)
      };
    },
    toTeX: function (transform) {
      // I18N: As in the command, "Translation by <3, 1>"
      return i18n__namespace.$_("Translation by %(vector)s", {
        vector: texFromVector(transform.vector)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);

        _defineProperty(this, "state", {
          vector: this.props.vector || [null, null]
        });

        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          const x = this.refs.x.getValue(); // eslint-disable-next-line react/no-string-refs

          const y = this.refs.y.getValue();
          return {
            vector: [x, y]
          };
        });

        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);

          const vector = ___default["default"].clone(this.state.vector);

          if (id === "x") {
            vector[0] = value;
          } else if (id === "y") {
            vector[1] = value;
          }

          this.setState({
            vector: vector
          }, () => {
            this.props.onChange(cb);
          });
        });

        _defineProperty(this, "getInputPaths", () => {
          return [["x"], ["y"]];
        });
      }

      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            vector: this.props.vector
          });
        }
      }

      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const vector = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "<"
        }, i18n__namespace.doNotTranslate("\\langle")), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "vec_x" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x",
          placeholder: 0,
          value: this.state.vector[0],
          useArrowKeys: true,
          onChange: val0 => {
            const val1 = this.state.vector[1];
            this.setState({
              vector: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "x"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "vec_y" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y",
          placeholder: 0,
          value: this.state.vector[1],
          useArrowKeys: true,
          onChange: val1 => {
            const val0 = this.state.vector[0];
            this.setState({
              vector: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "y"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ">"
        }, i18n__namespace.doNotTranslate("\\rangle"))];
        return /*#__PURE__*/React__namespace.createElement("div", null, i18n__namespace.$_("Translation by %(vector)s", {
          vector: vector
        }));
      }

    }
  },
  rotation: {
    // I18N: As in the command, "Rotate the polygon"
    verbName: i18n__namespace._("Rotate"),
    nounName: i18n__namespace._("Rotation"),
    lowerNounName: i18n__namespace._("rotation"),
    apply: function (transform) {
      return function (coord) {
        return kmath.point.rotateDeg(coord, transform.angleDeg, transform.center);
      };
    },
    isValid: function (transform) {
      return ___default["default"].isFinite(transform.angleDeg) && ___default["default"].isFinite(transform.center[0]) && ___default["default"].isFinite(transform.center[1]);
    },
    isEmpty: function (transform) {
      return transform.angleDeg === null && transform.center[0] === null && transform.center[1] === null;
    },
    isNoOp: function (transform) {
      return kmath.number.equal(transform.angleDeg, 0);
    },
    collapse: function (transform1, transform2) {
      if (!kmath.point.equal(transform1.center, transform2.center)) {
        return false;
      }

      return {
        center: transform1.center,
        angleDeg: transform1.angleDeg + transform2.angleDeg
      };
    },
    toTeX: function (transform) {
      return i18n__namespace.$_("Rotation by %(degrees)s about %(point)s", {
        degrees: texFromAngleDeg(transform.angleDeg),
        point: texFromPoint(transform.center)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);

        _defineProperty(this, "state", {
          center: this.props.center || [null, null],
          angleDeg: this.props.angleDeg || null
        });

        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          const angleDeg = this.refs.angleDeg.getValue(); // eslint-disable-next-line react/no-string-refs

          const centerX = this.refs.centerX.getValue(); // eslint-disable-next-line react/no-string-refs

          const centerY = this.refs.centerY.getValue();
          return {
            angleDeg: angleDeg,
            center: [centerX, centerY]
          };
        });

        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);

          let angleDeg = ___default["default"].clone(this.state.angleDeg);

          const center = ___default["default"].clone(this.state.center);

          if (id === "angleDeg") {
            angleDeg = value;
          } else if (id === "centerX") {
            center[0] = value;
          } else if (id === "centerY") {
            center[1] = value;
          }

          this.setState({
            angleDeg: angleDeg,
            center: center
          }, () => {
            this.props.onChange(cb);
          });
        });

        _defineProperty(this, "getInputPaths", () => {
          return [["centerX"], ["centerY"], ["angleDeg"]];
        });
      }

      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            center: this.props.center,
            angleDeg: this.props.angleDeg
          });
        }
      }

      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const point = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "X" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "centerX",
          placeholder: 0,
          value: this.state.center[0],
          useArrowKeys: true,
          onChange: val0 => {
            const val1 = this.state.center[1];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "centerX"),
          onBlur: ___default["default"].partial(this.props.onBlur, "centerX"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "Y" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "centerY",
          placeholder: 0,
          value: this.state.center[1],
          useArrowKeys: true,
          onChange: val1 => {
            const val0 = this.state.center[0];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "centerY"),
          onBlur: ___default["default"].partial(this.props.onBlur, "centerY"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        const degrees = [/*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "deg" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "angleDeg",
          placeholder: 0,
          value: this.state.angleDeg,
          useArrowKeys: true,
          onChange: val => {
            this.setState({
              angleDeg: val
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "angleDeg"),
          onBlur: ___default["default"].partial(this.props.onBlur, "angleDeg"),
          keypadElement: this.props.keypadElement
        }), DEGREE_SIGN]; // I18N: %(point)s must come before %(degrees)s in this phrase

        const text = i18n__namespace.$_("Rotation about %(point)s by %(degrees)s", {
          point,
          degrees
        });
        return /*#__PURE__*/React__namespace.createElement("div", null, text);
      }

    }
  },
  reflection: {
    // I18N: As in the command, "Reflect the polygon"
    verbName: i18n__namespace._("Reflect"),
    nounName: i18n__namespace._("Reflection"),
    lowerNounName: i18n__namespace._("reflection"),
    apply: function (transform) {
      return function (coord) {
        return kmath.point.reflectOverLine(coord, transform.line);
      };
    },
    isValid: function (transform) {
      // A bit hacky, but we'll also define reflecting over a
      // single point as a no-op, to avoid NaN fun.
      return ___default["default"].all(___default["default"].flatten(transform.line), ___default["default"].isFinite) && !kmath.point.equal(transform.line[0], transform.line[1]);
    },
    isEmpty: function (transform) {
      return ___default["default"].all(___default["default"].flatten(transform.line), ___default["default"].isNull);
    },
    isNoOp: function (transform) {
      // Invalid transforms are implicitly no-ops, so we don't
      // have to catch that case here.
      return false;
    },
    collapse: function (transform1, transform2) {
      // $FlowFixMe[incompatible-call]
      if (!kmath.line.equal(transform1.line, transform2.line)) {
        return false;
      }

      return [];
    },
    toTeX: function (transform) {
      const point1 = transform.line[0];
      const point2 = transform.line[1];
      return i18n__namespace.$_("Reflection over the line from %(point1)s to %(point2)s", {
        point1: texFromPoint(point1),
        point2: texFromPoint(point2)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);

        _defineProperty(this, "state", {
          line: this.props.line || [[null, null], [null, null]]
        });

        _defineProperty(this, "changePoint", (i, j, val, cb) => {
          const line = ___default["default"].map(this.state.line, ___default["default"].clone);

          line[i][j] = val;
          this.setState({
            line: line
          }, () => {
            this.props.onChange(cb);
          });
        });

        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          const x1 = this.refs.x1.getValue(); // eslint-disable-next-line react/no-string-refs

          const y1 = this.refs.y1.getValue(); // eslint-disable-next-line react/no-string-refs

          const x2 = this.refs.x2.getValue(); // eslint-disable-next-line react/no-string-refs

          const y2 = this.refs.y2.getValue();
          return {
            line: [[x1, y1], [x2, y2]]
          };
        });

        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);

          let j;

          if (id[0] === "x") {
            j = 0;
          } else if (id[0] === "y") {
            j = 1;
          }

          let i;

          if (id[1] === "1") {
            i = 0;
          } else if (id[1] === "2") {
            i = 1;
          }

          this.changePoint(i, j, value, cb);
        });

        _defineProperty(this, "getInputPaths", () => {
          return [["x1"], ["y1"], ["x2"], ["y2"]];
        });
      }

      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            line: this.props.line
          });
        }
      }

      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const point1 = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "x1" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x1",
          value: this.state.line[0][0],
          useArrowKeys: true // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 0, 0),
          onFocus: ___default["default"].partial(this.props.onFocus, "x1"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x1"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "y1" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y1",
          value: this.state.line[0][1],
          useArrowKeys: true // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 0, 1),
          onFocus: ___default["default"].partial(this.props.onFocus, "y1"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y1"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        const point2 = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "x2" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x2",
          value: this.state.line[1][0],
          useArrowKeys: true // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 1, 0),
          onFocus: ___default["default"].partial(this.props.onFocus, "x2"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x2"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "y2" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y2",
          value: this.state.line[1][1],
          useArrowKeys: true // eslint-disable-next-line react/jsx-no-bind
          ,
          onChange: this.changePoint.bind(this, 1, 1),
          onFocus: ___default["default"].partial(this.props.onFocus, "y2"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y2"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        return /*#__PURE__*/React__namespace.createElement("div", null, i18n__namespace.$_("Reflection over the line from " + "%(point1)s to %(point2)s", {
          point1,
          point2
        }));
      }

    }
  },
  dilation: {
    // I18N: As in the command, "Dilate the polygon"
    verbName: i18n__namespace._("Dilate"),
    nounName: i18n__namespace._("Dilation"),
    lowerNounName: i18n__namespace._("dilation"),
    apply: function (transform) {
      return function (coord) {
        return dilatePointFromCenter(coord, transform.center, transform.scale);
      };
    },
    isValid: function (transform) {
      return ___default["default"].isFinite(transform.scale) && ___default["default"].isFinite(transform.center[0]) && ___default["default"].isFinite(transform.center[1]);
    },
    isEmpty: function (transform) {
      return transform.scale === null && transform.center[0] === null && transform.center[1] === null;
    },
    isNoOp: function (transform) {
      return kmath.number.equal(transform.scale, 1);
    },
    collapse: function (transform1, transform2) {
      if (!kmath.point.equal(transform1.center, transform2.center)) {
        return false;
      }

      return {
        center: transform1.center,
        scale: transform1.scale * transform2.scale
      };
    },
    toTeX: function (transform) {
      const scaleString = stringFromFraction(transform.scale);
      return i18n__namespace.$_("Dilation of scale %(scale)s about %(point)s", {
        scale: scaleString,
        point: texFromPoint(transform.center)
      });
    },
    Input: class Input extends React__namespace.Component {
      constructor() {
        super(...arguments);

        _defineProperty(this, "state", {
          center: this.props.center || [null, null],
          scale: this.props.scale || null
        });

        _defineProperty(this, "value", () => {
          // eslint-disable-next-line react/no-string-refs
          const scale = this.refs.scale.getValue(); // eslint-disable-next-line react/no-string-refs

          const x = this.refs.x.getValue(); // eslint-disable-next-line react/no-string-refs

          const y = this.refs.y.getValue();
          return {
            scale: scale,
            center: [x, y]
          };
        });

        _defineProperty(this, "setInputValue", (path, value, cb) => {
          const id = ___default["default"].first(path);

          let scale = this.state.scale;

          const center = ___default["default"].clone(this.state.center);

          if (id === "x") {
            center[0] = value;
          } else if (id === "y") {
            center[1] = value;
          } else if (id === "scale") {
            scale = value;
          }

          this.setState({
            scale: scale,
            center: center
          }, () => {
            this.props.onChange(cb);
          });
        });

        _defineProperty(this, "getInputPaths", () => {
          return [["x"], ["y"], ["scale"]];
        });
      }

      componentDidUpdate(prevProps) {
        if (!deepEq(this.props, prevProps)) {
          this.setState({
            center: this.props.center,
            scale: this.props.scale
          });
        }
      }

      render() {
        const InputComponent = inputComponentForApiOptions(this.props.apiOptions);
        const {
          TeX
        } = getDependencies();
        const point = [/*#__PURE__*/React__namespace.createElement(TeX, {
          key: "("
        }, "("), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "point_x" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "x",
          placeholder: 0,
          value: this.state.center[0],
          useArrowKeys: true,
          onChange: val0 => {
            const val1 = this.state.center[1];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "x"),
          onBlur: ___default["default"].partial(this.props.onBlur, "x"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ","
        }, ", {}"), /*#__PURE__*/React__namespace.createElement(InputComponent, {
          key: "point_y" // eslint-disable-next-line react/no-string-refs
          ,
          ref: "y",
          placeholder: 0,
          value: this.state.center[1],
          useArrowKeys: true,
          onChange: val1 => {
            const val0 = this.state.center[0];
            this.setState({
              center: [val0, val1]
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "y"),
          onBlur: ___default["default"].partial(this.props.onBlur, "y"),
          keypadElement: this.props.keypadElement
        }), /*#__PURE__*/React__namespace.createElement(TeX, {
          key: ")"
        }, ")")];
        const scale = /*#__PURE__*/React__namespace.createElement(InputComponent // eslint-disable-next-line react/no-string-refs
        , {
          ref: "scale",
          placeholder: 1,
          value: this.state.scale,
          useArrowKeys: true,
          onChange: val => {
            this.setState({
              scale: val
            }, () => {
              this.props.onChange();
            });
          },
          onFocus: ___default["default"].partial(this.props.onFocus, "scale"),
          onBlur: ___default["default"].partial(this.props.onBlur, "scale"),
          keypadElement: this.props.keypadElement
        });
        return /*#__PURE__*/React__namespace.createElement("div", null, i18n__namespace.$_("Dilation about %(point)s by %(scale)s", {
          point,
          scale
        }));
      }

    }
  }
};
/* Various functions to deal with different shape types */

const ShapeTypes = {
  getPointCountForType: function (type) {
    const splitType = type.split("-");

    if (splitType[0] === "polygon") {
      return splitType[1] || 3;
    }

    if (splitType[0] === "line" || splitType[0] === "lineSegment") {
      return 2;
    }

    if (splitType[0] === "angle") {
      return 3;
    }

    if (splitType[0] === "circle") {
      return 2;
    }

    if (splitType[0] === "point") {
      return 1;
    }
  },
  addMovableShape: function (graphie, options) {
    if (options.editable && options.translatable) {
      throw new PerseusError("It doesn't make sense to have a movable shape " + "where you can stretch the points and translate them " + "simultaneously. options: " + JSON.stringify(options), Errors.InvalidInput);
    }

    const points = ___default["default"].map(options.shape.coords, function (coord) {
      let isMoving = false;
      let previousCoord = coord;

      const onMove = function (x, y) {
        if (!isMoving) {
          previousCoord = currentPoint.coord;
          isMoving = true;
        }

        let moveVector = kmath.vector.subtract([x, y], currentPoint.coord); // Translate from (x, y) semantics to (dX, dY) semantics
        // This is more useful for translations on multiple points,
        // where we care about how the points moved, not where any
        // individual point ended up

        if (options.onMove) {
          moveVector = options.onMove(moveVector[0], moveVector[1]);
        } // Perform a translation on all points in this shape when
        // any point moves


        if (options.translatable) {
          ___default["default"].each(points, function (point) {
            // The point itself will be updated by the
            // movablePoint class, so only translate the other
            // points
            if (point !== currentPoint) {
              point.setCoord(kmath.vector.add(point.coord, moveVector));
            }
          });
        } // Update our shape and our currentPoint
        // Without this, some shapes (circles, angles) appear
        // "bouncy" as they are updated with currentPoint at the
        // current mouse coordinate (oldCoord), rather than newCoord


        const oldCoord = currentPoint.coord;
        const newCoord = kmath.vector.add(currentPoint.coord, moveVector); // Temporarily change our coordinate so that
        // shape.update() sees the new coordinate

        currentPoint.coord = newCoord;
        shape.update(); // ...But don't break onMove, which assumes it
        // is the only thing changing our coord

        currentPoint.coord = oldCoord;
        return newCoord;
      };

      const onMoveEnd = function () {
        // onMove isn't guaranteed to be called before onMoveEnd, so
        // we have to take into account that we may not have moved and
        // set previousCoord.
        // $FlowFixMe[prop-missing]
        if (options.onMoveEnd && isMoving) {
          isMoving = false; // We don't use the supplied x and y parameters here
          // because MovablePoint's onMoveEnd semantics suck.
          // It returns the mouseX, mouseY without processing them
          // through onMove, leaving us with weird fractional moves

          const change = kmath.vector.subtract(currentPoint.coord, previousCoord);
          options.onMoveEnd(change[0], change[1]);
        }

        shape.update();
      };

      const currentPoint = graphie.addMovablePoint({
        coord: coord,
        normalStyle: options.normalPointStyle,
        highlightStyle: options.highlightPointStyle,
        constraints: {
          fixed: !options.translatable && !options.editable
        },
        visible: options.showPoints,
        // $FlowFixMe[prop-missing]
        snapX: options.snap && options.snap[0] || 0,
        // $FlowFixMe[prop-missing]
        snapY: options.snap && options.snap[1] || 0,
        bounded: false,
        // Don't bound it when placing it on the graph
        onMove: onMove,
        onMoveEnd: onMoveEnd
      }); // Bound it when moving
      // We can't set this earlier, because doing so would mean any
      // points outside of the graph would be moved into a moved into
      // a position that doesn't preserve the shape

      currentPoint.bounded = true;
      return currentPoint;
    });

    const shape = ShapeTypes.addShape(graphie, options, points);
    const removeShapeWithoutPoints = shape.remove;

    shape.remove = function () {
      removeShapeWithoutPoints.apply(shape);

      ___default["default"].invoke(points, "remove");
    };

    return shape;
  },
  addShape: function (graphie, options, points) {
    points = points || options.shape.coords;

    const types = ShapeTypes._typesOf(options.shape);

    const typeOptions = options.shape.options || ShapeTypes.defaultOptions(types);

    const shapes = ShapeTypes._mapTypes(types, points, function (type, points, i) {
      const shapeOptions = ___default["default"].extend({}, options, typeOptions[i]);

      return ShapeTypes._addType(graphie, type, points, shapeOptions);
    });

    const updateFuncs = ___default["default"].filter(___default["default"].pluck(shapes, "update"), ___default["default"].identity);

    const update = function () {
      ___default["default"].invoke(updateFuncs, "call");
    };

    const removeFuncs = ___default["default"].filter(___default["default"].pluck(shapes, "remove"), ___default["default"].identity);

    const remove = function () {
      ___default["default"].invoke(removeFuncs, "call");
    };

    const getOptions = function () {
      return ___default["default"].map(shapes, function (shape) {
        if (shape.getOptions) {
          return shape.getOptions();
        }

        return {};
      });
    };

    const toJSON = function () {
      const coords = ___default["default"].map(points, function (pt) {
        if (___default["default"].isArray(pt)) {
          return pt;
        }

        return pt.coord;
      });

      return {
        type: types,
        coords: coords,
        options: getOptions()
      };
    };

    return {
      type: types,
      points: points,
      update: update,
      remove: remove,
      toJSON: toJSON,
      getOptions: getOptions
    };
  },
  equal: function (shape1, shape2) {
    const types1 = ShapeTypes._typesOf(shape1);

    const types2 = ShapeTypes._typesOf(shape2);

    if (types1.length !== types2.length) {
      return false;
    }

    const shapes1 = ShapeTypes._mapTypes(types1, shape1.coords, ShapeTypes._combine);

    const shapes2 = ShapeTypes._mapTypes(types2, shape2.coords, ShapeTypes._combine);

    return ___default["default"].all(___default["default"].map(shapes1, function (partialShape1, i) {
      const partialShape2 = shapes2[i];

      if (partialShape1.type !== partialShape2.type) {
        return false;
      }

      return ShapeTypes._forType(partialShape1.type).equal(partialShape1.coords, partialShape2.coords);
    }));
  },
  _typesOf: function (shape) {
    let types = shape.type;

    if (!___default["default"].isArray(types)) {
      types = [types];
    }

    return ___default["default"].map(types, function (type) {
      if (type === "polygon") {
        return "polygon-3";
      }

      return type;
    });
  },
  defaultOptions: function (types) {
    return ___default["default"].map(types, function (type) {
      const typeDefaultOptions = ShapeTypes._forType(type).defaultOptions;

      return ___default["default"].extend({}, typeDefaultOptions);
    });
  },
  _forType: function (type) {
    const baseType = type.split("-")[0];
    return ShapeTypes[baseType];
  },
  _mapTypes: function (types, points, func, context) {
    return ___default["default"].map(types, function (type, i) {
      const pointCount = ShapeTypes.getPointCountForType(type);

      const currentPoints = ___default["default"].first(points, pointCount);

      points = ___default["default"].rest(points, pointCount); // $FlowFixMe[extra-arg]

      return func.call(context, type, currentPoints, i);
    });
  },
  _addType: function (graphie, type, points, options) {
    const lineCoords = ___default["default"].isArray(points[0]) ? {
      coordA: points[0],
      coordZ: points[1]
    } : {
      pointA: points[0],
      pointZ: points[1]
    };
    type = type.split("-")[0];

    if (type === "polygon") {
      const polygon = graphie.addMovablePolygon(___default["default"].extend({}, options, {
        fixed: !options.editable,
        snapX: options.snap && options.snap[0] || 0,
        snapY: options.snap && options.snap[1] || 0,
        points: points,
        constrainToGraph: false
      }));
      return {
        update: polygon.transform.bind(polygon),
        remove: polygon.remove.bind(polygon)
      };
    }

    if (type === "line" || type === "lineSegment") {
      const line = graphie.addMovableLineSegment(___default["default"].extend({}, options, lineCoords, {
        movePointsWithLine: true,
        fixed: true,
        constraints: {
          fixed: true
        },
        extendLine: type === "line"
      })); // TODO(jack): Hide points on uneditable lines when translation
      // is a vector.
      // We can't just remove the points yet, because they are the
      // translation handle for the line.

      return {
        update: line.transform.bind(line, true),
        remove: line.remove.bind(line)
      };
    }

    if (type === "angle") {
      // If this angle is editable, we want to be able to make angles
      // both larger and smaller than 180 degrees.
      // If this angle is not editable, it should always maintain
      // it's angle measure, even if it is reflected (causing the
      // clockwise-ness of the points to change)
      const shouldChangeReflexivity = options.editable ? null : false;
      const angle = graphie.addMovableAngle({
        angleLabel: "$deg0",
        fixed: true,
        points: points,
        normalStyle: options.normalStyle,
        reflex: options.reflex
      }); // Hide non-vertex points on uneditable angles

      if (!___default["default"].isArray(points[0]) && !options.editable) {
        points[0].remove();
        points[2].remove();
      }

      return {
        update: angle.update.bind(angle, shouldChangeReflexivity),
        remove: angle.remove.bind(angle),
        getOptions: function () {
          return {
            reflex: angle.isReflex()
          };
        }
      };
    }

    if (type === "circle") {
      let perimeter = {
        // temporary object for the first removal
        remove: ___default["default"].identity
      };

      const redrawPerim = function () {
        const coord0 = points[0].coord || points[0];
        const coord1 = points[1].coord || points[1];
        const radius = kmath.point.distanceToPoint(coord0, coord1);
        perimeter.remove();
        perimeter = graphie.circle(coord0, radius, ___default["default"].extend({
          stroke: KhanColors.DYNAMIC,
          "stroke-width": 2
        }, options.normalStyle));
      };

      redrawPerim();

      if (points[1].remove && !options.editable) {
        points[1].remove();
      }

      return {
        update: redrawPerim,
        remove: function () {
          // Not _.bind because the remove function changes
          // when the perimeter is redrawn
          perimeter.remove();
        }
      };
    }

    if (type === "point") {
      // do nothing
      return {
        update: null,
        remove: null
      };
    }

    throw new PerseusError("Invalid shape type " + type, Errors.InvalidInput);
  },
  _combine: function (type, coords) {
    return {
      type: type,
      coords: coords
    };
  },
  polygon: {
    equal: orderInsensitiveCoordsEqual
  },
  line: {
    equal: kmath.line.equal
  },
  lineSegment: {
    equal: orderInsensitiveCoordsEqual
  },
  angle: {
    equal: function (points1, points2) {
      if (!kmath.point.equal(points1[1], points2[1])) {
        return false;
      }

      const line1_0 = [points1[1], points1[0]];
      const line1_2 = [points1[1], points1[2]];
      const line2_0 = [points2[1], points2[0]];
      const line2_2 = [points2[1], points2[2]];
      const equalUnflipped = kmath.ray.equal(line1_0, line2_0) && kmath.ray.equal(line1_2, line2_2);
      const equalFlipped = kmath.ray.equal(line1_0, line2_2) && kmath.ray.equal(line1_2, line2_0);
      return equalUnflipped || equalFlipped;
    },
    defaultOptions: {
      reflex: false
    }
  },
  circle: {
    equal: function (points1, points2) {
      const radius1 = kmath.point.distanceToPoint(points1[0], points1[1]);
      const radius2 = kmath.point.distanceToPoint(points2[0], points2[1]);
      return kmath.point.equal(points1[0], points2[0]) && kmath.number.equal(radius1, radius2);
    }
  },
  point: {
    equal: kmath.point.equal
  }
};
const TransformationListItem = TransformOps.ListItem;

class TransformationList extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_transformationRefs", () => {
      return ___default["default"].times(this.props.transformations.length, i => {
        // eslint-disable-next-line react/no-string-refs
        return this.refs["transformation" + i];
      });
    });

    _defineProperty(this, "value", () => {
      return ___default["default"].invoke(this._transformationRefs(), "value");
    });

    _defineProperty(this, "handleChange", (changed, callback) => {
      this.props.onChange(this.value(), callback);
    });

    _defineProperty(this, "focusLast", () => {
      const transformationRefs = this._transformationRefs();

      if (transformationRefs.length !== 0) {
        ___default["default"].last(transformationRefs).focus();
      }
    });
  }

  render() {
    if (this.props.mode === "static") {
      return /*#__PURE__*/React__namespace.createElement("span", null); // don't render anything
    }

    const transformationList = ___default["default"].map(this.props.transformations, function (transform, i) {
      return /*#__PURE__*/React__namespace.createElement(TransformationListItem, {
        ref: "transformation" + i,
        key: "transformation" + i,
        transform: transform,
        mode: this.props.mode,
        onChange: this.handleChange,
        onFocus: ___default["default"].partial(this.props.onFocus, "" + i),
        onBlur: ___default["default"].partial(this.props.onBlur, "" + i),
        keypadElement: this.props.keypadElement,
        apiOptions: this.props.apiOptions
      });
    }, this);

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-transformation-list"
    }, transformationList);
  }

}

class ToolButton extends React__namespace.Component {
  render() {
    const classes = this.props.toggled ? "simple-button exercise-orange toggled highlighted-tool-button" : "simple-button";
    return /*#__PURE__*/React__namespace.createElement("button", {
      type: "button",
      className: classes,
      disabled: this.props.disabled,
      onClick: this.props.onClick,
      onTouchStart: captureScratchpadTouchStart
    }, this.props.children);
  }

}

class ToolsBar extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      selected: null
    });

    _defineProperty(this, "changeSelected", tool => {
      this.props.removeTool(this.state.selected);

      if (!tool || tool === this.state.selected) {
        this.setState({
          selected: null
        });
      } else {
        this.props.addTool(tool);
        this.setState({
          selected: tool
        });
      }
    });
  }

  render() {
    const tools = ___default["default"].map(Transformations, function (tool, type) {
      if (this.props.enabled[type]) {
        return /*#__PURE__*/React__namespace.createElement(ToolButton, {
          key: type,
          disabled: this.props.apiOptions.readOnly,
          toggled: this.state.selected === type // eslint-disable-next-line react/jsx-no-bind
          ,
          onClick: this.changeSelected.bind(this, type)
        }, tool.verbName);
      }
    }, this);

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "transformer-tools-bar"
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: "simple-button-group"
    }, tools), /*#__PURE__*/React__namespace.createElement("button", {
      className: "transformer-undo-button simple-button",
      type: "button",
      disabled: this.props.apiOptions.readOnly,
      onClick: this.props.onUndoClick,
      onTouchStart: captureScratchpadTouchStart
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconUndo), " " + i18n__namespace._("Undo")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "clear"
    }));
  }

}

class AddTransformBar extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "changeSelected", tool => {
      if (tool) {
        this.props.addTool(tool);
      }
    });
  }

  render() {
    const tools = ___default["default"].map(Transformations, function (tool, type) {
      if (this.props.enabled[type]) {
        return /*#__PURE__*/React__namespace.createElement(ToolButton, {
          key: type,
          toggled: false,
          disabled: this.props.apiOptions.readOnly // eslint-disable-next-line react/jsx-no-bind
          ,
          onClick: this.changeSelected.bind(this, type)
        }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconPlus), " ", tool.nounName);
      }
    }, this);

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "transformer-tools-bar"
    }, tools, /*#__PURE__*/React__namespace.createElement("button", {
      className: "transformer-undo-button simple-button",
      type: "button",
      onClick: this.props.onUndoClick,
      disabled: this.props.apiOptions.readOnly,
      onTouchStart: captureScratchpadTouchStart
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconUndo), " " + i18n__namespace._("Undo")), /*#__PURE__*/React__namespace.createElement("div", {
      className: "clear"
    }));
  }

}

class Transformer extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "tools", void 0);

    _defineProperty(this, "currentTool", void 0);

    _defineProperty(this, "transformations", void 0);

    _defineProperty(this, "shape", void 0);

    _defineProperty(this, "dilationCircle", void 0);

    _defineProperty(this, "rotatePoint", void 0);

    _defineProperty(this, "rotateHandle", void 0);

    _defineProperty(this, "shouldSetupGraphie", (nextProps, prevProps) => {
      if (!deepEq(prevProps.starting, nextProps.starting)) {
        return true;
      }

      if (prevProps.graphMode !== nextProps.graphMode) {
        return true;
      }

      if (prevProps.listMode !== nextProps.listMode) {
        return true;
      }

      if (prevProps.drawSolutionShape !== nextProps.drawSolutionShape) {
        return true;
      }

      if (nextProps.drawSolutionShape && !deepEq(prevProps.correct.shape, nextProps.correct.shape)) {
        return true;
      }

      if (!deepEq(this.tools, nextProps.tools)) {
        return true;
      }

      return false;
    });

    _defineProperty(this, "graphie", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.graph.graphie();
    });

    _defineProperty(this, "setupGraphie", graphie => {
      // A background image of our solution:
      if (this.props.drawSolutionShape && this.props.correct.shape && this.props.correct.shape.coords) {
        ShapeTypes.addShape(graphie, {
          fixed: true,
          shape: this.props.correct.shape,
          normalStyle: {
            stroke: KhanColors.GRAY,
            "stroke-dasharray": "",
            "stroke-width": 2
          }
        });
      }

      this.currentTool = null; // eslint-disable-next-line react/no-string-refs

      this.refs.toolsBar.changeSelected(null);
      this.addTransformerShape(this.props.starting.shape,
      /* translatable */
      false);
      this.setTransformations(this.props.transformations); // Save a copy of our tools so that we can check future
      // this.props.tools changes against them
      // This seems weird, but gives us an easy way to tell whether
      // props changes were self-inflicted (for which a graphie reset
      // is not required, and is in fact a bad idea right now because
      // of resetting the size of the dilation tool).
      // TODO (jack): A deepClone method would be nice here

      this.tools = {
        translation: ___default["default"].clone(this.props.tools.translation),
        rotation: ___default["default"].clone(this.props.tools.rotation),
        reflection: ___default["default"].clone(this.props.tools.reflection),
        dilation: ___default["default"].clone(this.props.tools.dilation)
      };
    });

    _defineProperty(this, "setTransformations", transformations => {
      this.resetCoords();
      this.transformations = ___default["default"].clone(transformations);

      ___default["default"].each(this.transformations, this.applyTransform);
    });

    _defineProperty(this, "addTransformerShape", (shape, translatable) => {
      const self = this;
      const graphie = this.graphie();
      this.shape = ShapeTypes.addMovableShape(graphie, {
        shape: shape,
        editable: false,
        showPoints: this.props.graphMode !== "static",
        translatable: translatable,
        onMove: function (dX, dY) {
          dX = KhanMath.roundToNearest(graphie.snap[0], dX);
          dY = KhanMath.roundToNearest(graphie.snap[1], dY); // NOTE(kevinb): object is missing .constraints property
          // $FlowFixMe[prop-missing]

          self.addTransform({
            type: "translation",
            vector: [dX, dY]
          });
          return [dX, dY];
        },
        normalPointStyle: {
          fill: translatable ? KhanColors.INTERACTIVE : KhanColors.DYNAMIC,
          stroke: translatable ? KhanColors.INTERACTIVE : KhanColors.DYNAMIC
        },
        highlightPointStyle: {
          fill: KhanColors.INTERACTING,
          stroke: KhanColors.INTERACTING
        }
      });
    });

    _defineProperty(this, "addTool", toolId => {
      const self = this;

      if (this.props.graphMode === "interactive") {
        if (toolId === "translation") {
          this.currentTool = this.addTranslationTool();
        } else if (toolId === "rotation") {
          this.currentTool = this.addRotationTool();
        } else if (toolId === "reflection") {
          this.currentTool = this.addReflectionTool();
        } else if (toolId === "dilation") {
          this.currentTool = this.addDilationTool();
        } else {
          throw new PerseusError("Invalid tool id: " + toolId, Errors.InvalidInput);
        }
      } else {
        let transform;

        if (toolId === "translation") {
          // NOTE(kevinb): object is missing .constraints property
          // $FlowFixMe[prop-missing]
          transform = {
            type: "translation",
            // NOTE(kevib): these should be numbers
            // $FlowFixMe[incompatible-type]
            vector: [null, null]
          };
        } else if (toolId === "rotation") {
          // NOTE(kevinb): object is missing .constraints property
          // $FlowFixMe[prop-missing]
          transform = {
            type: "rotation",
            // NOTE(kevib): these should be numbers
            // $FlowFixMe[incompatible-type]
            center: [null, null],
            // NOTE(kevib): this should be a number
            // $FlowFixMe[incompatible-type]
            angleDeg: null
          };
        } else if (toolId === "reflection") {
          // Reflections with nulls in them won't be applied until
          // fills in the blanks
          transform = {
            type: "reflection",
            line: [// NOTE(kevib): these should be numbers
            // $FlowFixMe[incompatible-type]
            [null, null], // NOTE(kevib): these should be numbers
            // $FlowFixMe[incompatible-type]
            [null, null]]
          };
        } else if (toolId === "dilation") {
          // NOTE(kevinb): object is missing .constraints property
          // $FlowFixMe[prop-missing]
          transform = {
            type: "dilation",
            // NOTE(kevib): these should be numbers
            // $FlowFixMe[incompatible-type]
            center: [null, null],
            // NOTE(kevib): this should be a number
            // $FlowFixMe[incompatible-type]
            scale: null
          };
        } else {
          throw new PerseusError("Invalid tool id: " + toolId, Errors.InvalidInput);
        } // $FlowFixMe[prop-missing]


        this.doTransform(transform, function () {
          self.refs.transformationList.focusLast();
        });
      }
    });

    _defineProperty(this, "removeTool", toolId => {
      if (this.currentTool) {
        this.currentTool.remove();
      }

      this.currentTool = null;
    });

    _defineProperty(this, "addTranslationTool", () => {
      var _this$shape, _this$shape2;

      const self = this;
      (_this$shape = this.shape) === null || _this$shape === void 0 ? void 0 : _this$shape.remove();
      this.addTransformerShape((_this$shape2 = this.shape) === null || _this$shape2 === void 0 ? void 0 : _this$shape2.toJSON(),
      /* translatable */
      true);
      return {
        remove: function () {
          var _self$shape, _self$shape2;

          (_self$shape = self.shape) === null || _self$shape === void 0 ? void 0 : _self$shape.remove();
          self.addTransformerShape((_self$shape2 = self.shape) === null || _self$shape2 === void 0 ? void 0 : _self$shape2.toJSON(),
          /* translatable */
          false);
        }
      };
    });

    _defineProperty(this, "snapCoord", coord => {
      const graphie = this.graphie();
      return ___default["default"].map(coord, function (val, dim) {
        return KhanMath.roundToNearest(graphie.snap[dim], val);
      });
    });

    _defineProperty(this, "normalizeReflectionCoords", messyCoords => {
      // $FlowFixMe[incompatible-call]
      const midpoint = this.snapCoord(kmath.line.midpoint(messyCoords));
      const origDirectionPolar = kmath.vector.polarDegFromCart(kmath.vector.subtract(messyCoords[0], messyCoords[1]));
      const direction = kmath.vector.cartFromPolarDeg(1, KhanMath.roundToNearest(45, origDirectionPolar[1]));

      const coords = ___default["default"].map([-1, 1], function (directionCoefficient) {
        const coord = kmath.vector.add(midpoint, kmath.vector.scale(direction, directionCoefficient * this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST)));
        return this.snapCoord(coord);
      }, this);

      return coords;
    });

    _defineProperty(this, "addReflectionTool", () => {
      const options = this.props.tools.reflection;

      if (!options.enabled) {
        return;
      }

      const self = this; // eslint-disable-next-line react/no-string-refs

      const graphie = this.refs.graph.graphie();

      const updateReflectionTool = function () {
        self.changeTool("reflection", {
          coords: ___default["default"].pluck(reflectPoints, "coord")
        });
      };

      const coords = this.normalizeReflectionCoords(options.coords); // The points defining the line of reflection; hidden from the
      // user.

      const reflectPoints = ___default["default"].map(coords, function (coord) {
        return graphie.addMovablePoint({
          coord: coord,
          visible: false
        });
      }, this); // the line of reflection
      // TODO(jack): graphie.style here is a hack to prevent the dashed
      // style from leaking into the rest of the shapes. Remove when
      // graphie.addMovableLineSegment doesn't leak styles anymore.


      let reflectLine;
      const normalColor = colorForTool(options);
      graphie.style({}, function () {
        reflectLine = graphie.addMovableLineSegment({
          fixed: options.constraints.fixed,
          constraints: options.constraints,
          pointA: reflectPoints[0],
          pointZ: reflectPoints[1],
          snapX: graphie.snap[0],
          snapY: graphie.snap[1],
          extendLine: true,
          normalStyle: {
            stroke: normalColor,
            "stroke-width": 2,
            "stroke-dasharray": "- "
          },
          highlightStyle: {
            stroke: KhanColors.INTERACTING,
            "stroke-width": 2,
            "stroke-dasharray": "- " // TODO(jack) solid doesn't
            // work here, but would be
            // nicer

          },
          movePointsWithLine: true,
          onMoveEnd: updateReflectionTool
        });
      }); // the "button" point in the center of the line of reflection

      const reflectButton = graphie.addReflectButton({
        fixed: options.constraints.fixed,
        line: reflectLine,
        size: this.scaleToCurrentRange(REFLECT_BUTTON_SIZE),
        onClick: function () {
          self.doTransform({
            type: "reflection",
            line: ___default["default"].pluck(reflectPoints, "coord")
          });

          if (reflectRotateHandle) {
            // flip the rotation handle
            reflectRotateHandle.setCoord(kmath.vector.add(reflectButton.coord, kmath.vector.subtract(reflectButton.coord, reflectRotateHandle.coord)));
            reflectRotateHandle.update();
          }
        },
        normalStyle: {
          stroke: normalColor,
          "stroke-width": 2,
          fill: normalColor
        },
        highlightStyle: {
          stroke: KhanColors.INTERACTING,
          "stroke-width": 3,
          fill: KhanColors.INTERACTING
        },
        onMoveEnd: updateReflectionTool
      });
      let reflectRotateHandle = null;

      if (!options.constraints.fixed) {
        // The rotation handle for rotating the line of reflection
        const initRotateHandleAngle = kmath.vector.polarDegFromCart(kmath.vector.subtract(reflectPoints[1].coord, reflectPoints[0].coord))[1] + 90; // 90 degrees off of the line

        reflectRotateHandle = graphie.addRotateHandle({
          center: reflectButton,
          radius: this.scaleToCurrentRange(REFLECT_ROTATE_HANDLE_DIST),
          angleDeg: initRotateHandleAngle,
          width: this.scaleToCurrentRange(0.24),
          hoverWidth: this.scaleToCurrentRange(0.4),
          lengthAngle: 17,
          onMove: function (newAngle) {
            return KhanMath.roundToNearest(45, newAngle);
          },
          onMoveEnd: updateReflectionTool
        });
      } // Move the reflectButton and reflectRotateHandle with the line


      $__default["default"](reflectLine).on("move", function () {
        reflectButton.update();
        $__default["default"](reflectButton).trigger("move"); // update the rotation handle,
        // which watches for this in util/interactive.js.
      }); // Update the line and reflect button when the reflectRotateHandle is
      // rotated

      if (reflectRotateHandle) {
        $__default["default"](reflectRotateHandle).on("move", function () {
          const rotateHandleApprox = self.snapCoord( // $FlowFixMe[incompatible-use]
          reflectRotateHandle.coord);
          const rotateVector = kmath.vector.subtract(rotateHandleApprox, reflectButton.coord);
          const flipped = reflectButton.isFlipped() ? 1 : 0;
          reflectPoints[flipped].setCoord(kmath.vector.add(reflectButton.coord, kmath.vector.rotateDeg(rotateVector, 90)));
          reflectPoints[1 - flipped].setCoord(kmath.vector.add(reflectButton.coord, kmath.vector.rotateDeg(rotateVector, -90)));
          reflectLine.transform(true);
          reflectButton.update();
        });
      }

      return {
        remove: function () {
          reflectButton.remove();

          if (reflectRotateHandle) {
            reflectRotateHandle.remove();
          }

          reflectLine.remove();
          reflectPoints[0].remove();
          reflectPoints[1].remove();
        }
      };
    });

    _defineProperty(this, "scaleToCurrentRange", dist => {
      // eslint-disable-next-line react/no-string-refs
      return scaleToRange(dist, this.refs.graph.props.range);
    });

    _defineProperty(this, "addRotationTool", () => {
      const options = this.props.tools.rotation;

      if (!options.enabled) {
        return;
      }

      const self = this; // eslint-disable-next-line react/no-string-refs

      const graphie = this.refs.graph.graphie();
      const pointColor = colorForTool(options); // The center of our rotation, which can be moved to change the
      // center of rotation

      this.rotatePoint = graphie.addMovablePoint({
        constraints: options.constraints,
        coord: options.coord,
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        normalStyle: {
          // ugh, this seems to be a global and
          "stroke-dasharray": "",
          // is set to dash above
          stroke: pointColor,
          fill: pointColor
        },
        highlightStyle: {
          "stroke-dasharray": "",
          stroke: KhanColors.INTERACTING,
          fill: KhanColors.INTERACTING
        }
      }); // The point that we move around the center of rotation to actually
      // cause rotations

      this.rotateHandle = graphie.addRotateHandle({
        center: this.rotatePoint,
        radius: this.scaleToCurrentRange(ROTATE_HANDLE_DIST),
        width: this.scaleToCurrentRange(0.24),
        hoverWidth: this.scaleToCurrentRange(0.4),
        onMove: function (newAngle, oldAngle) {
          const transform = self.getRotationTransformFromAngle( // $FlowFixMe[incompatible-use]
          self.rotatePoint.coord, newAngle - oldAngle); // Rotate polygon with rotateHandle

          self.doTransform(transform); // $FlowFixMe[prop-missing]

          return oldAngle + transform.angleDeg;
        }
      }); // Update tools.rotation.coord
      // $FlowFixMe[incompatible-use]

      this.rotatePoint.onMoveEnd = (x, y) => {
        self.changeTool("rotation", {
          coord: [x, y]
        });
      };

      return {
        remove: function () {
          var _self$rotateHandle, _self$rotatePoint;

          (_self$rotateHandle = self.rotateHandle) === null || _self$rotateHandle === void 0 ? void 0 : _self$rotateHandle.remove();
          (_self$rotatePoint = self.rotatePoint) === null || _self$rotatePoint === void 0 ? void 0 : _self$rotatePoint.remove();
        }
      };
    });

    _defineProperty(this, "addDilationTool", () => {
      const options = this.props.tools.dilation;

      if (!options.enabled) {
        return;
      }

      const self = this; // eslint-disable-next-line react/no-string-refs

      const graphie = this.refs.graph.graphie();
      const pointColor = colorForTool(options); // the circle for causing dilation transforms

      self.dilationCircle = graphie.addCircleGraph({
        centerConstraints: options.constraints,
        center: options.coord,
        radius: self.scaleToCurrentRange(2),
        snapX: graphie.snap[0],
        snapY: graphie.snap[1],
        minRadius: self.scaleToCurrentRange(1),
        snapRadius: self.scaleToCurrentRange(0.5),
        onResize: function (newRadius, oldRadius) {
          // NOTE(kevinb): object is missing .constraints property
          // $FlowFixMe[prop-missing]
          self.doTransform({
            type: "dilation",
            // NOTE(kevinb): It's hard to convince that this.dilationCircle
            // will still be defined here.
            // $FlowFixMe[incompatible-use]
            center: self.dilationCircle.centerPoint.coord,
            scale: newRadius / oldRadius
          });
        },
        circleNormalStyle: {
          stroke: pointColor,
          "stroke-width": 2,
          "stroke-dasharray": "- ",
          "fill-opacity": 0
        },
        circleHighlightStyle: {
          stroke: KhanColors.INTERACTING,
          "stroke-width": 2,
          "stroke-dasharray": "",
          fill: KhanColors.INTERACTING,
          "fill-opacity": 0.05
        },
        centerNormalStyle: {
          stroke: pointColor,
          fill: pointColor,
          "stroke-width": 2,
          "stroke-dasharray": ""
        },
        centerHighlightStyle: {
          stroke: pointColor,
          fill: pointColor,
          "stroke-width": 2,
          "stroke-dasharray": ""
        }
      }); // $FlowFixMe[incompatible-use]

      const origOnMoveEnd = this.dilationCircle.centerPoint.onMoveEnd; // $FlowFixMe[incompatible-use]

      this.dilationCircle.centerPoint.onMoveEnd = function () {
        if (origOnMoveEnd) {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          origOnMoveEnd(args);
        }

        self.changeTool("dilation", {
          // $FlowFixMe[incompatible-use]
          coord: self.dilationCircle.centerPoint.coord
        });
      };

      return {
        remove: function () {
          var _self$dilationCircle;

          (_self$dilationCircle = self.dilationCircle) === null || _self$dilationCircle === void 0 ? void 0 : _self$dilationCircle.remove();
        }
      };
    });

    _defineProperty(this, "getRotationTransformFromAngle", (center, angleChanged) => {
      angleChanged = (angleChanged + 360) % 360;

      if (angleChanged > 180) {
        angleChanged -= 360;
      }

      const roundedAngle = Math.round(angleChanged / ROTATE_SNAP_DEGREES) * ROTATE_SNAP_DEGREES; // NOTE(kevinb): return object is missing .constraints property
      // $FlowFixMe[prop-missing]

      return {
        type: "rotation",
        center: center,
        angleDeg: roundedAngle
      };
    });

    _defineProperty(this, "doTransform", (transform, callback) => {
      this.applyTransform(transform);
      this.addTransform(transform, callback);
    });

    _defineProperty(this, "applyTransform", transform => {
      if (this.props.graphMode !== "static") {
        const transformFunc = TransformOps.apply(transform); // $FlowFixMe[incompatible-call]

        this.applyCoordTransformation(transformFunc);
      }
    });

    _defineProperty(this, "applyCoordTransformation", pointTransform => {
      var _this$shape3;

      // $FlowFixMe[incompatible-use]
      ___default["default"].each(this.shape.points, function (point) {
        // $FlowFixMe[prop-missing]
        const newCoord = pointTransform(point.coord);
        point.setCoord(newCoord);
      });

      (_this$shape3 = this.shape) === null || _this$shape3 === void 0 ? void 0 : _this$shape3.update();
    });

    _defineProperty(this, "resetCoords", () => {
      var _this$shape4;

      const startCoords = this.props.starting.shape.coords; // $FlowFixMe[incompatible-use]

      ___default["default"].each(this.shape.points, function (point, i) {
        point.setCoord(startCoords[i]);
      });

      (_this$shape4 = this.shape) === null || _this$shape4 === void 0 ? void 0 : _this$shape4.update();
    });

    _defineProperty(this, "handleUndoClick", () => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.toolsBar.changeSelected(null);

      if (this.props.transformations.length) {
        this.props.onChange({
          transformations: ___default["default"].initial(this.props.transformations)
        });
      }
    });

    _defineProperty(this, "setTransformationProps", (newTransfomationList, callback) => {
      this.props.onChange({
        transformations: newTransfomationList
      }, callback);
    });

    _defineProperty(this, "addTransform", (transform, callback) => {
      this.transformations = TransformOps.append(this.transformations, transform);
      this.props.onChange({
        transformations: ___default["default"].clone(this.transformations)
      }, callback);
    });

    _defineProperty(this, "changeTool", (tool, changes) => {
      const newTools = ___default["default"].clone(this.props.tools);

      newTools[tool] = ___default["default"].extend({}, this.props.tools[tool], changes);
      this.tools[tool] = ___default["default"].clone(newTools[tool]);
      this.props.onChange({
        tools: newTools
      });
      this.props.trackInteraction();
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Transformer.validate(this.getUserInput(), rubric);
    });

    _defineProperty(this, "getCoords", () => {
      const startCoords = this.props.starting.shape.coords;
      const transforms = this.props.transformations;
      return ___default["default"].reduce(transforms, function (coords, transform) {
        return ___default["default"].map(coords, TransformOps.apply(transform));
      }, startCoords);
    });

    _defineProperty(this, "getEditorJSON", () => {
      const json = ___default["default"].pick(this.props, "grading", "starting", "graphMode", "listMode", "tools", "drawSolutionShape", "gradeEmpty"); // eslint-disable-next-line react/no-string-refs


      json.graph = this.refs.graph.toJSON();
      json.version = 1.2; // Give us some safety to change the format
      // when we realize that I wrote
      // a horrible json spec for this widget

      json.answer = this.getUserInput();
      return json;
    });

    _defineProperty(this, "getUserInput", () => {
      var _this$shape5;

      return {
        transformations: this.props.transformations,
        // This doesn't call this.shape.toJSON() because that doesn't
        // handle coordinates in formal mode without movement, since
        // the movablepoints never move
        shape: {
          // $FlowFixMe[incompatible-use]
          type: this.shape.type,
          coords: this.getCoords(),
          options: (_this$shape5 = this.shape) === null || _this$shape5 === void 0 ? void 0 : _this$shape5.getOptions()
        }
      };
    });

    _defineProperty(this, "_handleFocus", function () {
      for (var _len2 = arguments.length, path = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        path[_key2] = arguments[_key2];
      }

      _this.props.onFocus(path);
    });

    _defineProperty(this, "_handleBlur", function () {
      for (var _len3 = arguments.length, path = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        path[_key3] = arguments[_key3];
      }

      _this.props.onBlur(path);
    });

    _defineProperty(this, "_getTransformationForID", transformationID => {
      // Returns the 'transformation' component corresponding to a given ID
      const refPath = ["transformationList", "transformation" + transformationID]; // Follow the path of references

      let component = this;

      ___default["default"].each(refPath, ref => {
        component = component.refs[ref];
      });

      return component;
    });

    _defineProperty(this, "getInputPaths", () => {
      // If we're in static mode, then there is no transformation list, and,
      // as a result, no input paths.
      if (this.props.listMode === "static") {
        return [];
      }

      let inputPaths = [];

      ___default["default"].each(this.props.transformations, (transformation, i) => {
        transformation = this._getTransformationForID(i);
        const innerPaths = transformation.getInputPaths();

        const fullPaths = ___default["default"].map(innerPaths, innerPath => {
          return ["" + i].concat(innerPath);
        });

        inputPaths = inputPaths.concat(fullPaths);
      });

      return inputPaths;
    });

    _defineProperty(this, "_passToInner", function (functionName, path) {
      if (!path || !path.length) {
        return;
      } // First argument tells us which transformation will receive the call;
      // remaining arguments are used within that transformation to identify
      // a specific input.


      const innerPath = ___default["default"].rest(path); // Pass arguments down to appropriate 'transformation' component


      const transformationID = ___default["default"].head(path);

      const caller = this._getTransformationForID(transformationID);

      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      return caller[functionName](innerPath, ...args);
    });

    _defineProperty(this, "focus", () => {
      // Just focus the first showing input
      const inputs = this.getInputPaths();

      if (inputs.length > 0) {
        this.focusInputPath(inputs[0]);
        return true;
      }

      return false;
    });

    _defineProperty(this, "focusInputPath", path => {
      // Since the transformer exposes the input API, it needs to be robust
      // to empty paths. We don't expect this to happen, as entire-widget
      // focusing is typically done through the focus() method, which already
      // handles the empty path case properly, but it's better to be safe
      // here.
      if (path.length === 0) {
        return false;
      }

      assert(path.length >= 2);
      return this._passToInner("focusInputPath", path);
    });

    _defineProperty(this, "blurInputPath", path => {
      // Since the transformer exposes the input API, it needs to be robust
      // to empty paths (which indicate a blurring of the entire widget,
      // e.g., when switching from interacting with the transformer to
      // interacting with some other widget).
      if (path.length === 0) {
        return false;
      }

      assert(path.length >= 2);
      return this._passToInner("blurInputPath", path);
    });

    _defineProperty(this, "setInputValue", (path, value, cb) => {
      assert(path.length >= 2);
      return this._passToInner("setInputValue", path, value, cb);
    });

    _defineProperty(this, "getDOMNodeForPath", path => {
      assert(path.length >= 2);
      return this._passToInner("getDOMNodeForPath", path);
    });

    _defineProperty(this, "getGrammarTypeForPath", path => {
      assert(path.length >= 2);
      return this._passToInner("getGrammarTypeForPath", path);
    });
  }

  render() {
    // Fill in any missing value in this.props.graph
    // this can happen because the graph json doesn't include
    // box, for example
    const graph = ___default["default"].extend(defaultGraphProps(this.props.graph, defaultBoxSize), this.props.graph);

    const interactiveToolsMode = this.props.graphMode === "interactive";
    const ToolsBarClass = interactiveToolsMode ? ToolsBar : AddTransformBar; // This style is applied inline because it is dependent on the
    // size of the graph as set by the graph.box prop, and this also
    // lets us specify it in the same place the graph's width is
    // specified.

    const toolsBar = /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        width: graph.box[0]
      }
    }, /*#__PURE__*/React__namespace.createElement(ToolsBarClass // eslint-disable-next-line react/no-string-refs
    , {
      ref: "toolsBar",
      enabled: pluckObject(this.props.tools, "enabled"),
      apiOptions: this.props.apiOptions,
      addTool: this.addTool,
      removeTool: this.removeTool,
      onUndoClick: this.handleUndoClick
    }));
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-widget " + "perseus-widget-transformer"
    }, /*#__PURE__*/React__namespace.createElement(Graph // eslint-disable-next-line react/no-string-refs
    , {
      ref: "graph",
      box: graph.box,
      range: graph.range,
      labels: graph.labels,
      step: graph.step,
      gridStep: graph.gridStep,
      markings: graph.markings,
      backgroundImage: graph.backgroundImage,
      showProtractor: graph.showProtractor,
      onGraphieUpdated: this.setupGraphie,
      setDrawingAreaAvailable: this.props.apiOptions.setDrawingAreaAvailable
    }), !interactiveToolsMode && i18n__namespace._("Add transformations below:"), this.props.graphMode === "static" && [/*#__PURE__*/React__namespace.createElement("br", {
      key: "static-br"
    }), /*#__PURE__*/React__namespace.createElement("em", {
      key: "static-nomove"
    }, " ", i18n__namespace._("Note: For this question, the shape will not move."), " ")], interactiveToolsMode && toolsBar, /*#__PURE__*/React__namespace.createElement(TransformationList // eslint-disable-next-line react/no-string-refs
    , {
      ref: "transformationList",
      mode: this.props.listMode,
      transformations: this.props.transformations,
      onChange: this.setTransformationProps,
      onFocus: this._handleFocus,
      onBlur: this._handleBlur,
      keypadElement: this.props.keypadElement,
      apiOptions: this.props.apiOptions
    }), !interactiveToolsMode && toolsBar);
  }

  componentDidMount() {
    this.setupGraphie(this.graphie());
  }

  componentDidUpdate(prevProps) {
    if (this.shouldSetupGraphie(this.props, prevProps)) {
      // eslint-disable-next-line react/no-string-refs
      this.refs.graph.reset();
    } else if (!deepEq(this.props.transformations, this.transformations)) {
      this.setTransformations(this.props.transformations);
    }
  }

  static validate(guess, rubric) {
    // Check for any required transformations
    for (const type in Transformations) {
      if (rubric.tools[type].required) {
        const isUsed = ___default["default"].any(___default["default"].map(guess.transformations, function (transform) {
          // Required transformations must appear in the
          // transformation list, and must not be no-ops
          return transform.type === type && !TransformOps.isEmpty(transform) && !TransformOps.isNoOp(transform);
        }));

        if (!isUsed) {
          return {
            type: "invalid",
            message: i18n__namespace._("Your transformation must use a " + "%(type)s.", {
              type: Transformations[type].lowerNounName
            })
          };
        }
      }
    } // Compare shapes


    if (ShapeTypes.equal(guess.shape, rubric.correct.shape)) {
      return {
        type: "points",
        earned: 1,
        total: 1,
        message: null
      };
    }

    if (!rubric.gradeEmpty && deepEq(guess.shape.coords, rubric.starting.shape.coords)) {
      return {
        type: "invalid",
        message: i18n__namespace._("Use the interactive graph to define a " + "correct transformation.")
      };
    }

    return {
      type: "points",
      earned: 0,
      total: 1,
      message: null
    };
  }

}

_defineProperty(Transformer, "defaultProps", ___default["default"].defaults({
  transformations: []
}, defaultTransformerProps));

var Transformer$1 = {
  name: "transformer",
  displayName: "Transformer",
  widget: Transformer
};

var hubble = {exports: {}};

(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
	  module.exports = factory();
	})(commonjsGlobal$1, function () {
	  return (
	    /******/
	    function (modules) {
	      // webpackBootstrap

	      /******/
	      // The module cache

	      /******/
	      var installedModules = {};
	      /******/

	      /******/
	      // The require function

	      /******/

	      function __webpack_require__(moduleId) {
	        /******/

	        /******/
	        // Check if module is in cache

	        /******/
	        if (installedModules[moduleId]) {
	          /******/
	          return installedModules[moduleId].exports;
	          /******/
	        }
	        /******/
	        // Create a new module (and put it into the cache)

	        /******/


	        var module = installedModules[moduleId] = {
	          /******/
	          i: moduleId,

	          /******/
	          l: false,

	          /******/
	          exports: {}
	          /******/

	        };
	        /******/

	        /******/
	        // Execute the module function

	        /******/

	        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	        /******/

	        /******/
	        // Flag the module as loaded

	        /******/

	        module.l = true;
	        /******/

	        /******/
	        // Return the exports of the module

	        /******/

	        return module.exports;
	        /******/
	      }
	      /******/

	      /******/

	      /******/
	      // expose the modules object (__webpack_modules__)

	      /******/


	      __webpack_require__.m = modules;
	      /******/

	      /******/
	      // expose the module cache

	      /******/

	      __webpack_require__.c = installedModules;
	      /******/

	      /******/
	      // define getter function for harmony exports

	      /******/

	      __webpack_require__.d = function (exports, name, getter) {
	        /******/
	        if (!__webpack_require__.o(exports, name)) {
	          /******/
	          Object.defineProperty(exports, name, {
	            /******/
	            configurable: false,

	            /******/
	            enumerable: true,

	            /******/
	            get: getter
	            /******/

	          });
	          /******/
	        }
	        /******/

	      };
	      /******/

	      /******/
	      // getDefaultExport function for compatibility with non-harmony modules

	      /******/


	      __webpack_require__.n = function (module) {
	        /******/
	        var getter = module && module.__esModule ?
	        /******/
	        function getDefault() {
	          return module['default'];
	        } :
	        /******/
	        function getModuleExports() {
	          return module;
	        };
	        /******/

	        __webpack_require__.d(getter, 'a', getter);
	        /******/


	        return getter;
	        /******/
	      };
	      /******/

	      /******/
	      // Object.prototype.hasOwnProperty.call

	      /******/


	      __webpack_require__.o = function (object, property) {
	        return Object.prototype.hasOwnProperty.call(object, property);
	      };
	      /******/

	      /******/
	      // __webpack_public_path__

	      /******/


	      __webpack_require__.p = "";
	      /******/

	      /******/
	      // Load entry module and return exports

	      /******/

	      return __webpack_require__(__webpack_require__.s = 1);
	      /******/
	    }
	    /************************************************************************/

	    /******/
	    ([
	    /* 0 */

	    /***/
	    function (module, exports) {
	      var isObject = function (obj) {
	        return obj === Object(obj);
	      };

	      var merge = function () {
	        var obj = {};

	        for (var i = 0; i < arguments.length; i++) {
	          var source = arguments[i];

	          if (source) {
	            for (var prop in source) {
	              obj[prop] = source[prop];
	            }
	          }
	        }

	        return obj;
	      };

	      var clone = function (obj) {
	        if (!isObject(obj)) {
	          return obj;
	        }

	        return Array.isArray(obj) ? obj.slice() : merge(obj);
	      };

	      module.exports = {
	        isObject: isObject,
	        merge: merge,
	        clone: clone
	      };
	      /***/
	    },
	    /* 1 */

	    /***/
	    function (module, exports, __webpack_require__) {
	      /* TODO batch *all* mutations
	       * idea: freeze / thaw implementations for all types
	       * lens constructor thaws, freeze delegates to type's freeze
	       */
	      var util = __webpack_require__(0);

	      var clone = util.clone;
	      var isObject = util.isObject;
	      var merge = util.merge;

	      var arr = __webpack_require__(2);

	      var obj = __webpack_require__(3);

	      var str = __webpack_require__(4); // equivalents, without requiring it
	      // find the implementation to use for a given object


	      var dispatch = function (x) {
	        if (Array.isArray(x)) {
	          return arr;
	        } else if (isObject(x)) {
	          return obj;
	        } else if (typeof x === "string") {
	          return str;
	        }
	      }; // This is underscore with a different name


	      var lens = function (obj) {
	        if (obj instanceof lens) {
	          return obj;
	        }

	        if (!(this instanceof lens)) {
	          return new lens(obj);
	        }

	        var ops = dispatch(obj);
	        this._wrapped = ops.thaw ? ops.thaw(obj) : obj;
	      };

	      lens.prototype.freeze = function () {
	        var obj = this._wrapped;
	        var ops = dispatch(obj);
	        return ops.freeze ? ops.freeze(obj) : obj;
	      };

	      lens.prototype.zoom = function (lensArr) {
	        if (this._zoomStack === undefined) {
	          this._zoomStack = [];
	        }

	        this._zoomStack.push({
	          zoom: lensArr,
	          wrapped: this._wrapped
	        });

	        this._wrapped = lens(this._wrapped).get(lensArr);
	        return this;
	      };

	      lens.prototype.deZoom = function () {
	        var frame = this._zoomStack.pop();

	        this._wrapped = lens(frame.wrapped).set(frame.zoom, this._wrapped).freeze();
	        return this;
	      };

	      lens.prototype.get = function (lensArr) {
	        var obj = this._wrapped;

	        for (var i = 0; i < lensArr.length; i++) {
	          obj = dispatch(obj).get(obj, lensArr[i]);
	        }

	        return obj;
	      };

	      lens.prototype.mod = function (lensArr, f) {
	        var obj = this._wrapped;
	        var newObj = clone(obj);
	        var ops = dispatch(obj);

	        if (lensArr.length === 0) {
	          this._wrapped = f(this._wrapped);
	        } else if (lensArr.length === 1) {
	          this._wrapped = ops.mod(newObj, lensArr[0], f);
	        } else {
	          var monocle = lensArr[0];
	          var shortLens = lensArr.slice(1); // newObj = ops.mod(obj[monocle], shortLens, f);

	          newObj[monocle] = lens(obj[monocle]).mod(shortLens, f).freeze();
	          this._wrapped = newObj;
	        }

	        return this;
	      }; // TODO - move to individual files


	      lens.prototype.merge = function (lensArr, props) {
	        this._wrapped = lens(this._wrapped).mod(lensArr, function (oldProps) {
	          return merge(oldProps, props);
	        }).freeze();
	        return this;
	      }; // Lens must have length >= 1 or there would be nothing to return


	      lens.prototype.del = function (lensArr) {
	        var obj = this._wrapped;
	        var ops = dispatch(obj);

	        if (lensArr.length === 1) {
	          this._wrapped = ops.del(obj, lensArr[0]);
	        } else {
	          var monocle = lensArr[0];
	          var shortLens = lensArr.slice(1);
	          var newObj = clone(obj);
	          newObj[monocle] = lens(obj[monocle]).del(shortLens).freeze();
	          this._wrapped = newObj;
	        }

	        return this;
	      };

	      lens.prototype.set = function (lensArr, set) {
	        return this.mod(lensArr, function () {
	          return set;
	        });
	      };

	      module.exports = lens;
	      /***/
	    },
	    /* 2 */

	    /***/
	    function (module, exports) {
	      var get = function (arr, monocle) {
	        return arr[monocle];
	      };

	      var set = function (arr, monocle, val) {
	        var newArr = arr.splice();
	        newArr[monocle] = val;
	        return newArr;
	      };

	      var mod = function (arr, monocle, f) {
	        var newArr = arr.slice();
	        newArr[monocle] = f(arr[monocle]);
	        return newArr;
	      };

	      var del = function (arr, monocle) {
	        var newArr = arr.slice();
	        newArr.splice(monocle, 1);
	        return newArr;
	      };
	      /*
	      // Lens must point to a member of an array. We'll insert into that array.
	      lens.prototype.insertAt = function(lensArr, toInsert) {
	          var obj = this._wrapped;
	      
	          var arrLens = lensArr.slice(0, -1);
	          var arr = lens(obj).get(arrLens).slice(); // slice to copy
	      
	          var arrIdx = lensArr[lensArr.length-1];
	          arr.splice(arrIdx, 0, toInsert);
	          return lens(obj).set(arrLens, arr);
	      };
	      
	      lens.prototype.insertBefore = lens.prototype.insertAt;
	      lens.prototype.insertAfter = function(lensArr, toInsert) {
	          var newLens = lensArr.slice();
	          newLens[newLens.length-1] += 1;
	          return lens(this._wrapped).insertAt(newLens, toInsert);
	      };
	      */


	      module.exports = {
	        get: get,
	        set: set,
	        mod: mod,
	        del: del
	      };
	      /***/
	    },
	    /* 3 */

	    /***/
	    function (module, exports, __webpack_require__) {
	      var clone = __webpack_require__(0).clone;

	      var get = function (obj, monocle) {
	        return obj[monocle];
	      };

	      var set = function (obj, monocle, val) {
	        var newObj = clone(obj);
	        newObj[monocle] = val;
	        return newObj;
	      };

	      var mod = function (obj, monocle, f) {
	        var newObj = clone(obj);
	        newObj[monocle] = f(obj[monocle]);
	        return newObj;
	      };

	      var del = function (obj, monocle) {
	        var newObj = clone(obj);
	        delete newObj[monocle];
	        return newObj;
	      };

	      module.exports = {
	        get: get,
	        set: set,
	        mod: mod,
	        del: del
	      };
	      /***/
	    },
	    /* 4 */

	    /***/
	    function (module, exports) {
	      var get = function (arr, monocle) {
	        return arr[monocle];
	      };

	      var set = function (arr, monocle, val) {
	        var newArr = arr.splice();
	        newArr[monocle] = val;
	        return newArr;
	      };

	      var mod = function (arr, monocle, f) {
	        var newArr = arr.splice();
	        newArr[monocle] = f(arr[monocle]);
	        return newArr;
	      };

	      var del = function (arr, monocle) {
	        var newArr = arr.slice();
	        newArr.splice(monocle);
	        return newArr;
	      };

	      module.exports = {
	        get: get,
	        set: set,
	        mod: mod,
	        del: del
	      };
	      /***/
	    }
	    /******/
	    ])
	  );
	});
} (hubble));

var lens = /*@__PURE__*/getDefaultExportFromCjs(hubble.exports);

/* eslint-disable eqeqeq, no-unused-vars */

/*
 * A class for formatting number to significant digits.
 * Copyright (C) 2001 Stephen Ostermiller
 * http://ostermiller.org/contact.pl?regarding?JavaScript+Significant+Figures
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**
 * An object tho both scans floating points to
 * determine the number of significant figures.
 * and can display a floating point using any number
 * of significant figures.
 *
 * @param s A string representation of a floating point.
 */
class SignificantFigures {
  constructor(s) {
    _defineProperty(this, "order", void 0);

    _defineProperty(this, "mantissa", void 0);

    _defineProperty(this, "positive", void 0);

    _defineProperty(this, "sigFigs", void 0);

    _defineProperty(this, "sigDecs", void 0);

    this.order = parseOrder(s);
    this.mantissa = parseMantissa(s);
    this.positive = parseSign(s);
    /**
     * Get the number of significant figures this object uses.
     * Leading zeros are not significant.  Traling zeros up to
     * and after the decimal point are significant.
     * Significant figures is good to know when the number is
     * used in multiplication.
     *
     * @return the number of significant figures.
     */

    this.sigFigs = this.mantissa.length;
    /**
     * Get the least significant decimal this object uses.
     * This is useful to know if a number is being used
     * in addition.
     * 400 - 2 the hundreds place (10^2) is the least significant decimal.
     * 75 - 0 the ones place (10^0) is the least significant decimal.
     * .543 - -3 the 1/1000's place (10^-3) is the least significant decimal.
     *
     * @return an integer representing the least significant decimal place.
     */

    this.sigDecs = this.order - this.mantissa.length;
  }

}
/**
 * Format a floating point for display using the specified
 * number of significant figures and least significant decimal.
 * Scientific notation may used by this method if this
 * object is very small, very large, has many significant
 * figures, or the number of significant figures would be
 * ambiguous in the output if scientific notation were not
 * used.
 *
 * @param f A floating point number that should be displayed
 * @param sigFigs desired number of significant figures (integer).
 * @param sigDecs the least significant decimal place (integer).
 * @param scientific true iff scientific notation should always be used.
 * @return a string of this object formatted correctly.
 */

function displaySigFigs(f, sigFigs, sigDecs, scientific) {
  const s = "" + f;
  let order = parseOrder(s);
  let mantissa = parseMantissa(s);
  let positive = parseSign(s);
  let add;
  let decAdd;
  let sigAdd;
  let zeroScientific = false;

  if (f == 0 || mantissa == "" || mantissa == "0") {
    mantissa = "";

    for (let i = 0; i < sigFigs; i++) {
      mantissa += "0";
    }

    order = sigFigs + sigDecs;

    if (sigDecs < 0 && -sigDecs >= sigFigs) {
      zeroScientific = true;
    }
  } else {
    decAdd = order - mantissa.length - sigDecs;
    sigAdd = sigFigs - mantissa.length;
    add = Math.min(sigAdd, decAdd);

    if (add < 0) {
      let rounded = round(mantissa, -add);

      if (rounded.length > mantissa.length + add) {
        order++;

        if (decAdd > sigAdd) {
          rounded = round(rounded, 1);
        }
      }

      mantissa = rounded;
    } else if (add > 0) {
      for (let i = 0; i < add; i++) {
        mantissa += "0";
      }
    }

    if (mantissa == "" || mantissa == "0") {
      mantissa = "0";
      positive = true;
      order = 1 + sigDecs;

      if (order != 0) {
        zeroScientific = true;
      }
    }
  }

  const useScientific = scientific || mantissa.length > 20 || order > 4 || order < -2 || order - mantissa.length > 0 && trailingZeros(mantissa) > 0 || zeroScientific;
  let returnVal = "";

  if (!positive) {
    returnVal += "-";
  }

  if (useScientific) {
    returnVal += mantissa.charAt(0);

    if (mantissa.length > 1) {
      returnVal += "." + mantissa.substring(1, mantissa.length);
    }

    if (order - 1 != 0) {
      returnVal += " x 10^" + (order - 1);
    }
  } else {
    let wholePart = "";
    let fractPart = "";
    let needDot = true;

    if (order > 0) {
      if (mantissa.length > order) {
        wholePart = mantissa.substring(0, order);
        fractPart = mantissa.substring(order, mantissa.length);
      } else {
        wholePart = mantissa;
        needDot = trailingZeros(mantissa) != 0;

        for (let i = 0; i < order - mantissa.length; i++) {
          wholePart += "0";
        }
      }
    } else {
      for (let i = 0; i < -order; i++) {
        fractPart += "0";
      }

      fractPart += mantissa;
    }

    returnVal += (wholePart == "" ? "0" : wholePart) + (needDot ? "." : "") + fractPart;
  }

  return returnVal;
}
/**
 * Count the significant trailing zeros on this object.
 *
 * @return the number of trailing zeros
 */

function trailingZeros(mantissa) {
  let zeros = 0;

  for (let i = mantissa.length - 1; i >= 0; i--) {
    const c = mantissa.charAt(i);

    if (c == "0") {
      zeros++;
    } else {
      return zeros;
    }
  }

  return zeros;
}
/**
 * Parse a string representation of a floating point
 * and pull out the sign.
 *
 * @param s the string representation of a floating point.
 * @return true iff this is a positive number
 */


function parseSign(s) {
  let beginning = true;
  let seenDot = false;
  let seenSomething = false;
  let zeros = "";
  let all = "";
  let pos = true;

  for (let i = 0; i < s.length; i++) {
    const c = s.charAt(i);

    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;

      beginning = false;
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        }
      } else {

        if (seenSomething) {
          zeros += c;
        }
      }

      beginning = false;
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
      beginning = false;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      parseInt(s.substring(i + 1, s.length));
      i = s.length;
    } else if (beginning && (c == "+" || c == "-")) {
      if (c == "-") {
        pos = !pos;
      }
    }
  }

  if (all == "") {
    return true;
  }

  return pos;
}
/**
 * Parse a string representation of a floating point
 * and pull out the mantissa.
 *
 * @param s the string representation of a floating point.
 * @return the mantissa of this number.
 */


function parseMantissa(s) {
  let seenDot = false;
  let seenSomething = false;
  let zeros = "";
  let leadZeros = "";
  let all = "";

  for (let i = 0; i < s.length; i++) {
    const c = s.charAt(i);

    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        } else {
          leadZeros += c;
        }
      } else {

        if (seenSomething) {
          leadZeros += c;
          zeros += c;
        } else {
          leadZeros += c;
        }
      }
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      parseInt(s.substring(i + 1, s.length));
      i = s.length;
    } else ;
  }

  if (all == "") {
    return leadZeros;
  }

  return all;
}
/**
 * Parse a string representation of a floating point
 * and pull out the exponent.
 *
 * @param s the string representation of a floating point.
 * @return (integer) the number after the e.
 */


function parseOrder(s) {
  let seenDot = false;
  let seenSomething = false;
  let zeros = "";
  let all = "";
  let decPlaces = 0;
  let totalDecs = 0;

  for (let i = 0; i < s.length; i++) {
    const c = s.charAt(i);

    if (c >= "1" && c <= "9") {
      all += zeros + c;
      zeros = "";
      seenSomething = true;

      if (!seenDot) {
        totalDecs++;
        decPlaces++;
      }
    } else if (c == "0") {
      if (seenDot) {
        if (seenSomething) {
          all += zeros + c;
          zeros = "";
        } else {
          decPlaces--;
        }
      } else {
        totalDecs++;

        if (seenSomething) {
          decPlaces++;
          zeros += c;
        }
      }
    } else if (!seenDot && c == ".") {
      all += zeros;
      zeros = "";
      seenDot = true;
    } else if (c == "e" || c == "E" && i + 1 < s.length) {
      const raised = parseInt(s.substring(i + 1, s.length));
      decPlaces += raised;
      totalDecs += raised;
      i = s.length;
    } else ;
  }

  if (all == "") {
    return totalDecs;
  }

  return decPlaces;
}
/**
 * Remove the specified number of digits from string by
 * rounding.  Proper rounding rules for scientific purposes
 * are followed.
 * This method may cause an extra significant figure
 * to be added to the number.  For example, if 999999
 * were rounded, A one would carry over and become
 * a significant figure.  Those who call this method
 * should check for this and call round again if needed.
 *
 * @param mantissa A string representing an whole number of arbitrary length.
 * @param digits A number of digits to remove
 * @return A string represted the rounded version of mantissa
 */


function round(mantissa, digits) {
  const last = mantissa.length - digits - 1;

  if (last < 0) {
    return "";
  }

  if (last >= mantissa.length - 1) {
    return mantissa;
  }

  const nextToLast = mantissa.charAt(last + 1);
  const lastChar = mantissa.charAt(last);
  let roundUp = false;

  if (nextToLast > "5") {
    roundUp = true;
  } else if (nextToLast == "5") {
    for (let j = last + 2; j < mantissa.length; j++) {
      if (mantissa.charAt(j) != "0") {
        roundUp = true;
      }
    } // $FlowIgnore[unsafe-addition]: lashChar gets coerced from a string to a number here


    if (lastChar % 2 == 1) {
      roundUp = true;
    }
  }

  let result = "";

  for (let i = last; i >= 0; i--) {
    const c = mantissa.charAt(i);

    if (roundUp) {
      let nextChar;

      if (c == "9") {
        nextChar = "0";
      } else {
        switch (c) {
          case "0":
            nextChar = "1";
            break;

          case "1":
            nextChar = "2";
            break;

          case "2":
            nextChar = "3";
            break;

          case "3":
            nextChar = "4";
            break;

          case "4":
            nextChar = "5";
            break;

          case "5":
            nextChar = "6";
            break;

          case "6":
            nextChar = "7";
            break;

          case "7":
            nextChar = "8";
            break;

          case "8":
            nextChar = "9";
            break;
        }

        roundUp = false;
      } // $FlowIgnore[incompatible-type]: switch case isn't exhaustive so Flow doesn't know nextChar is defined


      result = nextChar + result;
    } else {
      result = c + result;
    }
  }

  if (roundUp) {
    result = "1" + result;
  }

  return result;
}

const ALL = "all";
const countSigfigs = function (value) {
  return new SignificantFigures(value).sigFigs;
};

/* I just wrote this, but it's old by analogy to `OldExpression`, in that it's
 * the version that non-mathquill platforms get stuck with. Constructed with an
 * <input>, a parser, popsicle sticks, and glue.
 *
 * In the same way as OldExpression, this parses continuously as you type, then
 * shows and hides an error buddy. The error message is only shown after a
 * rolling two second delay, but hidden immediately on further typing.
 */
class OldUnitInput extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "_errorTimeout", void 0);

    _defineProperty(this, "_showError", () => {
      if (this.props.value === "") {
        return;
      } // eslint-disable-next-line react/no-string-refs


      const $error = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.error));

      if (!$error.is(":visible")) {
        $error.css({
          top: 50,
          opacity: 0.1
        }).show().animate({
          top: 0,
          opacity: 1.0
        }, 300);
      }
    });

    _defineProperty(this, "_hideError", () => {
      // eslint-disable-next-line react/no-string-refs
      const $error = $__default["default"](ReactDOM__default["default"].findDOMNode(this.refs.error));

      if ($error.is(":visible")) {
        $error.animate({
          top: 50,
          opacity: 0.1
        }, 300, function () {
          // eslint-disable-next-line @babel/no-invalid-this
          $__default["default"](this).hide();
        });
      }
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return change.apply(_this, args);
    });

    _defineProperty(this, "handleBlur", () => {
      this.props.onBlur([]); // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax

      clearTimeout(this._errorTimeout);

      if (!KAS__namespace.unitParse(this.props.value).parsed) {
        this._showError();
      }
    });

    _defineProperty(this, "handleChange", event => {
      this._hideError();

      this.props.onChange({
        value: event.target.value
      });
    });

    _defineProperty(this, "simpleValidate", (rubric, onInputError) => {

      return OldUnitInput.validate(this.getUserInput(), rubric);
    });

    _defineProperty(this, "getUserInput", () => {
      return this.props.value;
    });

    _defineProperty(this, "getInputPaths", () => {
      // The widget itself is an input, so we return a single empty list to
      // indicate this.
      return [[]];
    });

    _defineProperty(this, "focusInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      const input = ReactDOM__default["default"].findDOMNode(this.refs.input);

      if (input) {
        /**
         * TODO(somewhatabstract, JIRA-XXXX):
         * Change to using a ref callback so that focus() can be
         * accessed.
         */
        // $FlowFixMe[prop-missing]
        input.focus();
      }
    });

    _defineProperty(this, "handleFocus", () => {
      this.props.onFocus([]);
    });

    _defineProperty(this, "blurInputPath", inputPath => {
      // eslint-disable-next-line react/no-string-refs
      const input = ReactDOM__default["default"].findDOMNode(this.refs.input);

      if (input) {
        /**
         * TODO(somewhatabstract, JIRA-XXXX):
         * Change to using a ref callback so that focus() can be
         * accessed.
         */
        // $FlowFixMe[prop-missing]
        input.blur();
      }
    });

    _defineProperty(this, "setInputValue", (path, newValue, cb) => {
      this.props.onChange({
        value: newValue
      }, cb);
    });

    _defineProperty(this, "getDOMNodeForPath", () => {
      // eslint-disable-next-line react/no-string-refs
      return ReactDOM__default["default"].findDOMNode(this.refs.input);
    });

    _defineProperty(this, "getGrammarTypeForPath", inputPath => {
      return "unit";
    });
  }

  static validate(userInput, rubric) {
    const answer = KAS__namespace.unitParse(rubric.value).expr;
    const guess = KAS__namespace.unitParse(userInput);

    if (!guess.parsed) {
      return {
        type: "invalid",
        message: i18n__namespace._("I couldn't understand those units.")
      };
    } // Note: we check sigfigs, then numerical correctness, then units, so
    // the most significant things come last, that way the user will see
    // the most important message.


    let message = null; // did the user specify the right number of sigfigs?
    // TODO(joel) - add a grading mode where the wrong number of sigfigs
    // isn't marked wrong

    const sigfigs = rubric.sigfigs;
    const sigfigsCorrect = countSigfigs(guess.coefficient) === sigfigs;

    if (!sigfigsCorrect) {
      message = i18n__namespace._("Check your significant figures.");
    } // now we need to check that the answer is correct to the precision we
    // require.


    let numericallyCorrect;

    try {
      const x = new KAS__namespace.Var("x");
      const equality = new KAS__namespace.Eq(answer.simplify(), "=", new KAS__namespace.Mul(x, guess.expr.simplify()));
      const conversion = equality.solveLinearEquationForVariable(x); // Make sure the conversion factor between the user's input answer
      // and the canonical answer is 1, to sigfig places.
      // TODO(joel) is this sound?

      numericallyCorrect = Number(conversion.eval()).toPrecision(sigfigs) === Number(1).toPrecision(sigfigs);
    } catch (e) {
      numericallyCorrect = false;
    }

    if (!numericallyCorrect) {
      message = i18n__namespace._("That answer is numerically incorrect.");
    }

    let kasCorrect;
    const guessUnit = primUnits(guess.expr.simplify());
    const answerUnit = primUnits(answer.simplify());

    if (rubric.accepting === ALL) {
      // We're accepting all units - KAS does the hard work of figuring
      // out if the user's unit is equivalent to the author's unit.
      kasCorrect = KAS__namespace.compare(guessUnit, answerUnit).equal;
    } else {
      // Are any of the accepted units the same as what the user entered?
      kasCorrect = ___default["default"](rubric.acceptingUnits).any(unit => {
        const thisAnswerUnit = primUnits(KAS__namespace.unitParse(unit).unit.simplify());
        return KAS__namespace.compare(thisAnswerUnit, guessUnit // TODO(joel) - make this work as intended.
        // { form: true }
        ).equal;
      });
    }

    if (!kasCorrect) {
      message = i18n__namespace._("Check your units.");
    }

    const correct = kasCorrect && numericallyCorrect && sigfigsCorrect;
    return {
      type: "points",
      earned: correct ? 1 : 0,
      total: 1,
      message
    };
  } // TODO(joel) think about showing the error buddy


  render() {
    const input = this.props.apiOptions.staticRender ? /*#__PURE__*/React__namespace.createElement(MathOutput, {
      onChange: this.handleChange,
      ref: "input" // eslint-disable-line react/no-string-refs
      ,
      className: ClassNames.INTERACTIVE,
      value: this.props.value,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    }) : /*#__PURE__*/React__namespace.createElement("input", {
      onChange: this.handleChange,
      ref: "input" // eslint-disable-line react/no-string-refs
      ,
      className: ClassNames.INTERACTIVE,
      value: this.props.value,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    });
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "old-unit-input"
    }, input, /*#__PURE__*/React__namespace.createElement("div", {
      ref: "error",
      className: "error",
      style: {
        display: "none"
      }
    }, i18n__namespace._("I don't understand that")));
  }

  componentDidUpdate() {
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    clearTimeout(this._errorTimeout);

    if (KAS__namespace.unitParse(this.props.value).parsed) {
      this._hideError();
    } else {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      this._errorTimeout = setTimeout(this._showError, 2000);
    }
  }

  componentWillUnmount() {
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax
    clearTimeout(this._errorTimeout);
  } // end mobile stuff


} // Extract the primitive units from a unit expression. This first simplifies
// `expr` to a `Mul` like "5 kg m / s^2" then removes the first term.

_defineProperty(OldUnitInput, "defaultProps", {
  apiOptions: ApiOptions.defaults,
  value: ""
});

const primUnits = function (expr) {
  return expr.simplify().asMul().partition()[1].flatten().simplify();
};

var Unit = {
  name: "unit-input",
  displayName: "Unit",
  defaultAlignment: "inline-block",
  widget: OldUnitInput,
  transform: x => lens(x).del(["value"]).freeze(),
  version: {
    major: 0,
    minor: 1
  },
  hidden: true
};

/**
 * This is a component that adds a link to the transcript for embedded videos in articles.
 */
const IS_URL$1 = /^https?:\/\//;

const getYoutubeId = url => {
  const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
  const match = url.match(regExp);

  if (match && match[7].length === 11) {
    return match[7];
  }

  return "videoNotFound";
}; // will accept a youtube link or a video's slug name from embedded video and then query accordingly.


/**
 * Video Transcript Link Component.
 */
const VideoTranscriptLink = props => {
  const {
    location
  } = props;
  const {
    useVideo
  } = getDependencies();
  const [id, kind] = IS_URL$1.test(location) ? [getYoutubeId(location), "YOUTUBE_ID"] : [location, "READABLE_ID"]; // The result value conforms to the wonder-blocks-data `Result` type
  // which is used by our GraphQL framework.

  const result = useVideo(id, kind);

  switch (result.status) {
    case "loading":
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Loading..."));

    case "success":
      {
        var _result$data;

        const video = (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.video;
        return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, {
          style: styles$6.transcriptLink
        }, /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.Text, null, video === null || video === void 0 ? void 0 : video.title), /*#__PURE__*/React__namespace.createElement(wonderBlocksLayout.Strut, {
          size: 10
        }), /*#__PURE__*/React__namespace.createElement(Link__default["default"], {
          href: "/transcript/" + ((video === null || video === void 0 ? void 0 : video.contentId) || "videoNotFound"),
          target: "_blank",
          className: "visited-no-recolor"
        }, i18n__namespace._("See video transcript")));
      }

    case "error":
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Something went wrong."));

    case "aborted":
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Something went wrong."));

    default:
      return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, i18n__namespace._("Something went wrong."));
  }
};

const styles$6 = aphrodite.StyleSheet.create({
  transcriptLink: {
    flexDirection: "row",
    width: "100%",
    justifyContent: "center"
  }
});

// Current default is 720p, based on the typical videos we upload currently
const DEFAULT_WIDTH = 1280;
const DEFAULT_HEIGHT = 720;
const KA_EMBED = "{host}/embed_video?slug={slug}" + "&internal_video_only=1";
const IS_URL = /^https?:\/\//;
const IS_KA_SITE = /(khanacademy\.org|localhost)/;

/**
 * Video renderer.
 */
class Video extends React__namespace.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "getUserInput", () => {
      return null;
    });

    _defineProperty(this, "simpleValidate", rubric => {
      return Video.validate(null, rubric);
    });

    _defineProperty(this, "change", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // $FlowFixMe[incompatible-call]
      return change.apply(_this, args);
    });
  }

  /**
   * This is the widget's grading function.
   * Points for videos are tallied by the embedded video itself, in the case
   * of Khan Academy videos.
   */
  static validate(userInput, rubric) {
    return {
      type: "points",
      earned: 0,
      total: 0,
      message: null
    };
  }

  render() {
    const {
      InitialRequestUrl
    } = getDependencies();
    const location = this.props.location;

    if (!location) {
      return /*#__PURE__*/React__namespace.createElement("div", null);
    }

    let url;

    if (IS_URL.test(location)) {
      url = location;
    } else {
      url = KA_EMBED.replace("{slug}", location);
      let embedHostname = "https://www.khanacademy.org";

      if (IS_KA_SITE.test(InitialRequestUrl.host)) {
        embedHostname = InitialRequestUrl.origin;
      }

      url = url.replace("{host}", embedHostname);
    }

    return /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, null, /*#__PURE__*/React__namespace.createElement(FixedToResponsive, {
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT // The key is here for the benefit of the editor, to ensure that
      // any changes cause a re-rendering of the frame.
      ,
      key: location + this.props.alignment
    }, /*#__PURE__*/React__namespace.createElement(wonderBlocksCore.View, {
      style: a11y.srOnly
    }, i18n__namespace._("Khan Academy video wrapper")), /*#__PURE__*/React__namespace.createElement("iframe", {
      // TODO(joshuan): Consider not using iframes when we're
      // loading this from webapp. This iframe is problematic
      // for screenreaders.
      className: "perseus-video-widget",
      sandbox: "allow-same-origin allow-scripts",
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT,
      src: url,
      allowFullScreen: true
    })), /*#__PURE__*/React__namespace.createElement(VideoTranscriptLink, {
      location: location
    }));
  }

}

var Video$1 = {
  name: "video",
  displayName: "Video",
  defaultAlignment: "block",
  supportedAlignments: ["block", "float-left", "float-right", "full-width"],
  widget: Video
};

// As new widgets get added here, please also make sure they get added in
var extraWidgets = [Categorizer$1, CSProgram$1, Dropdown$1, Explanation$1, Definition$1, Grapher$1, GradedGroup$2, GradedGroupSet$1, Group$1, Iframe$1, Image$1, Interactive, InteractiveGraph$1, LabelImage$1, LightsPuzzle$1, Matrix$1, Matcher$1, Measurer$1, Molecule$1, NumberLine$1, Orderer$1, Passage$1, PassageRef$1, PassageRefTarget$1, Plotter$1, ReactionDiagram, Sequence$1, Simulator$1, Sorter$1, Table$1, Transformer$1, Unit, Video$1];

/**
 * This should be called by all clients, specifying whether extra widgets are
 * needed via `loadExtraWidgets`. It is idempotent, so it's not a problem to
 * call it multiple times.
 *
 * skipMathJax:
 *   If false/undefined, MathJax will be configured, and the
 *   promise will wait for MathJax to load (if it hasn't already).
 */
const init = function (options) {
  registerWidgets(basicWidgets);
  registerWidgets(extraWidgets); // Pass skipMathJax: true if MathJax is already loaded and configured.

  const skipMathJax = options.skipMathJax;

  if (skipMathJax) {
    return Promise.resolve();
  }

  return new Promise((resolve, reject) => {
    MathJax.Hub.Config({
      messageStyle: "none",
      skipStartupTypeset: "none",
      "HTML-CSS": {
        availableFonts: ["TeX"],
        imageFont: null,
        scale: 100,
        showMathMenu: false
      }
    });
    MathJax.Hub.Configured();
    MathJax.Hub.Queue(resolve);
  });
};

var allWidgets = [...basicWidgets, ...extraWidgets];

registerWidgets(allWidgets); // $FlowFixMe[signature-verification-failure]

const ItemVersion = getVersionVector();
ItemVersion["::renderer::"] = version.itemDataVersion;

/**
 * A mixin that renders a custom software keypad in additional to the base
 * component. The base component will receive blur events when the keypad is
 * dismissed and can access the keypad element itself so as to manage its
 * activation and dismissal.
 *
 * TODO(charlie): This would make a nicer higher-order component, except that
 * we need to expose methods on the base component (i.e., `ItemRenderer`). When
 * `ItemRenderer` and friends are written as ES6 Classes, we can have them
 * extend a `ProvideKeypad` component instead of using this mixin.
 */
// NOTE: This is not a real component.  It's a collection of methods used to
// create and manage a Keypad instances.
// TODO(LP-10789): replace this with a React Context object to pass information
// between Perseus and the Keypad.
const ProvideKeypad = {
  propTypes: {
    apiOptions: PropTypes__default["default"].shape({
      customKeypad: PropTypes__default["default"].bool,
      nativeKeypadProxy: PropTypes__default["default"].func
    }),
    // An Aphrodite style object, to be applied to the keypad container.
    // Note that, given our awkward structure of injecting the keypad, this
    // style won't be applied or updated dynamically. Rather, it will only
    // be applied in `componentDidMount`.
    keypadStyle: PropTypes__default["default"].any
  },

  getInitialState() {
    // $FlowFixMe[object-this-reference]
    const _this = this;

    let keypadElement = null;

    if (_this.props.apiOptions && _this.props.apiOptions.customKeypad && _this.props.apiOptions.nativeKeypadProxy) {
      keypadElement = _this.props.apiOptions.nativeKeypadProxy(() => _this.blur && _this.blur());
    }

    return {
      keypadElement
    };
  },

  componentDidMount() {
    // $FlowFixMe[object-this-reference]
    const _this = this;

    if (_this.props.apiOptions && _this.props.apiOptions.customKeypad && !_this.props.apiOptions.nativeKeypadProxy) {
      var _document$body;

      // TODO(charlie): Render this and the wrapped component in the same
      // React tree. We may also want to add this keypad asynchronously
      // or on-demand in the future.
      _this._keypadContainer = document.createElement("div");
      (_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.appendChild(_this._keypadContainer); // TODO(LP-11406): Replace with React Portal
      // eslint-disable-next-line no-restricted-syntax

      ReactDOM__default["default"].render( /*#__PURE__*/React__namespace.createElement(mathInput.Keypad, {
        onElementMounted: element => {
          // NOTE(kevinb): The reason why this setState works is
          // b/c we're calling it manually from item-renderer.jsx
          // and we're manually setting the 'this' by using 'call'
          _this.setState({
            keypadElement: element
          });
        },
        onDismiss: () => {
          _this.blur && _this.blur();
        },
        style: _this.props.keypadStyle
      }), _this._keypadContainer);
    }
  },

  componentWillUnmount() {
    // $FlowFixMe[object-this-reference]
    const _this = this;

    if (_this._keypadContainer) {
      ReactDOM__default["default"].unmountComponentAtNode(_this._keypadContainer);

      if (_this._keypadContainer.parentNode) {
        // Note ChildNode.remove() isn't available in older Android
        // webviews.
        _this._keypadContainer.parentNode.removeChild(_this._keypadContainer);
      }

      _this._keypadContainer = null;
    }
  },

  keypadElement() {
    // $FlowFixMe[object-this-reference]
    const _this = this;

    return _this.state.keypadElement;
  }

};

const rendererProps = PropTypes__default["default"].shape({
  content: PropTypes__default["default"].string,
  widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
  images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any)
});

class ArticleRenderer extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "_currentFocus", void 0);

    _defineProperty(this, "keypadElement", () => {
      return ProvideKeypad.keypadElement.call(this);
    });

    _defineProperty(this, "_handleFocusChange", (newFocusPath, oldFocusPath) => {
      // TODO(charlie): DRY this up--some of this logic is repeated in
      // ItemRenderer.
      if (newFocusPath) {
        this._setCurrentFocus(newFocusPath);
      } else {
        this._onRendererBlur(oldFocusPath);
      }
    });

    _defineProperty(this, "_setCurrentFocus", newFocusPath => {
      const keypadElement = this.keypadElement();
      const prevFocusPath = this._currentFocus;
      this._currentFocus = newFocusPath; // Use the section prefix to extract the relevant Renderer's input
      // paths, so as to check whether the focused path represents an
      // input.

      let didFocusInput = false;

      if (this._currentFocus) {
        const [sectionRef, ...focusPath] = this._currentFocus; // eslint-disable-next-line react/no-string-refs

        const inputPaths = this.refs[sectionRef].getInputPaths();
        didFocusInput = inputPaths.some(inputPath => {
          return Util.inputPathsEqual(inputPath, focusPath);
        });
      }

      if (this.props.apiOptions.onFocusChange != null) {
        this.props.apiOptions.onFocusChange(this._currentFocus, prevFocusPath, didFocusInput && keypadElement && keypadElement.getDOMNode());
      }

      if (keypadElement) {
        if (didFocusInput) {
          keypadElement.activate();
        } else {
          keypadElement.dismiss();
        }
      }
    });

    _defineProperty(this, "_onRendererBlur", blurPath => {
      const blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
      // before blur.

      if (!Util.inputPathsEqual(blurPath, blurringFocusPath)) {
        return;
      } // Wait until after any new focus events fire this tick before declaring
      // that nothing is focused, since if there were a focus change across
      // sections, we could receive the blur before the focus.
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
      // eslint-disable-next-line no-restricted-syntax


      setTimeout(() => {
        if (Util.inputPathsEqual(this._currentFocus, blurringFocusPath)) {
          this._setCurrentFocus(null);
        }
      });
    });

    _defineProperty(this, "blur", () => {
      if (this._currentFocus) {
        const [sectionRef, ...inputPath] = this._currentFocus; // eslint-disable-next-line react/no-string-refs

        this.refs[sectionRef].blurPath(inputPath);
      }
    });

    _defineProperty(this, "_sections", () => {
      return Array.isArray(this.props.json) ? this.props.json : [this.props.json];
    });

    this.state = ProvideKeypad.getInitialState.call(this);
  }

  componentDidMount() {
    ProvideKeypad.componentDidMount.call(this);
    this._currentFocus = null;
  }

  shouldComponentUpdate(nextProps, nextState) {
    return nextProps !== this.props || nextState !== this.state;
  }

  componentWillUnmount() {
    ProvideKeypad.componentWillUnmount.call(this);
  }

  render() {
    const apiOptions = { ...ApiOptions.defaults,
      ...this.props.apiOptions,
      isArticle: true
    };
    const classes = classNames__default["default"]({
      "framework-perseus": true,
      "perseus-article": true,
      "bibliotron-article": this.props.useNewStyles,
      // NOTE(charlie): For exercises, this is applied outside of Perseus
      // (in webapp).
      [ClassNames.MOBILE]: apiOptions.isMobile
    }); // TODO(alex): Add mobile api functions and pass them down here

    const sections = this._sections().map((section, i) => {
      const refForSection = "section-".concat(i);
      return /*#__PURE__*/React__namespace.createElement("div", {
        key: i,
        className: "clearfix"
      }, /*#__PURE__*/React__namespace.createElement(Renderer, _extends$1({}, section, {
        ref: refForSection,
        key: i,
        key_: i,
        keypadElement: this.keypadElement(),
        apiOptions: { ...apiOptions,
          onFocusChange: (newFocusPath, oldFocusPath) => {
            // Prefix the paths with the relevant section,
            // so as to allow us to distinguish between
            // equivalently-named inputs across Renderers.
            this._handleFocusChange(newFocusPath && [refForSection].concat(newFocusPath), oldFocusPath && [refForSection].concat(oldFocusPath));
          }
        },
        linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "article"),
        legacyPerseusLint: this.props.legacyPerseusLint
      })));
    });

    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classes
    }, sections);
  }

}

_defineProperty(ArticleRenderer, "propTypes", { ...ProvideKeypad.propTypes,
  apiOptions: PropTypes__default["default"].shape({
    onFocusChange: PropTypes__default["default"].func,
    isMobile: PropTypes__default["default"].bool
  }),
  json: PropTypes__default["default"].oneOfType([rendererProps, PropTypes__default["default"].arrayOf(rendererProps)]).isRequired,
  // Whether to use the new Bibliotron styles for articles
  useNewStyles: PropTypes__default["default"].bool,
  linterContext: PerseusLinter__namespace.linterContextProps,
  legacyPerseusLint: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string)
});

_defineProperty(ArticleRenderer, "defaultProps", {
  apiOptions: {},
  useNewStyles: false,
  linterContext: PerseusLinter__namespace.linterContextDefault
});

/* Renders just a hint preview */
class HintRenderer extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "getSerializedState", () => {
      // eslint-disable-next-line react/no-string-refs
      return this.refs.renderer.getSerializedState();
    });

    _defineProperty(this, "restoreSerializedState", (state, callback) => {
      // eslint-disable-next-line react/no-string-refs
      this.refs.renderer.restoreSerializedState(state, callback);
    });
  }

  render() {
    const {
      apiOptions,
      className,
      hint,
      lastHint,
      lastRendered,
      pos,
      totalHints
    } = this.props;
    const {
      isMobile
    } = apiOptions;
    const classNames = classNames__default["default"](!isMobile && "perseus-hint-renderer", isMobile && aphrodite.css(styles$5.newHint), isMobile && lastRendered && aphrodite.css(styles$5.lastRenderedNewHint), lastHint && "last-hint", lastRendered && "last-rendered", className); // TODO(charlie): Allowing `staticRender` here would require that we
    // extend `HintsRenderer` and `HintRenderer` to implement the full
    // "input' API, so that clients could access the static inputs. Allowing
    // `customKeypad` would require that we extend `ItemRenderer` to support
    // nested inputs in the `HintsRenderer`. For now, we disable these
    // options. Instead, clients will get standard <input/> elements, which
    // aren't nice to use on mobile, but are at least usable.

    const rendererApiOptions = { ...apiOptions,
      customKeypad: false,
      staticRender: false
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames,
      tabIndex: "-1"
    }, !apiOptions.isMobile && /*#__PURE__*/React__namespace.createElement("span", {
      className: "perseus-sr-only"
    }, i18n__namespace._("Hint #%(pos)s", {
      pos: pos + 1
    })), !apiOptions.isMobile && !apiOptions.satStyling && totalHints && pos != null && /*#__PURE__*/React__namespace.createElement("span", {
      className: "perseus-hint-label",
      style: {
        display: "block",
        color: apiOptions.hintProgressColor
      }
    }, "".concat(pos + 1, " / ").concat(totalHints)), /*#__PURE__*/React__namespace.createElement(Renderer // eslint-disable-next-line react/no-string-refs
    , {
      ref: "renderer",
      widgets: hint.widgets,
      content: hint.content || "",
      images: hint.images,
      apiOptions: rendererApiOptions,
      findExternalWidgets: this.props.findExternalWidgets,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "hint")
    }));
  }

}

_defineProperty(HintRenderer, "defaultProps", {
  linterContext: PerseusLinter__namespace.linterContextDefault
});

const styles$5 = aphrodite.StyleSheet.create({
  newHint: {
    marginBottom: 1.5 * baseUnitPx,
    borderLeftColor: gray97,
    borderLeftStyle: "solid",
    borderLeftWidth: hintBorderWidth,
    // Only apply left-padding on tablets, to avoid being flush with the
    // border. On phones, padding is applied internally by the child
    // renderers. Some content on phones that is rendered at full-bleed may
    // end up flush with the border, but that's acceptable for now.
    [mediaQueries.lgOrSmaller]: {
      paddingLeft: baseUnitPx
    },
    [mediaQueries.smOrSmaller]: {
      paddingLeft: 0
    },
    ":focus": {
      outline: "none"
    }
  },
  lastRenderedNewHint: {
    marginBottom: 0,
    borderLeftColor: kaGreen$1
  }
});

// Use of UNSAFE_componentWillReceiveProps:
// eslint-disable-next-line react/no-unsafe
class HintsRenderer extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      isFinalHelpPage: false
    });

    _defineProperty(this, "_hintsVisible", () => {
      if (this.props.hintsVisible == null || this.props.hintsVisible === -1) {
        return this.props.hints.length;
      }

      return this.props.hintsVisible;
    });

    _defineProperty(this, "_cacheImagesInHint", hint => {
      ___default["default"].each(hint.images, (data, src) => {
        const image = new Image();
        image.src = Util.getRealImageUrl(src);
      });
    });

    _defineProperty(this, "_cacheHintImages", () => {
      // Only cache images in the first hint at the start. When hints are
      // taken, cache images in the rest of the hints
      if (this._hintsVisible() > 0) {
        ___default["default"].each(this.props.hints, this._cacheImagesInHint);
      } else if (this.props.hints.length > 0) {
        this._cacheImagesInHint(this.props.hints[0]);
      }
    });

    _defineProperty(this, "getApiOptions", () => {
      // When an item is answered correctly, the entire exercise is set to
      // `readOnly = true` so that the user cannot switch answers. However, this
      // makes hyperlinks in hints unclickable. Thus, we always set readOnly to be
      // false in hints.
      return { ...ApiOptions.defaults,
        ...this.props.apiOptions,
        readOnly: false
      };
    });

    _defineProperty(this, "getSerializedState", () => {
      return ___default["default"].times(this._hintsVisible(), i => {
        // eslint-disable-next-line react/no-string-refs
        return this.refs["hintRenderer" + i].getSerializedState();
      });
    });

    _defineProperty(this, "restoreSerializedState", (state, callback) => {
      // We need to wait until all the renderers are finished restoring their
      // state before we fire our callback.
      let numCallbacks = 1;

      const fireCallback = () => {
        --numCallbacks;

        if (callback && numCallbacks === 0) {
          callback();
        }
      };

      ___default["default"].each(state, (hintState, i) => {
        // eslint-disable-next-line react/no-string-refs
        const hintRenderer = this.refs["hintRenderer" + i]; // This is not ideal in that it doesn't restore state
        // if the hint isn't visible, but we can't exactly restore
        // the state to an unmounted renderer, so...
        // If you want to restore state to hints, make sure to
        // have the appropriate number of hints visible already.

        if (hintRenderer) {
          ++numCallbacks;
          hintRenderer.restoreSerializedState(hintState, fireCallback);
        }
      }); // This makes sure that the callback is fired if there aren't any
      // mounted renderers.


      fireCallback();
    });
  }

  componentDidMount() {
    this._cacheHintImages();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    // $FlowFixMe[unsafe-addition]
    if (nextProps.hintsVisible - this.props.hintsVisible > 1) {
      this.setState({
        isFinalHelpPage: true
      });
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (!___default["default"].isEqual(prevProps.hints, this.props.hints) || prevProps.hintsVisible !== this.props.hintsVisible) {
      this._cacheHintImages();
    } // When a new hint is displayed we immediately focus it
    // $FlowFixMe[invalid-compare]


    if (prevProps.hintsVisible < this.props.hintsVisible) {
      // $FlowFixMe[unsafe-addition]
      const pos = this.props.hintsVisible - 1; // $FlowFixMe[prop-missing]
      // $FlowFixMe[incompatible-use]

      ReactDOM__default["default"].findDOMNode(this.refs["hintRenderer" + pos]).focus(); // eslint-disable-line react/no-string-refs
    }
  }

  render() {
    const apiOptions = this.getApiOptions();

    const hintsVisible = this._hintsVisible();

    const hints = [];
    const isFinalHelpPage = this.state.isFinalHelpPage;
    this.props.hints.slice(0, hintsVisible).forEach((hint, i) => {
      const lastHint = i === this.props.hints.length - 1 && !/\*\*/.test(hint.content);
      const lastRendered = i === hintsVisible - 1;
      const renderer = /*#__PURE__*/React__namespace.createElement(HintRenderer, {
        lastHint: lastHint,
        lastRendered: lastRendered,
        hint: hint,
        pos: i,
        totalHints: this.props.hints.length,
        ref: "hintRenderer" + i,
        key: "hintRenderer" + i,
        apiOptions: apiOptions,
        findExternalWidgets: this.props.findExternalWidgets,
        linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "hints[" + i + "]")
      });

      if (isFinalHelpPage) {
        hints.push(renderer);
      } else {
        if (hint.replace && hints.length > 0) {
          hints[hints.length - 1] = renderer;
        } else {
          hints.push(renderer);
        }
      }
    });
    const {
      getAnotherHint
    } = apiOptions;
    const showGetAnotherHint = getAnotherHint && hintsVisible > 0 && hintsVisible < this.props.hints.length;
    const hintRatioCopy = "(".concat(hintsVisible, "/").concat(this.props.hints.length, ")");
    const classNames = classNames__default["default"](this.props.className, apiOptions.isMobile && hintsVisible > 0 && aphrodite.css(styles$4.mobileHintStylesHintsRenderer));
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: classNames
    }, apiOptions.isMobile && hintsVisible > 0 && /*#__PURE__*/React__namespace.createElement("div", {
      className: aphrodite.css(styles$4.mobileHintStylesHintTitle, sharedStyles.responsiveLabel)
    }, i18n__namespace._("Hints")), hints, showGetAnotherHint && /*#__PURE__*/React__namespace.createElement("button", {
      rel: "button",
      className: aphrodite.css(styles$4.linkButton, styles$4.getAnotherHintButton, apiOptions.isMobile && styles$4.mobileHintStylesGetAnotherHintButton),
      onClick: evt => {
        evt.preventDefault();
        evt.stopPropagation();

        if (getAnotherHint) {
          getAnotherHint();
        }
      }
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$4.plusText, apiOptions.isMobile && styles$4.mobileHintStylesPlusText)
    }, "+"), /*#__PURE__*/React__namespace.createElement("span", {
      className: aphrodite.css(styles$4.getAnotherHintText)
    }, i18n__namespace._("Get another hint"), " ", hintRatioCopy)));
  }

}

_defineProperty(HintsRenderer, "defaultProps", {
  linterContext: PerseusLinter__namespace.linterContextDefault
});

const hintIndentation = baseUnitPx + hintBorderWidth;
const styles$4 = aphrodite.StyleSheet.create({
  // eslint-disable-next-line react-native/no-unused-styles
  rendererMargins: {
    marginTop: baseUnitPx
  },
  linkButton: {
    cursor: "pointer",
    border: "none",
    backgroundColor: "transparent",
    fontSize: "100%",
    fontFamily: "inherit",
    fontWeight: "bold",
    color: kaGreen$1,
    padding: 0,
    position: "relative"
  },
  plusText: {
    fontSize: 20,
    position: "absolute",
    top: -3,
    left: 0
  },
  getAnotherHintText: {
    marginLeft: 16
  },
  mobileHintStylesHintsRenderer: {
    marginTop: 4 * baseUnitPx,
    border: "solid ".concat(gray85),
    borderWidth: "1px 0 0 0",
    position: "relative",
    ":before": {
      content: '""',
      display: "table",
      clear: "both"
    },
    ":after": {
      content: '""',
      display: "table",
      clear: "both"
    }
  },
  mobileHintStylesHintTitle: {
    fontFamily: "inherit",
    fontStyle: "normal",
    fontWeight: "bold",
    color: gray17,
    paddingTop: baseUnitPx,
    paddingBottom: 1.5 * baseUnitPx,
    [mediaQueries.lgOrSmaller]: {
      paddingLeft: 0
    },
    [mediaQueries.smOrSmaller]: {
      // On phones, ensure that the button is aligned with the hint body
      // content, which is inset at the standard `baseUnitPx`, plus an
      // additional `hintBorderWidth`.
      paddingLeft: hintIndentation
    }
  },
  getAnotherHintButton: {
    marginTop: 1.5 * baseUnitPx
  },
  mobileHintStylesGetAnotherHintButton: {
    [mediaQueries.lgOrSmaller]: {
      paddingLeft: 0
    },
    [mediaQueries.smOrSmaller]: {
      // As with the title, on phones, ensure that the button is aligned
      // with the hint body content.
      paddingLeft: hintIndentation
    }
  },
  mobileHintStylesPlusText: {
    [mediaQueries.lgOrSmaller]: {
      left: 0
    },
    [mediaQueries.smOrSmaller]: {
      left: hintIndentation
    }
  }
});

const {
  mapObject: mapObject$1
} = objective_;

class ItemRenderer extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "questionRenderer", void 0);

    _defineProperty(this, "hintsRenderer", void 0);

    _defineProperty(this, "_currentFocus", void 0);

    _defineProperty(this, "_handleFocusChange", (newFocus, oldFocus) => {
      if (newFocus != null) {
        this._setCurrentFocus(newFocus);
      } else {
        this._onRendererBlur(oldFocus);
      }
    });

    _defineProperty(this, "handleInteractWithWidget", widgetId => {
      const withRemoved = ___default["default"].difference(this.state.questionHighlightedWidgets, [widgetId]);

      this.setState({
        questionCompleted: false,
        questionHighlightedWidgets: withRemoved
      });

      if (this.props.apiOptions.interactionCallback) {
        this.props.apiOptions.interactionCallback();
      }
    });

    this.state = { // NOTE: This value is used in provide-keypad.jsx which contains a
      // "mixin" that this file calls methods on.
      ...ProvideKeypad.getInitialState.call(this),
      hintsVisible: props.initialHintsVisible || 0,
      questionCompleted: false,
      questionHighlightedWidgets: []
    };
  }

  componentDidMount() {
    ProvideKeypad.componentDidMount.call(this);

    if (this.props.controlPeripherals && this.props.apiOptions.setDrawingAreaAvailable) {
      this.props.apiOptions.setDrawingAreaAvailable(true);
    }

    this._currentFocus = null;
    this.update();
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      questionHighlightedWidgets: []
    });
  }

  componentDidUpdate() {
    this.update();
  }

  componentWillUnmount() {
    ProvideKeypad.componentWillUnmount.call(this);
    const workArea = document.querySelector(this.props.workAreaSelector);

    if (workArea != null) {
      ReactDOM__namespace.unmountComponentAtNode(workArea);
    }

    const hintsArea = document.querySelector(this.props.hintsAreaSelector);

    if (hintsArea != null) {
      ReactDOM__namespace.unmountComponentAtNode(hintsArea);
    }

    if (this.props.controlPeripherals) {
      const answerArea = this.props.item.answerArea || {};

      if (answerArea.calculator) {
        $__default["default"]("#calculator").hide();
      }

      if (answerArea.periodicTable) {
        $__default["default"](".periodic-table-info-box").hide();
      }

      if (answerArea.zTable) {
        $__default["default"](".z-table-info-box").hide();
      }

      if (answerArea.tTable) {
        $__default["default"](".t-table-info-box").hide();
      }

      if (answerArea.chi2Table) {
        $__default["default"](".chi2-table-info-box").hide();
      }
    }
  }

  keypadElement() {
    return ProvideKeypad.keypadElement.call(this);
  }

  update() {
    const apiOptions = { ...ApiOptions.defaults,
      ...this.props.apiOptions,
      onFocusChange: this._handleFocusChange
    };
    const workArea = document.querySelector(this.props.workAreaSelector);
    const hintsArea = document.querySelector(this.props.hintsAreaSelector);

    if (!workArea || !hintsArea) {
      return;
    } // Since the item renderer works by rendering things into three divs
    // that have completely different places in the DOM, we have to do this
    // strangeness instead of relying on React's normal render() method.
    // TODO(alpert): Figure out how to clean this up somehow
    // TODO(LP-11406): Replace with React Portal
    // eslint-disable-next-line no-restricted-syntax


    ReactDOM__namespace.render(
    /*#__PURE__*/
    // metadata (from item.question, aka PerseusRenderer)
    // replace (also item.question, aka PerseusRenderer)
    // savedState (I _think_ this is serializedState on Renderer)
    // $FlowFixMe[prop-missing] metadata, replace, savedState (see above)
    React__namespace.createElement(Renderer, _extends$1({
      ref: node => {
        if (!node) {
          return;
        }

        this.questionRenderer = node; // NOTE(jeremy): Why don't we just pass this into the
        // renderer as a prop?

        const {
          answerableCallback
        } = apiOptions;

        if (answerableCallback) {
          const isAnswerable = this.questionRenderer.emptyWidgets().length === 0;
          answerableCallback(isAnswerable);
        }
      },
      keypadElement: this.keypadElement(),
      problemNum: this.props.problemNum,
      onInteractWithWidget: this.handleInteractWithWidget,
      highlightedWidgets: this.state.questionHighlightedWidgets,
      apiOptions: apiOptions,
      questionCompleted: this.state.questionCompleted,
      reviewMode: this.props.reviewMode,
      savedState: this.props.savedState,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "question")
    }, this.props.item.question, {
      legacyPerseusLint: this.props.legacyPerseusLint
    })), workArea); // TODO(LP-11406): Replace with React Portal
    // eslint-disable-next-line no-restricted-syntax

    ReactDOM__namespace.render( /*#__PURE__*/React__namespace.createElement(HintsRenderer, {
      ref: node => this.hintsRenderer = node,
      hints: this.props.item.hints,
      hintsVisible: this.state.hintsVisible,
      apiOptions: apiOptions,
      linterContext: PerseusLinter__namespace.pushContextStack(this.props.linterContext, "hints")
    }), hintsArea);
    const answerArea = this.props.item.answerArea || {};

    if (this.props.controlPeripherals) {
      $__default["default"]("#calculator").toggle(answerArea.calculator || false);
      $__default["default"](".periodic-table-info-box").toggle(answerArea.periodicTable || false);
      $__default["default"](".z-table-info-box").toggle(answerArea.zTable || false);
      $__default["default"](".t-table-info-box").toggle(answerArea.tTable || false);
      $__default["default"](".chi2-table-info-box").toggle(answerArea.chi2Table || false);
    } else {
      if (answerArea.calculator) {
        this.props.onShowCalculator && this.props.onShowCalculator();
      }

      if (answerArea.periodicTable) {
        this.props.onShowPeriodicTable && this.props.onShowPeriodicTable();
      }

      if (answerArea.zTable) {
        this.props.onShowZTable && this.props.onShowZTable();
      }

      if (answerArea.tTable) {
        this.props.onShowTTable && this.props.onShowTTable();
      }

      if (answerArea.chi2Table) {
        this.props.onShowChi2Table && this.props.onShowChi2Table();
      }
    }
  }

  // Sets the current focus path and element and send an onChangeFocus event
  // back to our parent.
  _setCurrentFocus(newFocus) {
    const keypadElement = this.keypadElement(); // By the time this happens, newFocus cannot be a prefix of
    // prevFocused, since we must have either been called from
    // an onFocusChange within a renderer, which is only called when
    // this is not a prefix, or between the question and answer areas,
    // which can never prefix each other.

    const prevFocus = this._currentFocus;
    this._currentFocus = newFocus; // Determine whether the newly focused path represents an input.

    const inputPaths = this.getInputPaths();
    const didFocusInput = this._currentFocus && inputPaths.some(inputPath => {
      return Util.inputPathsEqual(inputPath, this._currentFocus);
    });

    if (this.props.apiOptions.onFocusChange != null) {
      this.props.apiOptions.onFocusChange(this._currentFocus, prevFocus, // $FlowFixMe[incompatible-call]: onFocusChange expects an HTMLElement or nothing
      didFocusInput && keypadElement && keypadElement.getDOMNode());
    }

    if (keypadElement) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  }

  _onRendererBlur(blurPath) {
    const blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
    // before blur.

    if (!Util.inputPathsEqual(blurPath, blurringFocusPath)) {
      return;
    } // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused, since if there were a focus change
    // across Renderers (e.g., from the HintsRenderer to the
    // QuestionRenderer), we could receive the blur before the focus.
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API
    // eslint-disable-next-line no-restricted-syntax


    setTimeout(() => {
      if (Util.inputPathsEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    });
  }
  /**
   * Accepts a question area widgetId, or an answer area widgetId of
   * the form "answer-input-number 1", or the string "answer-area"
   * for the whole answer area (if the answer area is a single widget).
   */
  // eslint-disable-next-line ft-flow/no-weak-types


  _setWidgetProps(widgetId, newProps, callback) {
    this.questionRenderer._setWidgetProps(widgetId, newProps, callback);
  }
  /**
   * Sets the input value into the widget found at `path`. The `focus`
   * function provided is called when all affected widgets have been
   * re-rendered with the new value.
   */


  setInputValue(path, newValue, focus) {
    return this.questionRenderer.setInputValue(path, newValue, focus);
  }

  focusPath(path) {
    return this.questionRenderer.focusPath(path);
  }

  blurPath(path) {
    return this.questionRenderer.blurPath(path);
  }

  getDOMNodeForPath(path) {
    return this.questionRenderer.getDOMNodeForPath(path);
  }

  getGrammarTypeForPath(path) {
    return this.questionRenderer.getGrammarTypeForPath(path);
  }

  getInputPaths() {
    const questionAreaInputPaths = this.questionRenderer.getInputPaths();
    return questionAreaInputPaths;
  } // NOTE: this must remain as an arrow function because we pass it Renderer


  focus() {
    return this.questionRenderer.focus();
  }

  blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  }

  showHint() {
    if (this.state.hintsVisible < this.getNumHints()) {
      this.setState({
        hintsVisible: this.state.hintsVisible + 1
      });
    }
  }

  getNumHints() {
    return this.props.item.hints.length;
  }
  /**
   * Grades the item.
   *
   * Returns a KE-style score of {
   *     empty: bool,
   *     correct: bool,
   *     message: string|null,
   *     guess: Array
   * }
   */


  scoreInput() {
    const guessAndScore = this.questionRenderer.guessAndScore();
    const guess = guessAndScore[0];
    const score = guessAndScore[1]; // Continue to include an empty guess for the now defunct answer area.
    // TODO(alex): Check whether we rely on the format here for
    //             analyzing ProblemLogs. If not, remove this layer.

    const maxCompatGuess = [guess, []];
    const keScore = Util.keScoreFromPerseusScore(score, maxCompatGuess, this.questionRenderer.getSerializedState());
    const emptyQuestionAreaWidgets = this.questionRenderer.emptyWidgets();
    this.setState({
      questionCompleted: keScore.correct,
      questionHighlightedWidgets: emptyQuestionAreaWidgets
    });
    return keScore;
  }
  /**
   * Returns an array of all widget IDs in the order they occur in
   * the question content.
   */


  getWidgetIds() {
    return this.questionRenderer.getWidgetIds();
  }
  /**
   * Returns an object mapping from widget ID to KE-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */


  scoreWidgets() {
    const qScore = this.questionRenderer.scoreWidgets();
    const qGuess = this.questionRenderer.getUserInputForWidgets();
    const state = this.questionRenderer.getSerializedState();
    return mapObject$1(qScore, (score, id) => {
      return Util.keScoreFromPerseusScore(score, qGuess[id], state[id]);
    });
  }
  /**
   * Get a representation of the current state of the item.
   */


  getSerializedState() {
    var _this$hintsRenderer;

    return {
      question: this.questionRenderer.getSerializedState(),
      hints: (_this$hintsRenderer = this.hintsRenderer) === null || _this$hintsRenderer === void 0 ? void 0 : _this$hintsRenderer.getSerializedState()
    };
  } // TODO(kevinb): make the type for this state better


  restoreSerializedState(state, callback) {
    var _this$hintsRenderer2;

    // We need to wait for both the question renderer and the hints
    // renderer to finish restoring their states.
    let numCallbacks = 2;

    const fireCallback = () => {
      --numCallbacks;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this.questionRenderer.restoreSerializedState(state.question, fireCallback);
    (_this$hintsRenderer2 = this.hintsRenderer) === null || _this$hintsRenderer2 === void 0 ? void 0 : _this$hintsRenderer2.restoreSerializedState(state.hints, fireCallback);
  }

  showRationalesForCurrentlySelectedChoices() {
    this.questionRenderer.showRationalesForCurrentlySelectedChoices();
  }

  deselectIncorrectSelectedChoices() {
    this.questionRenderer.deselectIncorrectSelectedChoices();
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", null);
  }

}

_defineProperty(ItemRenderer, "defaultProps", {
  apiOptions: ApiOptions.defaults,
  // defaults are set in `this.update()`
  controlPeripherals: true,
  hintsAreaSelector: "#hintsarea",
  initialHintsVisible: 0,
  workAreaSelector: "#workarea",
  reviewMode: false,
  linterContext: PerseusLinter__namespace.linterContextDefault
});

/**
 * A React context for signaling when all of the components in a Perseus
 * renderer is fully rendered.  This means that all images and math have
 * finished loading/rendering.
 *
 * Currently only used by ServerItemRender to indicate when the question
 * renderer is fully rendered.
 */
const defaultContext = {
  onRendered: isRendered => {}
};
const context$1 = /*#__PURE__*/React__namespace.createContext(defaultContext);

const {
  mapObject
} = objective_;

/* eslint-disable-next-line react/no-unsafe */
class ServerItemRenderer extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "questionRenderer", void 0);

    _defineProperty(this, "hintsRenderer", void 0);

    _defineProperty(this, "_currentFocus", void 0);

    _defineProperty(this, "_fullyRendered", void 0);

    _defineProperty(this, "blurTimeoutID", void 0);

    _defineProperty(this, "_handleFocusChange", (newFocus, oldFocus) => {
      if (newFocus != null) {
        this._setCurrentFocus(newFocus);
      } else {
        this._onRendererBlur(oldFocus);
      }
    });

    _defineProperty(this, "handleInteractWithWidget", widgetId => {
      const withRemoved = ___default["default"].difference(this.state.questionHighlightedWidgets, [widgetId]);

      this.setState({
        questionCompleted: false,
        questionHighlightedWidgets: withRemoved
      });

      if (this.props.apiOptions.interactionCallback) {
        this.props.apiOptions.interactionCallback();
      }
    });

    _defineProperty(this, "setAssetStatus", (assetKey, status) => {
      // setState doesn't properly merge objects so we have to do it ourselves
      const assetStatuses = { ...this.state.assetStatuses,
        [assetKey]: status
      };
      this.setState({
        assetStatuses
      });
    });

    this.state = {
      questionCompleted: false,
      questionHighlightedWidgets: [],
      assetStatuses: {}
    };
    this._fullyRendered = false;
  }

  componentDidMount() {
    this._currentFocus = null;
    this._fullyRendered = false;
  }

  UNSAFE_componentWillReceiveProps(nextProps) {
    this.setState({
      questionHighlightedWidgets: []
    });
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.apiOptions.answerableCallback) {
      const isAnswerable = this.questionRenderer.emptyWidgets().length === 0;
      const {
        answerableCallback
      } = this.props.apiOptions;

      if (answerableCallback) {
        answerableCallback(isAnswerable);
      }
    }

    if (!this._fullyRendered) {
      const assetsLoaded = Object.values(this.state.assetStatuses).every(Boolean);

      if (assetsLoaded) {
        this._fullyRendered = true;
        this.props.onRendered(true);
      }
    }
  }

  componentWillUnmount() {
    if (this.blurTimeoutID != null) {
      // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
      // eslint-disable-next-line no-restricted-syntax
      clearTimeout(this.blurTimeoutID);
      this.blurTimeoutID = null;
    }
  }

  // Sets the current focus path and element and
  // send an onChangeFocus event back to our parent.
  _setCurrentFocus(newFocus) {
    const {
      apiOptions: {
        isMobile,
        onFocusChange
      },
      keypadElement
    } = this.props; // By the time this happens, newFocus cannot be a prefix of
    // prevFocused, since we must have either been called from
    // an onFocusChange within a renderer, which is only called when
    // this is not a prefix, or between the question and answer areas,
    // which can never prefix each other.

    const prevFocus = this._currentFocus;
    this._currentFocus = newFocus; // Determine whether the newly focused path represents an input.

    const inputPaths = this.getInputPaths();
    const didFocusInput = this._currentFocus && inputPaths.some(inputPath => {
      return Util.inputPathsEqual(inputPath, this._currentFocus);
    });

    if (onFocusChange != null) {
      onFocusChange(this._currentFocus, prevFocus, // $FlowFixMe[incompatible-call]: onFocusChange expects an HTMLElement or nothing
      didFocusInput && keypadElement && keypadElement.getDOMNode(), // $FlowFixMe[incompatible-call]: onFocusChange expects an HTMLElement or nothing
      didFocusInput && // $FlowFixMe[incompatible-call]: onFocusChange expects an HTMLElement or nothing
      this.questionRenderer.getDOMNodeForPath(newFocus));
    }

    if (keypadElement && isMobile) {
      if (didFocusInput) {
        keypadElement.activate();
      } else {
        keypadElement.dismiss();
      }
    }
  }

  _onRendererBlur(blurPath) {
    const blurringFocusPath = this._currentFocus; // Failsafe: abort if ID is different, because focus probably happened
    // before blur

    if (!___default["default"].isEqual(blurPath, blurringFocusPath)) {
      return;
    } // Wait until after any new focus events fire this tick before
    // declaring that nothing is focused.
    // If a different widget was focused, we'll see an onBlur event
    // now, but then an onFocus event on a different element before
    // this callback is executed
    // TODO(jeff, CP-3128): Use Wonder Blocks Timing API.
    // eslint-disable-next-line no-restricted-syntax


    this.blurTimeoutID = setTimeout(() => {
      if (___default["default"].isEqual(this._currentFocus, blurringFocusPath)) {
        this._setCurrentFocus(null);
      }
    }, 0);
  }
  /**
   * Accepts a question area widgetId, or an answer area widgetId of
   * the form "answer-input-number 1", or the string "answer-area"
   * for the whole answer area (if the answer area is a single widget).
   */
  // eslint-disable-next-line ft-flow/no-weak-types


  _setWidgetProps(widgetId, newProps, callback) {
    this.questionRenderer._setWidgetProps(widgetId, newProps, callback);
  }

  setInputValue(path, newValue, focus) {
    return this.questionRenderer.setInputValue(path, newValue, focus);
  }

  focusPath(path) {
    return this.questionRenderer.focusPath(path);
  }

  blurPath(path) {
    return this.questionRenderer.blurPath(path);
  }

  getDOMNodeForPath(path) {
    return this.questionRenderer.getDOMNodeForPath(path);
  }

  getGrammarTypeForPath(path) {
    return this.questionRenderer.getGrammarTypeForPath(path);
  }

  getInputPaths() {
    const questionAreaInputPaths = this.questionRenderer.getInputPaths();
    return questionAreaInputPaths;
  }

  focus() {
    return this.questionRenderer.focus();
  }

  blur() {
    if (this._currentFocus) {
      this.blurPath(this._currentFocus);
    }
  }

  getNumHints() {
    return this.props.item.hints.length;
  }
  /**
   * Grades the item.
   */


  scoreInput() {
    const guessAndScore = this.questionRenderer.guessAndScore();
    const guess = guessAndScore[0];
    const score = guessAndScore[1]; // Continue to include an empty guess for the now defunct answer area.
    // TODO(alex): Check whether we rely on the format here for
    //             analyzing ProblemLogs. If not, remove this layer.

    const maxCompatGuess = [guess, []];
    const keScore = Util.keScoreFromPerseusScore(score, maxCompatGuess, this.questionRenderer.getSerializedState());
    const emptyQuestionAreaWidgets = this.questionRenderer.emptyWidgets();
    this.setState({
      questionCompleted: keScore.correct,
      questionHighlightedWidgets: emptyQuestionAreaWidgets
    });
    return keScore;
  }
  /**
   * Returns an array of all widget IDs in the order they occur in
   * the question content.
   */


  getWidgetIds() {
    return this.questionRenderer.getWidgetIds();
  }
  /**
   * Returns an object mapping from widget ID to KE-style score.
   * The keys of this object are the values of the array returned
   * from `getWidgetIds`.
   */


  scoreWidgets() {
    const qScore = this.questionRenderer.scoreWidgets();
    const qGuess = this.questionRenderer.getUserInputForWidgets();
    const state = this.questionRenderer.getSerializedState();
    return mapObject(qScore, (score, id) => {
      return Util.keScoreFromPerseusScore(score, qGuess[id], state);
    });
  }
  /**
   * Get a representation of the current state of the item.
   */


  getSerializedState() {
    return {
      question: this.questionRenderer.getSerializedState(),
      hints: this.hintsRenderer.getSerializedState()
    };
  }

  restoreSerializedState(state, callback) {
    // We need to wait for both the question renderer and the hints
    // renderer to finish restoring their states.
    let numCallbacks = 2;

    const fireCallback = () => {
      --numCallbacks;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this.questionRenderer.restoreSerializedState(state.question, fireCallback);
    this.hintsRenderer.restoreSerializedState(state.hints, fireCallback);
  }

  showRationalesForCurrentlySelectedChoices() {
    this.questionRenderer.showRationalesForCurrentlySelectedChoices();
  }

  deselectIncorrectSelectedChoices() {
    this.questionRenderer.deselectIncorrectSelectedChoices();
  } // This must be pre-bound otherwise SvgImage's shouldComponentUpdate
  // won't behave correctly and we'll get an infinite loop.


  render() {
    const apiOptions = { ...ApiOptions.defaults,
      ...this.props.apiOptions,
      onFocusChange: this._handleFocusChange
    };
    const contextValue = {
      assetStatuses: this.state.assetStatuses,
      setAssetStatus: this.setAssetStatus
    };
    const questionRenderer = /*#__PURE__*/React__namespace.createElement(context$3.Provider, {
      value: contextValue
    }, /*#__PURE__*/React__namespace.createElement(Renderer, {
      keypadElement: this.props.keypadElement,
      problemNum: this.props.problemNum,
      onInteractWithWidget: this.handleInteractWithWidget,
      highlightedWidgets: this.state.questionHighlightedWidgets,
      apiOptions: apiOptions,
      questionCompleted: this.state.questionCompleted,
      reviewMode: this.props.reviewMode,
      ref: elem => {
        if (elem != null) {
          this.questionRenderer = elem;
        }
      },
      content: this.props.item.question.content,
      widgets: this.props.item.question.widgets,
      images: this.props.item.question.images
    }));
    const hintsRenderer = /*#__PURE__*/React__namespace.createElement(HintsRenderer, {
      hints: this.props.item.hints,
      hintsVisible: this.props.hintsVisible,
      apiOptions: apiOptions,
      ref: elem => this.hintsRenderer = elem
    });
    return /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("div", null, questionRenderer), /*#__PURE__*/React__namespace.createElement("div", {
      className: // Avoid adding any horizontal padding when applying the
      // mobile hint styles, which are flush to the left.
      // NOTE(charlie): We may still want to apply this
      // padding for desktop exercises.
      apiOptions.isMobile ? undefined : aphrodite.css(styles$3.hintsContainer)
    }, hintsRenderer));
  }

}

_defineProperty(ServerItemRenderer, "defaultProps", {
  apiOptions: {},
  // a deep default is done in `this.update()`
  onRendered: isRendered => {}
});

const styles$3 = aphrodite.StyleSheet.create({
  hintsContainer: {
    marginLeft: 50
  }
});
const ref = /*#__PURE__*/React__namespace.forwardRef((props, ref) => /*#__PURE__*/React__namespace.createElement(context$1.Consumer, null, _ref => {
  let {
    onRendered
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(ServerItemRenderer, _extends$1({}, props, {
    onRendered: onRendered,
    ref: ref
  }));
}));

class ArrowPicker extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: this.props.value,
      allowEmpty: false,
      buttons: [{
        value: "",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2014")
      }, {
        value: "->",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2192")
      }
      /*
      TODO(eater): fix khan-exercises so these are supported
      {value: "<-", content: <span>&#x2190;</span>},
      {value: "<->", content: <span>&#x2194;</span>}
      */
      ],
      onChange: this.props.onChange
    });
  }

}

_defineProperty(ArrowPicker, "defaultProps", {
  value: ""
});

const COLORS = [KhanColors.BLACK, KhanColors.BLUE, KhanColors.GREEN, KhanColors.PINK, KhanColors.PURPLE, KhanColors.RED, KhanColors.GRAY];
const LIGHT_COLORS = [KhanColors.LIGHT_BLUE, KhanColors.LIGHT_ORANGE, KhanColors.LIGHT_PINK, KhanColors.LIGHT_GREEN, KhanColors.LIGHT_PURPLE, KhanColors.LIGHT_RED, "#fff"];

class ColorPicker extends React__namespace.Component {
  render() {
    const colors = this.props.lightColors ? LIGHT_COLORS : COLORS;
    return /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: this.props.value,
      allowEmpty: false,
      buttons: ___default["default"].map(colors, color => {
        return {
          value: color,
          content: /*#__PURE__*/React__namespace.createElement("span", null, /*#__PURE__*/React__namespace.createElement("span", {
            className: "colorpicker-circle",
            style: {
              background: color
            }
          }), "\xA0")
        };
      }),
      onChange: this.props.onChange
    });
  }

}

_defineProperty(ColorPicker, "defaultProps", {
  value: KhanColors.BLACK,
  lightColors: false
});

class DashPicker extends React__namespace.Component {
  render() {
    return /*#__PURE__*/React__namespace.createElement(ButtonGroup, {
      value: this.props.value,
      allowEmpty: false,
      buttons: [{
        value: "",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2014")
      }, {
        value: "-",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2013\u2013\u2013")
      }, {
        value: "- ",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\u2013\xA0\xA0\u2013")
      }, {
        value: ".",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\xB7\xB7\xB7\xB7")
      }, {
        value: ". ",
        content: /*#__PURE__*/React__namespace.createElement("span", null, "\xB7 \xB7 \xB7")
      }],
      onChange: this.props.onChange
    });
  }

}

_defineProperty(DashPicker, "defaultProps", {
  value: ""
});

class ElementContainer extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "toggle", e => {
      e.preventDefault();
      this.setState({
        show: !this.state.show
      });
    });

    this.state = {
      show: props.initiallyVisible
    };
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-interaction-element"
    }, /*#__PURE__*/React__namespace.createElement("a", {
      href: "#",
      className: "perseus-interaction-element-title " + (this.state.show ? "open" : "closed"),
      onClick: this.toggle
    }, this.state.show ? /*#__PURE__*/React__namespace.createElement(InlineIcon, iconChevronDown) : /*#__PURE__*/React__namespace.createElement(InlineIcon, iconChevronRight), this.props.title), /*#__PURE__*/React__namespace.createElement("div", {
      className: "perseus-interaction-element-content " + (this.state.show ? "enter" : "leave")
    }, this.props.children, (this.props.onUp != null || this.props.onDown != null || this.props.onDelete != null) && /*#__PURE__*/React__namespace.createElement("div", {
      className: "edit-controls"
    }, this.props.onUp != null && /*#__PURE__*/React__namespace.createElement("button", {
      onClick: this.props.onUp
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircleArrowUp)), this.props.onDown != null && /*#__PURE__*/React__namespace.createElement("button", {
      onClick: this.props.onDown
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconCircleArrowDown)), this.props.onDelete != null && /*#__PURE__*/React__namespace.createElement("button", {
      onClick: this.props.onDelete
    }, /*#__PURE__*/React__namespace.createElement(InlineIcon, iconTrash)))));
  }

}

_defineProperty(ElementContainer, "defaultProps", {
  initiallyVisible: false,
  title: "More"
});

class HUD extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "renderVisibleIcon", () => {
      return /*#__PURE__*/React__namespace.createElement("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        className: aphrodite.css(styles$2.icon)
      }, /*#__PURE__*/React__namespace.createElement("defs", null, /*#__PURE__*/React__namespace.createElement("path", {
        id: "a",
        d: "M7.401 10.035c-1.424.748-2.599 1.905-3.544 " + "3.48a1 1 0 0 1-1.714-1.03C4.325 8.849 7.652 7 " + "12 7c4.348 0 7.675 1.848 9.857 5.486a1 1 0 0 " + "1-1.714 1.028c-.945-1.574-2.12-2.73-3.544-" + "3.48a5 5 0 1 1-9.198 0zM12 15a3 3 0 1 0 0-6 3 3 " + "0 0 0 0 6z"
      })), /*#__PURE__*/React__namespace.createElement("g", {
        fill: "none",
        fillRule: "evenodd"
      }, /*#__PURE__*/React__namespace.createElement("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }), /*#__PURE__*/React__namespace.createElement("mask", {
        id: "b",
        fill: "#fff"
      }, /*#__PURE__*/React__namespace.createElement("use", {
        href: "#a"
      })), /*#__PURE__*/React__namespace.createElement("use", {
        fill: "#fff",
        fillRule: "nonzero",
        href: "#a"
      }), /*#__PURE__*/React__namespace.createElement("g", {
        fill: "#fff",
        mask: "url(#b)"
      }, /*#__PURE__*/React__namespace.createElement("path", {
        d: "M0 0h24v24H0z"
      }))));
    });

    _defineProperty(this, "renderHiddenIcon", () => {
      return /*#__PURE__*/React__namespace.createElement("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        className: aphrodite.css(styles$2.icon)
      }, /*#__PURE__*/React__namespace.createElement("defs", null, /*#__PURE__*/React__namespace.createElement("path", {
        id: "a",
        d: "M8.794 7.38C9.791 7.127 10.86 7 12 7c4.348 0 " + "7.675 1.848 9.857 5.486a1 1 0 0 1-1.714 " + "1.028c-.945-1.574-2.12-2.73-3.544-3.48.258." + "604.401 1.268.401 1.966 0 1.02-.305 " + "1.967-.828 2.757l2.535 2.536a1 1 0 0 " + "1-1.414 1.414l-12-12a1 1 0 0 1 " + "1.414-1.414L8.794 7.38zm5.914 5.913a3 3 0 0 " + "0-4.001-4.001l4 4.001zM6.072 8.486l2.976 " + "2.976a3 3 0 0 0 3.49 3.49l1.579 1.58A5 5 0 " + "0 1 7.4 10.035c-1.424.747-2.599 1.904-3.544 " + "3.478a1 1 0 0 1-1.714-1.028c1.049-1.75 " + "2.363-3.085 3.929-4z"
      })), /*#__PURE__*/React__namespace.createElement("g", {
        fill: "none",
        fillRule: "evenodd"
      }, /*#__PURE__*/React__namespace.createElement("path", {
        fill: "none",
        d: "M0 0h24v24H0z"
      }), /*#__PURE__*/React__namespace.createElement("mask", {
        id: "b",
        fill: "#fff"
      }, /*#__PURE__*/React__namespace.createElement("use", {
        href: "#a"
      })), /*#__PURE__*/React__namespace.createElement("use", {
        fill: "#fff",
        fillRule: "nonzero",
        href: "#a"
      }), /*#__PURE__*/React__namespace.createElement("g", {
        fill: "#fff",
        mask: "url(#b)"
      }, /*#__PURE__*/React__namespace.createElement("path", {
        d: "M0 0h24v24H0z"
      }))));
    });
  }

  render() {
    let state;
    let icon;

    if (this.props.enabled) {
      state = styles$2.enabled;
      icon = this.renderVisibleIcon();
    } else {
      state = styles$2.disabled;
      icon = this.renderHiddenIcon();
    }

    return /*#__PURE__*/React__namespace.createElement("button", {
      className: aphrodite.css(styles$2.hud, this.props.fixedPosition && styles$2.hudFixedPosition, state),
      onClick: e => {
        this.props.onClick();
      }
    }, icon, this.props.message);
  }

}

_defineProperty(HUD, "propTypes", {
  message: PropTypes__default["default"].string.isRequired,
  enabled: PropTypes__default["default"].bool.isRequired,
  onClick: PropTypes__default["default"].func.isRequired,
  fixedPosition: PropTypes__default["default"].bool
});

_defineProperty(HUD, "defaultProps", {
  fixedPosition: true
});

const styles$2 = aphrodite.StyleSheet.create({
  hud: {
    boxSizing: "border-box",
    height: 36,
    padding: "9px 16px",
    borderRadius: 18,
    fontFamily: boldFontFamily,
    fontSize: "15px",
    lineHeight: "18px",
    color: white$1,
    userSelect: "none",
    borderWidth: 0 // <button> gives us a border by default

  },
  // We want to render the element in-place in our fixtures, so allow us to
  // render in the bottom corner in production and in-place in testing.
  hudFixedPosition: {
    bottom: 20,
    position: "fixed",
    right: 20,
    zIndex: 1
  },
  icon: {
    width: 24,
    height: 24,
    marginRight: 8,
    marginTop: -3,
    verticalAlign: "middle"
  },
  enabled: {
    backgroundColor: warningColor,
    ":hover": {
      backgroundColor: warningColorHover
    },
    ":active": {
      backgroundColor: warningColorActive
    }
  },
  disabled: {
    backgroundColor: gray76,
    ":hover": {
      backgroundColor: "#a1a5a9" // in between those two grays

    },
    ":active": {
      backgroundColor: gray68
    }
  }
});

/**
 * MultiButtonGroup is an aesthetically pleasing group of buttons,
 * which allows multiple buttons to be selected at the same time.
 *
 * NOTE: This component is almost identical to ./button-group.jsx except that
 * this component allows multiple selection!
 */
class MultiButtonGroup extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "toggleSelect", newValue => {
      const values = (this.props.values || []).slice(0);
      const allowEmpty = this.props.allowEmpty;

      if (values.indexOf(newValue) >= 0 && (values.length > 1 || allowEmpty)) {
        // If the value is already selected, unselect it
        values.splice(values.indexOf(newValue), 1);
      } else {
        // Otherwise merge with other values and return
        if (values.indexOf(newValue) < 0) {
          values.push(newValue);
        }
      }

      this.props.onChange(values);
    });
  }

  focus() {
    var _ReactDOM$findDOMNode;

    // $FlowFixMe[prop-missing]
    (_ReactDOM$findDOMNode = ReactDOM__namespace.findDOMNode(this)) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.focus();
    return true;
  }

  render() {
    const values = this.props.values || [];
    const buttons = this.props.buttons.map((button, i) => {
      const selected = values.indexOf(button.value) >= 0;
      return /*#__PURE__*/React__namespace.createElement("button", {
        title: button.title,
        type: "button",
        id: "" + i,
        key: "" + i,
        ref: "button" + i,
        className: aphrodite.css(styles$1.buttonStyle, selected && styles$1.selectedStyle),
        onClick: () => this.toggleSelect(button.value)
      }, button.content || "" + button.value);
    });
    const outerStyle = {
      display: "inline-block"
    };
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: outerStyle
    }, buttons);
  }

}

_defineProperty(MultiButtonGroup, "defaultProps", {
  values: [],
  allowEmpty: true
});

const styles$1 = aphrodite.StyleSheet.create({
  buttonStyle: {
    backgroundColor: "white",
    border: "1px solid #ccc",
    borderLeft: "0",
    cursor: "pointer",
    margin: "0",
    padding: "5px 10px",
    position: "relative",
    // for hover
    ":first-child": {
      borderLeft: "1px solid #ccc",
      borderTopLeftRadius: "3px",
      borderBottomLeftRadius: "3px"
    },
    ":last-child": {
      borderRight: "1px solid #ccc",
      borderTopRightRadius: "3px",
      borderBottomRightRadius: "3px"
    },
    ":hover": {
      backgroundColor: "#ccc"
    },
    ":focus": {
      zIndex: 2
    }
  },
  selectedStyle: {
    backgroundColor: "#ddd"
  }
});

/* eslint-disable react/prop-types */
/* A checkbox that syncs its value to props using the
 * renderer's onChange method, and gets the prop name
 * dynamically from its props list
 */

const PropCheckBox = createReactClass__default["default"]({
  displayName: "PropCheckBox",
  propTypes: {
    labelAlignment: PropTypes__default["default"].oneOf(["left", "right"])
  },
  DEFAULT_PROPS: {
    label: null,
    onChange: null,
    labelAlignment: "left"
  },
  getDefaultProps: function () {
    return this.DEFAULT_PROPS;
  },
  propName: function () {
    const propName = ___default["default"].find(___default["default"].keys(this.props), function (localPropName) {
      return !___default["default"].has(this.DEFAULT_PROPS, localPropName);
    }, this);

    if (!propName) {
      throw new PerseusError("Attempted to create a PropCheckBox with no prop!", Errors.InvalidInput);
    }

    return propName;
  },
  _labelAlignLeft: function () {
    return this.props.labelAlignment === "left";
  },
  render: function () {
    const propName = this.propName();
    return /*#__PURE__*/React__namespace.createElement("label", null, this._labelAlignLeft() && this.props.label, /*#__PURE__*/React__namespace.createElement("input", {
      type: "checkbox",
      checked: this.props[propName],
      onChange: this.toggle
    }), !this._labelAlignLeft() && this.props.label);
  },
  toggle: function () {
    const propName = this.propName();
    const changes = {};
    changes[propName] = !this.props[propName];
    this.props.onChange(changes);
  }
});

const truth = () => true;
/* A minor abstraction on top of NumberInput for ranges
 *
 */


class RangeInput extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onChange", (i, newVal) => {
      const value = this.props.value;

      if (i === 0) {
        this.props.onChange([newVal, value[1]]);
      } else {
        this.props.onChange([value[0], newVal]);
      }
    });
  }

  render() {
    const value = this.props.value;
    const checkValidity = this.props.checkValidity || truth;
    return /*#__PURE__*/React__namespace.createElement("div", {
      className: "range-input"
    }, /*#__PURE__*/React__namespace.createElement(NumberInput, _extends$1({}, this.props, {
      value: value[0],
      checkValidity: val => checkValidity([val, value[1]]) // eslint-disable-next-line react/jsx-no-bind
      ,
      onChange: this.onChange.bind(this, 0),
      placeholder: this.props.placeholder[0]
    })), /*#__PURE__*/React__namespace.createElement(NumberInput, _extends$1({}, this.props, {
      value: value[1],
      checkValidity: val => checkValidity([value[0], val]) // eslint-disable-next-line react/jsx-no-bind
      ,
      onChange: this.onChange.bind(this, 1),
      placeholder: this.props.placeholder[1]
    })));
  }

}

_defineProperty(RangeInput, "propTypes", {
  value: PropTypes__default["default"].array.isRequired,
  onChange: PropTypes__default["default"].func.isRequired,
  placeholder: PropTypes__default["default"].array,
  checkValidity: PropTypes__default["default"].func
});

_defineProperty(RangeInput, "defaultProps", {
  placeholder: [null, null]
});

var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ButtonGroup: ButtonGroup,
    Graph: Graph,
    Graphie: Graphie,
    HUD: HUD,
    Icon: Icon,
    InfoTip: InfoTip,
    InlineIcon: InlineIcon,
    MathInput: MathInput,
    MultiButtonGroup: MultiButtonGroup,
    NumberInput: NumberInput,
    PropCheckBox: PropCheckBox,
    RangeInput: RangeInput,
    SvgImage: SvgImage,
    TextInput: TextInput,
    TexButtons: TexButtons,
    TextListEditor: TextListEditor
});

const devices = {
  PHONE: "phone",
  TABLET: "tablet",
  DESKTOP: "desktop"
}; // How many pixels do we reserve on the right-hand side of a preview
// for displaying lint indicators? This space needs to be reserved
// in DeviceFramer, but it is actually allocated in PerseusFrame

const lintGutterWidth = 36; // How wide a border does PerseusFrame draw? We need to allocate enough
// space for it in DeviceFramer.

const perseusFrameBorderWidth = 1;

var constants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    devices: devices,
    lintGutterWidth: lintGutterWidth,
    perseusFrameBorderWidth: perseusFrameBorderWidth
});

/**
 * KeypadContext provides a way to the Keypad and (Server)ItemRenderer to
 * communicate.
 *
 * The KeypadContext.Provider wraps the ExerciseFooter while KeypadContext.Consumer
 * wraps each (Server)ItemRenderer render site and the Keypad rendered in the
 * ExerciseFooter.
 */
const context = /*#__PURE__*/React__namespace.createContext({
  setKeypadElement: keypadElement => {},
  keypadElement: null,
  setRenderer: renderer => {},
  renderer: null,
  setScrollableElement: scrollableElement => {},
  scrollableElement: null
});

/**
 * Traverses a {content, widgets, images} renderer props object,
 * such as `itemData.question`
 *
 * This traversal is deep and handles some widget prop upgrades
 * (TODO(aria): Handle minor prop upgrades :) )
 *
 * This is the right way to traverse itemData.
 *
 * NOTE: We should not expose this on the perseus API yet. Instead,
 * build the traversal method you want inside perseus, and use this
 * from that. We might eventually expose this, but I'd like to be
 * more confident in the interface provided first.
 */

const noop = function () {};

const deepCallbackFor = function (contentCallback, widgetCallback, optionsCallback) {
  const deepCallback = function (widgetInfo, widgetId) {
    var _upgradedWidgetInfo$v;

    // This doesn't modify the widget info if the widget info
    // is at a later version than is supported, which is important
    // for our latestVersion test below.
    const upgradedWidgetInfo = upgradeWidgetInfoToLatestVersion(widgetInfo);
    const latestVersion = getVersion(upgradedWidgetInfo.type); // Only traverse our children if we can understand this version
    // of the widget props.
    // TODO(aria): This will break if the traversal code assumes that
    // any props that usually get defaulted in are present. That is,
    // it can fail on minor version upgrades.
    // For this reason, and because the upgrade code doesn't handle
    // minor versions correctly (it doesn't report anything useful
    // about what minor version a widget is actually at, since it
    // doesn't have meaning in the context of upgrades), we
    // just check the major version here.
    // TODO(aria): This is seriously quirky and would be unpleasant
    // to think about while writing traverseChildWidgets code. Please
    // make all of this a little tighter.
    // I think once we use react class defaultProps instead of relying
    // on getDefaultProps, this will become easier.

    let newWidgetInfo;

    if (latestVersion && ((_upgradedWidgetInfo$v = upgradedWidgetInfo.version) === null || _upgradedWidgetInfo$v === void 0 ? void 0 : _upgradedWidgetInfo$v.major) === latestVersion.major) {
      newWidgetInfo = traverseChildWidgets$4(upgradedWidgetInfo, rendererOptions => {
        return traverseRenderer$1(rendererOptions, contentCallback, // so that we traverse grandchildren, too:
        deepCallback, optionsCallback);
      });
    } else {
      newWidgetInfo = upgradedWidgetInfo;
    }

    const userWidgetInfo = widgetCallback(newWidgetInfo, widgetId);

    if (userWidgetInfo !== undefined) {
      return userWidgetInfo;
    }

    return newWidgetInfo;
  };

  return deepCallback;
};

const traverseRenderer$1 = function (rendererOptions, contentCallback, deepWidgetCallback, optionsCallback) {
  let newContent = rendererOptions.content;

  if (rendererOptions.content != null) {
    const modifiedContent = contentCallback(rendererOptions.content);

    if (modifiedContent !== undefined) {
      newContent = modifiedContent;
    }
  }

  const newWidgets = objective_.mapObject(rendererOptions.widgets || {}, function (widgetInfo, widgetId) {
    // Widgets without info or a type are empty widgets, and
    // should always be renderable. It's also annoying to write
    // checks for this everywhere, so we just filter them out once and
    // for all!
    if (widgetInfo == null || widgetInfo.type == null) {
      return widgetInfo;
    }

    return deepWidgetCallback(widgetInfo, widgetId);
  });

  const newOptions = ___default["default"].extend({}, rendererOptions, {
    content: newContent,
    widgets: newWidgets
  });

  const userOptions = optionsCallback(newOptions);

  if (userOptions !== undefined) {
    return userOptions;
  }

  return newOptions;
};

const traverse = function (rendererOptions, contentCallback, widgetCallback, optionsCallback) {
  contentCallback = contentCallback || noop;
  widgetCallback = widgetCallback || noop;
  optionsCallback = optionsCallback || noop;
  return traverseRenderer$1(rendererOptions, contentCallback, deepCallbackFor(contentCallback, widgetCallback, optionsCallback), optionsCallback);
};

/**
 * Utility functions for constructing and inferring multi-item shapes.
 *
 * A shape is an object that serves as a runtime type declaration: it specifies
 * a tree structure for a particular class of multi-item. See shape-types.js
 * for further discussion.
 *
 * This module allows you to construct arbitrary Shape trees, by combining
 * leaf node shapes like `content` and `hint` into composite shapes like
 * `arrayOf(shape({foo: content, bar: hint}))`.
 */

/**
 * These tools allow you to construct arbirtary shapes, by combining simple
 * leaf shapes like `content` and `hint` into composite shapes like
 * `arrayOf(shape({question: content, hints: arrayOf(hint)}))`.
 */
const contentShape = {
  type: "content"
};
const hintShape = {
  type: "hint"
};
const tagsShape = {
  type: "tags"
};

const buildArrayShape = elementShape => ({
  type: "array",
  elementShape
});

const buildObjectShape = shape => ({
  type: "object",
  shape
});

const hintsShape = buildArrayShape(hintShape);
var shapes = {
  content: contentShape,
  hint: hintShape,
  hints: hintsShape,
  tags: tagsShape,
  arrayOf: buildArrayShape,
  shape: buildObjectShape
};

/**
 * This is a TreeMapper that only has mappers specified for its leaf nodes; its
 * array mapper is the identity function.
 *
 * This is the TreeMapper initially returned by `buildMapper`. It allows you to
 * change the types of your ContentMapper and HintMapper, which is safe because
 * none of the other mappers that depend on those types (aka ArrayMapper) have
 * been specified yet. (Or, more specifically, the ArrayMapper is currently
 * `identity`, which can trivially vary with the ContentMapper and HintMapper's
 * types.)
 *
 * Once you call `setArrayMapper`, however, we move to the other class:
 * TreeMapperForLeavesAndCollections.
 */
class TreeMapperJustForLeaves {
  constructor(content, hint, tags) {
    _defineProperty(this, "content", void 0);

    _defineProperty(this, "hint", void 0);

    _defineProperty(this, "tags", void 0);

    _defineProperty(this, "array", void 0);

    this.content = content;
    this.hint = hint;
    this.tags = tags;
    this.array = identity;
  }

  setContentMapper(newContentMapper) {
    return new TreeMapperJustForLeaves(newContentMapper, this.hint, this.tags);
  }

  setHintMapper(newHintMapper) {
    return new TreeMapperJustForLeaves(this.content, newHintMapper, this.tags);
  }

  setTagsMapper(newTagsMapper) {
    return new TreeMapperJustForLeaves(this.content, this.hint, newTagsMapper);
  }

  setArrayMapper(newArrayMapper) {
    return new TreeMapperForLeavesAndCollections(this.content, this.hint, this.tags, newArrayMapper);
  }

  mapTree(tree, shape) {
    return mapTree(tree, shape, [], this);
  }

}
/**
 * This is a TreeMapper that already has an ArrayMapper specified, so its
 * ContentMapper and HintMapper are now locked in.
 */


class TreeMapperForLeavesAndCollections {
  constructor(content, hint, tags, array) {
    _defineProperty(this, "content", void 0);

    _defineProperty(this, "hint", void 0);

    _defineProperty(this, "tags", void 0);

    _defineProperty(this, "array", void 0);

    this.content = content;
    this.hint = hint;
    this.tags = tags;
    this.array = array;
  }

  setArrayMapper(newArrayMapper) {
    return new TreeMapperForLeavesAndCollections(this.content, this.hint, this.tags, newArrayMapper);
  }

  mapTree(tree, shape) {
    return mapTree(tree, shape, [], this);
  }

}

function identity(x) {
  return x;
}
/**
 * Return a new TreeMapper that will perform a no-op transformation on an input
 * tree. To make it useful, chain any combination of `setContentMapper`,
 * `setHintMapper`, `setTagMapper`, and `setArrayMapper` to specify
 * transformations for the individual node types.
 */


function buildMapper() {
  return new TreeMapperJustForLeaves(identity, identity, identity);
}
/**
 * Copy the given tree, apply the corresponding transformation specified in the
 * TreeMapper to each node, and return the resulting tree.
 */

function mapTree(tree, shape, path, mappers) {
  // We trust the shape of the multi-item to match the shape provided at
  // runtime. Therefore, in each shape branch, we cast the node to `any` and
  // reinterpret it as the expected node type.
  if (shape.type === "content") {
    const content = tree;
    return mappers.content(content, shape, path);
  }

  if (shape.type === "hint") {
    const hint = tree;
    return mappers.hint(hint, shape, path);
  }

  if (shape.type === "tags") {
    const tags = tree;
    return mappers.tags(tags, shape, path);
  }

  if (shape.type === "array") {
    const array = tree;

    if (!Array.isArray(array)) {
      throw new PerseusError("Invalid object of type \"".concat(typeof array, "\" found at path ") + "".concat(["<root>"].concat(path).join("."), ". Expected array."), Errors.Internal);
    }

    const elementShape = shape.elementShape;
    const mappedElements = array.map((inner, i) => mapTree(inner, elementShape, path.concat(i), mappers));
    return mappers.array(mappedElements, array, shape, path);
  }

  if (shape.type === "object") {
    const object = tree;

    if (object && typeof object !== "object") {
      throw new PerseusError("Invalid object of type \"".concat(typeof object, "\" found at ") + "path ".concat(["<root>"].concat(path).join("."), ". Expected ") + "\"object\" type.", Errors.InvalidInput);
    }

    const valueShapes = shape.shape;

    if (!valueShapes) {
      throw new PerseusError("Unexpected shape ".concat(JSON.stringify(shape), " at path ") + "".concat(["<root>"].concat(path).join("."), "."), Errors.InvalidInput);
    }

    const newObject = {};
    Object.keys(valueShapes).forEach(key => {
      if (!(key in object)) {
        throw new PerseusError("Key \"".concat(key, "\" is missing from shape at path ") + "".concat(["<root>"].concat(path).join("."), "."), Errors.InvalidInput);
      }

      newObject[key] = mapTree(object[key], valueShapes[key], path.concat(key), mappers);
    });
    return newObject;
  }

  throw new PerseusError("unexpected shape type ".concat(shape.type), Errors.InvalidInput);
}

/**
 * Utility functions for constructing and manipulating multi-items.
 *
 * These functions apply *specifically* to Items and ItemTrees - things that
 * actually semantically *are* multi-items. For more general functions for
 * traversing and manipulating *anything* shaped like a multi-item (like a
 * renderer tree or a score tree or, well, a multi-item), see trees.js.
 */

/**
 * Return a semantically empty ItemTree that conforms to the given shape.
 *
 * - An empty content node has an empty content string and no widgets/images.
 * - An empty hint node has an empty content string and no widgets/images.
 * - An empty array node has no elements.
 * - An empty object node has a semantically empty node for each of its keys.
 *   (That is, we recursively call buildEmptyItemTreeForShape for each key.)
 */
function buildEmptyItemTreeForShape(shape) {
  if (shape.type === "content") {
    return {
      __type: "content",
      content: "",
      images: {},
      widgets: {}
    };
  }

  if (shape.type === "hint") {
    return {
      __type: "hint",
      replace: false,
      content: "",
      images: {},
      widgets: {}
    };
  }

  if (shape.type === "tags") {
    return [];
  }

  if (shape.type === "array") {
    return [];
  }

  if (shape.type === "object") {
    const valueShapes = shape.shape;
    const object = {};
    Object.keys(valueShapes).forEach(key => {
      object[key] = buildEmptyItemTreeForShape(valueShapes[key]);
    });
    return object;
  }

  throw new PerseusError("unexpected shape type ".concat(shape.type), Errors.InvalidInput);
}
/**
 * Return a semantically empty Item that conforms to the given shape.
 *
 * - An empty content node has an empty content string and no widgets/images.
 * - An empty hint node has an empty content string and no widgets/images.
 * - An empty array node has no elements.
 * - An empty object node has a semantically empty node for each of its keys.
 *   (That is, we recursively call buildEmptyItemTreeForShape for each key.)
 */

function buildEmptyItemForShape(shape) {
  return treeToItem(buildEmptyItemTreeForShape(shape));
}
/**
 * Given an Item and its Shape, yield all of its content nodes to the callback.
 */

function findContentNodesInItem$2(item, shape, callback) {
  const itemTree = itemToTree(item);
  buildMapper().setContentMapper(callback).mapTree(itemTree, shape);
}
/**
 * Given an Item and its Shape, yield all of its hint nodes to the callback.
 */

function findHintNodesInItem(item, shape, callback) {
  const itemTree = itemToTree(item);
  buildMapper().setHintMapper(callback).mapTree(itemTree, shape);
}
/**
 * Given an ItemTree, return a Shape that it conforms to.
 *
 * The Shape might not be complete or correct Shape that this Item was designed
 * for. If you have access to the intended Shape, use that instead.
 */

function inferItemShape$2(item) {
  const itemTree = itemToTree(item);
  return inferItemTreeShape(itemTree);
}

function inferItemTreeShape(node) {
  if (Array.isArray(node)) {
    if (node.length) {
      if (typeof node[0] === "string") {
        // There's no ItemTree that can manifest as a string.
        // So, an array of strings must be a TagsNode, not ArrayNode.
        return shapes.tags;
      } // Otherwise, assume that this is a valid ArrayNode, and
      // therefore the shape of the first element applies to all
      // elements in the array.


      return shapes.arrayOf(inferItemTreeShape(node[0]));
    } // The array is empty, so we arbitrarily guess that it's a content
    // array. As discussed in the docstring, this might be incorrect,
    // and you shouldn't depend on it.


    return shapes.arrayOf(shapes.content);
  }

  if ( // TODO(mdr): Remove #LegacyContentNode support.
  typeof node === "object" && (node.__type === "content" || node.__type === "item")) {
    return shapes.content;
  }

  if (typeof node === "object" && node.__type === "hint") {
    return shapes.hint;
  }

  if (typeof node === "object") {
    const valueShapes = {};
    Object.keys(node).forEach(key => {
      valueShapes[key] = inferItemTreeShape(node[key]);
    });
    return shapes.shape(valueShapes);
  }

  throw new PerseusError("unexpected multi-item node ".concat(JSON.stringify(node)), Errors.InvalidInput);
}
/**
 * Convert the given Item to an ItemTree, by unwrapping the `_multi` key.
 */


function itemToTree(item) {
  return item._multi;
}
/**
 * Convert the given ItemTree to an Item, by wrapping it in the `_multi` key.
 */

function treeToItem(node) {
  return {
    _multi: node
  };
}

class MultiRenderer extends React__namespace.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "rendererDataTreeMapper", void 0);

    _defineProperty(this, "getRenderersMapper", void 0);

    _defineProperty(this, "_handleSerializedStateUpdated", (path, newState) => {
      const {
        onSerializedStateUpdated
      } = this.props;

      if (onSerializedStateUpdated) {
        const oldState = this._getSerializedState(this.props.serializedState);

        onSerializedStateUpdated(lens(oldState).set(path, newState).freeze());
      }
    });

    this.rendererDataTreeMapper = buildMapper().setContentMapper((c, _, p) => this._makeContentRendererData(c, p)).setHintMapper(h => this._makeHintRendererData(h)).setTagsMapper(t => null);
    this.getRenderersMapper = buildMapper().setContentMapper(c => c.makeRenderer()).setHintMapper(h => h.makeRenderer()).setArrayMapper((renderers, data, shape) => this._annotateRendererArray(renderers, data, shape)); // Keep state in sync with props.

    this.state = this._tryMakeRendererState(this.props);
  }
  /* eslint-enable react/sort-comp */


  UNSAFE_componentWillReceiveProps(nextProps) {
    // Keep state in sync with props.
    if (nextProps.item !== this.props.item) {
      this.setState(this._tryMakeRendererState(nextProps));
    }
  }
  /**
   * Attempt to build a State that includes a renderer tree corresponding to
   * the item provided in props. On error, return a state with `renderError`
   * set instead.
   */


  _tryMakeRendererState(props) {
    try {
      return {
        rendererDataTree: this._makeRendererDataTree(props.item, props.shape),
        renderError: null
      };
    } catch (e) {
      Log.error("Error building tree state", Errors.Internal, {
        cause: e
      });
      return {
        rendererDataTree: null,
        renderError: e
      };
    }
  }

  /**
   * Props that aren't directly used by the MultiRenderer are delegated to
   * the underlying Renderers.
   */
  _getRendererProps() {
    // `item`, `children`, and others are unused. I'm
    // explicitly pulling them out of `this.props` so I don't pass them to
    // `<Renderer>`. I'm not sure how else to do this.
    const {
      item: _,
      children: __,
      shape: ___,
      serializedState: ____,
      onSerializedStateUpdated: _____,
      ...otherProps
    } = this.props;
    return otherProps;
  }
  /**
   * Construct a Renderer and a ref placeholder for the given ContentNode.
   */


  _makeContentRendererData(content, path) {
    // NOTE(emily): The `findExternalWidgets` function here is computed
    //     inline and thus changes each time we run this function. If it
    //     were to change every render, it would cause the Renderer to
    //     re-render a lot more than is necessary. Don't re-compute this
    //     element unless it is necessary!
    // HACK(mdr): Flow can't prove that this is a ContentRendererData,
    //     because of how we awkwardly construct it in order to obtain a
    //     circular reference. But it is, I promise.
    const data = {
      ref: null,
      makeRenderer: null
    };

    const refFunc = e => data.ref = e;

    const findExternalWidgets = criterion => this._findWidgets(data, criterion);

    const handleSerializedState = state => this._handleSerializedStateUpdated(path, state);

    data.makeRenderer = () =>
    /*#__PURE__*/

    /**
     * TODO(somewhatabstract, JIRA-XXXX):
     * `content` contains props that Renderer doesn't have. However,
     * since the type for `content` is not exact, it's hard to know
     * if this spread is including undocumented props so mapping
     * one to one could introduce a bug. Need to work out the exact
     * type for ContentNode and then fix this.
     */
    // $FlowFixMe[cannot-spread-inexact]
    React__namespace.createElement(Renderer, _extends$1({}, this._getRendererProps(), content, {
      ref: refFunc,
      findExternalWidgets: findExternalWidgets,
      serializedState: this.props.serializedState ? lens(this.props.serializedState).get(path) : null,
      onSerializedStateUpdated: handleSerializedState
    }));

    return data;
  }
  /**
   * Construct a Renderer for the given HintNode, and keep track of the hint
   * itself for future use, too.
   */


  _makeHintRendererData(hint) {
    // TODO(mdr): Once HintsRenderer supports inter-widget communication,
    //     give it a ref. Until then, leave the ref null forever, to avoid
    //     confusing the findWidgets functions.
    //
    // NOTE(davidflanagan): As a partial step toward inter-widget
    // communication we're going to pass a findExternalWidgets function
    // (using a dummy data object). This allows passage-ref widgets in
    // hints to use findWidget() to find the passage widgets they reference.
    // Note that this is one-way only, however. It does not allow
    // widgets in the question to find widgets in the hints, for example.
    const findExternalWidgets = criterion => this._findWidgets({}, criterion);

    return {
      hint,
      findExternalWidgets,
      // _annotateRendererArray() needs this
      ref: null,
      makeRenderer: () => /*#__PURE__*/React__namespace.createElement(HintsRenderer, _extends$1({}, this._getRendererProps(), {
        findExternalWidgets: findExternalWidgets,
        hints: [hint]
      }))
    };
  }
  /**
   * Construct a tree of interconnected RendererDatas, corresponding to the
   * given item. Called in `_tryMakeRendererState`, in order to store this
   * tree in the component state.
   */


  _makeRendererDataTree(item, shape) {
    const itemTree = itemToTree(item);
    return this.rendererDataTreeMapper.mapTree(itemTree, shape);
  }
  /**
   * Return all widgets that meet the given criterion, from all Renderers
   * except the Renderer that triggered this call.
   *
   * This function is provided to each Renderer's `findExternalWidgets` prop,
   * which enables widgets in different Renderers to discover each other and
   * communicate.
   */


  _findWidgets(callingData, filterCriterion) {
    const results = [];

    this._mapRenderers(data => {
      if (callingData !== data && data.ref) {
        results.push(...data.ref.findInternalWidgets(filterCriterion));
      }
    });

    return results;
  }
  /**
   * Copy the renderer tree, apply the given transformation to the leaf nodes
   * and the optional given transformation to the array nodes, and return the
   * result.
   *
   * Used to provide structured data to the call site (the Renderer tree on
   * `render`, the Score tree on `getScores`, etc.), and to traverse the
   * renderer tree even when we disregard the output (like in
   * `_findWidgets`).
   */


  _mapRenderers( // eslint-disable-next-line no-restricted-syntax
  leafMapper) {
    const {
      rendererDataTree
    } = this.state;

    if (!rendererDataTree) {
      return null;
    }

    const mapper = buildMapper().setContentMapper(leafMapper).setHintMapper(leafMapper);
    return mapper.mapTree(rendererDataTree, this.props.shape);
  }

  _scoreFromRef(ref) {
    if (!ref) {
      return null;
    }

    const [guess, score] = ref.guessAndScore();
    let state;

    if (ref.getSerializedState) {
      state = ref.getSerializedState();
    }

    return Util.keScoreFromPerseusScore(score, guess, state);
  }
  /**
   * Return a tree in the shape of the multi-item, with scores at each of
   * the content nodes and `null` at the other leaf nodes.
   */


  getScores() {
    return this._mapRenderers(data => this._scoreFromRef(data.ref));
  }
  /**
   * Return a single composite score for all rendered content nodes.
   * The `guess` is a tree in the shape of the multi-item, with an individual
   * guess at each content node and `null` at the other leaf nodes.
   */


  score() {
    const scores = [];
    const state = [];

    const guess = this._mapRenderers(data => {
      var _data$ref;

      if (!data.ref) {
        return null;
      }

      if (data.ref.getSerializedState) {
        state.push(data.ref.getSerializedState());
      }

      scores.push(data.ref.score());
      return (_data$ref = data.ref) === null || _data$ref === void 0 ? void 0 : _data$ref.getUserInput();
    });

    const combinedScore = scores.reduce(Util.combineScores);
    return Util.keScoreFromPerseusScore(combinedScore, guess, state);
  }
  /**
   * Return a tree in the shape of the multi-item, with serialized state at
   * each of the content nodes and `null` at the other leaf nodes.
   *
   * If the lastSerializedState argument is supplied, this function will fill
   * in the state of not-currently-rendered content and hint nodes with the
   * values from the previous serialized state. If no lastSerializedState is
   * supplied, `null` will be returned for not-currently-rendered content and
   * hint nodes.
   */


  _getSerializedState(lastSerializedState) {
    return this._mapRenderers((data, _, path) => {
      if (data.ref) {
        return data.ref.getSerializedState();
      }

      if (lastSerializedState) {
        return lens(lastSerializedState).get(path);
      }

      return null;
    });
  }
  /**
   * Given a tree in the shape of the multi-item, with serialized state at
   * each of the content nodes, restore each state to the corresponding
   * renderer if currently mounted.
   */


  restoreSerializedState(serializedState, callback) {
    // We want to call our async callback only once all of the childrens'
    // callbacks have run. We add one to this counter before we call out to
    // each renderer and decrement it when it runs our callback.
    let numCallbacks = 0;

    const countCallback = () => {
      numCallbacks--;

      if (callback && numCallbacks === 0) {
        callback();
      }
    };

    this._mapRenderers((data, _, path) => {
      var _data$ref2;

      if (!data.ref) {
        return;
      }

      const state = lens(serializedState).get(path);

      if (!state) {
        return;
      }

      numCallbacks++;
      (_data$ref2 = data.ref) === null || _data$ref2 === void 0 ? void 0 : _data$ref2.restoreSerializedState(state, countCallback);
    });
  }
  /**
   * Given an array of renderers, if it happens to be an array of *hint*
   * renderers, then attach a `firstN` method to the array, which allows the
   * layout to render the hints together in one HintsRenderer.
   */


  _annotateRendererArray(renderers, rendererDatas, shape) {
    if (shape.elementShape.type === "hint") {
      // The shape says that these are HintRendererDatas, even though
      // it's not provable at compile time, so perform a cast.
      const hintRendererDatas = rendererDatas;
      renderers = [...renderers];

      renderers.firstN = n => /*#__PURE__*/React__namespace.createElement(HintsRenderer, _extends$1({}, this._getRendererProps(), {
        findExternalWidgets: hintRendererDatas[0] ? hintRendererDatas[0].findExternalWidgets : undefined,
        hints: hintRendererDatas.map(d => d.hint),
        hintsVisible: n
      }));
    }

    return renderers;
  }
  /**
   * Return a tree in the shape of the multi-item, with a Renderer at each
   * content node and a HintRenderer at each hint node.
   *
   * This is generated by running each of the `makeRenderer` functions at the
   * leaf nodes.
   */


  _getRenderers() {
    return this.getRenderersMapper.mapTree(this.state.rendererDataTree, this.props.shape);
  }

  render() {
    if (this.state.renderError) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        className: aphrodite.css(styles.error)
      }, i18n__namespace.$_("Error rendering: %(error)s", {
        error: String(this.state.renderError)
      }));
    } // Pass the renderer tree to the `children` function, which will
    // determine the actual content of this component.


    return this.props.children({
      renderers: this._getRenderers()
    });
  }

}

const styles = aphrodite.StyleSheet.create({
  error: {
    color: "red"
  }
});

/**
 * Utility functions to build React PropTypes for multi-items and shapes.
 *
 * If you're writing new components, though, consider using the Item and Shape
 * Flow types instead.
 */
/**
 * Return a PropType that accepts Items of the given shape, and rejects other
 * objects.
 *
 * Usage: `propTypes: {item: buildPropTypeForShape(myShape)}`
 */

function buildPropTypeForShape(shape) {
  return PropTypes__default["default"].oneOfType([PropTypes__default["default"].shape({
    _multi: buildTreePropTypeForShape(shape)
  }), PropTypes__default["default"].oneOf([null, undefined])]);
}
/**
 * Return a PropType that accepts ItemTrees of the given shape, and rejects
 * other objects.
 */

function buildTreePropTypeForShape(shape) {
  if (shape.type === "content") {
    return PropTypes__default["default"].shape({
      // TODO(mdr): Remove #LegacyContentNode support.
      __type: PropTypes__default["default"].oneOf(["content", "item"]).isRequired,
      content: PropTypes__default["default"].string,
      images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
      widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any)
    });
  }

  if (shape.type === "hint") {
    return PropTypes__default["default"].shape({
      __type: PropTypes__default["default"].oneOf(["hint"]).isRequired,
      content: PropTypes__default["default"].string,
      images: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
      widgets: PropTypes__default["default"].objectOf(PropTypes__default["default"].any),
      replace: PropTypes__default["default"].bool
    });
  }

  if (shape.type === "tags") {
    return PropTypes__default["default"].arrayOf(PropTypes__default["default"].string.isRequired);
  }

  if (shape.type === "array") {
    const elementPropType = buildTreePropTypeForShape(shape.elementShape);
    return PropTypes__default["default"].arrayOf(elementPropType.isRequired);
  }

  if (shape.type === "object") {
    const valueShapes = shape.shape;
    const propTypeShape = {};
    Object.keys(valueShapes).forEach(key => {
      propTypeShape[key] = buildTreePropTypeForShape(valueShapes[key]).isRequired;
    });
    return PropTypes__default["default"].shape(propTypeShape);
  }

  throw new PerseusError("unexpected shape type ".concat(shape.type), Errors.InvalidInput);
}

/**
 * This library provides support for Perseus multi-items: structured Perseus
 * content that content creators can easily create, and that applications can
 * easily render into different parts of the layout.
 *
 * For more details about application and motivation, see:
 * https://sites.google.com/a/khanacademy.org/forge/for-developers/perseus-items-and-multi-items
 *
 * This file primarily exposes the `MultiRenderer` component, which performs
 * multi-rendering. To multi-render a question, pass in the content of the item
 * to the `MultiRenderer` component as a props. Then, pass in a function which
 * takes an object of renderers (in the same structure as the content), and
 * return a render tree. The `MultiRenderer` component will allow you to
 * combine scores, serialized state, etc. without having to manually call on
 * each of the functions. It also handles inter-widgets requests between the
 * different renderers.
 * For more details, see `multi-items/multi-renderer.jsx`.
 *
 * Example:
 *
 *   item = {_multi: {
 *       left: <content data>,
 *       right: [<content data>, <content data>],
 *   }}
 *   shape = shapes.shape({
 *       left: shapes.content,
 *       right: shapes.arrayOf(shapes.content),
 *   })
 *
 *   <MultiRenderer item={item} shape={shape}>
 *       {({renderers}) =>
 *           <div>
 *               <div id="left">{renderers.left}</div>
 *               <ul id="right">
 *                   {renderers.right.map(r => <li>{r}</li>)}
 *               </ul>
 *           </div>
 *       }
 *   </MultiRenderer>
 *
 * This file also exposes `shapes`, which helps you construct a runtime type
 * declaration for your particular class of multi-item. This can then be used
 * to create a MultirendererEditor for your multi-item shape, and to validate
 * that a multi-item conforms to the shape via `buildPropTypeForShape`.
 * For more details, see `multi-items/shapes.js`.
 *
 * This file also exposes some utility functions for working with generic
 * multi-items, like `findContentNodesInItem`, `findHintNodesInItem`,
 * `inferItemShape`, and `buildEmptyItemForShape`.
 * For more details, see `multi-items/items.js`.
 */
var MultiItems = {
  // Tools for rendering your multi-items
  MultiRenderer,
  // Tools for declaring your multi-item shapes
  shapes,
  buildPropTypeForShape,
  // Tools for generically manipulating multi-items
  buildEmptyItemForShape,
  findContentNodesInItem: findContentNodesInItem$2,
  findHintNodesInItem,
  inferItemShape: inferItemShape$2
};

/**
 * Calculates whether a perseus item is renderable by a specific
 * perseus-item-data version.
 *
 * This is done inside of the perseus repo so that it can traverse
 * widget-specific data that might need to do a sub-traversal.
 * This supports widgets that contain renderers, such as the
 * group or sequence widgets.
 */
const {
  findContentNodesInItem: findContentNodesInItem$1,
  inferItemShape: inferItemShape$1
} = MultiItems;

const isUpgradedWidgetInfoRenderableBy = function (widgetInfo, widgetRendererVersion) {
  if (widgetRendererVersion == null) {
    // If the widget does not exist in this version, this will
    // be null, and that version of perseus cannot render the
    // widget (it doesn't even know the widget exists!)
    return false;
  }

  const widgetVersion = widgetInfo.version || {
    major: 0,
    minor: 0
  };

  if (widgetRendererVersion.major > widgetVersion.major) {
    return true;
  }

  if (widgetRendererVersion.major < widgetVersion.major) {
    return false;
  } // If the major versions are the same, the minor version acts
  // like a tie-breaker.
  // For example, input-number 3.2 can render an input-number
  // 2.4, 3.0, or 3.2, but not an input number 3.3 or 4.0.


  return widgetRendererVersion.minor >= widgetVersion.minor;
};

const isRawWidgetInfoRenderableBy = function (widgetInfo, rendererContentVersion) {
  // Empty/non-existant widgets are always safe to render
  if (widgetInfo == null || widgetInfo.type == null) {
    return true;
  } // NOTE: This doesn't modify the widget info if the widget info
  // is at a later version than is supported.


  const upgradedWidgetInfo = upgradeWidgetInfoToLatestVersion(widgetInfo);
  return isUpgradedWidgetInfoRenderableBy(upgradedWidgetInfo, rendererContentVersion[upgradedWidgetInfo.type]);
};

const isRendererContentRenderableBy = function (rendererOptions, rendererContentVersion) {
  let isRenderable = true;
  traverse(rendererOptions, null, function (widgetInfo) {
    isRenderable = isRenderable && isRawWidgetInfoRenderableBy(widgetInfo, rendererContentVersion);
  });
  return isRenderable;
};

const isItemRenderableByVersion = function (itemData, rendererContentVersion) {
  if (itemData == null || rendererContentVersion == null) {
    throw new PerseusError("missing parameter to Perseus.isRenderable.item", Errors.InvalidInput);
  }

  if (itemData._multi) {
    const shape = inferItemShape$1(itemData);
    let isRenderable = true;
    findContentNodesInItem$1(itemData, shape, node => {
      const nodeIsRenderable = isRendererContentRenderableBy(node, rendererContentVersion);

      if (!nodeIsRenderable) {
        isRenderable = false;
      }
    });
    return isRenderable;
  }

  return isRendererContentRenderableBy(itemData.question, rendererContentVersion);
};

/**
 * Identifies whether or not a given perseus item requires the use of a mouse
 * or screen, based on the widgets it contains.
 */
const {
  findContentNodesInItem,
  inferItemShape
} = MultiItems; // Iterate over a single Perseus renderer, mutating `widgets` by appending
// violating widget types discovered in this item.

function traverseRenderer(itemData, widgets) {
  traverse(itemData, null, function (info) {
    if (info.type && !isAccessible(info)) {
      widgets.push(info.type);
    }
  });
} // Returns a list of widgets that cause a given perseus item to require
// the use of a screen or mouse.
//
// For now we'll just check the `accessible` field on each of the widgets
// in the item data, but in the future we may specify accessibility on
// each widget with higher granularity.


function violatingWidgets(itemData) {
  // TODO(jordan): Hints as well
  const widgets = [];

  if (itemData._multi) {
    const shape = inferItemShape(itemData);
    findContentNodesInItem(itemData, shape, content => traverseRenderer(content, widgets));
  } else {
    traverseRenderer(itemData.question, widgets);
  } // Uniquify the list of widgets (by type)


  return ___default["default"].uniq(widgets);
}

/**
 * Some tests require some or all of the widgets and editors to be registered
 * in order for them to work. Requiring this file will register all of the
 * widgets and editors.
 */
const registerAllWidgetsForTesting = () => {
  registerWidgets(allWidgets);
};

const EditorJsonify = {
  serialize: function () {
    // Omit props that get passed to all widgets
    return ___default["default"].omit(this.props, WIDGET_PROP_BLACKLIST);
  }
};

/**
 * Main entry point
 */
const apiVersion = version.apiVersion;
const itemDataVersion = version.itemDataVersion;

exports.ApiOptions = ApiOptions;
exports.ArrowPicker = ArrowPicker;
exports.ArticleRenderer = ArticleRenderer;
exports.BaseRadio = BaseRadio;
exports.Categorizer = Categorizer$1;
exports.Changeable = changeable;
exports.ClassNames = ClassNames;
exports.ColorPicker = ColorPicker;
exports.DashPicker = DashPicker;
exports.Dependencies = dependencies;
exports.EditorJsonify = EditorJsonify;
exports.ElementContainer = ElementContainer;
exports.Errors = Errors;
exports.Expression = Expression;
exports.GrapherUtil = util;
exports.GrapherWidget = Grapher$1;
exports.HintRenderer = HintRenderer;
exports.HintsRenderer = HintsRenderer;
exports.InputNumber = InputNumber$1;
exports.InteractiveGraphWidget = InteractiveGraph$1;
exports.ItemRenderer = ItemRenderer;
exports.JiptParagraphs = JiptParagraphs;
exports.KeypadContext = context;
exports.KhanColors = KhanColors;
exports.KhanMath = KhanMath;
exports.LoadingContext = context$1;
exports.Log = Log;
exports.MatrixWidget = Matrix$1;
exports.MultiItems = MultiItems;
exports.NumericInput = NumericInput$1;
exports.PerseusError = PerseusError;
exports.PerseusMarkdown = PerseusMarkdown;
exports.PlotterWidget = Plotter$1;
exports.Radio = Radio;
exports.Renderer = Renderer;
exports.ServerItemRenderer = ref;
exports.SizingUtils = sizingUtils;
exports.TableWidget = Table$1;
exports.TransformerWidget = Transformer$1;
exports.Util = Util;
exports.WIDGET_PROP_BLACKLIST = WIDGET_PROP_BLACKLIST;
exports.WidgetJsonifyDeprecated = WidgetJsonifyDeprecated;
exports.Widgets = widgets$1;
exports.apiVersion = apiVersion;
exports.buildEmptyItemTreeForShape = buildEmptyItemTreeForShape;
exports.buildMapper = buildMapper;
exports.components = components;
exports.constants = constants;
exports.displaySigFigs = displaySigFigs;
exports.globalConstants = globalConstants;
exports.globalStyles = globalStyles;
exports.icons = iconPaths;
exports.init = init;
exports.interactiveSizes = interactiveSizes$1;
exports.isItemRenderableByVersion = isItemRenderableByVersion;
exports.itemDataVersion = itemDataVersion;
exports.itemToTree = itemToTree;
exports.itemVersion = ItemVersion;
exports.mediaQueries = mediaQueries;
exports.preprocessTex = preprocessTex;
exports.registerAllWidgetsForTesting = registerAllWidgetsForTesting;
exports.shapes = shapes;
exports.traverse = traverse;
exports.violatingWidgets = violatingWidgets;
exports.widgets = allWidgets;
//# sourceMappingURL=index.js.map
