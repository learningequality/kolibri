import json
import logging
import os
import re
import sys

import requests
import utils

logging.basicConfig(format="%(levelname)s: %(message)s", level=logging.INFO)
logging.StreamHandler(sys.stdout)


"""
    These utility functions allow us to maintain the noto source manifest file and
    download source files from Google's Github repos.
"""


# local paths
FONTS_SOURCE = os.path.abspath(os.path.join(os.path.dirname(__file__), "noto_source"))

FONT_MANIFEST_PATH = os.path.join(FONTS_SOURCE, "manifest.json")
with open(FONT_MANIFEST_PATH, "r") as mf:
    MANIFEST = json.load(mf)

KEY_REF = "ref"
KEY_FONTS = "fonts"
KEY_REG_URL = "reg_url"
KEY_BOLD_URL = "bold_url"

FONT_MANIFEST = MANIFEST[KEY_FONTS]


TTF_PATH = os.path.join(FONTS_SOURCE, "sources")

# Github API object keys
GH_PATH = "path"

# filename and directory patterns
OLD_STYLE_PATH = "^hinted/NotoSans\w*-\w*.ttf$"
PHASE_3_PATH = "^phaseIII_only/hinted/ttf/NotoSans\w*/NotoSans\w*-\w+\.ttf$"


DIRECTORY_PATTERN = "^NotoSans\w*$"
REG_PATTERN = "^(NotoSans\w*)-Regular\.ttf$"
BOLD_PATTERN = "^(NotoSans\w*)-Bold\.ttf$"


DOWNLOAD_URL = "https://raw.githubusercontent.com/googlei18n/noto-fonts/{ref}/{path}"


def _request(path):
    url = "https://api.github.com/repos/googlei18n/noto-fonts/" + path
    token = os.environ.get("GITHUB_TOKEN")
    headers = {"Authorization": "token {}".format(token)} if token else {}
    r = requests.get(url, headers=headers)
    if r.status_code == 403:
        logging.error("You've hit the Github API rate limit.")
        if not token:
            logging.info(
                "You can set a GITHUB_TOKEN environment variable with a github API token.\n"
                + "Generate a github token at https://github.com/settings/tokens and give it read-only permission."
            )
        sys.exit(1)
    else:
        r.raise_for_status()
    return r.json()


def _is_base_font(name):
    """
    Used to filter out some special variants that we don't need
    """
    MODIFIERS = ["Display", "Mono", "Slanted"]
    for m in MODIFIERS:
        if name.endswith(m):
            return False
    return True


def _manifest_object(reg_url, bold_url):
    """
    Primary font record in the manifest
    """
    return {KEY_REG_URL: reg_url, KEY_BOLD_URL: bold_url}


def _p3_download_url(base_font_name, is_bold, ref):
    path = "phaseIII_only/hinted/ttf/{base}/{base}-{weight}.ttf".format(
        base=base_font_name, weight=("Bold" if is_bold else "Regular")
    )
    return DOWNLOAD_URL.format(ref=ref, path=path)


def _old_download_url(base_font_name, is_bold, ref):
    path = "hinted/{}-{}.ttf".format(base_font_name, "Bold" if is_bold else "Regular")
    return DOWNLOAD_URL.format(ref=ref, path=path)


def _font_info(recursive_tree, ref, path_pattern, download_url_generator):
    """
    Grab info on all relevant older fonts. Returns a dict of objects generated by

        _manifest_object(reg_url, bold_url)

    which contain a download URL for the bold and regular font weights. Keys of the
    object are font base names, such as NotoSans or NotoSansArabic
    """
    file_names = [
        os.path.basename(item["path"])
        for item in recursive_tree["tree"]
        if re.match(path_pattern, item["path"])
    ]

    # Accumulate dicts of github info objects for regular and bold fonts
    reg_items = set()
    bold_items = set()
    for file_name in file_names:
        reg = re.match(pattern=REG_PATTERN, string=file_name)
        bold = re.match(pattern=BOLD_PATTERN, string=file_name)
        if reg:
            font_name = reg.group(1)
            if not _is_base_font(font_name):
                continue
            reg_items.add(font_name)
        elif bold:
            font_name = bold.group(1)
            if not _is_base_font(font_name):
                continue
            bold_items.add(font_name)

    # these are the fonts that have both regular and bold variants
    bold_and_reg = reg_items & bold_items

    # generate manifest objects, referring to the 'UI' variants when possible
    output = {}
    for font_name in bold_and_reg:
        # skip UI variants because these will always have a normal variant too
        if font_name.endswith("UI"):
            continue
        # for non-UI items, reference the UI variant when it exists
        if font_name + "UI" in bold_and_reg:
            base_font_name = font_name + "UI"
        else:
            base_font_name = font_name

        output[font_name] = _manifest_object(
            download_url_generator(base_font_name, False, ref),
            download_url_generator(base_font_name, True, ref),
        )

    return output


def update_manifest(ref=None):
    """
    Given a git reference in the Noto repo, such as a git commit hash or tag, extract
    information about the fonts available for use and save that information to the
    manifest file.

    The Noto repo currently contains both an older style and the newer "Phase 3"
    fonts. Phase 3 fonts have more consistent internal metrics which makes them amenable
    to being merged together, which we make use of. The older fonts are still usable,
    but cannot be merged together.

    Noto also contains both standard and "UI" variants of many fonts. When a font has a
    UI variant, it means that some of the glyphs in the standard variant are very tall
    and might overflow a typical line of text; the UI variant has the glypsh redrawn
    to fit.

    When searching for fonts to include, we take all language fonts that have both a
    regular and a bold variant, with preference given to Phase 3 and UI variants.
    """

    # grab the head of master
    if not ref:
        logging.info("Using head of master")
        ref = _request("git/refs/heads/master")["object"]["sha"]

    logging.info("Generating new manifest for reference '{}'".format(ref))

    git_tree = _request("git/trees/{}?recursive=1".format(ref))

    # backups
    font_info = _font_info(git_tree, ref, OLD_STYLE_PATH, _old_download_url)
    # prefer phase 3, replacing old-styles when possible
    font_info.update(_font_info(git_tree, ref, PHASE_3_PATH, _p3_download_url))

    new_manifest = {KEY_REF: ref, KEY_FONTS: font_info}
    utils.json_dump_formatted(new_manifest, FONT_MANIFEST_PATH)


def fetch_fonts():
    """
    download ttf files from the manifest
    """

    if not os.path.exists(TTF_PATH):
        os.makedirs(TTF_PATH)

    # out with the old
    for file_name in os.listdir(TTF_PATH):
        os.unlink(os.path.join(TTF_PATH, file_name))

    # in with the new
    for font_name in FONT_MANIFEST:
        font_info = FONT_MANIFEST[font_name]

        # regular
        output_path = get_path(font_name, False)
        logging.info("Writing {}".format(output_path))
        r = requests.get(font_info[KEY_REG_URL])
        r.raise_for_status()
        with open(output_path, "wb") as f:
            f.write(r.content)

        # bold
        output_path = get_path(font_name, True)
        logging.info("Writing {}".format(output_path))
        r = requests.get(font_info[KEY_BOLD_URL])
        r.raise_for_status()
        with open(output_path, "wb") as f:
            f.write(r.content)


@utils.memoize
def get_path(font_name, is_bold=False):
    info = FONT_MANIFEST[font_name]
    path = info[KEY_BOLD_URL] if is_bold else info[KEY_REG_URL]
    return os.path.join(TTF_PATH, os.path.basename(path))
